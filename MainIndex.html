<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypticus - Live Blockchain Gaming Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">CRYPTICUS</div>
        <button class="mobile-menu-btn" onclick="toggleMobileMenu()">☰</button>
        <div class="nav-menu" id="navMenu">
            <div class="nav-item active" onclick="showSection('games')">🎮 Games</div>
            <div class="nav-item" onclick="showSection('leaderboard')">🏆 Leaderboard</div>
            <div class="nav-item" onclick="showSection('profile')">👤 Profile</div>
            <div class="nav-item" onclick="showSection('chat')">💬 Chat</div>
            <div class="nav-item" onclick="showSection('news')">📰 News</div>
            <div class="nav-item" onclick="showSection('settings')">⚙️ Settings</div>
        </div>
        <div class="live-badge">🔴 LIVE ON CORE</div>
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">🔴 Not Connected</div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn">Connect Wallet</button>
            <button class="disconnect-btn hidden" id="disconnectBtn">Disconnect</button>
        </div>
    </div>
    
    <!-- Transaction Status Popup -->
    <div class="transaction-status" id="transactionStatus">
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
    </div>

<!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="news-feed">
                <h3>📰 Live Game Feed</h3>
                <div id="gameFeed">
                    <div class="news-item">
                        <div class="news-title">🎮 Active Games: 12</div>
                        <div class="news-time">Players online now</div>
                    </div>
                    <div class="news-item">
                        <div class="news-title">💰 Total Pool: 156.7 CORE</div>
                        <div class="news-time">Live betting volume</div>
                    </div>
                    <div class="news-item">
                        <div class="news-title">🏆 Last Winner: CryptoKing</div>
                        <div class="news-time">Won 5.2 CORE in Chess</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Age Verification Modal -->
        <div id="ageVerificationModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; align-items: center; justify-content: center;">
            <div style="background: rgba(0,0,0,0.95); border: 2px solid #4ecdc4; border-radius: 15px; padding: 2rem; text-align: center; max-width: 400px;">
                <h3 style="color: #4ecdc4; margin-bottom: 1rem;">🔞 Age Verification Required</h3>
                <p style="margin-bottom: 1.5rem;">You must be 18 or older to use this platform.</p>
                <p style="margin-bottom: 1.5rem; font-size: 0.9rem; color: #aaa;">By proceeding, you confirm you meet age requirements and agree to our terms.</p>
                <button onclick="verifyAge(true)" style="background: linear-gradient(45deg, #4ecdc4, #44a08d); border: none; padding: 1rem 2rem; border-radius: 25px; color: white; font-weight: bold; margin: 0.5rem; cursor: pointer;">I am 18+</button>
                <button onclick="verifyAge(false)" style="background: linear-gradient(45deg, #ff6b6b, #ee5a52); border: none; padding: 1rem 2rem; border-radius: 25px; color: white; font-weight: bold; margin: 0.5rem; cursor: pointer;">Under 18</button>
            </div>
        </div>
        
        <!-- Game Windows -->
        <div class="game-overlay hidden" id="gameOverlay"></div>

        <!-- Chess Game Window -->
        <div class="game-window hidden" id="chessGameWindow">
            <div class="game-window-header">
                <div class="game-window-title">♟️ Chess Masters</div>
                <div class="game-window-controls">
                    <button class="window-btn minimize-btn" onclick="minimizeGame('chess')">−</button>
                    <button class="window-btn close-btn" onclick="closeGame('chess')">×</button>
                </div>
            </div>
            <div class="game-window-content">
                <div class="game-status" id="chessStatus">Waiting for opponent...</div>
                <div class="chess-board" id="chessBoard"></div>
                <div class="game-controls">
                    <button class="game-btn" onclick="resignChess()">Resign</button>
                    <button class="game-btn" onclick="drawChess()">Offer Draw</button>
                </div>
            </div>
        </div>

        <!-- Checkers Game Window -->
        <div class="game-window hidden" id="checkersGameWindow">
            <div class="game-window-header">
                <div class="game-window-title">⚫ Checkers Pro</div>
                <div class="game-window-controls">
                    <button class="window-btn minimize-btn" onclick="minimizeGame('checkers')">−</button>
                    <button class="window-btn close-btn" onclick="closeGame('checkers')">×</button>
                </div>
            </div>
            <div class="game-window-content">
                <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
                <div class="checkers-board" id="checkersBoard"></div>
                <div class="game-controls">
                    <button class="game-btn" onclick="resignCheckers()">Resign</button>
                </div>
            </div>
        </div>

        <!-- Word Game Window -->
        <div class="game-window hidden" id="wordGameWindow">
            <div class="game-window-header">
                <div class="game-window-title">📝 Word Battle</div>
                <div class="game-window-controls">
                    <button class="window-btn minimize-btn" onclick="minimizeGame('word')">−</button>
                    <button class="window-btn close-btn" onclick="closeGame('word')">×</button>
                </div>
            </div>
            <div class="game-window-content">
                <div class="game-status" id="wordStatus">Round 1 of 3</div>
                <div class="word-game">
                    <h4 id="wordPrompt">Make a word with these letters:</h4>
                    <div id="wordLetters" style="font-size: 2rem; color: #4ecdc4; margin: 1rem 0;">BLOCKCHAIN</div>
                    <input type="text" class="word-input" id="wordInput" placeholder="Enter your word..." maxlength="20">
                    <div class="word-score">
                        <div>Your Score: <span id="playerScore">0</span></div>
                        <div>Opponent: <span id="opponentScore">0</span></div>
                    </div>
                    <div class="game-controls">
                        <button class="game-btn" onclick="submitWord()">Submit Word</button>
                        <button class="game-btn" onclick="skipRound()">Skip Round</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Content Area -->
        <div class="content-area">
            <!-- Games Section -->
            <div id="gamesSection">
                <div class="fee-info">
                    <h3>🏆 Smart Contract Gaming</h3>
                    <p><strong>97% of every stake goes directly to the winner!</strong></p>
                    <p>Powered by Core Blockchain • Instant payouts • Provably fair</p>
                    <p>Contract Address: <span id="contractAddress">Connecting...</span> (Verified ✅)</p>
                </div>

                <div class="legal-notice">
                    <h4>⚖️ Legal Notice</h4>
                    <p>• Educational gaming platform for skill development</p>
                    <p>• Minimum age: 18+ required</p>
                    <p>• Tax obligations: Players responsible for local tax compliance</p>
                    <p>• Not available in restricted jurisdictions</p>
                </div>
                
                <div class="active-games">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">🎯 Active Games - Join Now!</h3>
                    <div id="activeGamesList">
                        <div id="noActiveGames" style="text-align: center; padding: 2rem; color: #aaa;">
                            No active games right now. Create one below! 🎮
                        </div>
                    </div>
                </div>
                
                <h2>🎮 Blockchain Games (LIVE)</h2>
                <div class="games-grid">
                    <div class="game-card" id="chessCard">
                        <h3>♟️ Chess Masters</h3>
                        <p>Play chess with real CORE stakes! Smart contract ensures fair play.</p>
                        <input type="number" class="stake-input" id="chessStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button class="create-game-btn" onclick="startChessGame()">Start Chess Game</button>
                    </div>
                    
                    <div class="game-card" id="checkersCard">
                        <h3>⚫ Checkers Pro</h3>
                        <p>Fast checkers with blockchain stakes! Quick games, instant rewards.</p>
                        <input type="number" class="stake-input" id="checkersStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button class="create-game-btn" onclick="startCheckersGame()">Start Checkers Game</button>
                    </div>

                    <div class="game-card" id="wordCard">
                        <h3>📝 Word Battle</h3>
                        <p>Compete in word games with crypto stakes! Test your vocabulary.</p>
                        <input type="number" class="stake-input" id="wordStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button class="create-game-btn" onclick="startWordGame()">Start Word Game</button>
                    </div>
                    
                    <div class="game-card coming-soon">
                        <h3>⚔️ Crypto Kombat</h3>
                        <p>Epic fighting game with NFT characters! Stake tokens and battle for supremacy.</p>
                        <input type="number" class="stake-input" placeholder="Enter stake (min 0.01 CORE)" disabled>
                        <button class="create-game-btn" disabled>Coming Soon</button>
                    </div>
                    
                    <div class="game-card coming-soon">
                        <h3>⚽ Block League</h3>
                        <p>FIFA-style soccer with blockchain stakes! Build teams with NFT players.</p>
                        <input type="number" class="stake-input" placeholder="Enter stake (min 0.01 CORE)" disabled>
                        <button class="create-game-btn" disabled>Coming Soon</button>
                    </div>
                </div>
            </div>
            
            <!-- Leaderboard Section -->
            <div id="leaderboardSection" class="hidden">
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h3 style="color: #ffd700; margin-bottom: 1rem;">🏆 Top Players This Week</h3>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.8rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                        <div>
                            <strong>🥇 CryptoKing</strong>
                            <div style="font-size: 0.9rem; color: #4ecdc4;">23 wins • 156.7 CORE earned</div>
                        </div>
                        <div style="color: #ffd700; font-weight: bold;">156.7 CORE</div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.8rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                        <div>
                            <strong>🥈 BlockMaster</strong>
                            <div style="font-size: 0.9rem; color: #4ecdc4;">19 wins • 134.2 CORE earned</div>
                        </div>
                        <div style="color: #ffd700; font-weight: bold;">134.2 CORE</div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.8rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                        <div>
                            <strong>🥉 GameWarrior</strong>
                            <div style="font-size: 0.9rem; color: #4ecdc4;">17 wins • 98.5 CORE earned</div>
                        </div>
                        <div style="color: #ffd700; font-weight: bold;">98.5 CORE</div>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 2rem 0 1rem 0;">🎯 Recent Matches</h3>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>♟️ Chess:</strong> CryptoKing vs BlockMaster
                                <div style="font-size: 0.8rem; color: #aaa;">5 minutes ago</div>
                            </div>
                            <div style="color: #00ff88;">Winner: CryptoKing (+2.3 CORE)</div>
                        </div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>⚫ Checkers:</strong> GameWarrior vs TokenMaster
                                <div style="font-size: 0.8rem; color: #aaa;">12 minutes ago</div>
                            </div>
                            <div style="color: #00ff88;">Winner: GameWarrior (+1.8 CORE)</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Profile Section -->
            <div id="profileSection" class="hidden">
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">👤 Player Profile</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Games Played</h4>
                            <p style="font-size: 2rem; color: #4ecdc4;" id="profileGamesPlayed">0</p>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Games Won</h4>
                            <p style="font-size: 2rem; color: #00ff88;" id="profileGamesWon">0</p>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Total Earned</h4>
                            <p style="font-size: 2rem; color: #ffd700;" id="profileTotalEarned">0 CORE</p>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Win Rate</h4>
                            <p style="font-size: 2rem; color: #ff6b6b;" id="profileWinRate">0%</p>
                        </div>
                    </div>
                    
                    <h4 style="color: #4ecdc4; margin-bottom: 1rem;">🎮 Game Breakdown</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem;">♟️</div>
                            <div><strong>Chess</strong></div>
                            <div style="font-size: 0.9rem; color: #aaa;" id="chessStats">0W / 0L</div>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem;">⚫</div>
                            <div><strong>Checkers</strong></div>
                            <div style="font-size: 0.9rem; color: #aaa;" id="checkersStats">0W / 0L</div>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem;">📝</div>
                            <div><strong>Words</strong></div>
                            <div style="font-size: 0.9rem; color: #aaa;" id="wordStats">0W / 0L</div>
                        </div>
                    </div>
                </div>
            </div>
            
            /* styles.css - Part 1: Basic Layout and Header */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
    color: #ffffff;
    min-height: 100vh;
}

.header {
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    padding: 1rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    z-index: 1000;
}

.logo {
    font-size: 2rem;
    font-weight: bold;
    background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.nav-menu {
    display: flex;
    gap: 2rem;
    align-items: center;
}

.mobile-menu-btn {
    display: none;
    background: none;
    border: none;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
}

.nav-item {
    padding: 0.5rem 1rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid transparent;
}

.nav-item:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(78, 205, 196, 0.5);
}

.nav-item.active {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    color: white;
}

.live-badge {
    background: linear-gradient(45deg, #00ff88, #00cc6a);
    color: #000;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-weight: bold;
    font-size: 0.8rem;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.wallet-section {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.wallet-info {
    text-align: right;
}

.connection-status {
    font-size: 0.9rem;
    color: #ff6b6b;
}

.balance {
    font-size: 1.2rem;
    font-weight: bold;
}

.connect-btn {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 25px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.connect-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
}

.disconnect-btn {
    background: linear-gradient(45deg, #ff6b6b, #ee5a52);
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 25px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-left: 0.5rem;
}

.main-container {
    display: flex;
    min-height: calc(100vh - 80px);
}

.sidebar {
    width: 300px;
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
    border-right: 1px solid rgba(255, 255, 255, 0.1);
    padding: 2rem;
    overflow-y: auto;
}

.content-area {
    flex: 1;
    padding: 2rem;
    overflow-y: auto;
}

.hidden {
    display: none;
}

/* styles.css - Part 2: Games and Components */

.fee-info {
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 10px;
    padding: 2rem;
    margin-bottom: 2rem;
    text-align: center;
}

.fee-info h3 {
    color: #ffd700;
    margin-bottom: 1rem;
    font-size: 1.5rem;
}

.fee-info p {
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
}

.legal-notice {
    background: rgba(255, 107, 107, 0.1);
    border: 1px solid rgba(255, 107, 107, 0.3);
    border-radius: 10px;
    padding: 1.5rem;
    margin-bottom: 2rem;
}

.legal-notice h4 {
    color: #ff6b6b;
    margin-bottom: 1rem;
}

.legal-notice p {
    margin-bottom: 0.5rem;
}

.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 2rem;
    margin-top: 2rem;
}

.game-card {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 1.5rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

.game-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
    border-color: rgba(78, 205, 196, 0.5);
}

.coming-soon {
    opacity: 0.7;
    position: relative;
}

.coming-soon::after {
    content: "COMING SOON";
    position: absolute;
    top: 10px;
    right: 10px;
    background: linear-gradient(45deg, #ff6b6b, #ee5a52);
    color: white;
    padding: 0.3rem 0.8rem;
    border-radius: 15px;
    font-size: 0.7rem;
    font-weight: bold;
}

.create-game-btn {
    width: 100%;
    background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
    border: none;
    padding: 1rem;
    border-radius: 10px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    margin-top: 1rem;
}

.create-game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(255, 107, 107, 0.3);
}

.create-game-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.stake-input {
    width: 100%;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    padding: 0.8rem;
    color: white;
    font-size: 1rem;
    margin: 1rem 0;
}

.stake-input::placeholder {
    color: rgba(255, 255, 255, 0.6);
}

.news-feed {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    max-height: 400px;
    overflow-y: auto;
}

.news-item {
    padding: 1rem;
    margin: 0.5rem 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border-left: 3px solid #4ecdc4;
}

.news-title {
    font-weight: bold;
    margin-bottom: 0.5rem;
    color: #4ecdc4;
}

.news-time {
    font-size: 0.8rem;
    color: #aaa;
}

.active-games {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 1.5rem;
    margin-bottom: 2rem;
}

.game-lobby-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    margin: 0.5rem 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border-left: 3px solid #4ecdc4;
    transition: all 0.3s ease;
}

.game-lobby-item:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: translateX(5px);
}

.join-game-btn {
    background: linear-gradient(45deg, #00ff88, #00cc6a);
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    color: black;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.join-game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
}

/* styles.css - Part 3: Game Windows and Board Styles */

/* Game Window Styles */
.game-window {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(15px);
    border: 2px solid #4ecdc4;
    border-radius: 15px;
    padding: 1.5rem;
    z-index: 1000;
    max-width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
}

.game-window.minimized {
    top: auto;
    bottom: 20px;
    right: 20px;
    left: auto;
    transform: none;
    width: 300px;
    height: 60px;
    overflow: hidden;
    cursor: pointer;
}

.game-window-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.game-window-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: #4ecdc4;
}

.game-window-controls {
    display: flex;
    gap: 0.5rem;
}

.window-btn {
    background: rgba(255, 255, 255, 0.1);
    border: none;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    padding: 0.3rem 0.6rem;
    font-size: 0.8rem;
    transition: all 0.2s ease;
}

.window-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

.minimize-btn {
    background: rgba(255, 193, 7, 0.3);
}

.close-btn {
    background: rgba(220, 53, 69, 0.3);
}

.game-window-content {
    display: block;
}

.game-window.minimized .game-window-content {
    display: none;
}

.game-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    z-index: 999;
}

.game-overlay.hidden {
    display: none;
}

/* Chess Game Styles */
.chess-board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 3px solid #4ecdc4;
    border-radius: 10px;
    margin: 1rem auto;
    background: #f4f4f4;
}

.chess-square {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
}

.chess-square.white {
    background: #f0d9b5;
}

.chess-square.black {
    background: #b58863;
}

.chess-square.selected {
    background: #ff6b6b !important;
    box-shadow: inset 0 0 10px rgba(255, 107, 107, 0.5);
}

.chess-square.possible-move {
    background: rgba(78, 205, 196, 0.3) !important;
}

.chess-square.possible-move::after {
    content: '●';
    color: #4ecdc4;
    position: absolute;
    font-size: 1rem;
}

/* Checkers Game Styles */
.checkers-board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 3px solid #4ecdc4;
    border-radius: 10px;
    margin: 1rem auto;
}

.checkers-square {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.checkers-square.dark {
    background: #8b4513;
}

.checkers-square.light {
    background: #deb887;
}

.checkers-square.selected {
    background: #ff6b6b !important;
    box-shadow: inset 0 0 10px rgba(255, 107, 107, 0.5);
}

.checker-piece {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    border: 2px solid #000;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}

.red-piece {
    background: radial-gradient(circle, #ff4444, #cc0000);
}

.black-piece {
    background: radial-gradient(circle, #444444, #000000);
}

.king {
    font-size: 1.2rem;
}

/* Word Game Styles */
.word-game {
    max-width: 500px;
    margin: 1rem auto;
    text-align: center;
}

.word-input {
    width: 100%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    padding: 1rem;
    color: white;
    font-size: 1.2rem;
    text-align: center;
    margin: 1rem 0;
}

.word-score {
    display: flex;
    justify-content: space-between;
    margin: 1rem 0;
    padding: 1rem;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

.game-status {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin: 1rem 0;
    text-align: center;
}

.game-controls {
    display: flex;
    gap: 1rem;
    margin: 1rem 0;
    justify-content: center;
    flex-wrap: wrap;
}

.game-btn {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
}

.game-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* styles.css - Part 4: Transaction Status and Mobile Responsive */

/* Transaction Status */
.transaction-status {
    position: fixed;
    top: 100px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    border: 1px solid #4ecdc4;
    border-radius: 10px;
    padding: 1rem;
    max-width: 300px;
    z-index: 1000;
    transform: translateX(100%);
    transition: transform 0.3s ease;
}

.transaction-status.show {
    transform: translateX(0);
}

.tx-hash {
    font-family: monospace;
    font-size: 0.8rem;
    word-break: break-all;
    color: #4ecdc4;
    margin-top: 0.5rem;
}

/* Toggle Switch Styles */
.toggle-switch {
    position: relative;
    width: 60px;
    height: 30px;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.toggle-switch.active {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
}

.toggle-switch:not(.active) {
    background: rgba(255, 255, 255, 0.2);
}

.toggle-switch div {
    position: absolute;
    top: 3px;
    width: 24px;
    height: 24px;
    background: white;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.toggle-switch.active div {
    left: 33px;
}

.toggle-switch:not(.active) div {
    left: 3px;
}

/* Chat animations */
@keyframes slideInMessage {
    from {
        transform: translateX(-20px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.chat-message {
    animation: slideInMessage 0.3s ease;
}

.chat-message:hover {
    background: rgba(255, 255, 255, 0.08) !important;
    transform: translateX(2px);
    transition: all 0.2s ease;
}

/* Loading animations */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading {
    animation: spin 1s linear infinite;
}

/* Error states */
.error {
    color: #ff6b6b !important;
    border-color: #ff6b6b !important;
}

.success {
    color: #00ff88 !important;
    border-color: #00ff88 !important;
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .header {
        padding: 1rem;
        flex-wrap: wrap;
    }
    
    .nav-menu {
        position: fixed;
        top: 80px;
        left: -100%;
        width: 100%;
        height: calc(100vh - 80px);
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(10px);
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding-top: 2rem;
        gap: 2rem;
        transition: left 0.3s ease;
        z-index: 1000;
    }
    
    .nav-menu.active {
        left: 0;
    }
    
    .mobile-menu-btn {
        display: block;
    }
    
    .main-container {
        flex-direction: column;
    }
    
    .sidebar {
        width: 100%;
        order: 2;
        padding: 1rem;
    }
    
    .content-area {
        order: 1;
        padding: 1rem;
    }
    
    .games-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
    
    .chess-board, .checkers-board {
        grid-template-columns: repeat(8, 40px);
        grid-template-rows: repeat(8, 40px);
    }
    
    .chess-square, .checkers-square {
        font-size: 1.5rem;
    }
    
    .checker-piece {
        width: 35px;
        height: 35px;
    }
    
    .game-window {
        width: 95vw;
        height: 90vh;
        top: 5vh;
        left: 2.5vw;
        transform: none;
    }
    
    .wallet-section {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .wallet-info {
        text-align: center;
    }
    
    .game-controls {
        flex-direction: column;
    }
    
    .game-btn {
        width: 100%;
    }
}

@media (max-width: 480px) {
    .logo {
        font-size: 1.5rem;
    }
    
    .live-badge {
        font-size: 0.7rem;
        padding: 0.3rem 0.8rem;
    }
    
    .connect-btn, .disconnect-btn {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
    }
    
    .chess-board, .checkers-board {
        grid-template-columns: repeat(8, 35px);
        grid-template-rows: repeat(8, 35px);
    }
    
    .chess-square, .checkers-square {
        font-size: 1.2rem;
    }
    
    .checker-piece {
        width: 30px;
        height: 30px;
    }
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* High contrast mode */
@media (prefers-contrast: high) {
    .game-card {
        border: 2px solid #ffffff;
    }
    
    .nav-item {
        border: 1px solid #ffffff;
    }
    
    .chess-square.white {
        background: #ffffff;
        color: #000000;
    }
    
    .chess-square.black {
        background: #000000;
        color: #ffffff;
    }
}

// script.js - Part 1A: Global Variables and Contract Setup

// Global variables
let provider = null;
let signer = null;
let userAddress = null;
let currentSection = 'games';
let gameContract = null;
let ageVerified = false;
let kycCompleted = false;

// YOUR ACTUAL CONTRACT ADDRESS AND CORE CHAIN CONFIG
const CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = 1116; // Core Chain mainnet
const CORE_RPC_URL = "https://rpc.coredao.org";

// Smart Contract ABI (simplified for demo)
const CONTRACT_ABI = [
    "function createGame(uint8 gameType, uint256 stake) external payable",
    "function joinGame(uint256 gameId) external payable",
    "function makeMove(uint256 gameId, string memory move) external",
    "function declareWinner(uint256 gameId, address winner) external",
    "function getGameInfo(uint256 gameId) external view returns (tuple(address player1, address player2, uint256 stake, uint8 gameType, uint8 status))",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint8 gameType, uint256 stake)",
    "event GameJoined(uint256 indexed gameId, address indexed joiner)",
    "event MoveMade(uint256 indexed gameId, address indexed player, string move)",
    "event GameEnded(uint256 indexed gameId, address indexed winner, uint256 prize)"
];

// Game state variables
let currentGame = null;
let chessBoard = [];
let checkersBoard = [];
let selectedSquare = null;
let currentPlayer = 'white';
let gameId = null;

// Player stats (stored locally for demo)
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    chess: { wins: 0, losses: 0 },
    checkers: { wins: 0, losses: 0 },
    words: { wins: 0, losses: 0 }
};

// Active games management
let activeGames = [
    { id: 1, type: 'chess', creator: 'CryptoKing', stake: 0.5, status: 'waiting' },
    { id: 2, type: 'checkers', creator: 'GameMaster', stake: 0.3, status: 'waiting' },
    { id: 3, type: 'words', creator: 'WordWizard', stake: 0.8, status: 'waiting' }
];

// Enhanced window management
let windowZIndex = 1000;
let openWindows = [];

// Show transaction status
function showTransactionStatus(message, txHash = '') {
    const statusDiv = document.getElementById('transactionStatus');
    const messageDiv = document.getElementById('txStatusMessage');
    const hashDiv = document.getElementById('txHash');
    
    if (!statusDiv || !messageDiv || !hashDiv) return;
    
    messageDiv.textContent = message;
    if (txHash) {
        hashDiv.textContent = `TX: ${txHash.substring(0, 10)}...${txHash.substring(56)}`;
        // Make transaction hash clickable
        hashDiv.innerHTML = `<a href="https://scan.coredao.org/tx/${txHash}" target="_blank" style="color: #4ecdc4; text-decoration: none;">TX: ${txHash.substring(0, 10)}...${txHash.substring(56)}</a>`;
    } else {
        hashDiv.textContent = '';
    }
    
    statusDiv.classList.add('show');
    
    // Auto-hide after 8 seconds for successful transactions
    setTimeout(() => {
        statusDiv.classList.remove('show');
    }, 8000);
}

// Update contract address display
function updateContractDisplay() {
    const contractDisplay = document.getElementById('contractAddress');
    const settingsDisplay = document.getElementById('displayContractAddress');
    
    if (contractDisplay) {
        contractDisplay.innerHTML = `<a href="https://scan.coredao.org/address/${CONTRACT_ADDRESS}" target="_blank" style="color: #4ecdc4; text-decoration: none;">${CONTRACT_ADDRESS.substring(0, 6)}...${CONTRACT_ADDRESS.substring(38)}</a>`;
    }
    
    if (settingsDisplay) {
        settingsDisplay.innerHTML = `<a href="https://scan.coredao.org/address/${CONTRACT_ADDRESS}" target="_blank" style="color: #4ecdc4; text-decoration: none;">${CONTRACT_ADDRESS}</a>`;
    }
}

// script.js - Part 1B: Core Chain Network Setup

// Core Chain network configuration
const CORE_NETWORK = {
    chainId: '0x45c', // 1116 in hex
    chainName: 'Core Blockchain',
    nativeCurrency: {
        name: 'CORE',
        symbol: 'CORE',
        decimals: 18
    },
    rpcUrls: ['https://rpc.coredao.org'],
    blockExplorerUrls: ['https://scan.coredao.org']
};

// Check and switch to Core network
async function ensureCoreNetwork() {
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: CORE_NETWORK.chainId }],
        });
        return true;
    } catch (switchError) {
        // If network doesn't exist, add it
        if (switchError.code === 4902) {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [CORE_NETWORK],
                });
                return true;
            } catch (addError) {
                console.error('Failed to add Core network:', addError);
                showTransactionStatus('❌ Failed to add Core network');
                return false;
            }
        } else {
            console.error('Failed to switch to Core network:', switchError);
            showTransactionStatus('❌ Please switch to Core network');
            return false;
        }
    }
}

// Validate network
async function validateNetwork() {
    try {
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        if (chainId !== CORE_NETWORK.chainId) {
            showTransactionStatus('🔄 Switching to Core network...');
            return await ensureCoreNetwork();
        }
        return true;
    } catch (error) {
        console.error('Network validation error:', error);
        return false;
    }
}

// Update network status display
async function updateNetworkStatus() {
    try {
        if (!provider) return;
        
        const network = await provider.getNetwork();
        const blockNumber = await provider.getBlockNumber();
        const gasPrice = await provider.getGasPrice();
        const gasPriceGwei = ethers.utils.formatUnits(gasPrice, 'gwei');
        
        const networkStatus = document.getElementById('networkStatus');
        const blockInfo = document.getElementById('blockInfo');
        
        if (networkStatus) {
            if (network.chainId === CORE_CHAIN_ID) {
                networkStatus.innerHTML = '🟢 Core Blockchain - Connected';
                networkStatus.style.color = '#00ff88';
            } else {
                networkStatus.innerHTML = '🔴 Wrong Network - Switch to Core';
                networkStatus.style.color = '#ff6b6b';
            }
        }
        
        if (blockInfo) {
            blockInfo.textContent = `Block: ${blockNumber.toLocaleString()} | Gas: ${parseFloat(gasPriceGwei).toFixed(2)} GWEI`;
        }
        
    } catch (error) {
        console.error('Error updating network status:', error);
        const networkStatus = document.getElementById('networkStatus');
        if (networkStatus) {
            networkStatus.innerHTML = '🔴 Network Error';
            networkStatus.style.color = '#ff6b6b';
        }
    }
}

// Listen for network changes
function setupNetworkListeners() {
    if (window.ethereum) {
        window.ethereum.on('chainChanged', (chainId) => {
            console.log('Network changed to:', chainId);
            // Reload page to reset state
            window.location.reload();
        });
        
        window.ethereum.on('accountsChanged', (accounts) => {
            console.log('Accounts changed:', accounts);
            if (accounts.length === 0) {
                // User disconnected wallet
                disconnectWallet();
            } else if (accounts[0] !== userAddress) {
                // User switched accounts
                window.location.reload();
            }
        });
    }
}

// Disconnect wallet function
function disconnectWallet() {
    userAddress = null;
    provider = null;
    signer = null;
    gameContract = null;
    
    // Reset UI
    const connectionStatus = document.getElementById('connectionStatus');
    const balanceDisplay = document.getElementById('balanceDisplay');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    if (connectionStatus) connectionStatus.innerHTML = '🔴 Not Connected';
    if (balanceDisplay) balanceDisplay.textContent = '0.00 CORE';
    if (connectBtn) connectBtn.classList.remove('hidden');
    if (disconnectBtn) disconnectBtn.classList.add('hidden');
    
    showTransactionStatus('👋 Wallet disconnected');
}

// script.js - Part 1C: Wallet Connection Implementation

// WORKING Wallet connection - Fixed version for Core Chain
function initializeWalletConnection() {
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    if (connectBtn) {
        connectBtn.addEventListener('click', async () => {
            try {
                if (typeof window.ethereum === 'undefined') {
                    alert('Please install MetaMask or Core Wallet to play!');
                    return;
                }
                
                showTransactionStatus('Connecting wallet...');
                
                // First, ensure we're on Core network
                const networkValid = await validateNetwork();
                if (!networkValid) {
                    return;
                }
                
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts.length > 0) {
                    userAddress = accounts[0];
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    
                    // Verify we're connected to Core network
                    const network = await provider.getNetwork();
                    if (network.chainId !== CORE_CHAIN_ID) {
                        throw new Error('Please connect to Core Blockchain network');
                    }
                    
                    // Initialize smart contract
                    gameContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                    
                    // Update UI
                    document.getElementById('connectionStatus').innerHTML = 
                        `🟢 ${userAddress.substring(0, 6)}...${userAddress.substring(38)}`;
                    connectBtn.classList.add('hidden');
                    disconnectBtn.classList.remove('hidden');
                    
                    // Update balance
                    await updateBalance();
                    
                    // Update network status
                    await updateNetworkStatus();
                    
                    // Update contract display
                    updateContractDisplay();
                    
                    showTransactionStatus('✅ Wallet connected successfully!');
                    
                    // Listen for contract events
                    setupContractListeners();
                    
                    // Start periodic updates
                    startPeriodicUpdates();
                    
                } else {
                    throw new Error('No accounts returned from wallet');
                }
                
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showTransactionStatus('❌ Error connecting wallet: ' + error.message);
            }
        });
    }
    
    if (disconnectBtn) {
        disconnectBtn.addEventListener('click', () => {
            disconnectWallet();
        });
    }
}

// Update balance function
async function updateBalance() {
    try {
        if (!provider || !userAddress) return;
        
        const balance = await provider.getBalance(userAddress);
        const balanceInCore = ethers.utils.formatEther(balance);
        const balanceDisplay = document.getElementById('balanceDisplay');
        
        if (balanceDisplay) {
            balanceDisplay.textContent = parseFloat(balanceInCore).toFixed(4) + ' CORE';
        }
        
    } catch (error) {
        console.error('Error updating balance:', error);
        const balanceDisplay = document.getElementById('balanceDisplay');
        if (balanceDisplay) {
            balanceDisplay.textContent = 'Error loading';
        }
    }
}

// Setup contract event listeners
function setupContractListeners() {
    if (!gameContract) return;
    
    try {
        gameContract.on('GameCreated', (gameId, creator, gameType, stake) => {
            console.log('Game created:', gameId.toString(), creator, gameType, stake.toString());
            addChatMessage('System', `🎮 New game created! ID: ${gameId.toString()}`);
            
            // Add to active games if created by someone else
            if (creator.toLowerCase() !== userAddress.toLowerCase()) {
                const gameTypes = ['chess', 'checkers', 'words'];
                const newGame = {
                    id: gameId.toString(),
                    type: gameTypes[gameType] || 'unknown',
                    creator: creator.substring(0, 8) + '...',
                    stake: parseFloat(ethers.utils.formatEther(stake)),
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
            }
        });
        
        gameContract.on('GameJoined', (gameId, joiner) => {
            console.log('Game joined:', gameId.toString(), joiner);
            addChatMessage('System', `🎯 Player joined game ${gameId.toString()}!`);
            
            // Remove from active games
            activeGames = activeGames.filter(game => game.id !== gameId.toString());
            updateActiveGames();
        });
        
        gameContract.on('MoveMade', (gameId, player, move) => {
            console.log('Move made:', gameId.toString(), player, move);
            // Handle move in UI if it's our game
        });
        
        gameContract.on('GameEnded', (gameId, winner, prize) => {
            console.log('Game ended:', gameId.toString(), winner, prize.toString());
            const prizeInCore = ethers.utils.formatEther(prize);
            addChatMessage('System', `🏆 Game ${gameId.toString()} won! Prize: ${prizeInCore} CORE`);
            
            // Update player stats if they won
            if (winner.toLowerCase() === userAddress.toLowerCase()) {
                playerStats.gamesWon++;
                playerStats.totalEarned += parseFloat(prizeInCore);
                updateProfileDisplay();
                
                // Update balance
                setTimeout(updateBalance, 2000);
            }
        });
        
        console.log('Contract event listeners setup successfully');
        
    } catch (error) {
        console.error('Error setting up contract listeners:', error);
    }
}

// Start periodic updates
function startPeriodicUpdates() {
    // Update balance every 30 seconds
    setInterval(updateBalance, 30000);
    
    // Update network status every 60 seconds
    setInterval(updateNetworkStatus, 60000);
    
    // Update game feed every 20 seconds
    setInterval(updateGameFeed, 20000);
}

// script.js - Part 2: Game Creation Functions

// WORKING Chess Game Function - Fixed for Core Chain
async function startChessGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('chessStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        // Validate network first
        const networkValid = await validateNetwork();
        if (!networkValid) {
            return;
        }
        
        showTransactionStatus('Creating chess game...');
        
        // Estimate gas first
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        try {
            const gasEstimate = await gameContract.estimateGas.createGame(0, stakeWei, { value: stakeWei });
            const gasLimit = gasEstimate.mul(120).div(100); // Add 20% buffer
            
            const tx = await gameContract.createGame(0, stakeWei, { 
                value: stakeWei,
                gasLimit: gasLimit
            });
            
            showTransactionStatus('⏳ Transaction submitted...', tx.hash);
            const receipt = await tx.wait();
            
            // Add to active games lobby
            const newGame = {
                id: Date.now(),
                type: 'chess',
                creator: userAddress.substring(0, 8) + '...',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            // Open game window
            openGameWindow('chess');
            document.getElementById('chessStatus').textContent = 'Waiting for opponent...';
            initializeChessBoard();
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('✅ Chess game created! Waiting for opponent...');
            addChatMessage('System', `🎮 New chess game created! Stake: ${stakeAmount} CORE`);
            
            // Clear input
            document.getElementById('chessStake').value = '';
            
            // Update balance after successful transaction
            setTimeout(updateBalance, 3000);
            
        } catch (contractError) {
            console.error('Contract interaction error:', contractError);
            
            if (contractError.code === 4001) {
                showTransactionStatus('❌ Transaction cancelled by user');
            } else if (contractError.code === -32603) {
                showTransactionStatus('❌ Transaction failed - insufficient funds or gas');
            } else {
                showTransactionStatus('❌ Demo mode: Chess game created locally');
                
                // Fallback for demo - still create the game locally
                const newGame = {
                    id: Date.now(),
                    type: 'chess',
                    creator: 'You',
                    stake: stakeAmount,
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
                
                openGameWindow('chess');
                initializeChessBoard();
                document.getElementById('chessStake').value = '';
            }
        }
        
    } catch (error) {
        console.error('Error creating chess game:', error);
        showTransactionStatus('❌ Error creating game: ' + error.message);
    }
}

// WORKING Checkers Game Function - Fixed for Core Chain
async function startCheckersGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        const networkValid = await validateNetwork();
        if (!networkValid) return;
        
        showTransactionStatus('Creating checkers game...');
        
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        try {
            const gasEstimate = await gameContract.estimateGas.createGame(1, stakeWei, { value: stakeWei });
            const gasLimit = gasEstimate.mul(120).div(100);
            
            const tx = await gameContract.createGame(1, stakeWei, { 
                value: stakeWei,
                gasLimit: gasLimit
            });
            
            showTransactionStatus('⏳ Transaction submitted...', tx.hash);
            await tx.wait();
            
            const newGame = {
                id: Date.now(),
                type: 'checkers',
                creator: userAddress.substring(0, 8) + '...',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('checkers');
            document.getElementById('checkersStatus').textContent = 'Waiting for opponent...';
            initializeCheckersBoard();
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('✅ Checkers game created!');
            addChatMessage('System', `🎮 New checkers game created! Stake: ${stakeAmount} CORE`);
            
            document.getElementById('checkersStake').value = '';
            setTimeout(updateBalance, 3000);
            
        } catch (contractError) {
            console.error('Contract error:', contractError);
            showTransactionStatus('❌ Demo: Checkers game created locally');
            
            const newGame = {
                id: Date.now(),
                type: 'checkers',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('checkers');
            initializeCheckersBoard();
            document.getElementById('checkersStake').value = '';
        }
        
    } catch (error) {
        console.error('Error creating checkers game:', error);
        showTransactionStatus('❌ Error: ' + error.message);
    }
}

// WORKING Word Game Function - Fixed for Core Chain
async function startWordGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('wordStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        const networkValid = await validateNetwork();
        if (!networkValid) return;
        
        showTransactionStatus('Creating word game...');
        
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        try {
            const gasEstimate = await gameContract.estimateGas.createGame(2, stakeWei, { value: stakeWei });
            const gasLimit = gasEstimate.mul(120).div(100);
            
            const tx = await gameContract.createGame(2, stakeWei, { 
                value: stakeWei,
                gasLimit: gasLimit
            });
            
            showTransactionStatus('⏳ Transaction submitted...', tx.hash);
            await tx.wait();
            
            const newGame = {
                id: Date.now(),
                type: 'words',
                creator: userAddress.substring(0, 8) + '...',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('word');
            currentWordRound = 1;
            playerScore = 0;
            opponentScore = 0;
            startWordRound();
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('✅ Word game created!');
            addChatMessage('System', `🎮 New word game created! Stake: ${stakeAmount} CORE`);
            
            document.getElementById('wordStake').value = '';
            setTimeout(updateBalance, 3000);
            
        } catch (contractError) {
            console.error('Contract error:', contractError);
            showTransactionStatus('❌ Demo: Word game created locally');
            
            const newGame = {
                id: Date.now(),
                type: 'words',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('word');
            startWordRound();
            document.getElementById('wordStake').value = '';
        }
        
    } catch (error) {
        console.error('Error creating word game:', error);
        showTransactionStatus('❌ Error: ' + error.message);
    }
}

// Input validation for stake amounts
function validateStakeInput(input) {
    const value = parseFloat(input.value);
    if (isNaN(value) || value < 0.01) {
        input.style.borderColor = '#ff6b6b';
        return false;
    } else {
        input.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        return true;
    }
}

// Add input validation listeners
document.addEventListener('DOMContentLoaded', () => {
    const stakeInputs = ['chessStake', 'checkersStake', 'wordStake'];
    stakeInputs.forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
            input.addEventListener('input', () => validateStakeInput(input));
            input.addEventListener('blur', () => validateStakeInput(input));
        }
    });
});

// script.js - Part 3A: Game Window Management

// Enhanced game window management with better stacking
function openGameWindow(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (!gameWindow || !overlay) {
        console.error('Game window elements not found for:', gameType);
        return;
    }
    
    // Increment z-index for new windows
    windowZIndex += 10;
    gameWindow.style.zIndex = windowZIndex;
    
    // Add to open windows array
    if (!openWindows.includes(gameType)) {
        openWindows.push(gameType);
    }
    
    // Stagger position based on number of open windows
    const offset = openWindows.indexOf(gameType) * 30;
    gameWindow.style.top = `calc(50% + ${offset}px)`;
    gameWindow.style.left = `calc(50% + ${offset}px)`;
    
    gameWindow.classList.remove('hidden', 'minimized');
    overlay.classList.remove('hidden');
    
    // Event handlers
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            closeGame(gameType);
        }
    };
    
    gameWindow.onclick = (e) => {
        if (gameWindow.classList.contains('minimized')) {
            restoreGame(gameType);
            e.stopPropagation();
        } else {
            // Bring to front when clicked
            windowZIndex += 10;
            gameWindow.style.zIndex = windowZIndex;
        }
    };
}

function minimizeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (gameWindow && overlay) {
        gameWindow.classList.add('minimized');
        
        // Hide overlay if all windows are minimized
        const visibleWindows = openWindows.filter(type => {
            const window = document.getElementById(type + 'GameWindow');
            return window && !window.classList.contains('minimized');
        });
        
        if (visibleWindows.length === 0) {
            overlay.classList.add('hidden');
        }
        
        showTransactionStatus(`${gameType} game minimized`);
    }
}

function restoreGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (gameWindow && overlay) {
        // Bring to front
        windowZIndex += 10;
        gameWindow.style.zIndex = windowZIndex;
        
        gameWindow.classList.remove('minimized');
        overlay.classList.remove('hidden');
        
        showTransactionStatus(`${gameType} game restored`);
    }
}

function closeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (confirm(`Are you sure you want to close the ${gameType} game?`)) {
        if (gameWindow && overlay) {
            gameWindow.classList.add('hidden');
            
            // Remove from open windows
            openWindows = openWindows.filter(window => window !== gameType);
            
            // Hide overlay if no windows open
            if (openWindows.length === 0) {
                overlay.classList.add('hidden');
            }
            
            // Reset game state
            resetGameState(gameType);
            
            showTransactionStatus(`${gameType} game closed`);
            addChatMessage('System', `🚪 ${gameType} game closed`);
        }
    }
}

// Reset game state function
function resetGameState(gameType) {
    if (gameType === 'chess') {
        selectedSquare = null;
        currentPlayer = 'white';
        chessBoard = [];
    } else if (gameType === 'checkers') {
        selectedSquare = null;
        currentPlayer = 'red';
        checkersBoard = [];
    } else if (gameType === 'word') {
        currentWordRound = 1;
        playerScore = 0;
        opponentScore = 0;
        currentPrompt = null;
    }
    
    // Clear stake input
    const stakeInput = document.getElementById(gameType + 'Stake');
    if (stakeInput) stakeInput.value = '';
}

// script.js - Part 3B: Chess Game Logic

// Chess game functions
function initializeChessBoard() {
    chessBoard = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    
    const boardElement = document.getElementById('chessBoard');
    if (!boardElement) return;
    
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            square.onclick = () => handleChessClick(row, col);
            
            const piece = chessBoard[row][col];
            if (piece) {
                square.textContent = getChessPieceSymbol(piece);
            }
            
            boardElement.appendChild(square);
        }
    }
}

function getChessPieceSymbol(piece) {
    const symbols = {
        'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
        'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };
    return symbols[piece] || '';
}

function handleChessClick(row, col) {
    const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    if (!square) return;
    
    if (selectedSquare) {
        // Clear previous selection
        document.querySelectorAll('.chess-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
        });
        
        // Make move if valid
        if (isValidChessMove(selectedSquare.row, selectedSquare.col, row, col)) {
            makeChessMove(selectedSquare.row, selectedSquare.col, row, col);
        }
        selectedSquare = null;
    } else {
        // Select piece
        const piece = chessBoard[row][col];
        if (piece && isPlayerPiece(piece, currentPlayer)) {
            selectedSquare = { row, col };
            square.classList.add('selected');
            highlightPossibleMoves(row, col);
        }
    }
}

function isPlayerPiece(piece, player) {
    if (player === 'white') {
        return piece === piece.toUpperCase();
    } else {
        return piece === piece.toLowerCase();
    }
}

function isValidChessMove(fromRow, fromCol, toRow, toCol) {
    const piece = chessBoard[fromRow][fromCol];
    const targetPiece = chessBoard[toRow][toCol];
    
    // Can't capture own piece
    if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) {
        return false;
    }
    
    // Basic movement validation (simplified for demo)
    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);
    
    switch (piece.toLowerCase()) {
        case 'p': // Pawn
            const direction = piece === 'P' ? -1 : 1;
            const startRow = piece === 'P' ? 6 : 1;
            
            // Forward move
            if (fromCol === toCol && !targetPiece) {
                if (toRow === fromRow + direction) return true;
                if (fromRow === startRow && toRow === fromRow + 2 * direction) return true;
            }
            
            // Diagonal capture
            if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && targetPiece) {
                return true;
            }
            break;
            
        case 'r': // Rook
            if (fromRow === toRow || fromCol === toCol) {
                return isPathClear(fromRow, fromCol, toRow, toCol);
            }
            break;
            
        case 'n': // Knight
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            
        case 'b': // Bishop
            if (rowDiff === colDiff) {
                return isPathClear(fromRow, fromCol, toRow, toCol);
            }
            break;
            
        case 'q': // Queen
            if (fromRow === toRow || fromCol === toCol || rowDiff === colDiff) {
                return isPathClear(fromRow, fromCol, toRow, toCol);
            }
            break;
            
        case 'k': // King
            return rowDiff <= 1 && colDiff <= 1;
    }
    
    return false;
}

function isPathClear(fromRow, fromCol, toRow, toCol) {
    const rowStep = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
    const colStep = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
    
    let currentRow = fromRow + rowStep;
    let currentCol = fromCol + colStep;
    
    while (currentRow !== toRow || currentCol !== toCol) {
        if (chessBoard[currentRow][currentCol]) return false;
        currentRow += rowStep;
        currentCol += colStep;
    }
    
    return true;
}

function makeChessMove(fromRow, fromCol, toRow, toCol) {
    const piece = chessBoard[fromRow][fromCol];
    chessBoard[toRow][toCol] = piece;
    chessBoard[fromRow][fromCol] = null;
    
    // Update display
    initializeChessBoard();
    
    // Switch players
    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
    document.getElementById('chessStatus').textContent = `${currentPlayer}'s turn`;
    
    // Add move to chat
    const moveNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow} to ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
    addChatMessage('You', `Chess move: ${moveNotation}`);
    
    // Send move to smart contract (if in real game)
    if (gameId && gameContract) {
        const moveString = `${fromRow},${fromCol},${toRow},${toCol}`;
        sendMoveToContract(gameId, moveString);
    }
}

function highlightPossibleMoves(row, col) {
    // Get valid moves for this piece
    const validMoves = getValidMovesForPiece(row, col);
    validMoves.forEach(([r, c]) => {
        const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
        if (square) square.classList.add('possible-move');
    });
}

function getValidMovesForPiece(row, col) {
    const moves = [];
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if (isValidChessMove(row, col, r, c)) {
                moves.push([r, c]);
            }
        }
    }
    return moves;
}

// Chess game utility functions
function resignChess() {
    if (confirm('Are you sure you want to resign?')) {
        document.getElementById('chessStatus').textContent = 'Game resigned';
        playerStats.chess.losses++;
        updateProfileDisplay();
        addChatMessage('System', 'Chess game resigned');
        
        setTimeout(() => {
            closeGame('chess');
        }, 2000);
    }
}

function drawChess() {
    alert('Draw offer sent to opponent');
    addChatMessage('System', 'Draw offer sent');
}

// script.js - Part 4: Checkers Game Logic

// Checkers game functions
function initializeCheckersBoard() {
    checkersBoard = Array(8).fill().map(() => Array(8).fill(null));
    
    // Set up initial pieces
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if ((row + col) % 2 === 1) { // Dark squares only
                if (row < 3) {
                    checkersBoard[row][col] = 'red';
                } else if (row > 4) {
                    checkersBoard[row][col] = 'black';
                }
            }
        }
    }
    
    const boardElement = document.getElementById('checkersBoard');
    if (!boardElement) return;
    
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            square.onclick = () => handleCheckersClick(row, col);
            
            const piece = checkersBoard[row][col];
            if (piece) {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = `checker-piece ${piece}-piece`;
                if (piece.includes('King')) {
                    pieceDiv.classList.add('king');
                    pieceDiv.textContent = '♔';
                }
                square.appendChild(pieceDiv);
            }
            
            boardElement.appendChild(square);
        }
    }
}

function handleCheckersClick(row, col) {
    if (selectedSquare) {
        // Clear highlights
        document.querySelectorAll('.checkers-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
        });
        
        // Try to make move
        const validMoves = getValidCheckersMovesForPiece(selectedSquare.row, selectedSquare.col);
        const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
        
        if (isValidMove) {
            makeCheckersMove(selectedSquare.row, selectedSquare.col, row, col);
        } else {
            addChatMessage('System', '❌ Invalid move! Try again.');
        }
        selectedSquare = null;
    } else {
        // Select piece
        const piece = checkersBoard[row][col];
        if (piece && isCheckersPlayerPiece(piece, currentPlayer)) {
            selectedSquare = { row, col };
            
            const square = document.querySelector(`.checkers-square[data-row="${row}"][data-col="${col}"]`);
            if (square) square.classList.add('selected');
            
            // Highlight possible moves
            const validMoves = getValidCheckersMovesForPiece(row, col);
            validMoves.forEach(([r, c]) => {
                const moveSquare = document.querySelector(`.checkers-square[data-row="${r}"][data-col="${c}"]`);
                if (moveSquare) moveSquare.classList.add('possible-move');
            });
            
            if (validMoves.length === 0) {
                addChatMessage('System', '❌ This piece has no valid moves!');
            }
        } else if (piece) {
            addChatMessage('System', `❌ It's ${currentPlayer}'s turn!`);
        }
    }
}

function getValidCheckersMovesForPiece(row, col) {
    const piece = checkersBoard[row][col];
    const moves = [];
    
    if (!piece) return moves;
    
    const isRed = piece.includes('red');
    const isKing = piece.includes('King');
    
    // Determine move directions
    const directions = [];
    if (isRed || isKing) {
        directions.push([1, -1], [1, 1]); // Red moves down
    }
    if (!isRed || isKing) {
        directions.push([-1, -1], [-1, 1]); // Black moves up
    }
    
    // Check for captures first (mandatory in checkers)
    const captures = [];
    directions.forEach(([dr, dc]) => {
        const jumpRow = row + dr;
        const jumpCol = col + dc;
        const landRow = row + dr * 2;
        const landCol = col + dc * 2;
        
        if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8) {
            const jumpPiece = checkersBoard[jumpRow][jumpCol];
            const landPiece = checkersBoard[landRow][landCol];
            
            // Can capture if there's an enemy piece to jump and empty landing spot
            if (jumpPiece && !isCheckersPlayerPiece(jumpPiece, currentPlayer) && !landPiece) {
                captures.push([landRow, landCol]);
            }
        }
    });
    
    // If captures available, return only captures (mandatory)
    if (captures.length > 0) {
        return captures;
    }
    
    // Otherwise, regular moves
    directions.forEach(([dr, dc]) => {
        const newRow = row + dr;
        const newCol = col + dc;
        
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            if (!checkersBoard[newRow][newCol]) {
                moves.push([newRow, newCol]);
            }
        }
    });
    
    return moves;
}

function isCheckersPlayerPiece(piece, player) {
    if (player === 'red') {
        return piece.includes('red');
    } else {
        return piece.includes('black');
    }
}

function makeCheckersMove(fromRow, fromCol, toRow, toCol) {
    const piece = checkersBoard[fromRow][fromCol];
    const isCapture = Math.abs(fromRow - toRow) === 2;
    
    // Handle capture
    if (isCapture) {
        const captureRow = fromRow + (toRow - fromRow) / 2;
        const captureCol = fromCol + (toCol - fromCol) / 2;
        const capturedPiece = checkersBoard[captureRow][captureCol];
        checkersBoard[captureRow][captureCol] = null; // Remove captured piece
        
        addChatMessage('You', `Checkers capture! Jumped ${capturedPiece} at ${String.fromCharCode(97 + captureCol)}${8 - captureRow}`);
    }
    
    // Move piece
    checkersBoard[toRow][toCol] = piece;
    checkersBoard[fromRow][fromCol] = null;
    
    // Check for king promotion
    let promoted = false;
    if (piece === 'red' && toRow === 7) {
        checkersBoard[toRow][toCol] = 'redKing';
        promoted = true;
        addChatMessage('System', '👑 Red piece promoted to King!');
    } else if (piece === 'black' && toRow === 0) {
        checkersBoard[toRow][toCol] = 'blackKing';
        promoted = true;
        addChatMessage('System', '👑 Black piece promoted to King!');
    }
    
    // Update display
    initializeCheckersBoard();
    
    // Check for additional captures
    if (isCapture && !promoted) {
        const additionalCaptures = getValidCheckersMovesForPiece(toRow, toCol).filter(move => {
            return Math.abs(move[0] - toRow) === 2; // Only capture moves
        });
        
        if (additionalCaptures.length > 0) {
            // Must continue capturing with same piece
            addChatMessage('System', '🎯 Must continue capturing!');
            setTimeout(() => {
                handleCheckersClick(toRow, toCol);
            }, 500);
            return; // Don't end turn yet
        }
    }
    
    // Switch players
    currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
    document.getElementById('checkersStatus').textContent = `${currentPlayer}'s turn`;
    
    // Check for game end
    if (isCheckersGameOver()) {
        endCheckersGame();
    }
}

function isCheckersGameOver() {
    let redPieces = 0;
    let blackPieces = 0;
    let redCanMove = false;
    let blackCanMove = false;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = checkersBoard[row][col];
            if (piece && piece.includes('red')) {
                redPieces++;
                if (!redCanMove && getValidCheckersMovesForPiece(row, col).length > 0) {
                    redCanMove = true;
                }
            }
            if (piece && piece.includes('black')) {
                blackPieces++;
                if (!blackCanMove && getValidCheckersMovesForPiece(row, col).length > 0) {
                    blackCanMove = true;
                }
            }
        }
    }
    
    // Game over if no pieces left or no valid moves
    return redPieces === 0 || blackPieces === 0 || 
           (currentPlayer === 'red' && !redCanMove) || 
           (currentPlayer === 'black' && !blackCanMove);
}

function endCheckersGame() {
    let redPieces = 0;
    let blackPieces = 0;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = checkersBoard[row][col];
            if (piece && piece.includes('red')) redPieces++;
            if (piece && piece.includes('black')) blackPieces++;
        }
    }
    
    let winner;
    if (redPieces === 0) {
        winner = 'black';
    } else if (blackPieces === 0) {
        winner = 'red';
    } else {
        // No valid moves
        winner = currentPlayer === 'red' ? 'black' : 'red';
    }
    
    document.getElementById('checkersStatus').textContent = 
        `Game Over! ${winner} wins! Final: Red ${redPieces} - Black ${blackPieces}`;
    
    if (winner === 'red') {
        playerStats.checkers.wins++;
        playerStats.gamesWon++;
        addChatMessage('System', '🏆 You won the Checkers game!');
    } else {
        playerStats.checkers.losses++;
    }
    
    updateProfileDisplay();
}

function resignCheckers() {
    if (confirm('Are you sure you want to resign?')) {
        document.getElementById('checkersStatus').textContent = 'Game resigned';
        playerStats.checkers.losses++;
        updateProfileDisplay();
        addChatMessage('System', 'Checkers game resigned');
        
        setTimeout(() => {
            closeGame('checkers');
        }, 2000);
    }
}

// script.js - Part 5A: Word Game Setup and Logic

// Word Battle game variables
const wordPrompts = [
    { letters: "BLOCKCHAIN", category: "Technology" },
    { letters: "CRYPTICUS", category: "Gaming" },
    { letters: "ETHEREUM", category: "Cryptocurrency" },
    { letters: "SMARTCONTRACT", category: "DeFi" },
    { letters: "DECENTRALIZED", category: "Web3" },
    { letters: "BITCOIN", category: "Cryptocurrency" },
    { letters: "GAMING", category: "Entertainment" },
    { letters: "WALLET", category: "Technology" },
    { letters: "MINING", category: "Blockchain" },
    { letters: "TOKENS", category: "Cryptocurrency" }
];

let currentWordRound = 1;
let playerScore = 0;
let opponentScore = 0;
let currentPrompt = null;

// Word game functions
function startWordRound() {
    currentPrompt = wordPrompts[Math.floor(Math.random() * wordPrompts.length)];
    document.getElementById('wordStatus').textContent = `Round ${currentWordRound} of 3`;
    document.getElementById('wordPrompt').textContent = `Category: ${currentPrompt.category} - Unscramble this word:`;
    document.getElementById('wordLetters').textContent = scrambleWord(currentPrompt.letters);
    document.getElementById('wordInput').value = '';
    document.getElementById('playerScore').textContent = playerScore;
    document.getElementById('opponentScore').textContent = opponentScore;
    
    // Focus on input for better UX
    setTimeout(() => {
        const input = document.getElementById('wordInput');
        if (input) input.focus();
    }, 100);
}

function scrambleWord(word) {
    const letters = word.split('');
    
    // Fisher-Yates shuffle algorithm
    for (let i = letters.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [letters[i], letters[j]] = [letters[j], letters[i]];
    }
    
    // Ensure it's actually scrambled (not same as original)
    let scrambled = letters.join('');
    let attempts = 0;
    while (scrambled === word && attempts < 10) {
        for (let i = letters.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [letters[i], letters[j]] = [letters[j], letters[i]];
        }
        scrambled = letters.join('');
        attempts++;
    }
    
    return scrambled;
}

function calculateWordScore(word) {
    let baseScore = word.length * 10;
    
    // Difficulty bonus
    const difficultyBonus = {
        'easy': 0,
        'medium': 20,
        'hard': 40
    };
    
    const difficulty = word.length <= 6 ? 'easy' : word.length <= 10 ? 'medium' : 'hard';
    baseScore += difficultyBonus[difficulty];
    
    // Round bonus
    if (currentWordRound === 1) baseScore += 10; // First round bonus
    if (currentWordRound === 3) baseScore += 20; // Final round bonus
    
    return baseScore;
}

function isValidPartialWord(word) {
    if (word.length < 3) return false;
    
    // Check if word uses only available letters
    const availableLetters = currentPrompt.letters.split('');
    const wordLetters = word.split('');
    
    const usedLetters = [...availableLetters];
    for (let letter of wordLetters) {
        const index = usedLetters.indexOf(letter);
        if (index === -1) {
            return false;
        }
        usedLetters.splice(index, 1);
    }
    
    // Basic word validation (simplified)
    const validWords = ['BLOCK', 'CHAIN', 'CRYPTO', 'GAME', 'COIN', 'TOKEN', 'SMART', 'CODE', 'TECH'];
    return validWords.includes(word);
}

// script.js - Part 5B: Word Game Actions and End Game

function submitWord() {
    const word = document.getElementById('wordInput').value.toUpperCase().trim();
    if (!word) {
        alert('Please enter a word!');
        return;
    }
    
    // Check if correct answer
    if (word === currentPrompt.letters) {
        // Correct!
        let wordScore = calculateWordScore(word);
        playerScore += wordScore;
        addChatMessage('You', `✅ Correct! "${word}" (+${wordScore} points)`);
        document.getElementById('wordInput').value = '';
        
        // Move to next round
        setTimeout(() => {
            currentWordRound++;
            if (currentWordRound <= 3) {
                startWordRound();
            } else {
                endWordGame();
            }
        }, 1500);
        
    } else {
        // Check for valid partial words or close attempts
        if (isValidPartialWord(word)) {
            const bonusScore = Math.floor(word.length * 2);
            playerScore += bonusScore;
            addChatMessage('You', `🌟 Good try: "${word}" (+${bonusScore} bonus points)`);
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('wordInput').value = '';
        } else {
            addChatMessage('You', `❌ Wrong: "${word}". Try again!`);
            document.getElementById('wordInput').value = '';
        }
    }
    
    // Simulate opponent progress
    opponentScore += Math.floor(Math.random() * 30) + 15;
    document.getElementById('opponentScore').textContent = opponentScore;
}

function skipRound() {
    if (confirm('Skip this round? You\'ll lose potential points!')) {
        addChatMessage('System', `💡 Skipped! The answer was: ${currentPrompt.letters}`);
        
        // Opponent gets bonus for skip
        opponentScore += 40;
        document.getElementById('opponentScore').textContent = opponentScore;
        
        currentWordRound++;
        if (currentWordRound <= 3) {
            setTimeout(startWordRound, 1000);
        } else {
            endWordGame();
        }
    }
}

function endWordGame() {
    const winner = playerScore > opponentScore ? 'You' : 'Opponent';
    document.getElementById('wordStatus').textContent = 
        `Game Over! ${winner} wins! Final: ${playerScore} - ${opponentScore}`;
    
    if (winner === 'You') {
        playerStats.gamesWon++;
        playerStats.words.wins++;
        addChatMessage('System', '🏆 You won the Word Battle!');
    } else {
        playerStats.words.losses++;
    }
    
    updateProfileDisplay();
    
    // Show final stats
    const scoreDiff = Math.abs(playerScore - opponentScore);
    if (scoreDiff < 20) {
        addChatMessage('System', '🤝 Close game! Well played!');
    } else if (winner === 'You') {
        addChatMessage('System', '🚀 Dominant victory!');
    }
}

// Add Enter key support for word input
document.addEventListener('DOMContentLoaded', () => {
    const wordInput = document.getElementById('wordInput');
    if (wordInput) {
        wordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitWord();
            }
        });
        
        // Add input validation
        wordInput.addEventListener('input', (e) => {
            // Convert to uppercase and remove non-letters
            e.target.value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '');
        });
    }
});

// Utility function for sending moves to contract
async function sendMoveToContract(gameId, move) {
    try {
        if (gameContract && userAddress) {
            const tx = await gameContract.makeMove(gameId, move);
            showTransactionStatus('⏳ Sending move to blockchain...', tx.hash);
            await tx.wait();
            showTransactionStatus('✅ Move confirmed on blockchain!');
        }
    } catch (error) {
        console.error('Error sending move to contract:', error);
        showTransactionStatus('❌ Failed to send move to blockchain');
    }
}

// script.js - Part 6: Navigation and UI Functions

// Mobile menu toggle
function toggleMobileMenu() {
    const navMenu = document.getElementById('navMenu');
    if (navMenu) {
        navMenu.classList.toggle('active');
    }
}

// Navigation function
function showSection(section) {
    // Hide all sections
    const sections = ['gamesSection', 'leaderboardSection', 'profileSection', 'chatSection', 'newsSection', 'settingsSection'];
    sections.forEach(s => {
        const element = document.getElementById(s);
        if (element) element.classList.add('hidden');
    });
    
    // Show selected section
    const targetSection = document.getElementById(section + 'Section');
    if (targetSection) {
        targetSection.classList.remove('hidden');
    }
    
    // Update nav active state
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Find and activate the clicked nav item
    const clickedItem = event ? event.target : null;
    if (clickedItem && clickedItem.classList.contains('nav-item')) {
        clickedItem.classList.add('active');
    }
    
    currentSection = section;
    
    // Close mobile menu
    const navMenu = document.getElementById('navMenu');
    if (navMenu) {
        navMenu.classList.remove('active');
    }
    
    // Update profile stats when viewing profile
    if (section === 'profile') {
        updateProfileDisplay();
    }
    
    // Update network status when viewing settings
    if (section === 'settings') {
        updateNetworkStatus();
        updateContractDisplay();
    }
}

// Profile display function
function updateProfileDisplay() {
    const elements = {
        profileGamesPlayed: playerStats.gamesPlayed,
        profileGamesWon: playerStats.gamesWon,
        profileTotalEarned: playerStats.totalEarned.toFixed(4) + ' CORE',
        profileWinRate: playerStats.gamesPlayed > 0 ? 
            ((playerStats.gamesWon / playerStats.gamesPlayed) * 100).toFixed(1) + '%' : '0%',
        chessStats: `${playerStats.chess.wins}W / ${playerStats.chess.losses}L`,
        checkersStats: `${playerStats.checkers.wins}W / ${playerStats.checkers.losses}L`,
        wordStats: `${playerStats.words.wins}W / ${playerStats.words.losses}L`
    };
    
    Object.keys(elements).forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = elements[id];
        }
    });
}

// Settings toggle function
function toggleSetting(element) {
    const isActive = element.classList.contains('active');
    const toggleDot = element.querySelector('div');
    
    if (isActive) {
        element.classList.remove('active');
        element.style.background = 'rgba(255, 255, 255, 0.2)';
        if (toggleDot) toggleDot.style.left = '3px';
    } else {
        element.classList.add('active');
        element.style.background = 'linear-gradient(45deg, #4ecdc4, #44a08d)';
        if (toggleDot) toggleDot.style.left = '33px';
    }
    
    // Save setting to localStorage
    const settingName = element.parentElement.querySelector('strong').textContent;
    localStorage.setItem(`crypticus_${settingName.replace(/\s+/g, '_')}`, isActive ? 'false' : 'true');
}

// Load settings from localStorage
function loadSettings() {
    const settingElements = document.querySelectorAll('.toggle-switch');
    settingElements.forEach(element => {
        const settingName = element.parentElement.querySelector('strong').textContent;
        const saved = localStorage.getItem(`crypticus_${settingName.replace(/\s+/g, '_')}`);
        
        if (saved === 'false') {
            element.classList.remove('active');
            element.style.background = 'rgba(255, 255, 255, 0.2)';
            const toggleDot = element.querySelector('div');
            if (toggleDot) toggleDot.style.left = '3px';
        }
    });
}

// Age verification functions
function verifyAge(isAdult) {
    if (isAdult) {
        document.getElementById('ageVerificationModal').style.display = 'none';
        sessionStorage.setItem('ageVerified', 'true');
        ageVerified = true;
        showTransactionStatus('✅ Age verified. Welcome to Crypticus!');
    } else {
        alert('Sorry, you must be 18 or older to use this platform.');
        window.location.href = 'https://www.google.com';
    }
}

function checkAgeVerification() {
    const verified = sessionStorage.getItem('ageVerified');
    if (!verified) {
        document.getElementById('ageVerificationModal').style.display = 'flex';
    } else {
        ageVerified = true;
    }
}

// Auto-update functions
function updateGameFeed() {
    const feedMessages = [
        "🎮 Active Games: " + (Math.floor(Math.random() * 20) + 5),
        "💰 Total Pool: " + (Math.random() * 500 + 100).toFixed(1) + " CORE",
        "🏆 Last Winner: " + ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster'][Math.floor(Math.random() * 4)],
        "⚡ New high score in Word Battle!",
        "🔥 Epic chess match in progress!",
        "💎 Checkers tournament starting soon!"
    ];
    
    const gameFeed = document.getElementById('gameFeed');
    if (gameFeed) {
        gameFeed.innerHTML = '';
        feedMessages.slice(0, 3).forEach((message, index) => {
            const feedDiv = document.createElement('div');
            feedDiv.className = 'news-item';
            feedDiv.innerHTML = `
                <div class="news-title">${message}</div>
                <div class="news-time">${index * 5 + 2} minutes ago</div>
            `;
            gameFeed.appendChild(feedDiv);
        });
    }
}

// Error handling for missing elements
function safeElementUpdate(elementId, content, isHTML = false) {
    const element = document.getElementById(elementId);
    if (element) {
        if (isHTML) {
            element.innerHTML = content;
        } else {
            element.textContent = content;
        }
    } else {
        console.warn(`Element with ID '${elementId}' not found`);
    }
}

// Initialize UI on page load
function initializeUI() {
    console.log('🚀 Initializing Crypticus UI...');
    
    // Check age verification
    checkAgeVerification();
    
    // Initialize wallet connection
    initializeWalletConnection();
    
    // Setup network listeners
    setupNetworkListeners();
    
    // Load user settings
    loadSettings();
    
    // Update displays
    updateContractDisplay();
    updateGameFeed();
    updateActiveGames();
    updateProfileDisplay();
    
    // Start periodic updates
    setInterval(updateGameFeed, 20000);
    setInterval(() => {
        if (Math.random() < 0.3) addRandomChatMessage();
    }, 25000);
    
    console.log('✅ UI initialized successfully!');
}

// script.js - Part 7: Chat System and Final Initialization

// Chat functionality
function addChatMessage(user, message) {
    const chatMessages = document.getElementById('chatMessages');
    if (!chatMessages) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'chat-message';
    messageDiv.style.cssText = 'margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);';
    
    const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    messageDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start;">
            <div style="flex: 1;">
                <strong style="color: ${getUserColor(user)};">${user}:</strong> 
                <span>${processMessage(message)}</span>
            </div>
            <span style="font-size: 0.7rem; color: #aaa; margin-left: 1rem;">${timestamp}</span>
        </div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Limit message history
    while (chatMessages.children.length > 50) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

function getUserColor(user) {
    const colors = ['#4ecdc4', '#ff6b6b', '#ffd700', '#00ff88', '#ff8c42', '#c44569'];
    const hash = user.split('').reduce((a, b) => {
        a = ((a << 5) - a) + b.charCodeAt(0);
        return a & a;
    }, 0);
    return colors[Math.abs(hash) % colors.length];
}

function processMessage(message) {
    // Convert some text emoticons to emojis
    let processed = message
        .replace(/:D/g, '😃')
        .replace(/:\)/g, '🙂')
        .replace(/:P/g, '😛')
        .replace(/<3/g, '❤️');
    
    // Highlight important words
    const keywords = ['CORE', 'chess', 'checkers', 'word', 'win', 'game'];
    keywords.forEach(word => {
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        processed = processed.replace(regex, `<span style="color: #4ecdc4; font-weight: bold;">${word}</span>`);
    });
    
    return processed;
}

function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    if (!chatInput) return;
    
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    if (!userAddress) {
        alert('Please connect your wallet to chat!');
        return;
    }
    
    if (message.length > 200) {
        alert('Message too long! Maximum 200 characters.');
        return;
    }
    
    addChatMessage('You', message);
    chatInput.value = '';
    
    // Simulate responses
    setTimeout(() => {
        generateSmartResponse(message);
    }, 1000 + Math.random() * 2000);
}

function generateSmartResponse(userMessage) {
    const responses = {
        greeting: [
            "Hey there! Ready for some epic games? 🎮",
            "Welcome to Crypticus! Let's play! 🚀",
            "Hello! Good luck in your games! 🏆"
        ],
        chess: [
            "Chess is the ultimate strategy game! ♟️",
            "Love a good chess match! Good luck! 👑",
            "Chess masters unite! May the best player win! ⚔️"
        ],
        checkers: [
            "Checkers is so underrated! Great choice! ⚫",
            "Jump those pieces! Checkers is intense! 🎯",
            "King me! Checkers for the win! 👑"
        ],
        words: [
            "Word games are brain training! 🧠",
            "Vocabulary battles are the best! 📝",
            "Words are my weapon of choice! ⚡"
        ],
        crypto: [
            "CORE blockchain is amazing! 💎",
            "Crypto gaming is the future! 🚀",
            "HODL and play! Best combo ever! 💰"
        ],
        win: [
            "Congrats on the win! 🏆",
            "Victory tastes sweet! Well played! 🎉",
            "Another one bites the dust! GG! ⚡"
        ]
    };
    
    const lowerMessage = userMessage.toLowerCase();
    let responseCategory = 'general';
    
    if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) responseCategory = 'greeting';
    else if (lowerMessage.includes('chess')) responseCategory = 'chess';
    else if (lowerMessage.includes('checkers')) responseCategory = 'checkers';
    else if (lowerMessage.includes('word')) responseCategory = 'words';
    else if (lowerMessage.includes('crypto') || lowerMessage.includes('core')) responseCategory = 'crypto';
    else if (lowerMessage.includes('won') || lowerMessage.includes('win')) responseCategory = 'win';
    
    const responseList = responses[responseCategory] || [
        "That's interesting! 🤔",
        "Tell me more! 💭",
        "Absolutely! 👍",
        "I agree! 🎯",
        "Game on! 🎮"
    ];
    
    const randomUser = ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster', 'WordWizard'][Math.floor(Math.random() * 5)];
    const randomResponse = responseList[Math.floor(Math.random() * responseList.length)];
    
    addChatMessage(randomUser, randomResponse);
}

function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendChatMessage();
    }
}

function addRandomChatMessage() {
    const messages = [
        { user: "StakeHero", message: "Just won big in Checkers! 🎉" },
        { user: "WordWizard", message: "Word Battle high score: 847! 📝" },
        { user: "ChessMaster", message: "Looking for a chess opponent! ♟️" },
        { user: "CryptoGamer", message: "These games are incredible! 🚀" },
        { user: "BlockchainBro", message: "Best gaming platform ever! 💰" },
        { user: "TokenTitan", message: "Just earned 5 CORE! 🏆" }
    ];
    
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    addChatMessage(randomMessage.user, randomMessage.message);
}

// Join existing game function
async function joinGame(gameType, gameId, stake) {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    try {
        const networkValid = await validateNetwork();
        if (!networkValid) return;
        
        showTransactionStatus('Joining game...');
        
        const stakeWei = ethers.utils.parseEther(stake.toString());
        
        try {
            const gasEstimate = await gameContract.estimateGas.joinGame(gameId, { value: stakeWei });
            const gasLimit = gasEstimate.mul(120).div(100);
            
            const tx = await gameContract.joinGame(gameId, { 
                value: stakeWei,
                gasLimit: gasLimit
            });
            
            showTransactionStatus('⏳ Joining game...', tx.hash);
            await tx.wait();
            
            // Remove from active games and start the game
            activeGames = activeGames.filter(game => game.id != gameId);
            updateActiveGames();
            
            // Open game window
            openGameWindow(gameType);
            
            if (gameType === 'chess') {
                document.getElementById('chessStatus').textContent = 'Game started! Your turn.';
                initializeChessBoard();
            } else if (gameType === 'checkers') {
                document.getElementById('checkersStatus').textContent = 'Game started! Your turn.';
                initializeCheckersBoard();
            } else if (gameType === 'words') {
                document.getElementById('wordStatus').textContent = 'Game started! Round 1 of 3';
                startWordRound();
            }
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('✅ Joined game successfully!');
            addChatMessage('System', `🎮 You joined ${gameType} game! Stake: ${stake} CORE`);
            
            setTimeout(updateBalance, 3000);
            
        } catch (contractError) {
            console.error('Contract error:', contractError);
            showTransactionStatus('❌ Demo: Joined game locally');
            
            // Fallback for demo
            activeGames = activeGames.filter(game => game.id != gameId);
            updateActiveGames();
            openGameWindow(gameType);
            
            if (gameType === 'chess') {
                initializeChessBoard();
            } else if (gameType === 'checkers') {
                initializeCheckersBoard();
            } else if (gameType === 'words') {
                startWordRound();
            }
        }
        
    } catch (error) {
        console.error('Error joining game:', error);
        showTransactionStatus('❌ Error joining game: ' + error.message);
    }
}

// Update active games display
function updateActiveGames() {
    const gamesList = document.getElementById('activeGamesList');
    const noGamesDiv = document.getElementById('noActiveGames');
    
    if (!gamesList) return;
    
    if (activeGames.length === 0) {
        gamesList.innerHTML = '<div id="noActiveGames" style="text-align: center; padding: 2rem; color: #aaa;">No active games right now. Create one below! 🎮</div>';
        return;
    }
    
    if (noGamesDiv) noGamesDiv.style.display = 'none';
    gamesList.innerHTML = '';
    
    activeGames.forEach(game => {
        const gameDiv = document.createElement('div');
        gameDiv.className = 'game-lobby-item';
        
        const gameIcon = game.type === 'chess' ? '♟️' : game.type === 'checkers' ? '⚫' : '📝';
        const gameName = game.type === 'chess' ? 'Chess Masters' : game.type === 'checkers' ? 'Checkers Pro' : 'Word Battle';
        
        gameDiv.innerHTML = `
            <div>
                <strong>${gameIcon} ${gameName}</strong>
                <div style="font-size: 0.9rem; color: #aaa;">${game.creator} • Stake: ${game.stake} CORE</div>
            </div>
            <button class="join-game-btn" onclick="joinGame('${game.type}', '${game.id}', ${game.stake})">Join Game</button>
        `;
        
        gamesList.appendChild(gameDiv);
    });
}

// Final initialization when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Crypticus blockchain gaming platform loaded!');
    
    // Initialize everything
    initializeUI();
    
    // Close mobile menu when clicking outside
    document.addEventListener('click', (e) => {
        const navMenu = document.getElementById('navMenu');
        const mobileBtn = document.querySelector('.mobile-menu-btn');
        
        if (navMenu && mobileBtn && !navMenu.contains(e.target) && !mobileBtn.contains(e.target)) {
            navMenu.classList.remove('active');
        }
    });
    
    // Auto-hide transaction status on click
    const transactionStatus = document.getElementById('transactionStatus');
    if (transactionStatus) {
        transactionStatus.addEventListener('click', () => {
            transactionStatus.classList.remove('show');
        });
    }
    
    console.log('✅ All systems initialized successfully!');
    console.log('🎮 Ready for blockchain gaming on Core Chain!');
});

// Export functions for global access (if needed)
window.Crypticus = {
    startChessGame,
    startCheckersGame, 
    startWordGame,
    joinGame,
    showTransactionStatus,
    updateBalance,
    validateNetwork
};

// Auto-update time
        setInterval(updateTime, 1000);
        
        // Auto-refresh balance every 30 seconds
        setInterval(async () => {
            if (provider && userAccount) {
                const balance = await provider.getBalance(userAccount);
                const balanceFormatted = ethers.utils.formatEther(balance);
                document.getElementById('walletBalance').textContent = 
                    `${parseFloat(balanceFormatted).toFixed(4)} CORE`;
            }
        }, 30000);

        // Handle account changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    location.reload();
                } else {
                    connectWallet();
                }
            });
            
            window.ethereum.on('chainChanged', (chainId) => {
                location.reload();
            });
        }

        // Initialize time display
        updateTime();
    </script>
    </body>
</html>

// Complete Smart Contract ABI for your deployed contract
const COMPLETE_CONTRACT_ABI = [
    // Game Creation and Management
    "function createGame(string memory gameType, uint256 stakeAmount) external payable returns (uint256)",
    "function joinGame(uint256 gameId) external payable",
    "function endGame(uint256 gameId, address winner, string memory proof) external",
    "function cancelGame(uint256 gameId) external",
    
    // Game Information
    "function games(uint256) external view returns (uint256 gameId, address player1, address player2, uint256 stake, bool isActive, address winner, string memory gameType)",
    "function gameCounter() external view returns (uint256)",
    "function getActiveGames() external view returns (uint256[] memory)",
    "function getPlayerGames(address player) external view returns (uint256[] memory)",
    
    // Player Statistics
    "function playerStats(address) external view returns (uint256 gamesPlayed, uint256 gamesWon, uint256 totalStaked, uint256 totalWon)",
    "function getPlayerStats(address player) external view returns (uint256, uint256, uint256, uint256)",
    
    // Platform Management
    "function platformFee() external view returns (uint256)",
    "function owner() external view returns (address)",
    "function paused() external view returns (bool)",
    
    // Events
    "event GameCreated(uint256 indexed gameId, address indexed player1, uint256 stake, string gameType)",
    "event GameJoined(uint256 indexed gameId, address indexed player2)",
    "event GameEnded(uint256 indexed gameId, address indexed winner, uint256 payout)",
    "event GameCancelled(uint256 indexed gameId, address indexed player)",
    "event StakeDeposited(uint256 indexed gameId, address indexed player, uint256 amount)",
    "event PayoutSent(uint256 indexed gameId, address indexed winner, uint256 amount)"
];

// Enhanced Game State Management
class GameStateManager {
    constructor() {
        this.activeGames = new Map();
        this.gameHistory = [];
        this.playerStats = {
            gamesPlayed: 0,
            gamesWon: 0,
            totalStaked: 0,
            totalWon: 0
        };
    }

    // Add new game to active games
    addGame(gameId, gameData) {
        this.activeGames.set(gameId, {
            ...gameData,
            createdAt: new Date(),
            status: 'waiting'
        });
        this.updateGamesList();
    }

    // Update game status
    updateGameStatus(gameId, status, additionalData = {}) {
        const game = this.activeGames.get(gameId);
        if (game) {
            game.status = status;
            game.lastUpdated = new Date();
            Object.assign(game, additionalData);
            this.updateGamesList();
        }
    }

    // End game and move to history
    endGame(gameId, winner, payout) {
        const game = this.activeGames.get(gameId);
        if (game) {
            game.status = 'completed';
            game.winner = winner;
            game.payout = payout;
            game.endedAt = new Date();
            
            this.gameHistory.push(game);
            this.activeGames.delete(gameId);
            
            // Update player stats
            this.playerStats.gamesPlayed++;
            if (winner === userAccount) {
                this.playerStats.gamesWon++;
                this.playerStats.totalWon += payout;
            }
            
            this.updateGamesList();
            this.updatePlayerStats();
        }
    }

    // Get all active games
    getActiveGames() {
        return Array.from(this.activeGames.values());
    }

    // Update games list in UI
    updateGamesList() {
        const gamesList = document.getElementById('activeGamesList');
        if (!gamesList) return;

        const games = this.getActiveGames();
        gamesList.innerHTML = '';

        games.forEach(game => {
            const gameElement = document.createElement('div');
            gameElement.className = 'active-game-item';
            gameElement.innerHTML = `
                <div class="game-info">
                    <span class="game-type">${game.gameType}</span>
                    <span class="game-stake">${game.stake} CORE</span>
                </div>
                <div class="game-status ${game.status}">${game.status}</div>
                <div class="game-actions">
                    ${game.status === 'waiting' ? `<button onclick="joinGame(${game.gameId})">Join</button>` : ''}
                    ${game.player1 === userAccount ? `<button onclick="cancelGame(${game.gameId})">Cancel</button>` : ''}
                </div>
            `;
            gamesList.appendChild(gameElement);
        });
    }

    // Update player stats in UI
    updatePlayerStats() {
        const statsElements = {
            gamesPlayed: document.getElementById('gamesPlayed'),
            gamesWon: document.getElementById('gamesWon'),
            winRate: document.getElementById('winRate'),
            totalStaked: document.getElementById('totalStaked'),
            totalWon: document.getElementById('totalWon')
        };

        if (statsElements.gamesPlayed) {
            statsElements.gamesPlayed.textContent = this.playerStats.gamesPlayed;
        }
        if (statsElements.gamesWon) {
            statsElements.gamesWon.textContent = this.playerStats.gamesWon;
        }
        if (statsElements.winRate) {
            const winRate = this.playerStats.gamesPlayed > 0 ? 
                (this.playerStats.gamesWon / this.playerStats.gamesPlayed * 100).toFixed(1) : 0;
            statsElements.winRate.textContent = `${winRate}%`;
        }
        if (statsElements.totalStaked) {
            statsElements.totalStaked.textContent = `${this.playerStats.totalStaked.toFixed(4)} CORE`;
        }
        if (statsElements.totalWon) {
            statsElements.totalWon.textContent = `${this.playerStats.totalWon.toFixed(4)} CORE`;
        }
    }
}

// Initialize game state manager
const gameStateManager = new GameStateManager();

// Enhanced Blockchain Game Functions
async function createBlockchainGame(gameType, stakeAmount) {
    if (!contract) {
        showNotification('🔗 Please connect your wallet first!', 'error');
        return;
    }

    try {
        const button = document.getElementById(gameType + 'Btn');
        button.textContent = 'Creating Game...';
        button.disabled = true;

        // Validate stake amount
        const balance = await provider.getBalance(userAccount);
        const balanceEth = parseFloat(ethers.utils.formatEther(balance));
        
        if (balanceEth < stakeAmount) {
            throw new Error(`Insufficient balance. You need ${stakeAmount} CORE but only have ${balanceEth.toFixed(4)} CORE`);
        }

        // Create game on blockchain
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        showNotification(`🎮 Creating ${gameType} game with ${stakeAmount} CORE stake...`, 'info');
        
        const tx = await contract.createGame(gameType, stakeWei, {
            value: stakeWei,
            gasLimit: 200000
        });

        console.log('⏳ Transaction sent:', tx.hash);
        button.textContent = 'Confirming...';
        
        // Show transaction in UI
        showTransactionStatus(tx.hash, 'pending');

        // Wait for confirmation
        const receipt = await tx.wait();
        
        console.log('✅ Game created! Block:', receipt.blockNumber);
        
        // Get game ID from event
        const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
        const gameId = gameCreatedEvent?.args?.gameId?.toString();

        // Add to game state manager
        gameStateManager.addGame(gameId, {
            gameId: gameId,
            player1: userAccount,
            player2: null,
            stake: stakeAmount,
            gameType: gameType,
            transactionHash: tx.hash
        });

        showNotification(`🎉 SUCCESS! Game created on blockchain!\n\nGame ID: ${gameId}\nStake: ${stakeAmount} CORE`, 'success');
        showTransactionStatus(tx.hash, 'confirmed');

        button.textContent = `Game Created! (ID: ${gameId})`;
        button.style.background = '#10b981';

        // Update player stats
        gameStateManager.playerStats.totalStaked += stakeAmount;
        gameStateManager.updatePlayerStats();

    } catch (error) {
        console.error('Game creation failed:', error);
        showNotification('❌ Game creation failed: ' + error.message, 'error');
        
        // Reset button
        const button = document.getElementById(gameType + 'Btn');
        button.textContent = `Create Game (${stakeAmount} CORE)`;
        button.disabled = false;
    }
}

async function joinGame(gameId) {
    if (!contract) {
        showNotification('🔗 Please connect your wallet first!', 'error');
        return;
    }

    try {
        showNotification(`🎮 Joining game ${gameId}...`, 'info');

        // Get game details
        const gameData = await contract.games(gameId);
        const stakeAmount = parseFloat(ethers.utils.formatEther(gameData.stake));

        // Validate balance
        const balance = await provider.getBalance(userAccount);
        const balanceEth = parseFloat(ethers.utils.formatEther(balance));
        
        if (balanceEth < stakeAmount) {
            throw new Error(`Insufficient balance. You need ${stakeAmount} CORE to join this game`);
        }

        const tx = await contract.joinGame(gameId, {
            value: gameData.stake,
            gasLimit: 150000
        });

        console.log('⏳ Joining game transaction:', tx.hash);
        showTransactionStatus(tx.hash, 'pending');

        const receipt = await tx.wait();
        console.log('✅ Game joined! Block:', receipt.blockNumber);

        // Update game state
        gameStateManager.updateGameStatus(gameId, 'active', {
            player2: userAccount,
            transactionHash: tx.hash
        });

        showNotification(`🎉 Successfully joined game ${gameId}!`, 'success');
        showTransactionStatus(tx.hash, 'confirmed');

        // Start the actual game
        startGame(gameId, gameData.gameType);

    } catch (error) {
        console.error('Join game failed:', error);
        showNotification('❌ Failed to join game: ' + error.message, 'error');
    }
}

async function cancelGame(gameId) {
    if (!contract) {
        showNotification('🔗 Please connect your wallet first!', 'error');
        return;
    }

    try {
        showNotification(`🎮 Cancelling game ${gameId}...`, 'info');

        const tx = await contract.cancelGame(gameId, {
            gasLimit: 100000
        });

        console.log('⏳ Cancel game transaction:', tx.hash);
        showTransactionStatus(tx.hash, 'pending');

        const receipt = await tx.wait();
        console.log('✅ Game cancelled! Block:', receipt.blockNumber);

        // Update game state
        gameStateManager.updateGameStatus(gameId, 'cancelled');

        showNotification(`🎉 Game ${gameId} cancelled successfully!`, 'success');
        showTransactionStatus(tx.hash, 'confirmed');

    } catch (error) {
        console.error('Cancel game failed:', error);
        showNotification('❌ Failed to cancel game: ' + error.message, 'error');
    }
}

// Transaction Status and Notification System
function showTransactionStatus(txHash, status) {
    const statusContainer = document.getElementById('transactionStatus');
    if (!statusContainer) return;

    const statusElement = document.createElement('div');
    statusElement.className = `transaction-item ${status}`;
    statusElement.innerHTML = `
        <div class="transaction-info">
            <span class="transaction-hash">${txHash.slice(0, 10)}...${txHash.slice(-8)}</span>
            <span class="transaction-status ${status}">${status.toUpperCase()}</span>
        </div>
        <a href="https://scan.coredao.org/tx/${txHash}" target="_blank" class="view-tx">View</a>
    `;

    statusContainer.appendChild(statusElement);

    // Auto-remove after 10 seconds for confirmed transactions
    if (status === 'confirmed') {
        setTimeout(() => {
            statusElement.remove();
        }, 10000);
    }
}

function showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <div class="notification-content">
            <span class="notification-icon">${getNotificationIcon(type)}</span>
            <span class="notification-message">${message}</span>
        </div>
        <button class="notification-close" onclick="this.parentElement.remove()">×</button>
    `;

    // Add to page
    let notificationContainer = document.getElementById('notificationContainer');
    if (!notificationContainer) {
        notificationContainer = document.createElement('div');
        notificationContainer.id = 'notificationContainer';
        notificationContainer.className = 'notification-container';
        document.body.appendChild(notificationContainer);
    }

    notificationContainer.appendChild(notification);

    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 5000);

    // Add slide-in animation
    setTimeout(() => {
        notification.classList.add('show');
    }, 100);
}

function getNotificationIcon(type) {
    switch (type) {
        case 'success': return '✅';
        case 'error': return '❌';
        case 'warning': return '⚠️';
        case 'info': return 'ℹ️';
        default: return 'ℹ️';
    }
}

// CSS for notifications and transaction status (add to your existing styles)
const notificationStyles = `
    .notification-container {
        position: fixed;
        top: 60px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 350px;
    }

    .notification {
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 16px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        transform: translateX(400px);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .notification.show {
        transform: translateX(0);
    }

    .notification.success {
        background: rgba(16, 185, 129, 0.95);
        color: white;
        border-color: rgba(16, 185, 129, 0.5);
    }

    .notification.error {
        background: rgba(239, 68, 68, 0.95);
        color: white;
        border-color: rgba(239, 68, 68, 0.5);
    }

    .notification.warning {
        background: rgba(245, 158, 11, 0.95);
        color: white;
        border-color: rgba(245, 158, 11, 0.5);
    }

    .notification-content {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
    }

    .notification-message {
        font-size: 14px;
        font-weight: 500;
        white-space: pre-line;
    }

    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 20px;
        cursor: pointer;
        padding: 0;
        margin-left: 10px;
    }

    .transaction-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .transaction-item.pending {
        border-color: #f59e0b;
        background: rgba(245, 158, 11, 0.1);
    }

    .transaction-item.confirmed {
        border-color: #10b981;
        background: rgba(16, 185, 129, 0.1);
    }

    .transaction-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .transaction-hash {
        font-family: monospace;
        font-size: 12px;
        color: #94a3b8;
    }

    .transaction-status {
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        padding: 2px 6px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.2);
    }

    .transaction-status.pending {
        background: rgba(245, 158, 11, 0.3);
        color: #f59e0b;
    }

    .transaction-status.confirmed {
        background: rgba(16, 185, 129, 0.3);
        color: #10b981;
    }

    .view-tx {
        color: #10b981;
        text-decoration: none;
        font-size: 12px;
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid rgba(16, 185, 129, 0.3);
    }
`;

// Add notification styles to page
const styleSheet = document.createElement('style');
styleSheet.textContent = notificationStyles;
document.head.appendChild(styleSheet);

// Event Listeners and Real-time Updates
function setupContractEventListeners() {
    if (!contract) return;

    // Listen for GameCreated events
    contract.on('GameCreated', (gameId, player1, stake, gameType, event) => {
        console.log('🎮 Game Created:', {
            gameId: gameId.toString(),
            player1,
            stake: ethers.utils.formatEther(stake),
            gameType
        });

        // Add to active games if not already there
        if (!gameStateManager.activeGames.has(gameId.toString())) {
            gameStateManager.addGame(gameId.toString(), {
                gameId: gameId.toString(),
                player1,
                player2: null,
                stake: parseFloat(ethers.utils.formatEther(stake)),
                gameType,
                transactionHash: event.transactionHash
            });
        }

        // Show notification if it's another player's game
        if (player1.toLowerCase() !== userAccount.toLowerCase()) {
            showNotification(`🎮 New ${gameType} game available! Stake: ${ethers.utils.formatEther(stake)} CORE`, 'info');
        }
    });

    // Listen for GameJoined events
    contract.on('GameJoined', (gameId, player2, event) => {
        console.log('🎮 Game Joined:', {
            gameId: gameId.toString(),
            player2
        });

        gameStateManager.updateGameStatus(gameId.toString(), 'active', {
            player2,
            transactionHash: event.transactionHash
        });

        // Show notification
        if (player2.toLowerCase() === userAccount.toLowerCase()) {
            showNotification(`🎉 You joined game ${gameId}!`, 'success');
        } else {
            showNotification(`🎮 Player joined game ${gameId}!`, 'info');
        }
    });

    // Listen for GameEnded events
    contract.on('GameEnded', (gameId, winner, payout, event) => {
        console.log('🎮 Game Ended:', {
            gameId: gameId.toString(),
            winner,
            payout: ethers.utils.formatEther(payout)
        });

        const payoutAmount = parseFloat(ethers.utils.formatEther(payout));
        gameStateManager.endGame(gameId.toString(), winner, payoutAmount);

        // Show notification
        if (winner.toLowerCase() === userAccount.toLowerCase()) {
            showNotification(`🎉 You won game ${gameId}! Payout: ${payoutAmount} CORE`, 'success');
        } else {
            showNotification(`🎮 Game ${gameId} ended. Winner: ${winner.slice(0, 6)}...${winner.slice(-4)}`, 'info');
        }
    });

    // Listen for GameCancelled events
    contract.on('GameCancelled', (gameId, player, event) => {
        console.log('🎮 Game Cancelled:', {
            gameId: gameId.toString(),
            player
        });

        gameStateManager.updateGameStatus(gameId.toString(), 'cancelled');

        showNotification(`🎮 Game ${gameId} was cancelled`, 'info');
    });
}

// Load existing games from blockchain
async function loadExistingGames() {
    if (!contract) return;

    try {
        // Get total number of games
        const gameCounter = await contract.gameCounter();
        const totalGames = parseInt(gameCounter.toString());

        showNotification(`📊 Loading ${totalGames} games from blockchain...`, 'info');

        // Load recent games (last 50 or all if less)
        const startIndex = Math.max(1, totalGames - 49);
        const loadPromises = [];

        for (let i = startIndex; i <= totalGames; i++) {
            loadPromises.push(loadGameData(i));
        }

        const gameDataList = await Promise.all(loadPromises);
        
        // Process loaded games
        gameDataList.forEach(gameData => {
            if (gameData && gameData.isActive) {
                gameStateManager.addGame(gameData.gameId, gameData);
            }
        });

        showNotification(`✅ Loaded ${gameDataList.filter(g => g && g.isActive).length} active games`, 'success');

    } catch (error) {
        console.error('Failed to load existing games:', error);
        showNotification('⚠️ Failed to load existing games: ' + error.message, 'warning');
    }
}

async function loadGameData(gameId) {
    try {
        const gameData = await contract.games(gameId);
        
        return {
            gameId: gameId.toString(),
            player1: gameData.player1,
            player2: gameData.player2,
            stake: parseFloat(ethers.utils.formatEther(gameData.stake)),
            isActive: gameData.isActive,
            winner: gameData.winner,
            gameType: gameData.gameType || 'Unknown'
        };
    } catch (error) {
        console.error(`Failed to load game ${gameId}:`, error);
        return null;
    }
}

// Refresh game data periodically
function startGameRefreshInterval() {
    setInterval(async () => {
        if (contract && userAccount) {
            try {
                // Refresh player stats from blockchain
                const stats = await contract.getPlayerStats(userAccount);
                if (stats && stats.length >= 4) {
                    gameStateManager.playerStats = {
                        gamesPlayed: parseInt(stats[0].toString()),
                        gamesWon: parseInt(stats[1].toString()),
                        totalStaked: parseFloat(ethers.utils.formatEther(stats[2])),
                        totalWon: parseFloat(ethers.utils.formatEther(stats[3]))
                    };
                    gameStateManager.updatePlayerStats();
                }

                // Refresh balance
                const balance = await provider.getBalance(userAccount);
                const balanceFormatted = ethers.utils.formatEther(balance);
                const balanceElement = document.getElementById('walletBalance');
                if (balanceElement) {
                    balanceElement.textContent = `${parseFloat(balanceFormatted).toFixed(4)} CORE`;
                }

            } catch (error) {
                console.error('Failed to refresh data:', error);
            }
        }
    }, 30000); // Refresh every 30 seconds
}

// Initialize all event listeners and data loading
async function initializeGameSystem() {
    if (!contract) return;

    setupContractEventListeners();
    await loadExistingGames();
    startGameRefreshInterval();
    
    showNotification('🎮 Game system initialized! Ready to play!', 'success');
}

// Enhanced Wallet Connection Function
async function connectWalletEnhanced() {
    try {
        if (typeof window.ethereum === 'undefined') {
            showNotification('🦊 Please install MetaMask or Core Wallet to play!', 'error');
            return;
        }

        showNotification('🔗 Connecting to Core Blockchain...', 'info');

        // Request account access
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // Switch to Core Chain
        try {
            await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: '0x45C' }], // 1116 in hex
            });
        } catch (switchError) {
            if (switchError.code === 4902) {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: '0x45C',
                        chainName: 'Core Blockchain',
                        nativeCurrency: {
                            name: 'CORE',
                            symbol: 'CORE',
                            decimals: 18
                        },
                        rpcUrls: ['https://rpc.coredao.org'],
                        blockExplorerUrls: ['https://scan.coredao.org']
                    }]
                });
            }
        }

        // Initialize ethers
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        userAccount = await signer.getAddress();
        
        // Initialize contract with complete ABI
        contract = new ethers.Contract(CONTRACT_ADDRESS, COMPLETE_CONTRACT_ABI, signer);

        // Update UI
        updateWalletUI();
        
        // Initialize game system
        await initializeGameSystem();

        showNotification('✅ Successfully connected to Core Blockchain!', 'success');

    } catch (error) {
        console.error('Connection failed:', error);
        showNotification('❌ Connection failed: ' + error.message, 'error');
    }
}

// UI Update Functions
async function updateWalletUI() {
    // Update connection status
    const statusDot = document.getElementById('statusDot');
    const walletStatus = document.getElementById('walletStatus');
    const connectBtn = document.getElementById('connectBtn');
    const walletBalance = document.getElementById('walletBalance');

    if (statusDot) statusDot.classList.add('connected');
    if (walletStatus) walletStatus.textContent = 'Connected to Core';
    if (connectBtn) {
        connectBtn.textContent = 'Connected';
        connectBtn.style.background = '#10b981';
        connectBtn.disabled = true;
    }

    // Show wallet address
    const shortAddress = userAccount.slice(0, 6) + '...' + userAccount.slice(-4);
    
    // Get and display balance
    try {
        const balance = await provider.getBalance(userAccount);
        const balanceFormatted = ethers.utils.formatEther(balance);
        if (walletBalance) {
            walletBalance.textContent = `${parseFloat(balanceFormatted).toFixed(4)} CORE`;
        }
        console.log('💰 Balance:', balanceFormatted, 'CORE');
    } catch (error) {
        console.error('Failed to get balance:', error);
        if (walletBalance) {
            walletBalance.textContent = shortAddress;
        }
    }

    // Enable game buttons
    enableGameButtons();
}

function enableGameButtons() {
    const gameButtons = document.querySelectorAll('.create-game-btn');
    gameButtons.forEach(btn => {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
    });
}

function disableGameButtons() {
    const gameButtons = document.querySelectorAll('.create-game-btn');
    gameButtons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
    });
}

// Game Management Interface Functions
function createGameManagementSection() {
    const mainContent = document.querySelector('.main-content');
    if (!mainContent) return;

    // Create active games section
    const activeGamesSection = document.createElement('div');
    activeGamesSection.innerHTML = `
        <div class="section-header">
            <h2 class="section-title">🎮 Active Games</h2>
            <button class="refresh-btn" onclick="loadExistingGames()">🔄 Refresh</button>
        </div>
        <div id="activeGamesList" class="active-games-list">
            <div class="no-games-message">
                <span>No active games found. Create a game to get started!</span>
            </div>
        </div>
    `;

    // Create player stats section
    const playerStatsSection = document.createElement('div');
    playerStatsSection.innerHTML = `
        <h2 class="section-title">📊 Your Stats</h2>
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value" id="gamesPlayed">0</div>
                <div class="stat-label">Games Played</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="gamesWon">0</div>
                <div class="stat-label">Games Won</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="winRate">0%</div>
                <div class="stat-label">Win Rate</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalStaked">0 CORE</div>
                <div class="stat-label">Total Staked</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalWon">0 CORE</div>
                <div class="stat-label">Total Won</div>
            </div>
        </div>
    `;

    // Create transaction status section
    const transactionSection = document.createElement('div');
    transactionSection.innerHTML = `
        <h2 class="section-title">📋 Recent Transactions</h2>
        <div id="transactionStatus" class="transaction-status">
            <div class="no-transactions-message">
                <span>No recent transactions</span>
            </div>
        </div>
    `;

    // Insert sections after games grid
    const gamesGrid = document.querySelector('.games-grid');
    if (gamesGrid && gamesGrid.parentNode) {
        gamesGrid.parentNode.insertBefore(activeGamesSection, gamesGrid.nextSibling);
        activeGamesSection.parentNode.insertBefore(playerStatsSection, activeGamesSection.nextSibling);
        playerStatsSection.parentNode.insertBefore(transactionSection, playerStatsSection.nextSibling);
    }
}

// Add CSS for new sections
const gameManagementStyles = `
    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
    }

    .refresh-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 8px 12px;
        color: white;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .refresh-btn:hover {
        background: rgba(255, 255, 255, 0.2);
    }

    .active-games-list {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 16px;
        margin-bottom: 30px;
        min-height: 100px;
    }

    .active-game-item {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .active-game-item:last-child {
        margin-bottom: 0;
    }

    .game-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .game-type {
        font-weight: 600;
        color: #ff6b35;
    }

    .game-stake {
        font-size: 12px;
        color: #94a3b8;
    }

    .game-status {
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
    }

    .game-status.waiting {
        background: rgba(245, 158, 11, 0.2);
        color: #f59e0b;
    }

    .game-status.active {
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
    }

    .game-status.completed {
        background: rgba(107, 114, 128, 0.2);
        color: #6b7280;
    }

    .game-actions {
        display: flex;
        gap: 8px;
    }

    .game-actions button {
        background: #ff6b35;
        border: none;
        border-radius: 6px;
        padding: 6px 12px;
        color: white;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .game-actions button:hover {
        background: #ff8e53;
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 16px;
        margin-bottom: 30px;
    }

    .stat-item {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .stat-value {
        font-size: 24px;
        font-weight: 800;
        color: #ff6b35;
        margin-bottom: 4px;
    }

    .stat-label {
        font-size: 12px;
        color: #94a3b8;
        font-weight: 600;
    }

    .transaction-status {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 16px;
        margin-bottom: 30px;
        max-height: 300px;
        overflow-y: auto;
    }

    .no-games-message,
    .no-transactions-message {
        text-align: center;
        color: #94a3b8;
        font-style: italic;
        padding: 20px;
    }
`;

// Add the styles to the page
const gameManagementStyleSheet = document.createElement('style');
gameManagementStyleSheet.textContent = gameManagementStyles;
document.head.appendChild(gameManagementStyleSheet);

// Error Handling and Recovery Functions
class ErrorHandler {
    static handleWeb3Error(error, context = 'Transaction') {
        console.error(`${context} Error:`, error);

        if (error.code === 4001) {
            showNotification('❌ Transaction rejected by user', 'error');
        } else if (error.code === -32603) {
            showNotification('⚠️ Network error. Please check your connection.', 'warning');
        } else if (error.message?.includes('insufficient funds')) {
            showNotification('💰 Insufficient funds for this transaction', 'error');
        } else if (error.message?.includes('gas')) {
            showNotification('⛽ Gas estimation failed. Try again with higher gas limit.', 'warning');
        } else if (error.message?.includes('revert')) {
            const revertReason = this.extractRevertReason(error.message);
            showNotification(`❌ Transaction failed: ${revertReason}`, 'error');
        } else {
            showNotification(`❌ ${context} failed: ${error.message}`, 'error');
        }
    }

    static extractRevertReason(errorMessage) {
        const revertMatch = errorMessage.match(/revert (.+)/);
        return revertMatch ? revertMatch[1] : 'Unknown error';
    }

    static async handleConnectionLoss() {
        showNotification('🔗 Connection lost. Attempting to reconnect...', 'warning');
        
        try {
            if (window.ethereum && userAccount) {
                await connectWalletEnhanced();
                showNotification('✅ Reconnected successfully!', 'success');
            }
        } catch (error) {
            showNotification('❌ Reconnection failed. Please refresh the page.', 'error');
        }
    }

    static handleContractError(error, functionName) {
        console.error(`Contract ${functionName} Error:`, error);
        
        if (error.message?.includes('game does not exist')) {
            showNotification('❌ Game not found. It may have been cancelled.', 'error');
        } else if (error.message?.includes('game already joined')) {
            showNotification('⚠️ This game has already been joined by another player.', 'warning');
        } else if (error.message?.includes('not your game')) {
            showNotification('❌ You can only cancel games you created.', 'error');
        } else if (error.message?.includes('game not active')) {
            showNotification('⚠️ This game is no longer active.', 'warning');
        } else {
            this.handleWeb3Error(error, `Contract ${functionName}`);
        }
    }
}

// Network connectivity checker
function startNetworkMonitoring() {
    let wasOnline = navigator.onLine;

    setInterval(async () => {
        const isOnline = navigator.onLine;
        
        if (!isOnline && wasOnline) {
            showNotification('📡 Network connection lost', 'warning');
        } else if (isOnline && !wasOnline) {
            showNotification('📡 Network connection restored', 'success');
            if (contract && userAccount) {
                // Refresh data after reconnection
                await loadExistingGames();
            }
        }
        
        wasOnline = isOnline;
    }, 5000);
}

// Auto-retry mechanism for failed transactions
async function retryTransaction(transactionFunction, maxRetries = 3, delay = 2000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            showNotification(`⏳ Attempt ${attempt}/${maxRetries}...`, 'info');
            const result = await transactionFunction();
            return result;
        } catch (error) {
            console.error(`Attempt ${attempt} failed:`, error);
            
            if (attempt === maxRetries) {
                ErrorHandler.handleWeb3Error(error, 'Retry');
                throw error;
            }
            
            showNotification(`⚠️ Attempt ${attempt} failed, retrying in ${delay/1000}s...`, 'warning');
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 1.5; // Exponential backoff
        }
    }
}

// Safe contract interaction wrapper
async function safeContractCall(contractMethod, ...args) {
    try {
        if (!contract) {
            throw new Error('Contract not initialized. Please connect your wallet.');
        }

        if (!userAccount) {
            throw new Error('Wallet not connected. Please connect your wallet.');
        }

        // Check network
        const network = await provider.getNetwork();
        if (network.chainId !== CORE_CHAIN_ID) {
            throw new Error('Wrong network. Please switch to Core Blockchain.');
        }

        return await contractMethod(...args);
    } catch (error) {
        ErrorHandler.handleContractError(error, contractMethod.name || 'Unknown');
        throw error;
    }
}

// Wallet validation
async function validateWalletState() {
    try {
        if (!window.ethereum) {
            throw new Error('No Web3 wallet detected');
        }

        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length === 0) {
            throw new Error('No accounts connected');
        }

        const network = await provider.getNetwork();
        if (network.chainId !== CORE_CHAIN_ID) {
            throw new Error('Wrong network connected');
        }

        return true;
    } catch (error) {
        console.error('Wallet validation failed:', error);
        return false;
    }
}

// Final Initialization and Setup
document.addEventListener('DOMContentLoaded', function() {
    console.log('🎮 Crypticus Gaming Platform Loading...');
    
    // Initialize UI components
    initializeUI();
    
    // Start network monitoring
    startNetworkMonitoring();
    
    // Set up event listeners
    setupEventListeners();
    
    // Check for existing wallet connection
    checkExistingConnection();
    
    console.log('✅ Platform initialized successfully!');
});

function initializeUI() {
    // Disable game buttons initially
    disableGameButtons();
    
    // Create game management sections
    createGameManagementSection();
    
    // Initialize time display
    updateTime();
    
    // Set up auto-time updates
    setInterval(updateTime, 1000);
    
    // Add loading state to connect button
    const connectBtn = document.getElementById('connectBtn');
    if (connectBtn) {
        connectBtn.addEventListener('click', async () => {
            connectBtn.textContent = 'Connecting...';
            connectBtn.disabled = true;
            
            try {
                await connectWalletEnhanced();
            } catch (error) {
                connectBtn.textContent = 'Connect';
                connectBtn.disabled = false;
            }
        });
    }
}

function setupEventListeners() {
    // Handle wallet events
    if (window.ethereum) {
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);
        window.ethereum.on('disconnect', handleDisconnect);
    }
    
    // Handle visibility change (tab switching)
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Handle page unload
    window.addEventListener('beforeunload', handlePageUnload);
}

async function handleAccountsChanged(accounts) {
    console.log('Accounts changed:', accounts);
    
    if (accounts.length === 0) {
        // User disconnected
        resetWalletState();
        showNotification('👋 Wallet disconnected', 'info');
    } else if (accounts[0] !== userAccount) {
        // User switched accounts
        showNotification('🔄 Account changed, reconnecting...', 'info');
        await connectWalletEnhanced();
    }
}

function handleChainChanged(chainId) {
    console.log('Chain changed:', chainId);
    showNotification('🔄 Network changed, reloading...', 'info');
    setTimeout(() => location.reload(), 1500);
}

function handleDisconnect() {
    console.log('Wallet disconnected');
    resetWalletState();
    showNotification('👋 Wallet disconnected', 'info');
}

function handleVisibilityChange() {
    if (!document.hidden && contract && userAccount) {
        // Page became visible, refresh data
        console.log('Page visible, refreshing data...');
        refreshGameData();
    }
}

function handlePageUnload() {
    // Clean up event listeners
    if (window.ethereum && contract) {
        contract.removeAllListeners();
    }
}

function resetWalletState() {
    provider = null;
    signer = null;
    contract = null;
    userAccount = null;
    
    // Reset UI
    const statusDot = document.getElementById('statusDot');
    const walletStatus = document.getElementById('walletStatus');
    const connectBtn = document.getElementById('connectBtn');
    const walletBalance = document.getElementById('walletBalance');
    
    if (statusDot) statusDot.classList.remove('connected');
    if (walletStatus) walletStatus.textContent = 'Not Connected';
    if (connectBtn) {
        connectBtn.textContent = 'Connect';
        connectBtn.style.background = '';
        connectBtn.disabled = false;
    }
    if (walletBalance) walletBalance.textContent = '0.00 CORE';
    
    // Disable game buttons
    disableGameButtons();
    
    // Clear game state
    gameStateManager.activeGames.clear();
    gameStateManager.updateGamesList();
}

async function checkExistingConnection() {
    if (window.ethereum) {
        try {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.length > 0) {
                showNotification('🔄 Restoring wallet connection...', 'info');
                await connectWalletEnhanced();
            }
        } catch (error) {
            console.error('Failed to check existing connection:', error);
        }
    }
}

async function refreshGameData() {
    if (!contract || !userAccount) return;
    
    try {
        await loadExistingGames();
        
        // Refresh balance
        const balance = await provider.getBalance(userAccount);
        const balanceFormatted = ethers.utils.formatEther(balance);
        const balanceElement = document.getElementById('walletBalance');
        if (balanceElement) {
            balanceElement.textContent = `${parseFloat(balanceFormatted).toFixed(4)} CORE`;
        }
        
        console.log('✅ Game data refreshed');
    } catch (error) {
        console.error('Failed to refresh game data:', error);
    }
}

// Platform status indicator
function createPlatformStatus() {
    const platformStatus = document.createElement('div');
    platformStatus.id = 'platformStatus';
    platformStatus.innerHTML = `
        <div class="platform-status">
            <span class="status-indicator">🟢</span>
            <span>Platform Online</span>
            <span class="network-info">Core Blockchain</span>
        </div>
    `;
    
    const header = document.querySelector('.header');
    if (header) {
        header.appendChild(platformStatus);
    }
}

// Add platform status styles
const platformStatusStyles = `
    .platform-status {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(16, 185, 129, 0.1);
        border: 1px solid rgba(16, 185, 129, 0.3);
        border-radius: 8px;
        padding: 8px 12px;
        margin-top: 12px;
        font-size: 12px;
        font-weight: 600;
    }
    
    .status-indicator {
        font-size: 8px;
    }
    
    .network-info {
        color: #10b981;
        margin-left: auto;
    }
`;

const platformStatusStyleSheet = document.createElement('style');
platformStatusStyleSheet.textContent = platformStatusStyles;
document.head.appendChild(platformStatusStyleSheet);

// Initialize platform status
createPlatformStatus();

console.log('🎮 Crypticus Gaming Platform - All components loaded!');

</script>
    
    <!-- Additional utility script for enhanced functionality -->
    <script>
    // COMPLETE CHESS GAME ENGINE
        class ChessEngine {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.gameHistory = [];
                this.isGameOver = false;
                this.winner = null;
                this.selectedSquare = null;
                this.validMoves = [];
                this.kingPositions = { white: {row: 7, col: 4}, black: {row: 0, col: 4} };
                this.hasMoved = {
                    whiteKing: false,
                    blackKing: false,
                    whiteRookLeft: false,
                    whiteRookRight: false,
                    blackRookLeft: false,
                    blackRookRight: false
                };
            }

            initializeBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            getPieceAt(row, col) {
                if (row < 0 || row > 7 || col < 0 || col > 7) return null;
                return this.board[row][col];
            }

            setPieceAt(row, col, piece) {
                if (row >= 0 && row <= 7 && col >= 0 && col <= 7) {
                    this.board[row][col] = piece;
                }
            }

            isWhitePiece(piece) {
                return piece && piece === piece.toUpperCase();
            }

            isBlackPiece(piece) {
                return piece && piece === piece.toLowerCase();
            }

            isOwnPiece(piece, player) {
                if (!piece) return false;
                return player === 'white' ? this.isWhitePiece(piece) : this.isBlackPiece(piece);
            }

            isEnemyPiece(piece, player) {
                if (!piece) return false;
                return player === 'white' ? this.isBlackPiece(piece) : this.isWhitePiece(piece);
            }

            // Get all valid moves for a piece
            getValidMoves(row, col) {
                const piece = this.getPieceAt(row, col);
                if (!piece || !this.isOwnPiece(piece, this.currentPlayer)) return [];

                let moves = [];
                const pieceType = piece.toLowerCase();

                switch (pieceType) {
                    case 'p': moves = this.getPawnMoves(row, col); break;
                    case 'r': moves = this.getRookMoves(row, col); break;
                    case 'n': moves = this.getKnightMoves(row, col); break;
                    case 'b': moves = this.getBishopMoves(row, col); break;
                    case 'q': moves = this.getQueenMoves(row, col); break;
                    case 'k': moves = this.getKingMoves(row, col); break;
                }

                // Filter moves that would put own king in check
                return moves.filter(move => !this.wouldBeInCheck(row, col, move.row, move.col, this.currentPlayer));
            }

            getPawnMoves(row, col) {
                const moves = [];
                const piece = this.getPieceAt(row, col);
                const isWhite = this.isWhitePiece(piece);
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;

                // Forward move
                if (!this.getPieceAt(row + direction, col)) {
                    moves.push({row: row + direction, col: col});
                    
                    // Two squares from start
                    if (row === startRow && !this.getPieceAt(row + 2 * direction, col)) {
                        moves.push({row: row + 2 * direction, col: col});
                    }
                }

                // Diagonal captures
                [-1, 1].forEach(dcol => {
                    const newCol = col + dcol;
                    const targetPiece = this.getPieceAt(row + direction, newCol);
                    if (targetPiece && this.isEnemyPiece(targetPiece, this.currentPlayer)) {
                        moves.push({row: row + direction, col: newCol});
                    }
                });

                return moves;
            }

            getRookMoves(row, col) {
                const moves = [];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

                directions.forEach(([drow, dcol]) => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * drow;
                        const newCol = col + i * dcol;
                        const piece = this.getPieceAt(newRow, newCol);

                        if (piece === null) {
                            moves.push({row: newRow, col: newCol});
                        } else {
                            if (this.isEnemyPiece(piece, this.currentPlayer)) {
                                moves.push({row: newRow, col: newCol});
                            }
                            break;
                        }
                    }
                });

                return moves;
            }

            getKnightMoves(row, col) {
                const moves = [];
                const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];

                knightMoves.forEach(([drow, dcol]) => {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    const piece = this.getPieceAt(newRow, newCol);

                    if (piece === null || this.isEnemyPiece(piece, this.currentPlayer)) {
                        moves.push({row: newRow, col: newCol});
                    }
                });

                return moves;
            }

            getBishopMoves(row, col) {
                const moves = [];
                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                directions.forEach(([drow, dcol]) => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * drow;
                        const newCol = col + i * dcol;
                        const piece = this.getPieceAt(newRow, newCol);

                        if (piece === null) {
                            moves.push({row: newRow, col: newCol});
                        } else {
                            if (this.isEnemyPiece(piece, this.currentPlayer)) {
                                moves.push({row: newRow, col: newCol});
                            }
                            break;
                        }
                    }
                });

                return moves;
            }

            getQueenMoves(row, col) {
                return [...this.getRookMoves(row, col), ...this.getBishopMoves(row, col)];
            }

            getKingMoves(row, col) {
                const moves = [];
                const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];

                directions.forEach(([drow, dcol]) => {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    const piece = this.getPieceAt(newRow, newCol);

                    if (piece === null || this.isEnemyPiece(piece, this.currentPlayer)) {
                        moves.push({row: newRow, col: newCol});
                    }
                });

                return moves;
            }

            // Check if a move would put the player's king in check
            wouldBeInCheck(fromRow, fromCol, toRow, toCol, player) {
                // Make temporary move
                const originalPiece = this.getPieceAt(toRow, toCol);
                const movingPiece = this.getPieceAt(fromRow, fromCol);
                
                this.setPieceAt(toRow, toCol, movingPiece);
                this.setPieceAt(fromRow, fromCol, null);

                // Update king position if king moved
                let kingPos = {...this.kingPositions[player]};
                if (movingPiece && movingPiece.toLowerCase() === 'k') {
                    kingPos = {row: toRow, col: toCol};
                }

                const inCheck = this.isSquareUnderAttack(kingPos.row, kingPos.col, player === 'white' ? 'black' : 'white');

                // Restore board
                this.setPieceAt(fromRow, fromCol, movingPiece);
                this.setPieceAt(toRow, toCol, originalPiece);

                return inCheck;
            }

            // Check if a square is under attack by the opponent
            isSquareUnderAttack(row, col, byPlayer) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.getPieceAt(r, c);
                        if (piece && this.isOwnPiece(piece, byPlayer)) {
                            const moves = this.getRawValidMoves(r, c);
                            if (moves.some(move => move.row === row && move.col === col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // Get raw valid moves without check validation (to avoid infinite recursion)
            getRawValidMoves(row, col) {
                const piece = this.getPieceAt(row, col);
                if (!piece) return [];

                const pieceType = piece.toLowerCase();
                switch (pieceType) {
                    case 'p': return this.getPawnMoves(row, col);
                    case 'r': return this.getRookMoves(row, col);
                    case 'n': return this.getKnightMoves(row, col);
                    case 'b': return this.getBishopMoves(row, col);
                    case 'q': return this.getQueenMoves(row, col);
                    case 'k': return this.getKingMoves(row, col);
                    default: return [];
                }
            }

            // Make a move
            makeMove(fromRow, fromCol, toRow, toCol) {
                if (this.isGameOver) return false;

                const piece = this.getPieceAt(fromRow, fromCol);
                if (!piece || !this.isOwnPiece(piece, this.currentPlayer)) return false;

                const validMoves = this.getValidMoves(fromRow, fromCol);
                const isValidMove = validMoves.some(move => move.row === toRow && move.col === toCol);
                
                if (!isValidMove) return false;

                // Execute move
                const capturedPiece = this.getPieceAt(toRow, toCol);
                this.setPieceAt(toRow, toCol, piece);
                this.setPieceAt(fromRow, fromCol, null);

                // Update king position
                if (piece.toLowerCase() === 'k') {
                    this.kingPositions[this.currentPlayer] = {row: toRow, col: toCol};
                    this.hasMoved[this.currentPlayer + 'King'] = true;
                }

                // Update rook moved status
                if (piece.toLowerCase() === 'r') {
                    if (fromRow === (this.currentPlayer === 'white' ? 7 : 0)) {
                        if (fromCol === 0) this.hasMoved[this.currentPlayer + 'RookLeft'] = true;
                        if (fromCol === 7) this.hasMoved[this.currentPlayer + 'RookRight'] = true;
                    }
                }

                // Record move
                this.gameHistory.push({
                    from: {row: fromRow, col: fromCol},
                    to: {row: toRow, col: toCol},
                    piece: piece,
                    captured: capturedPiece,
                    player: this.currentPlayer
                });

                // Switch turns
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';

                // Check game end conditions
                this.checkGameEnd();

                return true;
            }

            // Check for checkmate, stalemate, etc.
            checkGameEnd() {
                const hasValidMoves = this.hasValidMoves(this.currentPlayer);
                const inCheck = this.isInCheck(this.currentPlayer);

                if (!hasValidMoves) {
                    this.isGameOver = true;
                    if (inCheck) {
                        this.winner = this.currentPlayer === 'white' ? 'black' : 'white';
                    } else {
                        this.winner = 'draw'; // Stalemate
                    }
                }
            }

            hasValidMoves(player) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.getPieceAt(row, col);
                        if (piece && this.isOwnPiece(piece, player)) {
                            if (this.getValidMoves(row, col).length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            isInCheck(player) {
                const kingPos = this.kingPositions[player];
                return this.isSquareUnderAttack(kingPos.row, kingPos.col, player === 'white' ? 'black' : 'white');
            }

            // Get game state for synchronization
            getGameState() {
                return {
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer,
                    gameHistory: [...this.gameHistory],
                    isGameOver: this.isGameOver,
                    winner: this.winner,
                    kingPositions: {...this.kingPositions},
                    hasMoved: {...this.hasMoved}
                };
            }

            // Restore game state from synchronization
            setGameState(state) {
                this.board = JSON.parse(JSON.stringify(state.board));
                this.currentPlayer = state.currentPlayer;
                this.gameHistory = [...state.gameHistory];
                this.isGameOver = state.isGameOver;
                this.winner = state.winner;
                this.kingPositions = {...state.kingPositions};
                this.hasMoved = {...state.hasMoved};
            }

            // Get algebraic notation for a move
            getMoveNotation(fromRow, fromCol, toRow, toCol) {
                const piece = this.getPieceAt(toRow, toCol);
                const files = 'abcdefgh';
                const ranks = '87654321';
                
                const fromSquare = files[fromCol] + ranks[fromRow];
                const toSquare = files[toCol] + ranks[toRow];
                
                return `${piece.toUpperCase()}${fromSquare}-${toSquare}`;
            }
        }
        
        // COMPLETE CHECKERS GAME ENGINE
        class CheckersEngine {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'red'; // red moves first
                this.gameHistory = [];
                this.isGameOver = false;
                this.winner = null;
                this.selectedSquare = null;
                this.validMoves = [];
                this.mustCapture = false;
                this.captureSequence = [];
            }

            initializeBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Place red pieces (top)
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            board[row][col] = 'r'; // red piece
                        }
                    }
                }
                
                // Place black pieces (bottom)
                for (let row = 5; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            board[row][col] = 'b'; // black piece
                        }
                    }
                }
                
                return board;
            }

            getPieceAt(row, col) {
                if (row < 0 || row > 7 || col < 0 || col > 7) return null;
                return this.board[row][col];
            }

            setPieceAt(row, col, piece) {
                if (row >= 0 && row <= 7 && col >= 0 && col <= 7) {
                    this.board[row][col] = piece;
                }
            }

            isRedPiece(piece) {
                return piece === 'r' || piece === 'R'; // R = red king
            }

            isBlackPiece(piece) {
                return piece === 'b' || piece === 'B'; // B = black king
            }

            isKing(piece) {
                return piece === 'R' || piece === 'B';
            }

            isOwnPiece(piece, player) {
                if (!piece) return false;
                return player === 'red' ? this.isRedPiece(piece) : this.isBlackPiece(piece);
            }

            isEnemyPiece(piece, player) {
                if (!piece) return false;
                return player === 'red' ? this.isBlackPiece(piece) : this.isRedPiece(piece);
            }

            // Get all valid moves for a piece
            getValidMoves(row, col) {
                const piece = this.getPieceAt(row, col);
                if (!piece || !this.isOwnPiece(piece, this.currentPlayer)) return [];

                // Check for mandatory captures first
                const captures = this.getCaptureMovesFromSquare(row, col);
                if (this.mustCapture && captures.length > 0) {
                    return captures;
                }

                // If no captures required, get regular moves
                if (!this.mustCapture) {
                    const regularMoves = this.getRegularMovesFromSquare(row, col);
                    return [...captures, ...regularMoves];
                }

                return captures;
            }

            // Get capture moves from a specific square
            getCaptureMovesFromSquare(row, col) {
                const piece = this.getPieceAt(row, col);
                if (!piece) return [];

                const captures = [];
                const isKing = this.isKing(piece);
                const isRed = this.isRedPiece(piece);

                // Determine directions based on piece type
                let directions = [];
                if (isKing) {
                    directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; // All directions for kings
                } else if (isRed) {
                    directions = [[1, -1], [1, 1]]; // Red moves down
                } else {
                    directions = [[-1, -1], [-1, 1]]; // Black moves up
                }

                directions.forEach(([drow, dcol]) => {
                    const jumpRow = row + drow;
                    const jumpCol = col + dcol;
                    const landRow = row + 2 * drow;
                    const landCol = col + 2 * dcol;

                    const jumpedPiece = this.getPieceAt(jumpRow, jumpCol);
                    const landingSquare = this.getPieceAt(landRow, landCol);

                    // Valid capture: enemy piece to jump over, empty landing square
                    if (jumpedPiece && this.isEnemyPiece(jumpedPiece, this.currentPlayer) && !landingSquare) {
                        captures.push({
                            row: landRow,
                            col: landCol,
                            capturedRow: jumpRow,
                            capturedCol: jumpCol,
                            isCapture: true
                        });
                    }
                });

                return captures;
            }

            // Get regular (non-capture) moves from a specific square
            getRegularMovesFromSquare(row, col) {
                const piece = this.getPieceAt(row, col);
                if (!piece) return [];

                const moves = [];
                const isKing = this.isKing(piece);
                const isRed = this.isRedPiece(piece);

                // Determine directions
                let directions = [];
                if (isKing) {
                    directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                } else if (isRed) {
                    directions = [[1, -1], [1, 1]]; // Red moves down
                } else {
                    directions = [[-1, -1], [-1, 1]]; // Black moves up
                }

                directions.forEach(([drow, dcol]) => {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    const targetSquare = this.getPieceAt(newRow, newCol);

                    if (!targetSquare) {
                        moves.push({
                            row: newRow,
                            col: newCol,
                            isCapture: false
                        });
                    }
                });

                return moves;
            }

            // Check if any player has mandatory captures
            updateMustCapture() {
                this.mustCapture = false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.getPieceAt(row, col);
                        if (piece && this.isOwnPiece(piece, this.currentPlayer)) {
                            const captures = this.getCaptureMovesFromSquare(row, col);
                            if (captures.length > 0) {
                                this.mustCapture = true;
                                return;
                            }
                        }
                    }
                }
            }

            // Make a move
            makeMove(fromRow, fromCol, toRow, toCol) {
                if (this.isGameOver) return false;

                const piece = this.getPieceAt(fromRow, fromCol);
                if (!piece || !this.isOwnPiece(piece, this.currentPlayer)) return false;

                // Update capture requirements
                this.updateMustCapture();

                const validMoves = this.getValidMoves(fromRow, fromCol);
                const targetMove = validMoves.find(move => move.row === toRow && move.col === toCol);
                
                if (!targetMove) return false;

                // Execute move
                this.setPieceAt(toRow, toCol, piece);
                this.setPieceAt(fromRow, fromCol, null);

                let capturedPiece = null;
                let isMultiCapture = false;

                // Handle capture
                if (targetMove.isCapture) {
                    capturedPiece = this.getPieceAt(targetMove.capturedRow, targetMove.capturedCol);
                    this.setPieceAt(targetMove.capturedRow, targetMove.capturedCol, null);

                    // Check for additional captures
                    const additionalCaptures = this.getCaptureMovesFromSquare(toRow, toCol);
                    if (additionalCaptures.length > 0) {
                        isMultiCapture = true;
                        this.mustCapture = true;
                        // Don't switch players yet - same player continues
                    } else {
                        this.mustCapture = false;
                    }
                } else {
                    this.mustCapture = false;
                }

                // Promote to king if reached opposite end
                if ((this.isRedPiece(piece) && toRow === 7) || (this.isBlackPiece(piece) && toRow === 0)) {
                    this.setPieceAt(toRow, toCol, piece.toUpperCase());
                }

                // Record move
                this.gameHistory.push({
                    from: {row: fromRow, col: fromCol},
                    to: {row: toRow, col: toCol},
                    piece: piece,
                    captured: capturedPiece,
                    capturedAt: targetMove.isCapture ? {row: targetMove.capturedRow, col: targetMove.capturedCol} : null,
                    player: this.currentPlayer,
                    isMultiCapture: isMultiCapture
                });

                // Switch turns only if not a multi-capture
                if (!isMultiCapture) {
                    this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';
                    this.updateMustCapture();
                }

                // Check game end conditions
                this.checkGameEnd();

                return true;
            }

            // Check for game end conditions
            checkGameEnd() {
                const redPieces = this.countPieces('red');
                const blackPieces = this.countPieces('black');

                // No pieces left
                if (redPieces === 0) {
                    this.isGameOver = true;
                    this.winner = 'black';
                    return;
                }
                if (blackPieces === 0) {
                    this.isGameOver = true;
                    this.winner = 'red';
                    return;
                }

                // No valid moves (blocked)
                if (!this.hasValidMoves(this.currentPlayer)) {
                    this.isGameOver = true;
                    this.winner = this.currentPlayer === 'red' ? 'black' : 'red';
                }
            }

            countPieces(player) {
                let count = 0;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.getPieceAt(row, col);
                        if (piece && this.isOwnPiece(piece, player)) {
                            count++;
                        }
                    }
                }
                return count;
            }

            hasValidMoves(player) {
                this.updateMustCapture();
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.getPieceAt(row, col);
                        if (piece && this.isOwnPiece(piece, player)) {
                            if (this.getValidMoves(row, col).length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // Get game state for synchronization
            getGameState() {
                return {
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer,
                    gameHistory: [...this.gameHistory],
                    isGameOver: this.isGameOver,
                    winner: this.winner,
                    mustCapture: this.mustCapture
                };
            }

            // Restore game state from synchronization
            setGameState(state) {
                this.board = JSON.parse(JSON.stringify(state.board));
                this.currentPlayer = state.currentPlayer;
                this.gameHistory = [...state.gameHistory];
                this.isGameOver = state.isGameOver;
                this.winner = state.winner;
                this.mustCapture = state.mustCapture;
            }

            // Get move notation
            getMoveNotation(fromRow, fromCol, toRow, toCol) {
                const files = 'abcdefgh';
                const ranks = '87654321';
                
                const fromSquare = files[fromCol] + ranks[fromRow];
                const toSquare = files[toCol] + ranks[toRow];
                
                const lastMove = this.gameHistory[this.gameHistory.length - 1];
                const isCapture = lastMove && lastMove.captured;
                
                return isCapture ? `${fromSquare}x${toSquare}` : `${fromSquare}-${toSquare}`;
            }
        }
        
        // COMPLETE WORD GAME ENGINE (Scrabble-style)
        class WordGameEngine {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'player1';
                this.gameHistory = [];
                this.isGameOver = false;
                this.winner = null;
                this.playerTiles = {
                    player1: [],
                    player2: []
                };
                this.scores = {
                    player1: 0,
                    player2: 0
                };
                this.tileBag = this.initializeTileBag();
                this.placedTiles = [];
                this.isFirstMove = true;
                this.passCount = 0;
                
                // Initialize player tiles
                this.drawTiles('player1', 7);
                this.drawTiles('player2', 7);
            }

            initializeBoard() {
                const board = Array(15).fill(null).map(() => Array(15).fill(null));
                
                // Mark special squares
                this.specialSquares = {
                    // Triple Word Score
                    '0,0': 'TW', '0,7': 'TW', '0,14': 'TW',
                    '7,0': 'TW', '7,14': 'TW',
                    '14,0': 'TW', '14,7': 'TW', '14,14': 'TW',
                    
                    // Double Word Score
                    '1,1': 'DW', '1,13': 'DW', '2,2': 'DW', '2,12': 'DW',
                    '3,3': 'DW', '3,11': 'DW', '4,4': 'DW', '4,10': 'DW',
                    '7,7': 'DW', '10,4': 'DW', '10,10': 'DW',
                    '11,3': 'DW', '11,11': 'DW', '12,2': 'DW', '12,12': 'DW',
                    '13,1': 'DW', '13,13': 'DW',
                    
                    // Triple Letter Score
                    '1,5': 'TL', '1,9': 'TL', '5,1': 'TL', '5,5': 'TL',
                    '5,9': 'TL', '5,13': 'TL', '9,1': 'TL', '9,5': 'TL',
                    '9,9': 'TL', '9,13': 'TL', '13,5': 'TL', '13,9': 'TL',
                    
                    // Double Letter Score
                    '0,3': 'DL', '0,11': 'DL', '2,6': 'DL', '2,8': 'DL',
                    '3,0': 'DL', '3,7': 'DL', '3,14': 'DL', '6,2': 'DL',
                    '6,6': 'DL', '6,8': 'DL', '6,12': 'DL', '7,3': 'DL',
                    '7,11': 'DL', '8,2': 'DL', '8,6': 'DL', '8,8': 'DL',
                    '8,12': 'DL', '11,0': 'DL', '11,7': 'DL', '11,14': 'DL',
                    '12,6': 'DL', '12,8': 'DL', '14,3': 'DL', '14,11': 'DL'
                };
                
                return board;
            }

            initializeTileBag() {
                const tiles = [];
                const letterDistribution = {
                    'A': {count: 9, value: 1}, 'B': {count: 2, value: 3}, 'C': {count: 2, value: 3},
                    'D': {count: 4, value: 2}, 'E': {count: 12, value: 1}, 'F': {count: 2, value: 4},
                    'G': {count: 3, value: 2}, 'H': {count: 2, value: 4}, 'I': {count: 9, value: 1},
                    'J': {count: 1, value: 8}, 'K': {count: 1, value: 5}, 'L': {count: 4, value: 1},
                    'M': {count: 2, value: 3}, 'N': {count: 6, value: 1}, 'O': {count: 8, value: 1},
                    'P': {count: 2, value: 3}, 'Q': {count: 1, value: 10}, 'R': {count: 6, value: 1},
                    'S': {count: 4, value: 1}, 'T': {count: 6, value: 1}, 'U': {count: 4, value: 1},
                    'V': {count: 2, value: 4}, 'W': {count: 2, value: 4}, 'X': {count: 1, value: 8},
                    'Y': {count: 2, value: 4}, 'Z': {count: 1, value: 10}, '*': {count: 2, value: 0} // Blank tiles
                };

                for (const [letter, info] of Object.entries(letterDistribution)) {
                    for (let i = 0; i < info.count; i++) {
                        tiles.push({letter: letter, value: info.value, id: Math.random().toString(36)});
                    }
                }

                // Shuffle tiles
                for (let i = tiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                }

                return tiles;
            }

            getTileAt(row, col) {
                if (row < 0 || row > 14 || col < 0 || col > 14) return null;
                return this.board[row][col];
            }

            setTileAt(row, col, tile) {
                if (row >= 0 && row <= 14 && col >= 0 && col <= 14) {
                    this.board[row][col] = tile;
                }
            }

            getSpecialSquare(row, col) {
                return this.specialSquares[`${row},${col}`] || null;
            }

            drawTiles(player, count) {
                const drawn = [];
                for (let i = 0; i < count && this.tileBag.length > 0; i++) {
                    const tile = this.tileBag.pop();
                    this.playerTiles[player].push(tile);
                    drawn.push(tile);
                }
                return drawn;
            }

            // Validate if placed tiles form valid words
            validateMove(placedTiles) {
                if (placedTiles.length === 0) return {valid: false, reason: "No tiles placed"};

                // Check if tiles are in a line
                const rows = [...new Set(placedTiles.map(t => t.row))];
                const cols = [...new Set(placedTiles.map(t => t.col))];
                
                if (rows.length > 1 && cols.length > 1) {
                    return {valid: false, reason: "Tiles must be in a straight line"};
                }

                // Check if tiles are connected
                if (!this.aretilesConnected(placedTiles)) {
                    return {valid: false, reason: "Tiles must be connected"};
                }

                // Check connection to existing tiles (except first move)
                if (!this.isFirstMove && !this.connectsToExistingTiles(placedTiles)) {
                    return {valid: false, reason: "New tiles must connect to existing tiles"};
                }

                // Check if first move uses center square
                if (this.isFirstMove && !placedTiles.some(t => t.row === 7 && t.col === 7)) {
                    return {valid: false, reason: "First move must use center square"};
                }

                // Get all words formed
                const wordsFormed = this.getWordsFormed(placedTiles);
                
                // Validate all words
                for (const word of wordsFormed) {
                    if (!this.isValidWord(word.letters.join(''))) {
                        return {valid: false, reason: `"${word.letters.join('')}" is not a valid word`};
                    }
                }

                return {valid: true, wordsFormed: wordsFormed};
            }

            aretilesConnected(placedTiles) {
                if (placedTiles.length <= 1) return true;

                placedTiles.sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);

                for (let i = 1; i < placedTiles.length; i++) {
                    const prev = placedTiles[i-1];
                    const curr = placedTiles[i];
                    
                    if (prev.row === curr.row) {
                        // Same row - check if consecutive or connected by existing tiles
                        if (!this.areSquaresConnectedHorizontally(prev.row, prev.col, curr.col)) {
                            return false;
                        }
                    } else {
                        // Same column - check if consecutive or connected by existing tiles
                        if (!this.areSquaresConnectedVertically(prev.col, prev.row, curr.row)) {
                            return false;
                        }
                    }
                }

                return true;
            }

            areSquaresConnectedHorizontally(row, col1, col2) {
                const start = Math.min(col1, col2);
                const end = Math.max(col1, col2);
                
                for (let col = start; col <= end; col++) {
                    const tile = this.getTileAt(row, col);
                    const isPlaced = this.placedTiles.some(t => t.row === row && t.col === col);
                    if (!tile && !isPlaced) return false;
                }
                return true;
            }

            areSquaresConnectedVertically(col, row1, row2) {
                const start = Math.min(row1, row2);
                const end = Math.max(row1, row2);
                
                for (let row = start; row <= end; row++) {
                    const tile = this.getTileAt(row, col);
                    const isPlaced = this.placedTiles.some(t => t.row === row && t.col === col);
                    if (!tile && !isPlaced) return false;
                }
                return true;
            }

            connectsToExistingTiles(placedTiles) {
                for (const tile of placedTiles) {
                    const neighbors = [
                        {row: tile.row - 1, col: tile.col},
                        {row: tile.row + 1, col: tile.col},
                        {row: tile.row, col: tile.col - 1},
                        {row: tile.row, col: tile.col + 1}
                    ];

                    for (const neighbor of neighbors) {
                        if (this.getTileAt(neighbor.row, neighbor.col)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            getWordsFormed(placedTiles) {
                const words = [];
                const allTilesOnBoard = [...this.getAllExistingTiles(), ...placedTiles];

                // Check horizontal words
                const rows = [...new Set(placedTiles.map(t => t.row))];
                for (const row of rows) {
                    const word = this.getWordInDirection(row, placedTiles[0].col, 0, 1, allTilesOnBoard);
                    if (word.letters.length > 1) words.push(word);
                }

                // Check vertical words
                const cols = [...new Set(placedTiles.map(t => t.col))];
                for (const col of cols) {
                    const word = this.getWordInDirection(placedTiles[0].row, col, 1, 0, allTilesOnBoard);
                    if (word.letters.length > 1) words.push(word);
                }

                // Check perpendicular words for each placed tile
                for (const tile of placedTiles) {
                    if (rows.length === 1) {
                        // Main word is horizontal, check vertical
                        const word = this.getWordInDirection(tile.row, tile.col, 1, 0, allTilesOnBoard);
                        if (word.letters.length > 1) words.push(word);
                    } else {
                        // Main word is vertical, check horizontal
                        const word = this.getWordInDirection(tile.row, tile.col, 0, 1, allTilesOnBoard);
                        if (word.letters.length > 1) words.push(word);
                    }
                }

                return words;
            }

            getWordInDirection(startRow, startCol, deltaRow, deltaCol, allTiles) {
                // Find start of word
                let row = startRow, col = startCol;
                while (this.hasTileAt(row - deltaRow, col - deltaCol, allTiles)) {
                    row -= deltaRow;
                    col -= deltaCol;
                }

                // Build word
                const word = {letters: [], tiles: [], score: 0};
                while (this.hasTileAt(row, col, allTiles)) {
                    const tile = this.getTileAtPosition(row, col, allTiles);
                    word.letters.push(tile.letter);
                    word.tiles.push({...tile, row, col});
                    row += deltaRow;
                    col += deltaCol;
                }

                return word;
            }

            hasTileAt(row, col, allTiles) {
                return allTiles.some(t => t.row === row && t.col === col);
            }

            getTileAtPosition(row, col, allTiles) {
                return allTiles.find(t => t.row === row && t.col === col) || this.getTileAt(row, col);
            }

            getAllExistingTiles() {
                const tiles = [];
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        const tile = this.getTileAt(row, col);
                        if (tile) {
                            tiles.push({...tile, row, col});
                        }
                    }
                }
                return tiles;
            }

            // Simple word validation (in real game, use dictionary API)
            isValidWord(word) {
                const commonWords = [
                    'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER', 'WAS', 'ONE',
                    'OUR', 'HAD', 'BY', 'HOT', 'WORD', 'WHAT', 'SOME', 'WE', 'IT', 'I', 'WHO', 'OIL',
                    'SIT', 'NOW', 'FIND', 'LONG', 'DOWN', 'DAY', 'DID', 'GET', 'HAS', 'HIM', 'HIS',
                    'HOW', 'ITS', 'MAY', 'NEW', 'SOUND', 'TAKE', 'ONLY', 'LITTLE', 'WORK', 'KNOW',
                    'PLACE', 'YEAR', 'LIVE', 'ME', 'BACK', 'GIVE', 'MOST', 'VERY', 'AFTER', 'THING',
                    'NAME', 'GOOD', 'SENTENCE', 'MAN', 'THINK', 'SAY', 'GREAT', 'WHERE', 'HELP',
                    'THROUGH', 'MUCH', 'BEFORE', 'LINE', 'RIGHT', 'TOO', 'MEAN', 'OLD', 'ANY',
                    'SAME', 'TELL', 'BOY', 'FOLLOW', 'CAME', 'WANT', 'SHOW', 'ALSO', 'AROUND',
                    'FORM', 'THREE', 'SMALL', 'SET', 'PUT', 'END', 'WHY', 'AGAIN', 'TURN', 'HERE',
                    'OFF', 'WENT', 'WELL', 'MANY', 'WOULD', 'SO', 'THESE', 'HER', 'LONG', 'MAKE',
                    'WAY', 'COULD', 'BEEN', 'CALL', 'FIRST', 'WHO', 'OIL', 'SIT', 'NOW', 'FIND',
                    'CAT', 'DOG', 'RUN', 'JUMP', 'PLAY', 'GAME', 'WIN', 'LOSE', 'TRY', 'GO'
                ];
                
                return word.length >= 2 && commonWords.includes(word.toUpperCase());
            }

            // Calculate score for words formed
            calculateScore(wordsFormed, placedTiles) {
                let totalScore = 0;
                let wordMultiplier = 1;

                for (const word of wordsFormed) {
                    let wordScore = 0;
                    let currentWordMultiplier = 1;

                    for (const tile of word.tiles) {
                        let letterScore = tile.value;
                        
                        // Apply letter multipliers only for newly placed tiles
                        const isNewTile = placedTiles.some(pt => pt.row === tile.row && pt.col === tile.col);
                        if (isNewTile) {
                            const special = this.getSpecialSquare(tile.row, tile.col);
                            if (special === 'DL') letterScore *= 2;
                            else if (special === 'TL') letterScore *= 3;
                            else if (special === 'DW') currentWordMultiplier *= 2;
                            else if (special === 'TW') currentWordMultiplier *= 3;
                        }

                        wordScore += letterScore;
                    }

                    totalScore += wordScore * currentWordMultiplier;
                }

                // Bonus for using all 7 tiles
                if (placedTiles.length === 7) {
                    totalScore += 50;
                }

                return totalScore;
            }

            // Make a move
            makeMove(placedTiles) {
                if (this.isGameOver) return {success: false, reason: "Game is over"};

                const validation = this.validateMove(placedTiles);
                if (!validation.valid) {
                    return {success: false, reason: validation.reason};
                }

                // Place tiles on board
                for (const tile of placedTiles) {
                    this.setTileAt(tile.row, tile.col, tile);
                    // Remove tile from player's hand
                    const tileIndex = this.playerTiles[this.currentPlayer].findIndex(t => t.id === tile.id);
                    if (tileIndex >= 0) {
                        this.playerTiles[this.currentPlayer].splice(tileIndex, 1);
                    }
                }

                // Calculate and add score
                const score = this.calculateScore(validation.wordsFormed, placedTiles);
                this.scores[this.currentPlayer] += score;

                // Record move
                this.gameHistory.push({
                    player: this.currentPlayer,
                    tiles: [...placedTiles],
                    wordsFormed: validation.wordsFormed,
                    score: score,
                    timestamp: Date.now()
                });

                // Draw new tiles
                this.drawTiles(this.currentPlayer, placedTiles.length);

                // Reset first move flag
                this.isFirstMove = false;
                this.passCount = 0;

                // Switch players
                this.currentPlayer = this.currentPlayer === 'player1' ? 'player2' : 'player1';

                // Check game end
                this.checkGameEnd();

                return {success: true, score: score, wordsFormed: validation.wordsFormed};
            }

            // Pass turn
            passTurn() {
                this.passCount++;
                this.currentPlayer = this.currentPlayer === 'player1' ? 'player2' : 'player1';
                
                this.gameHistory.push({
                    player: this.currentPlayer === 'player1' ? 'player2' : 'player1',
                    action: 'pass',
                    timestamp: Date.now()
                });

                // Game ends if both players pass consecutively
                if (this.passCount >= 2) {
                    this.endGame();
                }
            }

            // Exchange tiles
            exchangeTiles(tileIds) {
                if (this.tileBag.length < tileIds.length) {
                    return {success: false, reason: "Not enough tiles in bag"};
                }

                // Remove selected tiles and add back to bag
                const removedTiles = [];
                for (const tileId of tileIds) {
                    const tileIndex = this.playerTiles[this.currentPlayer].findIndex(t => t.id === tileId);
                    if (tileIndex >= 0) {
                        removedTiles.push(this.playerTiles[this.currentPlayer].splice(tileIndex, 1)[0]);
                    }
                }

                // Add tiles back to bag and shuffle
                this.tileBag.push(...removedTiles);
                for (let i = this.tileBag.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.tileBag[i], this.tileBag[j]] = [this.tileBag[j], this.tileBag[i]];
                }

                // Draw new tiles
                this.drawTiles(this.currentPlayer, removedTiles.length);

                // Switch players
                this.passCount = 0;
                this.currentPlayer = this.currentPlayer === 'player1' ? 'player2' : 'player1';

                return {success: true};
            }

            checkGameEnd() {
                // Game ends if a player uses all tiles or no tiles left in bag
                const currentPlayerTiles = this.playerTiles[this.currentPlayer].length;
                const otherPlayer = this.currentPlayer === 'player1' ? 'player2' : 'player1';
                const otherPlayerTiles = this.playerTiles[otherPlayer].length;

                if (currentPlayerTiles === 0 || (this.tileBag.length === 0 && (currentPlayerTiles === 0 || otherPlayerTiles === 0))) {
                    this.endGame();
                }
            }

            endGame() {
                this.isGameOver = true;
                
                // Subtract remaining tile values from scores
                for (const player of ['player1', 'player2']) {
                    let remainingValue = 0;
                    for (const tile of this.playerTiles[player]) {
                        remainingValue += tile.value;
                    }
                    this.scores[player] -= remainingValue;
                }

                // Determine winner
                if (this.scores.player1 > this.scores.player2) {
                    this.winner = 'player1';
                } else if (this.scores.player2 > this.scores.player1) {
                    this.winner = 'player2';
                } else {
                    this.winner = 'tie';
                }
            }

            // Get game state for synchronization
            getGameState() {
                return {
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer,
                    gameHistory: [...this.gameHistory],
                    isGameOver: this.isGameOver,
                    winner: this.winner,
                    playerTiles: {
                        player1: [...this.playerTiles.player1],
                        player2: [...this.playerTiles.player2]
                    },
                    scores: {...this.scores},
                    tileBag: [...this.tileBag],
                    isFirstMove: this.isFirstMove,
                    passCount: this.passCount
                };
            }

            // Restore game state
            setGameState(state) {
                this.board = JSON.parse(JSON.stringify(state.board));
                this.currentPlayer = state.currentPlayer;
                this.gameHistory = [...state.gameHistory];
                this.isGameOver = state.isGameOver;
                this.winner = state.winner;
                this.playerTiles = {
                    player1: [...state.playerTiles.player1],
                    player2: [...state.playerTiles.player2]
                };
                this.scores = {...state.scores};
                this.tileBag = [...state.tileBag];
                this.isFirstMove = state.isFirstMove;
                this.passCount = state.passCount;
            }
        }
        
        // CHESS GAME UI MANAGER - PART 4A: CORE CLASS
        class ChessGameManager {
            constructor(gameId, isPlayerWhite, container) {
                this.gameId = gameId;
                this.isPlayerWhite = isPlayerWhite;
                this.container = container;
                this.engine = new ChessEngine();
                this.selectedSquare = null;
                this.validMoves = [];
                this.isMyTurn = isPlayerWhite;
                this.gameState = 'active';
                this.moveTimer = 300; // 5 minutes per move
                this.timerInterval = null;
                
                this.pieceSymbols = {
                    'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
                    'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
                };
                
                this.createBoard();
                this.updateDisplay();
                this.startMoveTimer();
            }

            createBoard() {
                this.container.innerHTML = `
                    <div class="chess-game-window" id="chessGame${this.gameId}">
                        <div class="game-header">
                            <h3>Chess Game #${this.gameId}</h3>
                            <div class="game-controls">
                                <button class="resign-btn" onclick="resignChessGame(${this.gameId})">Resign</button>
                                <button class="offer-draw-btn" onclick="offerDraw(${this.gameId})">Draw</button>
                                <button class="close-btn" onclick="closeGame(${this.gameId})">×</button>
                            </div>
                        </div>
                        
                        <div class="players-info">
                            <div class="player opponent ${!this.isMyTurn ? 'active' : ''}">
                                <span class="player-name">Opponent</span>
                                <span class="player-color">${this.isPlayerWhite ? 'Black' : 'White'}</span>
                                <span class="thinking-indicator" id="opponentThinking${this.gameId}">🤔</span>
                            </div>
                            <div class="player current ${this.isMyTurn ? 'active' : ''}">
                                <span class="player-name">You</span>
                                <span class="player-color">${this.isPlayerWhite ? 'White' : 'Black'}</span>
                                <span class="turn-indicator" id="yourTurn${this.gameId}">⚡</span>
                            </div>
                        </div>
                        
                        <div class="chess-board-container">
                            <div class="chess-board" id="chessBoard${this.gameId}">
                                ${this.createBoardHTML()}
                            </div>
                        </div>
                        
                        <div class="game-info">
                            <div class="game-status" id="gameStatus${this.gameId}">
                                ${this.isMyTurn ? 'Your turn' : "Opponent's turn"}
                            </div>
                            <div class="move-timer" id="moveTimer${this.gameId}">
                                <span class="timer-label">Move time:</span>
                                <span class="timer-value">5:00</span>
                            </div>
                        </div>
                        
                        <div class="move-history">
                            <h4>Move History</h4>
                            <div class="moves-list" id="movesList${this.gameId}"></div>
                        </div>
                    </div>
                `;
            }

            createBoardHTML() {
                let boardHTML = '';
                const files = this.isPlayerWhite ? 'abcdefgh' : 'hgfedcba';
                const ranks = this.isPlayerWhite ? '87654321' : '12345678';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const actualRow = this.isPlayerWhite ? row : 7 - row;
                        const actualCol = this.isPlayerWhite ? col : 7 - col;
                        const isLight = (row + col) % 2 === 0;
                        const piece = this.engine.getPieceAt(actualRow, actualCol);
                        
                        boardHTML += `
                            <div class="chess-square ${isLight ? 'light' : 'dark'}" 
                                 data-row="${actualRow}" 
                                 data-col="${actualCol}"
                                 onclick="handleChessSquareClick(${this.gameId}, ${actualRow}, ${actualCol})">
                                ${piece ? `<div class="chess-piece">${this.pieceSymbols[piece]}</div>` : ''}
                                ${row === 7 ? `<div class="file-label">${files[col]}</div>` : ''}
                                ${col === 0 ? `<div class="rank-label">${ranks[row]}</div>` : ''}
                            </div>
                        `;
                    }
                }
                
                return boardHTML;
            }
        }
        
        // CHESS GAME UI MANAGER - PART 4B: INTERACTION METHODS
        // Add these methods to the ChessGameManager class

            handleSquareClick(row, col) {
                if (!this.isMyTurn || this.gameState !== 'active') return;

                const piece = this.engine.getPieceAt(row, col);
                
                if (this.selectedSquare) {
                    // Try to make a move
                    if (this.isValidMoveAttempt(row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                    } else if (piece && this.engine.isOwnPiece(piece, this.engine.currentPlayer)) {
                        // Select different piece
                        this.selectSquare(row, col);
                    } else {
                        // Deselect
                        this.deselectSquare();
                    }
                } else {
                    // Select piece
                    if (piece && this.engine.isOwnPiece(piece, this.engine.currentPlayer)) {
                        this.selectSquare(row, col);
                    }
                }
            }

            selectSquare(row, col) {
                this.selectedSquare = {row, col};
                this.validMoves = this.engine.getValidMoves(row, col);
                this.updateDisplay();
            }

            deselectSquare() {
                this.selectedSquare = null;
                this.validMoves = [];
                this.updateDisplay();
            }

            isValidMoveAttempt(row, col) {
                return this.validMoves.some(move => move.row === row && move.col === col);
            }

            async makeMove(fromRow, fromCol, toRow, toCol) {
                const success = this.engine.makeMove(fromRow, fromCol, toRow, toCol);
                
                if (success) {
                    // Record move for history
                    const moveNotation = this.engine.getMoveNotation(fromRow, fromCol, toRow, toCol);
                    this.addMoveToHistory(moveNotation);
                    
                    // Send move to opponent via blockchain/websocket
                    await this.sendMoveToOpponent(fromRow, fromCol, toRow, toCol);
                    
                    // Update UI
                    this.deselectSquare();
                    this.isMyTurn = false;
                    this.updateDisplay();
                    this.resetMoveTimer();
                    
                    // Check for game end
                    if (this.engine.isGameOver) {
                        this.endGame();
                    }
                    
                    showNotification(`Move: ${moveNotation}`, 'success');
                } else {
                    showNotification('Invalid move!', 'error');
                }
            }

            async sendMoveToOpponent(fromRow, fromCol, toRow, toCol) {
                const moveData = {
                    gameId: this.gameId,
                    from: {row: fromRow, col: fromCol},
                    to: {row: toRow, col: toCol},
                    gameState: this.engine.getGameState(),
                    timestamp: Date.now()
                };
                
                // Send via your real-time system (WebSocket, Firebase, etc.)
                // For now, we'll simulate with localStorage for demo
                localStorage.setItem(`chessMove_${this.gameId}`, JSON.stringify(moveData));
                
                console.log('Move sent:', moveData);
            }

            receiveOpponentMove(moveData) {
                if (moveData.gameId !== this.gameId) return;
                
                // Update engine state
                this.engine.setGameState(moveData.gameState);
                
                // Update UI
                this.isMyTurn = true;
                this.updateDisplay();
                this.resetMoveTimer();
                
                // Add move to history
                const move = moveData.gameState.gameHistory[moveData.gameState.gameHistory.length - 1];
                if (move) {
                    const notation = this.engine.getMoveNotation(move.from.row, move.from.col, move.to.row, move.to.col);
                    this.addMoveToHistory(notation);
                }
                
                showNotification('Opponent moved!', 'info');
                
                // Check for game end
                if (this.engine.isGameOver) {
                    this.endGame();
                }
            }
            
            // CHESS GAME UI MANAGER - PART 4C: DISPLAY AND TIMER METHODS
        // Add these methods to the ChessGameManager class

            updateDisplay() {
                // Clear all highlights
                this.clearHighlights();
                
                // Update all pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = this.container.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        const piece = this.engine.getPieceAt(row, col);
                        
                        if (square) {
                            const pieceElement = square.querySelector('.chess-piece');
                            if (piece) {
                                if (pieceElement) {
                                    pieceElement.textContent = this.pieceSymbols[piece];
                                } else {
                                    square.innerHTML += `<div class="chess-piece">${this.pieceSymbols[piece]}</div>`;
                                }
                            } else {
                                if (pieceElement) {
                                    pieceElement.remove();
                                }
                            }
                        }
                    }
                }
                
                // Highlight selected square
                if (this.selectedSquare) {
                    this.highlightSquare(this.selectedSquare.row, this.selectedSquare.col, 'selected');
                }
                
                // Highlight valid moves
                this.validMoves.forEach(move => {
                    this.highlightSquare(move.row, move.col, 'valid-move');
                });
                
                // Highlight last move
                if (this.engine.gameHistory.length > 0) {
                    const lastMove = this.engine.gameHistory[this.engine.gameHistory.length - 1];
                    this.highlightSquare(lastMove.from.row, lastMove.from.col, 'last-move');
                    this.highlightSquare(lastMove.to.row, lastMove.to.col, 'last-move');
                }
                
                // Highlight check
                if (this.engine.isInCheck(this.engine.currentPlayer)) {
                    const kingPos = this.engine.kingPositions[this.engine.currentPlayer];
                    this.highlightSquare(kingPos.row, kingPos.col, 'check');
                }
                
                // Update game status
                this.updateGameStatus();
                
                // Update player indicators
                this.updatePlayerIndicators();
            }

            highlightSquare(row, col, className) {
                const square = this.container.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (square) {
                    square.classList.add(className);
                }
            }

            clearHighlights() {
                const squares = this.container.querySelectorAll('.chess-square');
                squares.forEach(square => {
                    square.classList.remove('highlighted', 'valid-move', 'selected', 'last-move', 'check');
                });
            }

            updateGameStatus() {
                const statusElement = this.container.querySelector(`#gameStatus${this.gameId}`);
                if (!statusElement) return;
                
                let status = '';
                
                if (this.engine.isGameOver) {
                    if (this.engine.winner === 'draw') {
                        status = 'Game ended in draw';
                    } else {
                        const winner = this.engine.winner === 'white' ? 'White' : 'Black';
                        status = `${winner} wins!`;
                    }
                } else if (this.engine.isInCheck(this.engine.currentPlayer)) {
                    status = `${this.engine.currentPlayer === 'white' ? 'White' : 'Black'} is in check!`;
                } else {
                    status = this.isMyTurn ? 'Your turn' : "Opponent's turn";
                }
                
                statusElement.textContent = status;
            }

            updatePlayerIndicators() {
                const playerElements = this.container.querySelectorAll('.player');
                playerElements.forEach(player => {
                    player.classList.remove('active');
                });
                
                const activePlayer = this.isMyTurn ? '.player.current' : '.player.opponent';
                const activeElement = this.container.querySelector(activePlayer);
                if (activeElement) {
                    activeElement.classList.add('active');
                }
            }

            addMoveToHistory(moveNotation) {
                const movesList = this.container.querySelector(`#movesList${this.gameId}`);
                if (!movesList) return;
                
                const moveNumber = Math.ceil(this.engine.gameHistory.length / 2);
                const isWhiteMove = this.engine.gameHistory.length % 2 === 1;
                
                const moveElement = document.createElement('div');
                moveElement.className = `move-item ${isWhiteMove ? 'white-move' : 'black-move'}`;
                moveElement.textContent = `${isWhiteMove ? moveNumber + '.' : ''} ${moveNotation}`;
                
                movesList.appendChild(moveElement);
                movesList.scrollTop = movesList.scrollHeight;
            }

            startMoveTimer() {
                this.resetMoveTimer();
            }

            resetMoveTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                this.moveTimer = 300; // 5 minutes
                this.updateTimerDisplay();
                
                if (this.isMyTurn && this.gameState === 'active') {
                    this.timerInterval = setInterval(() => {
                        this.moveTimer--;
                        this.updateTimerDisplay();
                        
                        if (this.moveTimer <= 0) {
                            this.handleTimeOut();
                        }
                    }, 1000);
                }
            }

            updateTimerDisplay() {
                const timerElement = this.container.querySelector(`#moveTimer${this.gameId} .timer-value`);
                if (timerElement) {
                    const minutes = Math.floor(this.moveTimer / 60);
                    const seconds = this.moveTimer % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (this.moveTimer <= 30) {
                        timerElement.style.color = '#ef4444';
                        timerElement.style.animation = 'pulse 1s infinite';
                    } else {
                        timerElement.style.color = '#374151';
                        timerElement.style.animation = 'none';
                    }
                }
            }

            handleTimeOut() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                showNotification('Time out! You lose.', 'error');
                this.endGame('timeout');
            }
            
            // CHESS GAME UI MANAGER - PART 4D: END GAME AND BLOCKCHAIN SETTLEMENT
        // Add these methods to the ChessGameManager class

            async endGame(reason = 'normal') {
                this.gameState = 'ended';
                this.isMyTurn = false;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                // Determine winner for blockchain settlement
                let winner = null;
                if (reason === 'timeout') {
                    winner = this.isPlayerWhite ? 'black' : 'white';
                } else if (this.engine.winner && this.engine.winner !== 'draw') {
                    winner = this.engine.winner;
                }
                
                // Send game result to blockchain
                if (winner) {
                    await this.settleGameOnBlockchain(winner);
                }
                
                this.updateDisplay();
            }

            async settleGameOnBlockchain(winner) {
                try {
                    if (!contract || !userAccount) return;
                    
                    // Determine winner address
                    const winnerAddress = winner === (this.isPlayerWhite ? 'white' : 'black') ? userAccount : 'opponent_address';
                    
                    showNotification('🎮 Settling game on blockchain...', 'info');
                    
                    const tx = await contract.endGame(this.gameId, winnerAddress, "chess_game_completed", {
                        gasLimit: 150000
                    });
                    
                    showTransactionStatus(tx.hash, 'pending');
                    const receipt = await tx.wait();
                    
                    showNotification(`🎉 Game settled! Winner: ${winner}`, 'success');
                    showTransactionStatus(tx.hash, 'confirmed');
                    
                } catch (error) {
                    console.error('Failed to settle game:', error);
                    showNotification('❌ Failed to settle game on blockchain', 'error');
                }
            }
        }
        
        // CHECKERS GAME UI MANAGER - PART 5A: CORE CLASS
        class CheckersGameManager {
            constructor(gameId, isPlayerRed, container) {
                this.gameId = gameId;
                this.isPlayerRed = isPlayerRed;
                this.container = container;
                this.engine = new CheckersEngine();
                this.selectedSquare = null;
                this.validMoves = [];
                this.isMyTurn = isPlayerRed; // Red goes first
                this.gameState = 'active';
                this.moveTimer = 300;
                this.timerInterval = null;
                
                this.createBoard();
                this.updateDisplay();
                this.startMoveTimer();
            }

            createBoard() {
                this.container.innerHTML = `
                    <div class="checkers-game-window" id="checkersGame${this.gameId}">
                        <div class="game-header">
                            <h3>Checkers Game #${this.gameId}</h3>
                            <div class="game-controls">
                                <button class="resign-btn" onclick="resignCheckersGame(${this.gameId})">Resign</button>
                                <button class="close-btn" onclick="closeGame(${this.gameId})">×</button>
                            </div>
                        </div>
                        
                        <div class="players-info">
                            <div class="player opponent ${!this.isMyTurn ? 'active' : ''}">
                                <span class="player-name">Opponent</span>
                                <span class="player-color">${this.isPlayerRed ? 'Black' : 'Red'}</span>
                                <span class="piece-count" id="opponentPieces${this.gameId}">12</span>
                            </div>
                            <div class="player current ${this.isMyTurn ? 'active' : ''}">
                                <span class="player-name">You</span>
                                <span class="player-color">${this.isPlayerRed ? 'Red' : 'Black'}</span>
                                <span class="piece-count" id="yourPieces${this.gameId}">12</span>
                            </div>
                        </div>
                        
                        <div class="checkers-board-container">
                            <div class="checkers-board" id="checkersBoard${this.gameId}">
                                ${this.createBoardHTML()}
                            </div>
                        </div>
                        
                        <div class="game-info">
                            <div class="game-status" id="gameStatus${this.gameId}">
                                ${this.isMyTurn ? 'Your turn' : "Opponent's turn"}
                            </div>
                            <div class="capture-info" id="captureInfo${this.gameId}">
                                ${this.engine.mustCapture ? 'Must capture!' : ''}
                            </div>
                            <div class="move-timer" id="moveTimer${this.gameId}">
                                <span class="timer-label">Move time:</span>
                                <span class="timer-value">5:00</span>
                            </div>
                        </div>
                        
                        <div class="move-history">
                            <h4>Move History</h4>
                            <div class="moves-list" id="movesList${this.gameId}"></div>
                        </div>
                    </div>
                `;
                
                // Add CSS styles for checkers
                this.addCheckersStyles();
            }

            createBoardHTML() {
                let boardHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const isDark = (row + col) % 2 === 1;
                        const piece = this.engine.getPieceAt(row, col);
                        
                        boardHTML += `
                            <div class="checkers-square ${isDark ? 'dark' : 'light'}" 
                                 data-row="${row}" 
                                 data-col="${col}"
                                 onclick="handleCheckersSquareClick(${this.gameId}, ${row}, ${col})">
                                ${piece ? this.renderPiece(piece) : ''}
                            </div>
                        `;
                    }
                }
                
                return boardHTML;
            }

            renderPiece(piece) {
                const isRed = this.engine.isRedPiece(piece);
                const isKing = this.engine.isKing(piece);
                const pieceClass = `checkers-piece ${isRed ? 'red' : 'black'} ${isKing ? 'king' : ''}`;
                
                return `
                    <div class="${pieceClass}">
                        ${isKing ? '♛' : '●'}
                    </div>
                `;
            }
        }
        
        // CHECKERS GAME UI MANAGER - PART 5B: INTERACTION METHODS
        // Add these methods to the CheckersGameManager class

            handleSquareClick(row, col) {
                if (!this.isMyTurn || this.gameState !== 'active') return;

                const piece = this.engine.getPieceAt(row, col);
                
                if (this.selectedSquare) {
                    // Try to make a move
                    if (this.isValidMoveAttempt(row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                    } else if (piece && this.engine.isOwnPiece(piece, this.engine.currentPlayer)) {
                        // Select different piece
                        this.selectSquare(row, col);
                    } else {
                        // Deselect
                        this.deselectSquare();
                    }
                } else {
                    // Select piece
                    const currentPlayerColor = this.isPlayerRed ? 'red' : 'black';
                    if (piece && this.engine.isOwnPiece(piece, currentPlayerColor)) {
                        this.selectSquare(row, col);
                    }
                }
            }

            selectSquare(row, col) {
                this.selectedSquare = {row, col};
                this.validMoves = this.engine.getValidMoves(row, col);
                this.updateDisplay();
            }

            deselectSquare() {
                this.selectedSquare = null;
                this.validMoves = [];
                this.updateDisplay();
            }

            isValidMoveAttempt(row, col) {
                return this.validMoves.some(move => move.row === row && move.col === col);
            }

            async makeMove(fromRow, fromCol, toRow, toCol) {
                const success = this.engine.makeMove(fromRow, fromCol, toRow, toCol);
                
                if (success) {
                    // Record move for history
                    const moveNotation = this.engine.getMoveNotation(fromRow, fromCol, toRow, toCol);
                    this.addMoveToHistory(moveNotation);
                    
                    // Send move to opponent
                    await this.sendMoveToOpponent(fromRow, fromCol, toRow, toCol);
                    
                    // Update UI
                    this.deselectSquare();
                    
                    // Check if it's still the same player's turn (multi-capture)
                    const lastMove = this.engine.gameHistory[this.engine.gameHistory.length - 1];
                    if (!lastMove.isMultiCapture) {
                        this.isMyTurn = false;
                        this.resetMoveTimer();
                    }
                    
                    this.updateDisplay();
                    
                    // Check for game end
                    if (this.engine.isGameOver) {
                        this.endGame();
                    }
                    
                    showNotification(`Move: ${moveNotation}`, 'success');
                    
                    if (lastMove.isMultiCapture) {
                        showNotification('Multi-capture! Continue jumping!', 'info');
                    }
                } else {
                    showNotification('Invalid move!', 'error');
                }
            }

            async sendMoveToOpponent(fromRow, fromCol, toRow, toCol) {
                const moveData = {
                    gameId: this.gameId,
                    from: {row: fromRow, col: fromCol},
                    to: {row: toRow, col: toCol},
                    gameState: this.engine.getGameState(),
                    timestamp: Date.now()
                };
                
                // Store in localStorage for demo (replace with real networking)
                localStorage.setItem(`checkersMove_${this.gameId}`, JSON.stringify(moveData));
                console.log('Checkers move sent:', moveData);
            }

            receiveOpponentMove(moveData) {
                if (moveData.gameId !== this.gameId) return;
                
                // Update engine state
                this.engine.setGameState(moveData.gameState);
                
                // Update UI
                this.isMyTurn = true;
                this.updateDisplay();
                this.resetMoveTimer();
                
                // Add move to history
                const move = moveData.gameState.gameHistory[moveData.gameState.gameHistory.length - 1];
                if (move) {
                    const notation = this.engine.getMoveNotation(move.from.row, move.from.col, move.to.row, move.to.col);
                    this.addMoveToHistory(notation);
                }
                
                showNotification('Opponent moved!', 'info');
                
                if (this.engine.isGameOver) {
                    this.endGame();
                }
            }
            
            // CHECKERS GAME UI MANAGER - PART 5C: DISPLAY METHODS
        // Add these methods to the CheckersGameManager class

            updateDisplay() {
                // Clear highlights
                this.clearHighlights();
                
                // Update all pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = this.container.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        const piece = this.engine.getPieceAt(row, col);
                        
                        if (square) {
                            const pieceElement = square.querySelector('.checkers-piece');
                            if (piece) {
                                if (pieceElement) {
                                    pieceElement.outerHTML = this.renderPiece(piece);
                                } else {
                                    square.innerHTML = this.renderPiece(piece);
                                }
                            } else {
                                if (pieceElement) {
                                    pieceElement.remove();
                                }
                            }
                        }
                    }
                }
                
                // Highlight selected square
                if (this.selectedSquare) {
                    this.highlightSquare(this.selectedSquare.row, this.selectedSquare.col, 'selected');
                }
                
                // Highlight valid moves
                this.validMoves.forEach(move => {
                    this.highlightSquare(move.row, move.col, move.isCapture ? 'capture-move' : 'valid-move');
                });
                
                // Update piece counts
                this.updatePieceCounts();
                
                // Update game status
                this.updateGameStatus();
                
                // Update player indicators
                this.updatePlayerIndicators();
            }

            highlightSquare(row, col, className) {
                const square = this.container.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (square) {
                    square.classList.add(className);
                }
            }

            clearHighlights() {
                const squares = this.container.querySelectorAll('.checkers-square');
                squares.forEach(square => {
                    square.classList.remove('selected', 'valid-move', 'capture-move', 'last-move');
                });
            }

            updatePieceCounts() {
                const redCount = this.engine.countPieces('red');
                const blackCount = this.engine.countPieces('black');
                
                const yourPiecesElement = this.container.querySelector(`#yourPieces${this.gameId}`);
                const opponentPiecesElement = this.container.querySelector(`#opponentPieces${this.gameId}`);
                
                if (yourPiecesElement) {
                    yourPiecesElement.textContent = this.isPlayerRed ? redCount : blackCount;
                }
                
                if (opponentPiecesElement) {
                    opponentPiecesElement.textContent = this.isPlayerRed ? blackCount : redCount;
                }
            }

            updateGameStatus() {
                const statusElement = this.container.querySelector(`#gameStatus${this.gameId}`);
                const captureElement = this.container.querySelector(`#captureInfo${this.gameId}`);
                
                if (statusElement) {
                    let status = '';
                    
                    if (this.engine.isGameOver) {
                        if (this.engine.winner === 'red') {
                            status = 'Red wins!';
                        } else if (this.engine.winner === 'black') {
                            status = 'Black wins!';
                        } else {
                            status = 'Game ended in draw';
                        }
                    } else {
                        status = this.isMyTurn ? 'Your turn' : "Opponent's turn";
                    }
                    
                    statusElement.textContent = status;
                }
                
                if (captureElement) {
                    captureElement.textContent = this.engine.mustCapture ? 'Must capture!' : '';
                    captureElement.style.color = this.engine.mustCapture ? '#ef4444' : '';
                }
            }

            updatePlayerIndicators() {
                const playerElements = this.container.querySelectorAll('.player');
                playerElements.forEach(player => player.classList.remove('active'));
                
                const activePlayer = this.isMyTurn ? '.player.current' : '.player.opponent';
                const activeElement = this.container.querySelector(activePlayer);
                if (activeElement) {
                    activeElement.classList.add('active');
                }
            }

            addMoveToHistory(moveNotation) {
                const movesList = this.container.querySelector(`#movesList${this.gameId}`);
                if (!movesList) return;
                
                const moveElement = document.createElement('div');
                moveElement.className = 'move-item';
                moveElement.textContent = moveNotation;
                
                movesList.appendChild(moveElement);
                movesList.scrollTop = movesList.scrollHeight;
            }
            
            // CHECKERS GAME UI MANAGER - PART 5D: TIMER AND END GAME METHODS
        // Add these methods to the CheckersGameManager class

            startMoveTimer() {
                this.resetMoveTimer();
            }

            resetMoveTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                this.moveTimer = 300; // 5 minutes
                this.updateTimerDisplay();
                
                if (this.isMyTurn && this.gameState === 'active') {
                    this.timerInterval = setInterval(() => {
                        this.moveTimer--;
                        this.updateTimerDisplay();
                        
                        if (this.moveTimer <= 0) {
                            this.handleTimeOut();
                        }
                    }, 1000);
                }
            }

            updateTimerDisplay() {
                const timerElement = this.container.querySelector(`#moveTimer${this.gameId} .timer-value`);
                if (timerElement) {
                    const minutes = Math.floor(this.moveTimer / 60);
                    const seconds = this.moveTimer % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (this.moveTimer <= 30) {
                        timerElement.style.color = '#ef4444';
                    } else {
                        timerElement.style.color = '#374151';
                    }
                }
            }

            handleTimeOut() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                showNotification('Time out! You lose.', 'error');
                this.endGame('timeout');
            }

            async endGame(reason = 'normal') {
                this.gameState = 'ended';
                this.isMyTurn = false;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                // Determine winner for blockchain settlement
                let winner = null;
                if (reason === 'timeout') {
                    winner = this.isPlayerRed ? 'black' : 'red';
                } else if (this.engine.winner && this.engine.winner !== 'draw') {
                    winner = this.engine.winner;
                }
                
                // Send game result to blockchain
                if (winner) {
                    await this.settleGameOnBlockchain(winner);
                }
                
                this.updateDisplay();
            }

            async settleGameOnBlockchain(winner) {
                try {
                    if (!contract || !userAccount) return;
                    
                    const winnerAddress = winner === (this.isPlayerRed ? 'red' : 'black') ? userAccount : 'opponent_address';
                    
                    showNotification('🎮 Settling checkers game on blockchain...', 'info');
                    
                    const tx = await contract.endGame(this.gameId, winnerAddress, "checkers_game_completed", {
                        gasLimit: 150000
                    });
                    
                    showTransactionStatus(tx.hash, 'pending');
                    const receipt = await tx.wait();
                    
                    showNotification(`🎉 Checkers game settled! Winner: ${winner}`, 'success');
                    showTransactionStatus(tx.hash, 'confirmed');
                    
                } catch (error) {
                    console.error('Failed to settle checkers game:', error);
                    showNotification('❌ Failed to settle game on blockchain', 'error');
                }
            }
            
            // CHECKERS GAME UI MANAGER - PART 5E: CSS STYLES
        // Add this method to the CheckersGameManager class

            addCheckersStyles() {
                const styles = `
                    <style>
                        .checkers-game-window {
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(255, 255, 255, 0.95);
                            border-radius: 20px;
                            padding: 20px;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            backdrop-filter: blur(10px);
                            z-index: 1000;
                            color: #333;
                            max-width: 90vw;
                            max-height: 90vh;
                            overflow-y: auto;
                        }

                        .checkers-board-container {
                            display: flex;
                            justify-content: center;
                            margin: 20px 0;
                        }

                        .checkers-board {
                            display: grid;
                            grid-template-columns: repeat(8, 60px);
                            grid-template-rows: repeat(8, 60px);
                            border: 3px solid #8B4513;
                            border-radius: 8px;
                            overflow: hidden;
                            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
                        }

                        .checkers-square {
                            width: 60px;
                            height: 60px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            position: relative;
                            cursor: pointer;
                            transition: all 0.2s ease;
                        }

                        .checkers-square.light {
                            background: #f5deb3;
                        }

                        .checkers-square.dark {
                            background: #8B4513;
                        }

                        .checkers-square:hover {
                            box-shadow: inset 0 0 0 3px rgba(255, 107, 53, 0.5);
                        }

                        .checkers-square.selected {
                            box-shadow: inset 0 0 0 3px #ff6b35 !important;
                            background: rgba(255, 107, 53, 0.3) !important;
                        }

                        .checkers-square.valid-move {
                            box-shadow: inset 0 0 0 3px #10b981 !important;
                        }

                        .checkers-square.capture-move {
                            box-shadow: inset 0 0 0 3px #ef4444 !important;
                            animation: captureHighlight 1s infinite;
                        }

                        @keyframes captureHighlight {
                            0%, 100% { opacity: 1; }
                            50% { opacity: 0.7; }
                        }

                        .checkers-piece {
                            font-size: 40px;
                            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                            transition: all 0.2s ease;
                            user-select: none;
                            cursor: pointer;
                        }

                        .checkers-piece:hover {
                            transform: scale(1.1);
                        }

                        .checkers-piece.red {
                            color: #dc2626;
                        }

                        .checkers-piece.black {
                            color: #1f2937;
                        }

                        .checkers-piece.king {
                            font-size: 45px;
                            animation: kingGlow 2s infinite;
                        }

                        @keyframes kingGlow {
                            0%, 100% { text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }
                            50% { text-shadow: 2px 2px 8px rgba(255, 215, 0, 0.8); }
                        }

                        .piece-count {
                            background: rgba(255, 107, 53, 0.2);
                            color: #ff6b35;
                            padding: 4px 8px;
                            border-radius: 12px;
                            font-weight: 700;
                            font-size: 14px;
                        }

                        .capture-info {
                            font-weight: 700;
                            font-size: 14px;
                            color: #ef4444;
                            animation: pulse 1s infinite;
                        }

                        @media (max-width: 768px) {
                            .checkers-board {
                                grid-template-columns: repeat(8, 45px);
                                grid-template-rows: repeat(8, 45px);
                            }
                            
                            .checkers-square {
                                width: 45px;
                                height: 45px;
                            }
                            
                            .checkers-piece {
                                font-size: 30px;
                            }
                        }
                    </style>
                `;
                document.head.insertAdjacentHTML('beforeend', styles);
            }
        }
        
        // WORD GAME UI MANAGER - PART 6A: CORE CLASS AND SETUP
        class WordGameManager {
            constructor(gameId, isPlayer1, container) {
                this.gameId = gameId;
                this.isPlayer1 = isPlayer1;
                this.container = container;
                this.engine = new WordGameEngine();
                this.selectedTiles = [];
                this.placedTiles = [];
                this.isMyTurn = isPlayer1;
                this.gameState = 'active';
                this.draggedTile = null;
                
                this.createBoard();
                this.updateDisplay();
            }

            createBoard() {
                this.container.innerHTML = `
                    <div class="word-game-window" id="wordGame${this.gameId}">
                        <div class="game-header">
                            <h3>Word Battle #${this.gameId}</h3>
                            <div class="game-controls">
                                <button class="submit-btn" onclick="submitWordMove(${this.gameId})" disabled>Submit Word</button>
                                <button class="pass-btn" onclick="passTurn(${this.gameId})">Pass</button>
                                <button class="exchange-btn" onclick="showExchangeDialog(${this.gameId})">Exchange</button>
                                <button class="resign-btn" onclick="resignWordGame(${this.gameId})">Resign</button>
                                <button class="close-btn" onclick="closeGame(${this.gameId})">×</button>
                            </div>
                        </div>
                        
                        <div class="players-score">
                            <div class="player ${this.isMyTurn ? 'active' : ''}">
                                <span class="player-name">You</span>
                                <span class="player-score" id="yourScore${this.gameId}">0</span>
                            </div>
                            <div class="remaining-tiles">
                                <span>Tiles left: <span id="tilesLeft${this.gameId}">${this.engine.tileBag.length}</span></span>
                            </div>
                            <div class="player ${!this.isMyTurn ? 'active' : ''}">
                                <span class="player-name">Opponent</span>
                                <span class="player-score" id="opponentScore${this.gameId}">0</span>
                            </div>
                        </div>
                        
                        <div class="word-board-container">
                            <div class="word-board" id="wordBoard${this.gameId}">
                                ${this.createBoardHTML()}
                            </div>
                        </div>
                        
                        <div class="game-info">
                            <div class="game-status" id="gameStatus${this.gameId}">
                                ${this.isMyTurn ? 'Your turn - Place tiles to form words' : "Opponent's turn"}
                            </div>
                            <div class="word-preview" id="wordPreview${this.gameId}">
                                Place tiles on the board to form words
                            </div>
                        </div>
                        
                        <div class="player-tiles-container">
                            <h4>Your Tiles</h4>
                            <div class="player-tiles" id="playerTiles${this.gameId}">
                                ${this.createPlayerTilesHTML()}
                            </div>
                        </div>
                        
                        <div class="game-actions">
                            <button class="clear-btn" onclick="clearPlacedTiles(${this.gameId})">Clear Board</button>
                            <button class="shuffle-btn" onclick="shufflePlayerTiles(${this.gameId})">Shuffle Tiles</button>
                        </div>
                        
                        <div class="move-history">
                            <h4>Word History</h4>
                            <div class="words-list" id="wordsList${this.gameId}"></div>
                        </div>
                    </div>
                `;
                
                this.addWordGameStyles();
            }

            createBoardHTML() {
                let boardHTML = '';
                
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        const special = this.engine.getSpecialSquare(row, col);
                        const specialClass = special ? `special-${special.toLowerCase()}` : '';
                        const centerClass = (row === 7 && col === 7) ? 'center-star' : '';
                        
                        boardHTML += `
                            <div class="word-square ${specialClass} ${centerClass}" 
                                 data-row="${row}" 
                                 data-col="${col}"
                                 ondrop="dropTile(event, ${this.gameId}, ${row}, ${col})"
                                 ondragover="allowDrop(event)"
                                 onclick="handleWordSquareClick(${this.gameId}, ${row}, ${col})">
                                ${special ? `<span class="special-label">${special}</span>` : ''}
                                ${row === 7 && col === 7 ? '<span class="star">⭐</span>' : ''}
                            </div>
                        `;
                    }
                }
                
                return boardHTML;
            }

            createPlayerTilesHTML() {
                const playerKey = this.isPlayer1 ? 'player1' : 'player2';
                const tiles = this.engine.playerTiles[playerKey];
                
                return tiles.map(tile => `
                    <div class="player-tile" 
                         data-tile-id="${tile.id}"
                         draggable="true"
                         ondragstart="startTileDrag(event, ${this.gameId}, '${tile.id}')"
                         onclick="selectPlayerTile(${this.gameId}, '${tile.id}')">
                        <span class="tile-letter">${tile.letter === '*' ? '?' : tile.letter}</span>
                        <span class="tile-value">${tile.value}</span>
                    </div>
                `).join('');
            }
        }
        
        // WORD GAME UI MANAGER - PART 6B: INTERACTION METHODS
        // Add these methods to the WordGameManager class

            handleSquareClick(row, col) {
                if (!this.isMyTurn || this.gameState !== 'active') return;
                
                const existingTile = this.placedTiles.find(t => t.row === row && t.col === col);
                
                if (existingTile) {
                    // Remove tile from board and return to hand
                    this.removeTileFromBoard(row, col);
                } else if (this.selectedTiles.length > 0) {
                    // Place selected tile
                    this.placeTileOnBoard(row, col);
                }
            }

            placeTileOnBoard(row, col) {
                if (this.selectedTiles.length === 0) return;
                
                const tileId = this.selectedTiles[0];
                const playerKey = this.isPlayer1 ? 'player1' : 'player2';
                const tile = this.engine.playerTiles[playerKey].find(t => t.id === tileId);
                
                if (!tile) return;
                
                // Check if square is empty
                const existingTile = this.placedTiles.find(t => t.row === row && t.col === col);
                if (existingTile) return;
                
                // Add to placed tiles
                this.placedTiles.push({
                    ...tile,
                    row: row,
                    col: col
                });
                
                // Remove from selected
                this.selectedTiles = [];
                
                this.updateDisplay();
                this.validateCurrentPlacement();
            }

            removeTileFromBoard(row, col) {
                const tileIndex = this.placedTiles.findIndex(t => t.row === row && t.col === col);
                if (tileIndex >= 0) {
                    this.placedTiles.splice(tileIndex, 1);
                    this.updateDisplay();
                    this.validateCurrentPlacement();
                }
            }

            selectPlayerTile(tileId) {
                if (!this.isMyTurn || this.gameState !== 'active') return;
                
                // Toggle selection
                const index = this.selectedTiles.indexOf(tileId);
                if (index >= 0) {
                    this.selectedTiles.splice(index, 1);
                } else {
                    this.selectedTiles = [tileId]; // Only one tile selected at a time
                }
                
                this.updateDisplay();
            }

            // Drag and drop functionality
            startTileDrag(event, tileId) {
                this.draggedTile = tileId;
                event.dataTransfer.setData('text/plain', tileId);
                event.dataTransfer.effectAllowed = 'move';
            }

            allowDrop(event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }

            dropTile(event, row, col) {
                event.preventDefault();
                
                const tileId = event.dataTransfer.getData('text/plain');
                if (!tileId || !this.isMyTurn) return;
                
                // Check if square is empty
                const existingTile = this.placedTiles.find(t => t.row === row && t.col === col);
                if (existingTile) return;
                
                const playerKey = this.isPlayer1 ? 'player1' : 'player2';
                const tile = this.engine.playerTiles[playerKey].find(t => t.id === tileId);
                
                if (tile) {
                    this.placedTiles.push({
                        ...tile,
                        row: row,
                        col: col
                    });
                    
                    this.updateDisplay();
                    this.validateCurrentPlacement();
                }
                
                this.draggedTile = null;
            }

            validateCurrentPlacement() {
                const submitBtn = this.container.querySelector('.submit-btn');
                const wordPreview = this.container.querySelector(`#wordPreview${this.gameId}`);
                
                if (this.placedTiles.length === 0) {
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Submit Word';
                    wordPreview.textContent = 'Place tiles on the board to form words';
                    return;
                }
                
                // Simple validation - check if tiles form a line
                const validation = this.engine.validateMove(this.placedTiles);
                
                if (validation.valid) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = `Submit (${validation.wordsFormed.length} words)`;
                    
                    const words = validation.wordsFormed.map(w => w.letters.join('')).join(', ');
                    wordPreview.textContent = `Words: ${words}`;
                    wordPreview.style.color = '#10b981';
                } else {
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Invalid Placement';
                    wordPreview.textContent = validation.reason;
                    wordPreview.style.color = '#ef4444';
                }
            }

            clearPlacedTiles() {
                this.placedTiles = [];
                this.updateDisplay();
                this.validateCurrentPlacement();
            }

            shufflePlayerTiles() {
                const playerKey = this.isPlayer1 ? 'player1' : 'player2';
                const tiles = this.engine.playerTiles[playerKey];
                
                // Fisher-Yates shuffle
                for (let i = tiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                }
                
                this.updateDisplay();
            }
            
            // WORD GAME UI MANAGER - PART 6C: GAME ACTIONS
        // Add these methods to the WordGameManager class

            async submitMove() {
                if (this.placedTiles.length === 0 || !this.isMyTurn) return;
                
                const result = this.engine.makeMove(this.placedTiles);
                
                if (result.success) {
                    // Clear placed tiles
                    this.placedTiles = [];
                    
                    // Add to move history
                    this.addWordsToHistory(result.wordsFormed, result.score);
                    
                    // Send move to opponent
                    await this.sendMoveToOpponent();
                    
                    // Switch turns
                    this.isMyTurn = false;
                    this.updateDisplay();
                    
                    showNotification(`Word submitted! Score: +${result.score}`, 'success');
                    
                    // Check game end
                    if (this.engine.isGameOver) {
                        this.endGame();
                    }
                } else {
                    showNotification(`Invalid move: ${result.reason}`, 'error');
                }
            }

            async passTurn() {
                if (!this.isMyTurn) return;
                
                const confirmed = confirm('Are you sure you want to pass your turn?');
                if (confirmed) {
                    this.engine.passTurn();
                    
                    // Clear any placed tiles
                    this.placedTiles = [];
                    
                    // Send pass to opponent
                    await this.sendMoveToOpponent('pass');
                    
                    this.isMyTurn = false;
                    this.updateDisplay();
                    
                    showNotification('Turn passed', 'info');
                    
                    if (this.engine.isGameOver) {
                        this.endGame();
                    }
                }
            }

            showExchangeDialog() {
                if (!this.isMyTurn || this.engine.tileBag.length < 7) {
                    showNotification('Not enough tiles in bag to exchange', 'warning');
                    return;
                }
                
                // Create exchange dialog
                const dialog = document.createElement('div');
                dialog.className = 'exchange-dialog';
                dialog.innerHTML = `
                    <div class="dialog-overlay">
                        <div class="dialog-content">
                            <h3>Exchange Tiles</h3>
                            <p>Select tiles to exchange (this will end your turn):</p>
                            <div class="exchange-tiles">
                                ${this.createPlayerTilesHTML()}
                            </div>
                            <div class="dialog-actions">
                                <button onclick="confirmExchange(${this.gameId})">Exchange Selected</button>
                                <button onclick="cancelExchange(${this.gameId})">Cancel</button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(dialog);
            }

            async confirmExchange() {
                const selectedTileIds = this.selectedTiles;
                if (selectedTileIds.length === 0) {
                    showNotification('Please select tiles to exchange', 'warning');
                    return;
                }
                
                const result = this.engine.exchangeTiles(selectedTileIds);
                
                if (result.success) {
                    // Clear selections
                    this.selectedTiles = [];
                    
                    // Send exchange to opponent
                    await this.sendMoveToOpponent('exchange');
                    
                    this.isMyTurn = false;
                    this.updateDisplay();
                    
                    showNotification(`Exchanged ${selectedTileIds.length} tiles`, 'success');
                } else {
                    showNotification(`Exchange failed: ${result.reason}`, 'error');
                }
                
                // Close dialog
                const dialog = document.querySelector('.exchange-dialog');
                if (dialog) dialog.remove();
            }

            cancelExchange() {
                const dialog = document.querySelector('.exchange-dialog');
                if (dialog) dialog.remove();
            }

            async sendMoveToOpponent(moveType = 'word') {
                const moveData = {
                    gameId: this.gameId,
                    type: moveType,
                    gameState: this.engine.getGameState(),
                    placedTiles: moveType === 'word' ? [...this.placedTiles] : [],
                    timestamp: Date.now()
                };
                
                // Store in localStorage for demo (replace with real networking)
                localStorage.setItem(`wordMove_${this.gameId}`, JSON.stringify(moveData));
                console.log('Word game move sent:', moveData);
            }

            receiveOpponentMove(moveData) {
                if (moveData.gameId !== this.gameId) return;
                
                // Update engine state
                this.engine.setGameState(moveData.gameState);
                
                // Clear any pending placements
                this.placedTiles = [];
                this.selectedTiles = [];
                
                // Update UI
                this.isMyTurn = true;
                this.updateDisplay();
                
                // Add move to history if it was a word play
                if (moveData.type === 'word' && moveData.gameState.gameHistory.length > 0) {
                    const lastMove = moveData.gameState.gameHistory[moveData.gameState.gameHistory.length - 1];
                    if (lastMove.wordsFormed) {
                        this.addWordsToHistory(lastMove.wordsFormed, lastMove.score);
                    }
                }
                
                let message = 'Opponent ';
                switch (moveData.type) {
                    case 'word': message += 'played a word!'; break;
                    case 'pass': message += 'passed their turn'; break;
                    case 'exchange': message += 'exchanged tiles'; break;
                    default: message += 'made a move'; break;
                }
                
                showNotification(message, 'info');
                
                if (this.engine.isGameOver) {
                    this.endGame();
                }
            }
            
            // WORD GAME UI MANAGER - PART 6D: DISPLAY METHODS
        // Add these methods to the WordGameManager class

            updateDisplay() {
                this.updateBoard();
                this.updatePlayerTiles();
                this.updateScores();
                this.updateGameStatus();
                this.updatePlayerIndicators();
            }

            updateBoard() {
                // Clear all tiles from board display
                const squares = this.container.querySelectorAll('.word-square');
                squares.forEach(square => {
                    const tileElement = square.querySelector('.board-tile');
                    if (tileElement) tileElement.remove();
                    square.classList.remove('placed-tile', 'new-tile');
                });
                
                // Show existing tiles on board
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        const tile = this.engine.getTileAt(row, col);
                        if (tile) {
                            this.displayTileOnBoard(row, col, tile, false);
                        }
                    }
                }
                
                // Show newly placed tiles
                this.placedTiles.forEach(tile => {
                    this.displayTileOnBoard(tile.row, tile.col, tile, true);
                });
            }

            displayTileOnBoard(row, col, tile, isNew = false) {
                const square = this.container.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!square) return;
                
                const tileElement = document.createElement('div');
                tileElement.className = `board-tile ${isNew ? 'new-tile' : 'existing-tile'}`;
                tileElement.innerHTML = `
                    <span class="tile-letter">${tile.letter === '*' ? '?' : tile.letter}</span>
                    <span class="tile-value">${tile.value}</span>
                `;
                
                if (isNew) {
                    tileElement.onclick = () => this.removeTileFromBoard(row, col);
                    tileElement.style.cursor = 'pointer';
                }
                
                square.appendChild(tileElement);
                square.classList.add('placed-tile');
                if (isNew) square.classList.add('new-tile');
            }

            updatePlayerTiles() {
                const tilesContainer = this.container.querySelector(`#playerTiles${this.gameId}`);
                if (!tilesContainer) return;
                
                const playerKey = this.isPlayer1 ? 'player1' : 'player2';
                const tiles = this.engine.playerTiles[playerKey];
                
                // Filter out tiles that are currently placed on board
                const availableTiles = tiles.filter(tile => 
                    !this.placedTiles.some(placed => placed.id === tile.id)
                );
                
                tilesContainer.innerHTML = availableTiles.map(tile => {
                    const isSelected = this.selectedTiles.includes(tile.id);
                    return `
                        <div class="player-tile ${isSelected ? 'selected' : ''}" 
                             data-tile-id="${tile.id}"
                             draggable="true"
                             ondragstart="startTileDrag(event, ${this.gameId}, '${tile.id}')"
                             onclick="selectPlayerTile(${this.gameId}, '${tile.id}')">
                            <span class="tile-letter">${tile.letter === '*' ? '?' : tile.letter}</span>
                            <span class="tile-value">${tile.value}</span>
                        </div>
                    `;
                }).join('');
            }

            updateScores() {
                const yourScoreElement = this.container.querySelector(`#yourScore${this.gameId}`);
                const opponentScoreElement = this.container.querySelector(`#opponentScore${this.gameId}`);
                const tilesLeftElement = this.container.querySelector(`#tilesLeft${this.gameId}`);
                
                if (yourScoreElement) {
                    const yourScore = this.isPlayer1 ? this.engine.scores.player1 : this.engine.scores.player2;
                    yourScoreElement.textContent = yourScore;
                }
                
                if (opponentScoreElement) {
                    const opponentScore = this.isPlayer1 ? this.engine.scores.player2 : this.engine.scores.player1;
                    opponentScoreElement.textContent = opponentScore;
                }
                
                if (tilesLeftElement) {
                    tilesLeftElement.textContent = this.engine.tileBag.length;
                }
            }

            updateGameStatus() {
                const statusElement = this.container.querySelector(`#gameStatus${this.gameId}`);
                if (!statusElement) return;
                
                let status = '';
                
                if (this.engine.isGameOver) {
                    if (this.engine.winner === 'tie') {
                        status = 'Game ended in a tie!';
                    } else {
                        const winner = this.engine.winner === 'player1' ? 'Player 1' : 'Player 2';
                        const isWinner = (this.isPlayer1 && this.engine.winner === 'player1') || 
                                        (!this.isPlayer1 && this.engine.winner === 'player2');
                        status = isWinner ? 'You won!' : 'You lost!';
                    }
                } else {
                    status = this.isMyTurn ? 'Your turn - Place tiles to form words' : "Opponent's turn";
                }
                
                statusElement.textContent = status;
            }

            updatePlayerIndicators() {
                const playerElements = this.container.querySelectorAll('.player');
                playerElements.forEach(player => player.classList.remove('active'));
                
                const activePlayer = this.isMyTurn ? '.player:first-child' : '.player:last-child';
                const activeElement = this.container.querySelector(activePlayer);
                if (activeElement) {
                    activeElement.classList.add('active');
                }
            }

            addWordsToHistory(wordsFormed, score) {
                const wordsList = this.container.querySelector(`#wordsList${this.gameId}`);
                if (!wordsList) return;
                
                const moveElement = document.createElement('div');
                moveElement.className = 'word-move';
                
                const words = wordsFormed.map(w => w.letters.join('')).join(', ');
                moveElement.innerHTML = `
                    <div class="move-player">${this.isMyTurn ? 'You' : 'Opponent'}</div>
                    <div class="move-words">${words}</div>
                    <div class="move-score">+${score}</div>
                `;
                
                wordsList.appendChild(moveElement);
                wordsList.scrollTop = wordsList.scrollHeight;
            }
            
            // WORD GAME UI MANAGER - PART 6E: END GAME METHODS
        // Add these methods to the WordGameManager class

            async endGame(reason = 'normal') {
                this.gameState = 'ended';
                this.isMyTurn = false;
                
                // Clear any pending placements
                this.placedTiles = [];
                this.selectedTiles = [];
                
                // Determine winner for blockchain settlement
                let winner = null;
                if (this.engine.winner && this.engine.winner !== 'tie') {
                    const isWinner = (this.isPlayer1 && this.engine.winner === 'player1') || 
                                    (!this.isPlayer1 && this.engine.winner === 'player2');
                    winner = isWinner ? 'player1' : 'player2';
                }
                
                // Send game result to blockchain
                if (winner) {
                    await this.settleGameOnBlockchain(winner);
                }
                
                this.updateDisplay();
            }

            async settleGameOnBlockchain(winner) {
                try {
                    if (!contract || !userAccount) return;
                    
                    const winnerAddress = winner === 'player1' ? userAccount : 'opponent_address';
                    
                    showNotification('🎮 Settling word game on blockchain...', 'info');
                    
                    const tx = await contract.endGame(this.gameId, winnerAddress, "word_game_completed", {
                        gasLimit: 150000
                    });
                    
                    showTransactionStatus(tx.hash, 'pending');
                    const receipt = await tx.wait();
                    
                    showNotification(`🎉 Word game settled! Winner: ${winner}`, 'success');
                    showTransactionStatus(tx.hash, 'confirmed');
                    
                } catch (error) {
                    console.error('Failed to settle word game:', error);
                    showNotification('❌ Failed to settle game on blockchain', 'error');
                }
            }
        }
        
        // WORD GAME UI MANAGER - PART 6F: CSS STYLES PART 1
        // Add this method to the WordGameManager class

            addWordGameStyles() {
                const styles1 = `
                    <style>
                        .word-game-window {
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(255, 255, 255, 0.95);
                            border-radius: 20px;
                            padding: 20px;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            backdrop-filter: blur(10px);
                            z-index: 1000;
                            color: #333;
                            max-width: 95vw;
                            max-height: 95vh;
                            overflow-y: auto;
                            width: 800px;
                        }

                        .word-board-container {
                            display: flex;
                            justify-content: center;
                            margin: 20px 0;
                            overflow: auto;
                        }

                        .word-board {
                            display: grid;
                            grid-template-columns: repeat(15, 30px);
                            grid-template-rows: repeat(15, 30px);
                            gap: 1px;
                            background: #333;
                            border: 2px solid #333;
                            border-radius: 8px;
                            padding: 4px;
                        }

                        .word-square {
                            width: 30px;
                            height: 30px;
                            background: #f9f9f9;
                            border: 1px solid #ddd;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            position: relative;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            font-size: 8px;
                        }

                        .word-square:hover {
                            background: rgba(255, 107, 53, 0.1);
                            transform: scale(1.05);
                        }

                        .word-square.center-star {
                            background: linear-gradient(135deg, #ff6b35, #ff8e53);
                            color: white;
                        }

                        .word-square.special-tw {
                            background: linear-gradient(135deg, #dc2626, #ef4444);
                            color: white;
                        }

                        .word-square.special-dw {
                            background: linear-gradient(135deg, #f59e0b, #fbbf24);
                            color: white;
                        }

                        .word-square.special-tl {
                            background: linear-gradient(135deg, #2563eb, #3b82f6);
                            color: white;
                        }

                        .word-square.special-dl {
                            background: linear-gradient(135deg, #059669, #10b981);
                            color: white;
                        }

                        .special-label {
                            font-size: 6px;
                            font-weight: 700;
                            text-transform: uppercase;
                            position: absolute;
                            top: 1px;
                            left: 1px;
                            line-height: 1;
                        }

                        .star {
                            font-size: 12px;
                        }
                    </style>
                `;
                document.head.insertAdjacentHTML('beforeend', styles1);
                this.addWordGameStyles2();
            }
            
            // WORD GAME UI MANAGER - PART 6G: CSS STYLES PART 2
        // Add this method to the WordGameManager class

            addWordGameStyles2() {
                const styles2 = `
                    <style>
                        .board-tile {
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: linear-gradient(135deg, #fef3c7, #fde68a);
                            border: 2px solid #f59e0b;
                            border-radius: 4px;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                            z-index: 10;
                        }

                        .board-tile.new-tile {
                            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
                            border-color: #3b82f6;
                            animation: tilePlace 0.3s ease;
                        }

                        @keyframes tilePlace {
                            0% { transform: scale(0); opacity: 0; }
                            50% { transform: scale(1.2); opacity: 0.8; }
                            100% { transform: scale(1); opacity: 1; }
                        }

                        .tile-letter {
                            font-size: 14px;
                            font-weight: 700;
                            color: #333;
                            line-height: 1;
                        }

                        .tile-value {
                            font-size: 8px;
                            font-weight: 600;
                            color: #666;
                            position: absolute;
                            bottom: 1px;
                            right: 2px;
                        }

                        .player-tiles-container {
                            margin: 20px 0;
                            text-align: center;
                        }

                        .player-tiles-container h4 {
                            margin-bottom: 10px;
                            color: #374151;
                            font-size: 16px;
                        }

                        .player-tiles {
                            display: flex;
                            justify-content: center;
                            gap: 8px;
                            flex-wrap: wrap;
                            padding: 15px;
                            background: rgba(255, 107, 53, 0.1);
                            border-radius: 12px;
                            border: 2px dashed rgba(255, 107, 53, 0.3);
                            min-height: 60px;
                        }

                        .player-tile {
                            width: 50px;
                            height: 50px;
                            background: linear-gradient(135deg, #fef3c7, #fde68a);
                            border: 2px solid #f59e0b;
                            border-radius: 8px;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                            position: relative;
                            user-select: none;
                        }

                        .player-tile:hover {
                            transform: translateY(-2px);
                            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
                        }

                        .player-tile.selected {
                            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
                            border-color: #3b82f6;
                            transform: translateY(-4px);
                            box-shadow: 0 8px 16px rgba(59, 130, 246, 0.4);
                        }

                        .player-tile .tile-letter {
                            font-size: 24px;
                            font-weight: 700;
                            color: #333;
                        }

                        .player-tile .tile-value {
                            font-size: 10px;
                            font-weight: 600;
                            color: #666;
                            position: absolute;
                            bottom: 2px;
                            right: 4px;
                        }
                    </style>
                `;
                document.head.insertAdjacentHTML('beforeend', styles2);
                this.addWordGameStyles3();
            }
            
            // WORD GAME UI MANAGER - PART 6H: CSS STYLES PART 3
        // Add this method to the WordGameManager class

            addWordGameStyles3() {
                const styles3 = `
                    <style>
                        .players-score {
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin: 20px 0;
                            padding: 15px;
                            background: rgba(255, 107, 53, 0.1);
                            border-radius: 12px;
                            border: 1px solid rgba(255, 107, 53, 0.2);
                        }

                        .players-score .player {
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 5px;
                            padding: 10px;
                            border-radius: 8px;
                            transition: all 0.3s ease;
                        }

                        .players-score .player.active {
                            background: rgba(16, 185, 129, 0.2);
                            border: 2px solid #10b981;
                        }

                        .player-name {
                            font-weight: 700;
                            font-size: 14px;
                            color: #374151;
                        }

                        .player-score {
                            font-size: 24px;
                            font-weight: 800;
                            color: #ff6b35;
                            background: rgba(255, 255, 255, 0.8);
                            padding: 5px 15px;
                            border-radius: 20px;
                            border: 2px solid #ff6b35;
                        }

                        .remaining-tiles {
                            text-align: center;
                            font-size: 12px;
                            color: #6b7280;
                            background: rgba(0, 0, 0, 0.05);
                            padding: 8px 12px;
                            border-radius: 8px;
                        }

                        .game-controls {
                            display: flex;
                            gap: 8px;
                            flex-wrap: wrap;
                        }

                        .game-controls button {
                            padding: 8px 16px;
                            border: none;
                            border-radius: 8px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            font-size: 12px;
                        }

                        .submit-btn {
                            background: #10b981;
                            color: white;
                        }

                        .submit-btn:disabled {
                            background: #9ca3af;
                            cursor: not-allowed;
                        }

                        .pass-btn {
                            background: #f59e0b;
                            color: white;
                        }

                        .exchange-btn {
                            background: #6366f1;
                            color: white;
                        }

                        .resign-btn {
                            background: #ef4444;
                            color: white;
                        }

                        .close-btn {
                            background: #6b7280;
                            color: white;
                            font-size: 16px;
                            width: 32px;
                            height: 32px;
                            padding: 0;
                        }

                        .game-actions {
                            display: flex;
                            justify-content: center;
                            gap: 12px;
                            margin: 15px 0;
                        }

                        .clear-btn, .shuffle-btn {
                            background: rgba(107, 114, 128, 0.1);
                            border: 1px solid #6b7280;
                            color: #6b7280;
                            padding: 8px 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.3s ease;
                        }

                        .clear-btn:hover, .shuffle-btn:hover {
                            background: #6b7280;
                            color: white;
                        }
                    </style>
                `;
                document.head.insertAdjacentHTML('beforeend', styles3);
                this.addWordGameStyles4();
            }
            
            // WORD GAME UI MANAGER - PART 6I: CSS STYLES PART 4 (FINAL)
        // Add this method to the WordGameManager class

            addWordGameStyles4() {
                const styles4 = `
                    <style>
                        .game-info {
                            margin: 15px 0;
                            padding: 12px;
                            background: rgba(107, 114, 128, 0.1);
                            border-radius: 8px;
                            text-align: center;
                        }

                        .game-status {
                            font-weight: 600;
                            font-size: 16px;
                            color: #ff6b35;
                            margin-bottom: 8px;
                        }

                        .word-preview {
                            font-size: 14px;
                            color: #6b7280;
                            font-style: italic;
                        }

                        .move-history {
                            margin-top: 20px;
                            max-height: 120px;
                            overflow-y: auto;
                        }

                        .move-history h4 {
                            margin-bottom: 10px;
                            color: #374151;
                            font-size: 14px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        }

                        .words-list {
                            display: flex;
                            flex-direction: column;
                            gap: 4px;
                        }

                        .word-move {
                            display: grid;
                            grid-template-columns: 80px 1fr 60px;
                            gap: 8px;
                            padding: 8px;
                            background: rgba(0, 0, 0, 0.05);
                            border-radius: 6px;
                            font-size: 12px;
                            align-items: center;
                        }

                        .move-player {
                            font-weight: 600;
                            color: #6b7280;
                        }

                        .move-words {
                            font-family: monospace;
                            color: #374151;
                            font-weight: 600;
                        }

                        .move-score {
                            text-align: right;
                            font-weight: 700;
                            color: #10b981;
                        }

                        .exchange-dialog {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            z-index: 2000;
                        }

                        .dialog-overlay {
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.5);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            backdrop-filter: blur(4px);
                        }

                        .dialog-content {
                            background: white;
                            padding: 30px;
                            border-radius: 16px;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            max-width: 500px;
                            width: 90vw;
                            color: #333;
                        }

                        .dialog-content h3 {
                            margin-bottom: 15px;
                            color: #ff6b35;
                            text-align: center;
                        }

                        .exchange-tiles {
                            display: flex;
                            justify-content: center;
                            gap: 8px;
                            flex-wrap: wrap;
                            margin: 20px 0;
                            padding: 15px;
                            background: rgba(255, 107, 53, 0.1);
                            border-radius: 12px;
                            border: 2px dashed rgba(255, 107, 53, 0.3);
                        }

                        .dialog-actions {
                            display: flex;
                            gap: 12px;
                            justify-content: center;
                            margin-top: 20px;
                        }

                        .dialog-actions button {
                            padding: 10px 20px;
                            border: none;
                            border-radius: 8px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        }

                        .dialog-actions button:first-child {
                            background: #10b981;
                            color: white;
                        }

                        .dialog-actions button:last-child {
                            background: #6b7280;
                            color: white;
                        }

                        @media (max-width: 768px) {
                            .word-game-window {
                                width: 95vw;
                                height: 95vh;
                                padding: 15px;
                            }
                            
                            .word-board {
                                grid-template-columns: repeat(15, 25px);
                                grid-template-rows: repeat(15, 25px);
                            }
                            
                            .word-square {
                                width: 25px;
                                height: 25px;
                                font-size: 6px;
                            }
                            
                            .player-tile {
                                width: 40px;
                                height: 40px;
                            }
                            
                            .player-tile .tile-letter {
                                font-size: 20px;
                            }
                        }
                    </style>
                `;
                document.head.insertAdjacentHTML('beforeend', styles4);
            }
        }
        
        // GLOBAL GAME INTEGRATION - PART 7A: ENHANCED GAME CREATION
        
        // Enhanced game creation that starts actual gameplay
        async function createBlockchainGameEnhanced(gameType, stakeAmount) {
            if (!contract) {
                showNotification('🔗 Please connect your wallet first!', 'error');
                return;
            }

            try {
                const button = document.getElementById(gameType + 'Btn');
                button.textContent = 'Creating Game...';
                button.disabled = true;

                // Validate stake amount
                const balance = await provider.getBalance(userAccount);
                const balanceEth = parseFloat(ethers.utils.formatEther(balance));
                
                if (balanceEth < stakeAmount) {
                    throw new Error(`Insufficient balance. You need ${stakeAmount} CORE but only have ${balanceEth.toFixed(4)} CORE`);
                }

                // Create game on blockchain
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                
                showNotification(`🎮 Creating ${gameType} game with ${stakeAmount} CORE stake...`, 'info');
                
                const tx = await contract.createGame(gameType, stakeWei, {
                    value: stakeWei,
                    gasLimit: 200000
                });

                showTransactionStatus(tx.hash, 'pending');
                const receipt = await tx.wait();
                
                // Get game ID from event
                const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
                const gameId = gameCreatedEvent?.args?.gameId?.toString();

                if (gameId) {
                    // Create actual game instance
                    await createGameInstance(gameId, gameType, true, stakeAmount);
                    
                    showNotification(`🎉 Game created! Waiting for opponent...`, 'success');
                    showTransactionStatus(tx.hash, 'confirmed');

                    button.textContent = `Waiting for opponent... (ID: ${gameId})`;
                    button.style.background = '#f59e0b';
                }

            } catch (error) {
                console.error('Game creation failed:', error);
                ErrorHandler.handleWeb3Error(error, 'Game Creation');
                
                // Reset button
                const button = document.getElementById(gameType + 'Btn');
                button.textContent = `Create Game (${stakeAmount} CORE)`;
                button.disabled = false;
            }
        }

        // Create actual game instance
        async function createGameInstance(gameId, gameType, isPlayerOne, stakeAmount) {
            // Create game container
            const gameContainer = document.createElement('div');
            gameContainer.id = `gameContainer${gameId}`;
            document.body.appendChild(gameContainer);

            let gameInstance;

            switch (gameType) {
                case 'chess':
                    gameInstance = new ChessGameManager(gameId, isPlayerOne, gameContainer);
                    activeChessGames.set(gameId, gameInstance);
                    break;
                case 'checkers':
                    gameInstance = new CheckersGameManager(gameId, isPlayerOne, gameContainer);
                    activeCheckersGames.set(gameId, gameInstance);
                    break;
                case 'scrabble':
                case 'word':
                    gameInstance = new WordGameManager(gameId, isPlayerOne, gameContainer);
                    activeWordGames.set(gameId, gameInstance);
                    break;
                default:
                    throw new Error('Unknown game type: ' + gameType);
            }

            // Store in active games
            activeGames.set(gameId, {
                instance: gameInstance,
                type: gameType,
                isPlayerOne: isPlayerOne,
                stake: stakeAmount,
                status: 'waiting'
            });

            return gameInstance;
        }

        // Join an existing game
        async function joinBlockchainGame(gameId) {
            if (!contract) {
                showNotification('🔗 Please connect your wallet first!', 'error');
                return;
            }

            try {
                showNotification(`🎮 Joining game ${gameId}...`, 'info');

                // Get game details from blockchain
                const gameData = await contract.games(gameId);
                const stakeAmount = parseFloat(ethers.utils.formatEther(gameData.stake));
                const gameType = gameData.gameType || 'chess'; // Default to chess if not specified

                // Validate balance
                const balance = await provider.getBalance(userAccount);
                const balanceEth = parseFloat(ethers.utils.formatEther(balance));
                
                if (balanceEth < stakeAmount) {
                    throw new Error(`Insufficient balance. You need ${stakeAmount} CORE to join this game`);
                }

                const tx = await contract.joinGame(gameId, {
                    value: gameData.stake,
                    gasLimit: 150000
                });

                showTransactionStatus(tx.hash, 'pending');
                const receipt = await tx.wait();

                // Create game instance for player 2
                await createGameInstance(gameId, gameType, false, stakeAmount);
                
                // Update game status
                const game = activeGames.get(gameId);
                if (game) {
                    game.status = 'active';
                }

                showNotification(`🎉 Successfully joined game ${gameId}!`, 'success');
                showTransactionStatus(tx.hash, 'confirmed');

            } catch (error) {
                console.error('Join game failed:', error);
                ErrorHandler.handleWeb3Error(error, 'Join Game');
            }
        }
        
        // GLOBAL GAME INTEGRATION - PART 7A: ENHANCED GAME CREATION
        
        // Enhanced game creation that starts actual gameplay
        async function createBlockchainGameEnhanced(gameType, stakeAmount) {
            if (!contract) {
                showNotification('🔗 Please connect your wallet first!', 'error');
                return;
            }

            try {
                const button = document.getElementById(gameType + 'Btn');
                button.textContent = 'Creating Game...';
                button.disabled = true;

                // Validate stake amount
                const balance = await provider.getBalance(userAccount);
                const balanceEth = parseFloat(ethers.utils.formatEther(balance));
                
                if (balanceEth < stakeAmount) {
                    throw new Error(`Insufficient balance. You need ${stakeAmount} CORE but only have ${balanceEth.toFixed(4)} CORE`);
                }

                // Create game on blockchain
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                
                showNotification(`🎮 Creating ${gameType} game with ${stakeAmount} CORE stake...`, 'info');
                
                const tx = await contract.createGame(gameType, stakeWei, {
                    value: stakeWei,
                    gasLimit: 200000
                });

                showTransactionStatus(tx.hash, 'pending');
                const receipt = await tx.wait();
                
                // Get game ID from event
                const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
                const gameId = gameCreatedEvent?.args?.gameId?.toString();

                if (gameId) {
                    // Create actual game instance
                    await createGameInstance(gameId, gameType, true, stakeAmount);
                    
                    showNotification(`🎉 Game created! Waiting for opponent...`, 'success');
                    showTransactionStatus(tx.hash, 'confirmed');

                    button.textContent = `Waiting for opponent... (ID: ${gameId})`;
                    button.style.background = '#f59e0b';
                }

            } catch (error) {
                console.error('Game creation failed:', error);
                ErrorHandler.handleWeb3Error(error, 'Game Creation');
                
                // Reset button
                const button = document.getElementById(gameType + 'Btn');
                button.textContent = `Create Game (${stakeAmount} CORE)`;
                button.disabled = false;
            }
        }

        // Create actual game instance
        async function createGameInstance(gameId, gameType, isPlayerOne, stakeAmount) {
            // Create game container
            const gameContainer = document.createElement('div');
            gameContainer.id = `gameContainer${gameId}`;
            document.body.appendChild(gameContainer);

            let gameInstance;

            switch (gameType) {
                case 'chess':
                    gameInstance = new ChessGameManager(gameId, isPlayerOne, gameContainer);
                    activeChessGames.set(gameId, gameInstance);
                    break;
                case 'checkers':
                    gameInstance = new CheckersGameManager(gameId, isPlayerOne, gameContainer);
                    activeCheckersGames.set(gameId, gameInstance);
                    break;
                case 'scrabble':
                case 'word':
                    gameInstance = new WordGameManager(gameId, isPlayerOne, gameContainer);
                    activeWordGames.set(gameId, gameInstance);
                    break;
                default:
                    throw new Error('Unknown game type: ' + gameType);
            }

            // Store in active games
            activeGames.set(gameId, {
                instance: gameInstance,
                type: gameType,
                isPlayerOne: isPlayerOne,
                stake: stakeAmount,
                status: 'waiting'
            });

            return gameInstance;
        }

        // Join an existing game
        async function joinBlockchainGame(gameId) {
            if (!contract) {
                showNotification('🔗 Please connect your wallet first!', 'error');
                return;
            }

            try {
                showNotification(`🎮 Joining game ${gameId}...`, 'info');

                // Get game details from blockchain
                const gameData = await contract.games(gameId);
                const stakeAmount = parseFloat(ethers.utils.formatEther(gameData.stake));
                const gameType = gameData.gameType || 'chess'; // Default to chess if not specified

                // Validate balance
                const balance = await provider.getBalance(userAccount);
                const balanceEth = parseFloat(ethers.utils.formatEther(balance));
                
                if (balanceEth < stakeAmount) {
                    throw new Error(`Insufficient balance. You need ${stakeAmount} CORE to join this game`);
                }

                const tx = await contract.joinGame(gameId, {
                    value: gameData.stake,
                    gasLimit: 150000
                });

                showTransactionStatus(tx.hash, 'pending');
                const receipt = await tx.wait();

                // Create game instance for player 2
                await createGameInstance(gameId, gameType, false, stakeAmount);
                
                // Update game status
                const game = activeGames.get(gameId);
                if (game) {
                    game.status = 'active';
                }

                showNotification(`🎉 Successfully joined game ${gameId}!`, 'success');
                showTransactionStatus(tx.hash, 'confirmed');

            } catch (error) {
                console.error('Join game failed:', error);
                ErrorHandler.handleWeb3Error(error, 'Join Game');
            }
        }
        
        // GLOBAL GAME INTEGRATION - PART 7B: GLOBAL INTERACTION FUNCTIONS
        
        // Global game interaction functions
        function handleChessSquareClick(gameId, row, col) {
            const game = activeChessGames.get(gameId);
            if (game) {
                game.handleSquareClick(row, col);
            }
        }

        function handleCheckersSquareClick(gameId, row, col) {
            const game = activeCheckersGames.get(gameId);
            if (game) {
                game.handleSquareClick(row, col);
            }
        }

        function handleWordSquareClick(gameId, row, col) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.handleSquareClick(row, col);
            }
        }

        // Word game specific functions
        function submitWordMove(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.submitMove();
            }
        }

        function passTurn(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.passTurn();
            }
        }

        function showExchangeDialog(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.showExchangeDialog();
            }
        }

        function confirmExchange(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.confirmExchange();
            }
        }

        function cancelExchange(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.cancelExchange();
            }
        }

        function clearPlacedTiles(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.clearPlacedTiles();
            }
        }

        function shufflePlayerTiles(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.shufflePlayerTiles();
            }
        }

        function selectPlayerTile(gameId, tileId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.selectPlayerTile(tileId);
            }
        }

        // Drag and drop for word game
        function startTileDrag(event, gameId, tileId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.startTileDrag(event, tileId);
            }
        }

        function allowDrop(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        function dropTile(event, gameId, row, col) {
            const game = activeWordGames.get(gameId);
            if (game) {
                game.dropTile(event, row, col);
            }
        }

        // Game resignation functions
        async function resignChessGame(gameId) {
            const game = activeChessGames.get(gameId);
            if (game) {
                const confirmed = confirm('Are you sure you want to resign?');
                if (confirmed) {
                    await game.endGame('resignation');
                    showNotification('You resigned the chess game', 'info');
                }
            }
        }

        async function resignCheckersGame(gameId) {
            const game = activeCheckersGames.get(gameId);
            if (game) {
                const confirmed = confirm('Are you sure you want to resign?');
                if (confirmed) {
                    await game.endGame('resignation');
                    showNotification('You resigned the checkers game', 'info');
                }
            }
        }

        async function resignWordGame(gameId) {
            const game = activeWordGames.get(gameId);
            if (game) {
                const confirmed = confirm('Are you sure you want to resign?');
                if (confirmed) {
                    await game.endGame('resignation');
                    showNotification('You resigned the word game', 'info');
                }
            }
        }

        // Close game window
        function closeGame(gameId) {
            const gameContainer = document.getElementById(`gameContainer${gameId}`);
            if (gameContainer) {
                gameContainer.remove();
            }
            
            // Remove from active games
            activeGames.delete(gameId);
            activeChessGames.delete(gameId);
            activeCheckersGames.delete(gameId);
            activeWordGames.delete(gameId);
        }

        // Offer draw (chess only)
        function offerDraw(gameId) {
            showNotification('Draw offer sent to opponent', 'info');
            // Implement draw offer logic here
        }
        
        // GLOBAL GAME INTEGRATION - PART 7C: ENHANCED WALLET CONNECTION
        
        // Enhanced connection function that sets up real games
        async function connectWalletWithRealGames() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    showNotification('🦊 Please install MetaMask or Core Wallet to play!', 'error');
                    return;
                }

                showNotification('🔗 Connecting to Core Blockchain...', 'info');

                // Request account access
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                // Switch to Core Chain
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x45C' }], // 1116 in hex
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: '0x45C',
                                chainName: 'Core Blockchain',
                                nativeCurrency: {
                                    name: 'CORE',
                                    symbol: 'CORE',
                                    decimals: 18
                                },
                                rpcUrls: ['https://rpc.coredao.org'],
                                blockExplorerUrls: ['https://scan.coredao.org']
                            }]
                        });
                    }
                }

                // Initialize ethers
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                userAccount = await signer.getAddress();
                
                // Initialize contract with complete ABI
                contract = new ethers.Contract(CONTRACT_ADDRESS, COMPLETE_CONTRACT_ABI, signer);

                // Update UI
                await updateWalletUI();
                
                // Update game buttons to use real games
                updateGameButtonsToUseRealGames();
                
                // Initialize game system
                await initializeGameSystem();
                
                // Initialize game synchronization
                initializeGameSync();

                showNotification('✅ Successfully connected! Ready to play real games!', 'success');

            } catch (error) {
                console.error('Connection failed:', error);
                ErrorHandler.handleWeb3Error(error, 'Wallet Connection');
            }
        }

        // Update game buttons to use real gameplay
        function updateGameButtonsToUseRealGames() {
            // Update chess button
            const chessBtn = document.getElementById('chessBtn');
            if (chessBtn) {
                chessBtn.onclick = () => createBlockchainGameEnhanced('chess', 0.1);
            }
            
            // Update checkers button  
            const checkersBtn = document.getElementById('checkersBtn');
            if (checkersBtn) {
                checkersBtn.onclick = () => createBlockchainGameEnhanced('checkers', 0.05);
            }
            
            // Update word game button
            const scrabbleBtn = document.getElementById('scrabbleBtn');
            if (scrabbleBtn) {
                scrabbleBtn.onclick = () => createBlockchainGameEnhanced('word', 0.02);
            }
        }

        // Initialize real-time game synchronization
        function initializeGameSync() {
            // Check for moves from opponents every 5 seconds
            setInterval(() => {
                activeGames.forEach((game, gameId) => {
                    checkForOpponentMove(gameId, game.type);
                });
            }, 5000);
        }

        // Check for opponent moves (simplified version using localStorage)
        function checkForOpponentMove(gameId, gameType) {
            let moveKey = '';
            switch (gameType) {
                case 'chess': moveKey = `chessMove_${gameId}`; break;
                case 'checkers': moveKey = `checkersMove_${gameId}`; break;
                case 'word': moveKey = `wordMove_${gameId}`; break;
                default: return;
            }
            
            const moveData = localStorage.getItem(moveKey);
            if (moveData) {
                try {
                    const move = JSON.parse(moveData);
                    const game = activeGames.get(gameId);
                    
                    if (game && game.instance) {
                        // Check if this is a new move
                        const lastProcessed = localStorage.getItem(`lastProcessed_${gameId}`) || '0';
                        if (move.timestamp > parseInt(lastProcessed)) {
                            game.instance.receiveOpponentMove(move);
                            localStorage.setItem(`lastProcessed_${gameId}`, move.timestamp.toString());
                        }
                    }
                } catch (error) {
                    console.error('Failed to process opponent move:', error);
                }
            }
        }

        // Enhanced initialization that includes real games
        async function initializeRealGamePlatform() {
            console.log('🎮 Initializing Real Game Platform...');
            
            // Initialize UI components
            initializeUI();
            
            // Create game management sections
            createGameManagementSection();
            
            // Start network monitoring
            startNetworkMonitoring();
            
            // Set up event listeners
            setupEventListeners();
            
            // Set up enhanced wallet connection
            setupEnhancedWalletConnection();
            
            // Check for existing wallet connection
            await checkExistingConnection();
            
            console.log('✅ Real Game Platform initialized successfully!');
        }

        // Update the connect wallet button to use enhanced connection
        function setupEnhancedWalletConnection() {
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                // Remove old event listeners
                connectBtn.onclick = null;
                
                // Add new enhanced connection
                connectBtn.addEventListener('click', async () => {
                    connectBtn.textContent = 'Connecting...';
                    connectBtn.disabled = true;
                    
                    try {
                        await connectWalletWithRealGames();
                    } catch (error) {
                        connectBtn.textContent = 'Connect';
                        connectBtn.disabled = false;
                    }
                });
            }
        }
        
        // GLOBAL GAME INTEGRATION - PART 7D: CONTRACT EVENTS AND FINAL SETUP
        
        // Enhanced contract event setup
        function setupEnhancedContractEvents() {
            if (!contract) return;

            // Listen for GameJoined events to start games
            contract.on('GameJoined', async (gameId, player2, event) => {
                console.log('🎮 Game Joined:', gameId.toString());
                
                const gameIdStr = gameId.toString();
                const game = activeGames.get(gameIdStr);
                
                if (game && game.instance) {
                    // Start the actual game
                    game.status = 'active';
                    game.instance.isMyTurn = game.isPlayerOne; // Player 1 goes first
                    game.instance.updateDisplay();
                    
                    showNotification(`🎉 Opponent joined! Game ${gameIdStr} started!`, 'success');
                }
            });

            // Listen for GameEnded events
            contract.on('GameEnded', (gameId, winner, payout) => {
                console.log('🎮 Game Ended on blockchain:', gameId.toString());
                
                const gameIdStr = gameId.toString();
                const game = activeGames.get(gameIdStr);
                
                if (game && game.instance) {
                    showNotification(`🎮 Game ${gameIdStr} ended. Winner: ${winner.slice(0,6)}...${winner.slice(-4)}`, 'info');
                }
            });

            // Listen for GameCreated events
            contract.on('GameCreated', (gameId, player1, stake, gameType, event) => {
                console.log('🎮 Game Created:', {
                    gameId: gameId.toString(),
                    player1,
                    stake: ethers.utils.formatEther(stake),
                    gameType
                });

                // Show notification if it's another player's game
                if (player1.toLowerCase() !== userAccount.toLowerCase()) {
                    showNotification(`🎮 New ${gameType} game available! Stake: ${ethers.utils.formatEther(stake)} CORE`, 'info');
                }
            });
        }

        // Replace the old DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎮 Crypticus Real Gaming Platform Loading...');
            
            // Initialize real game platform instead of basic platform
            initializeRealGamePlatform();
            
            console.log('✅ Platform with real games loaded successfully!');
        });

        // Initialize everything with real games when DOM is ready
        window.addEventListener('load', function() {
            setupEnhancedContractEvents();
            
            console.log('🚀 Crypticus Real Gaming Platform Ready!');
            console.log('📍 Contract Address:', CONTRACT_ADDRESS);
            console.log('🌐 Network: Core Blockchain (Chain ID: 1116)');
            console.log('🎮 Real Chess, Checkers, and Word Games Available!');
            
            // Show platform ready notification after a short delay
            setTimeout(() => {
                if (!userAccount) {
                    showNotification('🎮 Welcome to Crypticus! Connect your wallet to start gaming.', 'info');
                }
            }, 2000);
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (contract) {
                contract.removeAllListeners();
            }
            
            // Clear any active timers
            activeGames.forEach(game => {
                if (game.instance && game.instance.timerInterval) {
                    clearInterval(game.instance.timerInterval);
                }
            });
        });

        // Global error handler for the gaming platform
        window.addEventListener('error', function(event) {
            console.error('Platform error:', event.error);
            
            // Don't show error notifications for minor issues
            if (event.error && event.error.message && 
                !event.error.message.includes('Non-Error promise rejection')) {
                showNotification('⚠️ An error occurred. Please refresh if issues persist.', 'warning');
            }
        });

        // Performance monitoring
        window.addEventListener('load', function() {
            const loadTime = performance.now();
            console.log(`⚡ Platform loaded in ${loadTime.toFixed(2)}ms`);
        });

        console.log('🎯 Real Gaming Platform Integration Complete!');
        console.log('📋 Players can now play actual games for real CORE tokens!');
        console.log('🚀 Ready for deployment and testing!');
        // Quick deployment verification
        console.log('🚀 Crypticus Gaming Platform Deployed!');
        console.log('📍 Contract Address:', CONTRACT_ADDRESS);
        console.log('🌐 Network: Core Blockchain (Chain ID: 1116)');
        console.log('💻 Platform Ready for Gaming!');
        
        // Performance monitoring
        window.addEventListener('load', function() {
            const loadTime = performance.now();
            console.log(`⚡ Platform loaded in ${loadTime.toFixed(2)}ms`);
            
            // Show platform ready notification after a short delay
            setTimeout(() => {
                if (!userAccount) {
                    showNotification('🎮 Welcome to Crypticus! Connect your wallet to start gaming.', 'info');
                }
            }, 2000);
        });
        
        // Global error handler
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            showNotification('⚠️ An error occurred. Please refresh if issues persist.', 'warning');
        });
        
        // Service worker registration for PWA (optional)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(err => {
                console.log('ServiceWorker registration failed:', err);
            });
        }
    </script>
</body>
</html>

