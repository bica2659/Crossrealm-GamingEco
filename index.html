<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrossRealm Gaming Ecosystem - Real Blockchain Gaming Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <!-- Add Socket.IO for real-time communication -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.js"></script>
</head>
<body>
    <div class="background"></div>

    <!-- Age Verification Modal -->
    <div class="age-verification" id="ageVerificationModal">
        <div class="verification-content">
            <h1><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h1>
            <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
            <div class="warning">
                <p><i class="fas fa-exclamation-circle"></i> Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
            </div>
            <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            <div class="verification-buttons">
                <button class="verify-btn accept" onclick="verifyAge(true)">I am 18+</button>
                <button class="verify-btn decline" onclick="verifyAge(false)">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Real-time Notifications Container -->
    <div class="notification-container" id="notificationContainer"></div>

    <!-- Anti-Bot Protection Modal -->
    <div class="anti-bot-challenge hidden" id="antiBotChallenge">
        <div class="modal-content">
            <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üõ°Ô∏è Human Verification</h3>
            <p style="margin-bottom: 1rem;">Please complete this challenge to continue playing:</p>
            <p id="captchaInstructions" style="margin-bottom: 1rem; font-weight: bold; color: #f39c12;">
                Select all squares containing chess pieces
            </p>
            
            <div class="captcha-grid" id="captchaGrid"></div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
                <button class="verify-btn accept" onclick="verifyCaptcha()" id="verifyCaptchaBtn" disabled>
                    Verify
                </button>
                <button class="verify-btn" onclick="refreshCaptcha()" style="background: #666;">
                    <i class="fas fa-refresh"></i> New Challenge
                </button>
            </div>
            
            <p style="margin-top: 1rem; font-size: 0.8rem; color: #aaa;">
                This helps us prevent automated bots and ensures fair play for all users.
            </p>
        </div>
    </div>

    <!-- Game Join Confirmation Modal -->
    <div class="modal hidden" id="gameJoinModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-handshake"></i> Join Game Confirmation</h3>
                <button class="close-modal" onclick="closeGameJoinModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div id="gameJoinDetails"></div>
                <div class="join-confirmation-buttons">
                    <button class="game-btn" onclick="confirmJoinGame()">
                        <i class="fas fa-check"></i> Confirm Join
                    </button>
                    <button class="game-btn secondary" onclick="closeGameJoinModal()">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Blockchain Transaction Confirmation Modal -->
    <div class="modal hidden" id="txConfirmationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-signature"></i> Transaction Confirmation</h3>
            </div>
            <div class="modal-body">
                <div class="tx-details">
                    <div class="tx-detail-item">
                        <span class="tx-label">Action:</span>
                        <span class="tx-value" id="txAction"></span>
                    </div>
                    <div class="tx-detail-item">
                        <span class="tx-label">Amount:</span>
                        <span class="tx-value" id="txAmount"></span>
                    </div>
                    <div class="tx-detail-item">
                        <span class="tx-label">Gas Fee:</span>
                        <span class="tx-value" id="txGasFee"></span>
                    </div>
                    <div class="tx-detail-item">
                        <span class="tx-label">Total:</span>
                        <span class="tx-value" id="txTotal"></span>
                    </div>
                </div>
                <div class="tx-confirmation-buttons">
                    <button class="game-btn" onclick="confirmTransaction()" id="confirmTxBtn">
                        <i class="fas fa-check"></i> Confirm Transaction
                    </button>
                    <button class="game-btn secondary" onclick="cancelTransaction()">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Invitation Modal -->
    <div class="modal hidden" id="gameInvitationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-envelope"></i> Game Invitation</h3>
            </div>
            <div class="modal-body">
                <div id="invitationDetails"></div>
                <div class="invitation-buttons">
                    <button class="game-btn" onclick="acceptInvitation()">
                        <i class="fas fa-check"></i> Accept
                    </button>
                    <button class="game-btn secondary" onclick="declineInvitation()">
                        <i class="fas fa-times"></i> Decline
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
        <div class="tx-progress">
            <div class="tx-progress-bar" id="txProgressBar"></div>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="logo">
            <i class="fas fa-dice-d20 logo-icon"></i>
            <h1>CROSSREALM</h1>
        </div>
        
        <nav class="nav-menu" id="navMenu">
            <div class="nav-item active" onclick="showSection('lobby')">üéØ Game Lobby</div>
            <div class="nav-item" onclick="showSection('create')">üéÆ Create Game</div>
            <div class="nav-item" onclick="showSection('mygames')">üé≤ My Games</div>
            <div class="nav-item" onclick="showSection('tournaments')">üèÜ Tournaments</div>
            <div class="nav-item" onclick="showSection('profile')">üë§ Profile</div>
            <div class="nav-item" onclick="showSection('settings')">‚öôÔ∏è Settings</div>
        </nav>
        
        <div class="live-badge" id="liveBadge">üî¥ LIVE ON CORE</div>
        
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">
                    <span class="connection-indicator disconnected"></span>Not Connected
                </div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn">
                <i class="fas fa-plug"></i> Connect Wallet
            </button>
            <button class="disconnect-btn hidden" id="disconnectBtn">Disconnect</button>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Real-time Connection Status -->
            <div class="realtime-status">
                <h3>üåê Real-time Status</h3>
                <div id="realtimeConnectionStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to multiplayer server...
                </div>
                <div class="connection-details">
                    <div class="detail-item">
                        <span>Players Online:</span>
                        <span id="playersOnline">0</span>
                    </div>
                    <div class="detail-item">
                        <span>Active Games:</span>
                        <span id="activeGamesCount">0</span>
                    </div>
                    <div class="detail-item">
                        <span>Your Status:</span>
                        <span id="userGameStatus">Available</span>
                    </div>
                </div>
            </div>

            <!-- Smart Contract Status -->
            <div class="contract-status">
                <h3>üîê Smart Contract Status</h3>
                <div class="contract-address" id="contractAddress">
                    0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A
                    <button class="copy-btn" onclick="copyContractAddress()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <div id="contractStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to Core Blockchain...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="connectionProgress" style="width: 0%"></div>
                </div>
            </div>

            <!-- My Active Games -->
            <div class="my-active-games">
                <h3>üéÆ My Active Games</h3>
                <div id="myActiveGamesList">
                    <div class="no-games">No active games</div>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="live-lobby">
                <h3>üìä Live Platform Stats</h3>
                <div class="lobby-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Online Players</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalGames">0</div>
                        <div class="stat-label">Active Games</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalVolume">0</div>
                        <div class="stat-label">CORE Volume</div>
                    </div>
                </div>
            </div>

            <!-- Recent Activity Feed -->
            <div class="live-lobby">
                <h3>üî• Recent Activity</h3>
                <div id="activityFeed"></div>
            </div>

            <!-- Tournament Leaderboard -->
            <div class="live-lobby">
                <h3>üèÜ Tournament Leaders</h3>
                <div id="tournamentLeaderboard">
                    <div class="leaderboard-item gold">
                        <span>ü•á CryptoKing</span>
                        <span>127 pts</span>
                    </div>
                    <div class="leaderboard-item silver">
                        <span>ü•à GameMaster</span>
                        <span>89 pts</span>
                    </div>
                    <div class="leaderboard-item bronze">
                        <span>ü•â ChessGM</span>
                        <span>76 pts</span>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Content Area -->
        <main class="content-area">
            <!-- Game Lobby Section -->
            <section id="lobbySection" class="section-content">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2>üéØ Live Game Lobby</h2>
                        <div class="lobby-controls">
                            <button onclick="refreshLobby()" class="game-btn" style="width: auto; padding: 0.5rem 1rem;">
                                <i class="fas fa-sync-alt"></i> Refresh
                            </button>
                            <div class="auto-refresh-toggle">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="autoRefreshToggle" checked onchange="toggleAutoRefresh()">
                                    <span class="slider"></span>
                                </label>
                                <span>Auto-refresh</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Real-time Game Filter -->
                    <div class="game-filters">
                        <div class="filter-group">
                            <label>Game Type:</label>
                            <select id="gameTypeFilter" class="filter-select" onchange="applyFilters()">
                                <option value="all">All Games</option>
                                <option value="chess">Chess</option>
                                <option value="checkers">Checkers</option>
                                <option value="words">Word Games</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>Stake Range:</label>
                            <select id="stakeFilter" class="filter-select" onchange="applyFilters()">
                                <option value="all">All Stakes</option>
                                <option value="low">0.01 - 0.1 CORE</option>
                                <option value="medium">0.1 - 1.0 CORE</option>
                                <option value="high">1.0+ CORE</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>Skill Level:</label>
                            <select id="skillFilter" class="filter-select" onchange="applyFilters()">
                                <option value="all">All Levels</option>
                                <option value="bronze">Bronze</option>
                                <option value="silver">Silver</option>
                                <option value="gold">Gold</option>
                                <option value="diamond">Diamond</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="gamesList" class="games-list"></div>
                    
                    <div id="noGames" class="hidden no-games">
                        <i class="fas fa-gamepad" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3>No Active Games</h3>
                        <p>Be the first to create a game and start earning CORE!</p>
                        <button onclick="showSection('create')" class="game-btn" style="margin-top: 1rem;">
                            Create First Game
                        </button>
                    </div>
                </div>
            </section>

            <!-- Other sections will be loaded dynamically -->
            <section id="createSection" class="section-content hidden"></section>
            <section id="mygamesSection" class="section-content hidden"></section>
            <section id="tournamentsSection" class="section-content hidden"></section>
            <section id="profileSection" class="section-content hidden"></section>
            <section id="settingsSection" class="section-content hidden"></section>
        </main>
    </div>

    <!-- Enhanced Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h3>üéÆ CrossRealm</h3>
                <p>The premier blockchain gaming platform built on Core Network. Play, compete, and earn with provably fair games.</p>
                <div class="social-links">
                    <a href="#" title="Twitter"><i class="fab fa-twitter"></i></a>
                    <a href="#" title="Discord"><i class="fab fa-discord"></i></a>
                    <a href="#" title="Telegram"><i class="fab fa-telegram"></i></a>
                    <a href="#" title="GitHub"><i class="fab fa-github"></i></a>
                </div>
            </div>
            
            <div class="footer-section">
                <h3>üéØ Games</h3>
                <p><a href="#" onclick="showSection('create')">Chess Masters</a></p>
                <p><a href="#" onclick="showSection('create')">Checkers Pro</a></p>
                <p><a href="#" onclick="showSection('create')">Word Battle</a></p>
                <p><a href="#" onclick="showSection('tournaments')">Tournaments</a></p>
            </div>
            
            <div class="footer-section">
                <h3>üîó Blockchain</h3>
                <p><a href="https://scan.coredao.org" target="_blank">Core Blockchain Explorer</a></p>
                <p><a href="#" onclick="copyContractAddress()">Smart Contract</a></p>
                <p><a href="https://coredao.org" target="_blank">Core Network</a></p>
                <p><a href="#" onclick="showSection('settings')">Network Settings</a></p>
            </div>
            
            <div class="footer-section">
                <h3>‚ÑπÔ∏è Support</h3>
                <p><a href="#" onclick="showHelp()">Help Center</a></p>
                <p><a href="#" onclick="showTerms()">Terms of Service</a></p>
                <p><a href="#" onclick="showPrivacy()">Privacy Policy</a></p>
                <p><a href="#" onclick="showFairPlay()">Fair Play</a></p>
            </div>
        </div>
        
        <div class="footer-bottom">
            <p>&copy; 2025 CrossRealm Gaming Platform. All rights reserved.</p>
            <p>Built on <strong>Core Blockchain</strong> ‚Ä¢ Licensed Gaming Platform ‚Ä¢ Age 18+ Only</p>
            <p>Contract: 0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A (Verified ‚úÖ)</p>
        </div>
    </footer>

<style>
/* ===========================
   CROSSREALM GAMING PLATFORM
   CSS STYLES & ANIMATIONS (ENHANCED)
   =========================== */

/* Base Variables & Reset */
:root {
    --primary: #4e54c8;
    --primary-dark: #363a9e;
    --secondary: #f39c12;
    --dark: #1a1c2c;
    --light: #f5f7fa;
    --danger: #e74c3c;
    --success: #2ecc71;
    --warning: #f1c40f;
    --gray: #95a5a6;
    --accent: #4ecdc4;
    --accent-dark: #44a08d;
    --glass: rgba(255, 255, 255, 0.1);
    --glass-border: rgba(255, 255, 255, 0.2);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html, body {
    height: 100%;
    overflow-x: hidden;
}

body {
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    color: var(--light);
    position: relative;
    line-height: 1.6;
}

.background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('https://images.unsplash.com/photo-1620336655052-b57986f5a26a?q=80&w=1920') no-repeat center center;
    background-size: cover;
    opacity: 0.1;
    z-index: -1;
}

.hidden {
    display: none !important;
}

/* ========================
   ANIMATIONS & KEYFRAMES
   ======================== */

@keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
}

@keyframes slideInDown {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes glow {
    0%, 100% { box-shadow: 0 0 20px rgba(78, 205, 196, 0.3); }
    50% { box-shadow: 0 0 30px rgba(78, 205, 196, 0.6); }
}

@keyframes slideInScale {
    from {
        opacity: 0;
        transform: translate(-50%, -60%) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

@keyframes slideInRight {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
}

@keyframes bounceIn {
    0% { transform: scale(0.3); opacity: 0; }
    50% { transform: scale(1.1); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

.pulse { animation: pulse 2s infinite; }
.shake { animation: shake 0.5s; }
.fade-in { animation: fadeIn 0.5s ease-out; }
.slide-in { animation: slideIn 0.5s ease-out; }
.slide-in-down { animation: slideInDown 0.5s ease-out; }
.glow { animation: glow 2s infinite; }
.bounce-in { animation: bounceIn 0.6s ease-out; }

/* ========================
   REAL-TIME NOTIFICATIONS
   ======================== */

.notification-container {
    position: fixed;
    top: 100px;
    right: 20px;
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    max-width: 350px;
}

.notification {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(26, 28, 44, 0.9));
    backdrop-filter: blur(15px);
    border: 2px solid var(--accent);
    border-radius: 10px;
    padding: 1rem;
    color: white;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
    animation: slideInRight 0.5s ease-out;
    cursor: pointer;
    transition: all 0.3s ease;
}

.notification:hover {
    transform: translateX(-5px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.7);
}

.notification.success {
    border-color: var(--success);
}

.notification.warning {
    border-color: var(--warning);
}

.notification.danger {
    border-color: var(--danger);
}

.notification.info {
    border-color: var(--accent);
}

.notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.notification-title {
    font-weight: bold;
    color: var(--accent);
}

.notification-close {
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.notification-close:hover {
    color: white;
}

.notification-body {
    font-size: 0.9rem;
    line-height: 1.4;
}

.notification-actions {
    margin-top: 0.5rem;
    display: flex;
    gap: 0.5rem;
}

.notification-btn {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 5px;
    color: white;
    cursor: pointer;
    padding: 0.3rem 0.8rem;
    font-size: 0.8rem;
    transition: all 0.2s ease;
}

.notification-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-1px);
}

.notification-btn.primary {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border-color: var(--accent);
}

/* ========================
   CONNECTION INDICATORS
   ======================== */

.connection-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 0.5rem;
}

.connected {
    background: #00ff88;
    animation: pulse 2s infinite;
}

.disconnected {
    background: #ff6b6b;
}

.pending {
    background: #f1c40f;
    animation: blink 1s infinite;
}

.loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255,255,255,.3);
    border-radius: 50%;
    border-top-color: var(--accent);
    animation: spin 1s ease-in-out infinite;
}

/* ========================
   REAL-TIME STATUS
   ======================== */

.realtime-status {
    background: rgba(0, 122, 255, 0.1);
    border: 1px solid rgba(0, 122, 255, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 2rem;
    text-align: center;
}

.connection-details {
    margin: 1rem 0;
}

.detail-item {
    display: flex;
    justify-content: space-between;
    padding: 0.25rem 0;
    font-size: 0.8rem;
}

.detail-item span:first-child {
    color: #aaa;
}

.detail-item span:last-child {
    color: var(--accent);
    font-weight: bold;
}

.my-active-games {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 2rem;
    border: 1px solid var(--glass-border);
}

.my-active-game {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 5px;
    padding: 0.5rem;
    margin: 0.5rem 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.3s ease;
}

.my-active-game:hover {
    border-color: var(--accent);
    transform: translateX(3px);
}

.game-quick-info {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
}

.game-type-icon {
    font-size: 1.2rem;
}

.game-stake-amount {
    color: var(--accent);
    font-weight: bold;
    font-size: 0.8rem;
}

.game-status-indicator {
    padding: 0.2rem 0.5rem;
    border-radius: 10px;
    font-size: 0.7rem;
    font-weight: bold;
}

.status-waiting {
    background: rgba(255, 193, 7, 0.3);
    color: #f1c40f;
}

.status-playing {
    background: rgba(46, 204, 113, 0.3);
    color: #2ecc71;
}

.status-your-turn {
    background: rgba(255, 107, 107, 0.3);
    color: #ff6b6b;
    animation: pulse 2s infinite;
}

/* ========================
   ENHANCED FILTERS
   ======================== */

.game-filters {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 1rem;
    border: 1px solid var(--glass-border);
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    align-items: end;
}

.filter-group {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    min-width: 120px;
}

.filter-group label {
    font-size: 0.8rem;
    color: var(--accent);
    font-weight: bold;
}

.filter-select {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 5px;
    padding: 0.5rem;
    color: white;
    font-size: 0.9rem;
    transition: all 0.3s ease;
}

.filter-select:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 5px rgba(78, 205, 196, 0.3);
}

.lobby-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.auto-refresh-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 40px;
    height: 20px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #666;
    transition: 0.3s;
    border-radius: 20px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: var(--accent);
}

input:checked + .slider:before {
    transform: translateX(20px);
}

/* ========================
   HEADER STYLES (ENHANCED)
   ======================== */

.header {
    position: relative;
    z-index: 100;
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    padding: 1rem;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    border-bottom: 1px solid var(--glass-border);
    backdrop-filter: blur(10px);
    min-height: 80px;
}

.logo {
    display: flex;
    align-items: center;
    gap: 10px;
}

.logo h1 {
    font-size: 1.8rem;
    background: linear-gradient(to right, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.logo-icon {
    font-size: 2.5rem;
    color: var(--secondary);
}

.nav-menu {
    display: flex;
    gap: 2rem;
    align-items: center;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.nav-menu::-webkit-scrollbar {
    display: none;
}

.nav-item {
    padding: 0.5rem 1rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid transparent;
    white-space: nowrap;
    flex-shrink: 0;
    position: relative;
}

.nav-item:hover {
    background: var(--glass);
    border-color: rgba(78, 205, 196, 0.5);
    transform: translateY(-2px);
}

.nav-item.active {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    color: white;
}

.nav-item.active::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid var(--accent);
}

.nav-item.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}

.nav-item.game-minimized {
    opacity: 0.8;
    cursor: pointer;
    pointer-events: auto;
    border: 1px dashed rgba(78, 205, 196, 0.5);
}

.live-badge {
    background: linear-gradient(45deg, #00ff88, #00cc6a);
    color: #000;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-weight: bold;
    font-size: 0.8rem;
    animation: pulse 2s infinite;
    position: relative;
}

.live-badge::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 8px;
    transform: translateY(-50%);
    width: 8px;
    height: 8px;
    background: #ff0000;
    border-radius: 50%;
    animation: blink 1s infinite;
}

.wallet-section {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.wallet-info {
    text-align: right;
}

.connection-status {
    font-size: 0.9rem;
    color: #ff6b6b;
}

.balance {
    font-size: 1.2rem;
    font-weight: bold;
}

.connect-btn, .disconnect-btn {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 25px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.connect-btn::before, .disconnect-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s;
}

.connect-btn:hover::before, .disconnect-btn:hover::before {
    left: 100%;
}

.disconnect-btn {
    background: linear-gradient(45deg, #ff6b6b, #ee5a52);
    margin-left: 0.5rem;
}

.connect-btn:hover, .disconnect-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
}

/* ========================
   MAIN LAYOUT (ENHANCED)
   ======================== */

.main-container {
    display: flex;
    min-height: calc(100vh - 80px);
    overflow: hidden;
}

.sidebar {
    width: 350px;
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
    border-right: 1px solid var(--glass-border);
    padding: 2rem;
    overflow-y: auto;
    overflow-x: hidden;
    max-height: calc(100vh - 80px);
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.5) transparent;
}

.sidebar::-webkit-scrollbar {
    width: 8px;
}

.sidebar::-webkit-scrollbar-track {
    background: var(--glass);
    border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.5);
    border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.8);
}

.content-area {
    flex: 1;
    padding: 2rem;
    overflow-y: auto;
    overflow-x: hidden;
    max-height: calc(100vh - 80px);
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.5) transparent;
}

.content-area::-webkit-scrollbar {
    width: 8px;
}

.content-area::-webkit-scrollbar-track {
    background: var(--glass);
    border-radius: 4px;
}

.content-area::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.5);
    border-radius: 4px;
}

.content-area::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.8);
}

.section-content {
    animation: fadeIn 0.5s ease-out;
}

/* ========================
   ENHANCED MODALS
   ======================== */

.age-verification {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.verification-content, .modal-content {
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    border: 2px solid var(--accent);
    border-radius: 20px;
    padding: 3rem;
    max-width: 500px;
    width: 90%;
    text-align: center;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
    animation: fadeIn 0.5s ease-out;
    position: relative;
}

.verification-content h1 {
    color: var(--warning);
    margin-bottom: 1.5rem;
    font-size: 2rem;
}

.warning {
    background: rgba(241, 196, 15, 0.1);
    border: 1px solid rgba(241, 196, 15, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin: 1.5rem 0;
}

.verification-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 2rem;
}

.verify-btn {
    padding: 1rem 2rem;
    border: none;
    border-radius: 10px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    position: relative;
    overflow: hidden;
}

.verify-btn.accept {
    background: linear-gradient(45deg, var(--success), #27ae60);
    color: white;
}

.verify-btn.decline {
    background: linear-gradient(45deg, var(--danger), #c0392b);
    color: white;
}

.verify-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    backdrop-filter: blur(5px);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--glass-border);
}

.modal-header h3 {
    color: var(--accent);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.close-modal {
    background: none;
    border: none;
    color: #aaa;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.close-modal:hover {
    background: rgba(255, 255, 255, 0.1);
    color: white;
}

/* Transaction Confirmation Modal */
.tx-details {
    background: var(--glass);
    border-radius: 10px;
    padding: 1.5rem;
    margin: 1rem 0;
    border: 1px solid var(--glass-border);
}

.tx-detail-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.tx-detail-item:last-child {
    border-bottom: none;
    font-weight: bold;
    color: var(--accent);
}

.tx-label {
    color: #aaa;
}

.tx-value {
    color: white;
    font-weight: bold;
}

.tx-confirmation-buttons, .join-confirmation-buttons, .invitation-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 1.5rem;
}

/* Enhanced Transaction Status */
.transaction-status {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
    border: 1px solid var(--accent);
    border-radius: 10px;
    padding: 1rem;
    min-width: 300px;
    max-width: 400px;
    z-index: 1001;
    transform: translateX(120%);
    transition: transform 0.3s ease;
}

.transaction-status.show {
    transform: translateX(0);
}

.tx-hash {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--accent);
    margin-top: 0.5rem;
    word-break: break-all;
}

.tx-progress {
    margin-top: 0.5rem;
    width: 100%;
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
}

.tx-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), #00ff88);
    border-radius: 2px;
    transition: width 0.3s ease;
    width: 0%;
}

/* ========================
   CONTINUE WITH REMAINING STYLES...
   ======================== */

/* All other existing CSS styles remain the same... */
/* Include all the original styles for: */
/* - Lobby & Game Components */
/* - Buttons & Interactive Elements */
/* - Game Display & Filtering */
/* - Footer Styles */
/* - Responsive Design */
/* - Utility Classes */

/* [Previous CSS continues here - keeping all original styles] */
</style>
<script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   ENHANCED CORE JAVASCRIPT - REAL BLOCKCHAIN INTEGRATION
   =========================== */

// ===========================
// CONSTANTS & CONFIGURATION
// ===========================

const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = "0x45c"; // Core Blockchain Chain ID
const CORE_RPC_URL = "https://rpc.coredao.org";

// Real-time server configuration (replace with your actual WebSocket server)
const REALTIME_SERVER_URL = "wss://your-websocket-server.com"; // Replace with actual server
const BACKUP_SERVER_URL = "https://api.jsonbin.io/v3/b/686ea4c0c264cf03d2e83902";

// Smart Contract ABI (Enhanced for real transactions)
const GAME_CONTRACT_ABI = [
    "function createGame(string memory gameType, uint256 timeLimit) external payable returns (uint256)",
    "function joinGame(uint256 gameId) external payable",
    "function submitMove(uint256 gameId, bytes memory moveData) external",
    "function finalizeGame(uint256 gameId, address winner) external",
    "function claimWinnings(uint256 gameId) external",
    "function refundStake(uint256 gameId) external",
    "function createTournament(string memory name, uint256 entryFee, uint256 maxPlayers) external payable returns (uint256)",
    "function joinTournament(uint256 tournamentId) external payable",
    "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint256 status, string memory gameType)",
    "function getTotalGames() external view returns (uint256)",
    "function getPlayerGames(address player) external view returns (uint256[] memory)",
    "function getGameMoves(uint256 gameId) external view returns (bytes[] memory)",
    "function owner() external view returns (address)",
    "function paused() external view returns (bool)",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint256 stake, string gameType)",
    "event GameJoined(uint256 indexed gameId, address indexed player)",
    "event GameFinalized(uint256 indexed gameId, address indexed winner, uint256 payout)",
    "event MoveSubmitted(uint256 indexed gameId, address indexed player, bytes moveData)",
    "event TournamentCreated(uint256 indexed tournamentId, address indexed creator, uint256 entryFee)",
    "event TournamentJoined(uint256 indexed tournamentId, address indexed player)"
];

// ===========================
// GLOBAL STATE VARIABLES (ENHANCED)
// ===========================

let web3Provider = null;
let userAccount = null;
let gameContract = null;
let currentBalance = 0;
let activeGames = [];
let globalGamesList = [];
let myCreatedGames = [];
let myJoinedGames = [];
let selectedGameType = null;
let gameUpdateInterval = null;
let multiplayerSession = null;
let gameRoomConnections = new Map();
let pendingMatches = new Map();
let webSocket = null;
let isConnectedToRealtime = false;
let pendingTransactions = new Map();
let gameInvitations = new Map();

// Real-time sync variables
let lastSyncTimestamp = 0;
let syncInterval = null;
let serverRetryCount = 0;
let maxRetries = 5;
let retryDelay = 2000;
let autoRefreshEnabled = true;

// Player stats and game state
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    winRate: 0,
    currentStreak: 0,
    bestStreak: 0
};

let playerSkillRatings = {
    chess: 456,
    checkers: 234,
    words: 89
};

// Current settings
let currentGameFilters = {
    gameType: 'all',
    stakeRange: 'all',
    skillLevel: 'all'
};

// Platform settings with secure defaults
let platformSettings = {
    autoJoin: false,
    sound: true,
    animations: true,
    defaultStake: 0.1,
    gameInvites: true,
    txNotifications: true,
    chatNotifications: false,
    autoLock: true,
    sessionTimeout: 30,
    hideBalance: false,
    gasPriority: 'standard',
    rpcEndpoint: CORE_RPC_URL,
    serverValidation: true,
    antiBot: true,
    realtimeEnabled: true
};

// Current section tracking
let currentSection = 'lobby';

// Game state tracking
let isGameActive = false;
let activeGameType = null;
let gameIsMinimized = false;

// ===========================
// ERROR HANDLING & LOGGING (ENHANCED)
// ===========================

class GameError extends Error {
    constructor(message, code = 'GAME_ERROR', details = {}) {
        super(message);
        this.name = 'GameError';
        this.code = code;
        this.details = details;
        this.timestamp = new Date().toISOString();
    }
}

class BlockchainError extends Error {
    constructor(message, code = 'BLOCKCHAIN_ERROR', txHash = null) {
        super(message);
        this.name = 'BlockchainError';
        this.code = code;
        this.txHash = txHash;
        this.timestamp = new Date().toISOString();
    }
}

function logError(error, context = '') {
    console.error(`[CrossRealm Error] ${context}:`, error);
    
    // Send to analytics in production
    if (platformSettings.developerMode) {
        console.trace();
    }
    
    // Store error for user support
    try {
        const errorLog = {
            message: error.message,
            code: error.code || 'UNKNOWN',
            context,
            timestamp: new Date().toISOString(),
            userAccount: userAccount || 'anonymous'
        };
        
        const existingLogs = JSON.parse(localStorage.getItem('crossrealm_error_logs') || '[]');
        existingLogs.push(errorLog);
        
        // Keep only last 50 errors
        if (existingLogs.length > 50) {
            existingLogs.splice(0, existingLogs.length - 50);
        }
        
        localStorage.setItem('crossrealm_error_logs', JSON.stringify(existingLogs));
    } catch (storageError) {
        console.warn('Failed to store error log:', storageError);
    }
}

function handleAsyncError(promise, context = '') {
    return promise.catch(error => {
        logError(error, context);
        throw error;
    });
}

// ===========================
// REAL-TIME WEBSOCKET CONNECTION (NEW)
// ===========================

function initializeRealTimeConnection() {
    try {
        console.log('üîÑ Initializing real-time connection...');
        
        if (!platformSettings.realtimeEnabled) {
            console.log('‚ö†Ô∏è Real-time disabled in settings');
            updateRealtimeStatus('disabled', 'Real-time disabled');
            return;
        }
        
        // Try WebSocket connection first, fallback to polling
        try {
            webSocket = new WebSocket(REALTIME_SERVER_URL);
            setupWebSocketHandlers();
        } catch (wsError) {
            console.warn('WebSocket not available, using fallback sync');
            setupFallbackSync();
        }
        
    } catch (error) {
        logError(error, 'Real-time connection initialization');
        setupFallbackSync();
    }
}

function setupWebSocketHandlers() {
    if (!webSocket) return;
    
    webSocket.onopen = () => {
        console.log('‚úÖ WebSocket connected');
        isConnectedToRealtime = true;
        updateRealtimeStatus('connected', 'Connected to real-time server');
        
        // Send authentication
        if (userAccount) {
            webSocket.send(JSON.stringify({
                type: 'authenticate',
                address: userAccount,
                timestamp: Date.now()
            }));
        }
        
        // Request initial data
        webSocket.send(JSON.stringify({
            type: 'requestGamesList',
            timestamp: Date.now()
        }));
    };
    
    webSocket.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            handleRealtimeMessage(data);
        } catch (error) {
            logError(error, 'WebSocket message parsing');
        }
    };
    
    webSocket.onclose = () => {
        console.log('‚ùå WebSocket disconnected');
        isConnectedToRealtime = false;
        updateRealtimeStatus('disconnected', 'Disconnected from server');
        
        // Attempt reconnection
        if (platformSettings.realtimeEnabled) {
            setTimeout(() => {
                if (serverRetryCount < maxRetries) {
                    serverRetryCount++;
                    console.log(`üîÑ Attempting reconnection (${serverRetryCount}/${maxRetries})`);
                    initializeRealTimeConnection();
                }
            }, retryDelay * serverRetryCount);
        }
    };
    
    webSocket.onerror = (error) => {
        logError(error, 'WebSocket error');
        updateRealtimeStatus('error', 'Connection error');
    };
}

function handleRealtimeMessage(data) {
    try {
        switch (data.type) {
            case 'gamesList':
                globalGamesList = data.games || [];
                updateGamesDisplay();
                updateLiveStats();
                break;
                
            case 'gameCreated':
                if (data.game) {
                    globalGamesList.push(data.game);
                    updateGamesDisplay();
                    showRealtimeNotification('success', 'New Game Available!', 
                        `${data.game.type} game with ${data.game.stake} CORE stake`);
                }
                break;
                
            case 'gameJoined':
                handleGameJoinedNotification(data);
                break;
                
            case 'gameMove':
                handleGameMoveUpdate(data);
                break;
                
            case 'gameFinished':
                handleGameFinishedUpdate(data);
                break;
                
            case 'invitation':
                handleGameInvitation(data);
                break;
                
            case 'playerStatus':
                updatePlayerOnlineStatus(data);
                break;
                
            default:
                console.log('Unknown message type:', data.type);
        }
    } catch (error) {
        logError(error, 'Real-time message handling');
    }
}

function setupFallbackSync() {
    console.log('üîÑ Setting up fallback polling sync');
    updateRealtimeStatus('polling', 'Using fallback sync');
    
    if (syncInterval) clearInterval(syncInterval);
    
    syncInterval = setInterval(async () => {
        if (autoRefreshEnabled) {
            try {
                await syncGamesList();
            } catch (error) {
                logError(error, 'Fallback sync');
            }
        }
    }, 5000);
}

function updateRealtimeStatus(status, message) {
    const statusElement = document.getElementById('realtimeConnectionStatus');
    if (statusElement) {
        let indicatorClass = 'pending';
        
        switch(status) {
            case 'connected':
                indicatorClass = 'connected';
                break;
            case 'disconnected':
            case 'error':
                indicatorClass = 'disconnected';
                break;
            case 'polling':
                indicatorClass = 'pending';
                message += ' (Polling mode)';
                break;
            case 'disabled':
                indicatorClass = 'disconnected';
                break;
        }
        
        statusElement.innerHTML = `<span class="connection-indicator ${indicatorClass}"></span>${message}`;
    }
}

// ===========================
// ENHANCED BLOCKCHAIN INTEGRATION
// ===========================

async function initializeBlockchain() {
    try {
        updateConnectionProgress(20);
        
        if (typeof window.ethereum === 'undefined') {
            console.log('MetaMask not detected - limited functionality');
            updateConnectionProgress(100);
            updateContractStatus('no-wallet', 'No wallet detected');
            await initializeWithoutWallet();
            return true;
        }

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        updateConnectionProgress(40);

        // Check network
        const network = await web3Provider.getNetwork();
        console.log('Current network:', network);
        
        updateConnectionProgress(60);
        
        if (network.chainId !== parseInt(CORE_CHAIN_ID, 16)) {
            console.log('Network mismatch - requesting switch to Core');
            await switchToCore();
        }
        
        updateConnectionProgress(80);
        
        // Initialize contract (read-only initially)
        gameContract = new ethers.Contract(
            GAME_CONTRACT_ADDRESS, 
            GAME_CONTRACT_ABI, 
            web3Provider
        );
        
        updateConnectionProgress(100);
        updateContractStatus('connected', 'Connected to Core Blockchain');
        
        // Initialize real-time connection
        initializeRealTimeConnection();
        
        return true;
    } catch (error) {
        logError(error, 'Blockchain initialization');
        updateContractStatus('error', 'Connection failed');
        await initializeWithoutWallet();
        return false;
    }
}

async function switchToCore() {
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: CORE_CHAIN_ID }],
        });
    } catch (switchError) {
        // This error code indicates that the chain has not been added to MetaMask
        if (switchError.code === 4902) {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: CORE_CHAIN_ID,
                        chainName: 'Core Blockchain',
                        nativeCurrency: {
                            name: 'CORE',
                            symbol: 'CORE',
                            decimals: 18
                        },
                        rpcUrls: [CORE_RPC_URL],
                        blockExplorerUrls: ['https://scan.coredao.org']
                    }]
                });
            } catch (addError) {
                throw new BlockchainError('Failed to add Core network', 'NETWORK_ADD_FAILED');
            }
        } else {
            throw new BlockchainError('Failed to switch to Core network', 'NETWORK_SWITCH_FAILED');
        }
    }
}

async function initializeWithoutWallet() {
    // Initialize with limited functionality
    console.log('üîÑ Initializing without wallet connection');
    initializeRealTimeConnection();
    await syncGamesList();
}

async function connectWallet() {
    try {
        showTransactionStatus('üîÑ Connecting wallet...', '');
        
        if (typeof window.ethereum === 'undefined') {
            throw new GameError('MetaMask not installed', 'NO_WALLET');
        }

        if (!await initializeBlockchain()) {
            throw new GameError('Failed to initialize blockchain', 'BLOCKCHAIN_INIT_FAILED');
        }

        const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
        });
        
        if (accounts.length === 0) {
            throw new GameError('No accounts found', 'NO_ACCOUNTS');
        }

        userAccount = accounts[0];
        
        // Get signer for contract interactions
        const signer = web3Provider.getSigner();
        if (gameContract) {
            gameContract = gameContract.connect(signer);
        }
        
        // Get balance
        const balance = await web3Provider.getBalance(userAccount);
        currentBalance = parseFloat(ethers.utils.formatEther(balance));
        
        // Update UI
        updateConnectionStatus('connected');
        updateBalanceDisplay();
        updateWalletButtons(true);
        
        showTransactionStatus('‚úÖ Wallet connected successfully!', '');
        
        // Load user data and start updates
        await loadUserData();
        await loadMyGames();
        await refreshLobby();
        startRealTimeUpdates();
        
        // Listen for account changes
        if (window.ethereum.on) {
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
        }
        
        // Authenticate with real-time server
        if (webSocket && webSocket.readyState === WebSocket.OPEN) {
            webSocket.send(JSON.stringify({
                type: 'authenticate',
                address: userAccount,
                timestamp: Date.now()
            }));
        }
        
        // Save connection state
        try {
            sessionStorage.setItem('walletConnected', 'true');
        } catch (e) {
            console.log('Session storage not available');
        }
        
    } catch (error) {
        logError(error, 'Wallet connection');
        showTransactionStatus('‚ùå Failed to connect wallet: ' + error.message, '');
        updateConnectionStatus('disconnected');
        throw error;
    }
}

function disconnectWallet() {
    try {
        userAccount = null;
        currentBalance = 0;
        gameContract = null;
        
        updateConnectionStatus('disconnected');
        updateBalanceDisplay();
        updateWalletButtons(false);
        
        // Clear intervals
        if (gameUpdateInterval) {
            clearInterval(gameUpdateInterval);
            gameUpdateInterval = null;
        }
        
        if (syncInterval) {
            clearInterval(syncInterval);
            syncInterval = null;
        }
        
        // Disconnect from real-time server
        if (webSocket) {
            webSocket.close();
            webSocket = null;
        }
        
        // Clear session
        try {
            sessionStorage.removeItem('walletConnected');
        } catch (e) {
            console.log('Session storage not available');
        }
        
        showTransactionStatus('üëã Wallet disconnected', '');
    } catch (error) {
        logError(error, 'Wallet disconnection');
    }
}

// ===========================
// REAL BLOCKCHAIN GAME CREATION
// ===========================

async function createRealBlockchainGame(gameType, stakeAmount, timeLimit = 1800) {
    if (!userAccount || !gameContract) {
        throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
    }
    
    if (currentBalance < stakeAmount) {
        throw new GameError('Insufficient CORE balance', 'INSUFFICIENT_BALANCE');
    }
    
    try {
        showTransactionStatus('üîÑ Creating blockchain transaction...', '');
        
        // Show transaction confirmation modal
        const confirmed = await showTransactionConfirmation({
            action: `Create ${gameType} game`,
            amount: `${stakeAmount} CORE`,
            gasFee: '0.002 CORE', // Estimated
            total: `${(stakeAmount + 0.002).toFixed(4)} CORE`
        });
        
        if (!confirmed) {
            throw new GameError('Transaction cancelled by user', 'USER_CANCELLED');
        }
        
        showTransactionStatus('üîÑ Submitting transaction to Core blockchain...', '');
        
        // Create the actual blockchain transaction
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        const tx = await gameContract.createGame(gameType, timeLimit, {
            value: stakeWei,
            gasLimit: 200000 // Adjust based on contract requirements
        });
        
        showTransactionStatus('‚è≥ Transaction submitted! Waiting for confirmation...', tx.hash);
        
        // Store pending transaction
        pendingTransactions.set(tx.hash, {
            type: 'createGame',
            gameType,
            stakeAmount,
            timestamp: Date.now()
        });
        
        // Wait for transaction confirmation
        const receipt = await tx.wait();
        
        if (receipt.status === 1) {
            // Parse game creation event
            const gameCreatedEvent = receipt.events?.find(event => event.event === 'GameCreated');
            
            if (gameCreatedEvent) {
                const gameId = gameCreatedEvent.args.gameId.toString();
                const realGame = {
                    id: parseInt(gameId),
                    blockchainId: gameId,
                    type: gameType,
                    creator: userAccount,
                    stake: stakeAmount,
                    status: 'waiting',
                    createdAt: Date.now(),
                    skillLevel: getPlayerSkillLevel(gameType),
                    timeControl: getTimeControlFromLimit(timeLimit),
                    serverValidated: true,
                    isReal: true,
                    txHash: tx.hash,
                    blockNumber: receipt.blockNumber
                };
                
                // Add to local lists
                globalGamesList.push(realGame);
                myCreatedGames.push(realGame);
                
                // Broadcast to real-time server
                if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                    webSocket.send(JSON.stringify({
                        type: 'gameCreated',
                        game: realGame,
                        creator: userAccount
                    }));
                }
                
                // Update balance
                currentBalance -= (stakeAmount + parseFloat(ethers.utils.formatEther(receipt.gasUsed.mul(receipt.effectiveGasPrice))));
                updateBalanceDisplay();
                
                showTransactionStatus('‚úÖ Real blockchain game created successfully!', tx.hash);
                
                // Clean up pending transaction
                pendingTransactions.delete(tx.hash);
                
                return parseInt(gameId);
            } else {
                throw new BlockchainError('Game creation event not found', 'EVENT_NOT_FOUND', tx.hash);
            }
        } else {
            throw new BlockchainError('Transaction failed', 'TX_FAILED', tx.hash);
        }
        
    } catch (error) {
        logError(error, 'Real blockchain game creation');
        
        if (error.code === 4001) {
            throw new GameError('Transaction rejected by user', 'USER_REJECTED');
        } else if (error.code === -32603) {
            throw new BlockchainError('Internal RPC error', 'RPC_ERROR');
        } else {
            throw error;
        }
    }
}

async function joinRealBlockchainGame(gameId, stakeAmount) {
    if (!userAccount || !gameContract) {
        throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
    }
    
    if (currentBalance < stakeAmount) {
        throw new GameError('Insufficient CORE balance', 'INSUFFICIENT_BALANCE');
    }
    
    try {
        // Get game details from blockchain
        const gameDetails = await gameContract.getGame(gameId);
        
        if (gameDetails.status.toString() !== '0') { // 0 = waiting
            throw new GameError('Game is not available for joining', 'GAME_NOT_AVAILABLE');
        }
        
        if (gameDetails.player1.toLowerCase() === userAccount.toLowerCase()) {
            throw new GameError('Cannot join your own game', 'CANNOT_JOIN_OWN_GAME');
        }
        
        const expectedStake = parseFloat(ethers.utils.formatEther(gameDetails.stake));
        if (Math.abs(expectedStake - stakeAmount) > 0.001) {
            throw new GameError('Stake amount mismatch', 'STAKE_MISMATCH');
        }
        
        // Show join confirmation
        const confirmed = await showGameJoinConfirmation({
            gameId,
            gameType: gameDetails.gameType,
            stake: stakeAmount,
            opponent: gameDetails.player1
        });
        
        if (!confirmed) {
            throw new GameError('Join cancelled by user', 'USER_CANCELLED');
        }
        
        showTransactionStatus('üîÑ Joining blockchain game...', '');
        
        // Create join transaction
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        const tx = await gameContract.joinGame(gameId, {
            value: stakeWei,
            gasLimit: 150000
        });
        
        showTransactionStatus('‚è≥ Transaction submitted! Joining game...', tx.hash);
        
        // Wait for confirmation
        const receipt = await tx.wait();
        
        if (receipt.status === 1) {
            // Find the game and update it
            const gameIndex = globalGamesList.findIndex(g => g.blockchainId === gameId.toString());
            if (gameIndex !== -1) {
                globalGamesList[gameIndex].status = 'playing';
                globalGamesList[gameIndex].player2 = userAccount;
                globalGamesList[gameIndex].joinedAt = Date.now();
                
                // Add to my joined games
                myJoinedGames.push(globalGamesList[gameIndex]);
            }
            
            // Notify the game creator via real-time
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                webSocket.send(JSON.stringify({
                    type: 'gameJoined',
                    gameId: gameId.toString(),
                    joiner: userAccount,
                    timestamp: Date.now()
                }));
            }
            
            // Update balance
            currentBalance -= (stakeAmount + parseFloat(ethers.utils.formatEther(receipt.gasUsed.mul(receipt.effectiveGasPrice))));
            updateBalanceDisplay();
            
            showTransactionStatus('‚úÖ Successfully joined blockchain game!', tx.hash);
            
            // Start the actual game
            setTimeout(() => {
                startRealMultiplayerGame(gameId, gameDetails.gameType);
            }, 1000);
            
            return true;
        } else {
            throw new BlockchainError('Join transaction failed', 'JOIN_TX_FAILED', tx.hash);
        }
        
    } catch (error) {
        logError(error, 'Real blockchain game joining');
        throw error;
    }
}

// ===========================
// ENHANCED GAME MANAGEMENT
// ===========================

function getPlayerSkillLevel(gameType) {
    const rating = playerSkillRatings[gameType] || 0;
    
    if (rating < 100) return 'bronze';
    if (rating < 300) return 'silver';
    if (rating < 600) return 'gold';
    return 'diamond';
}

function getTimeControlFromLimit(timeLimit) {
    if (timeLimit <= 300) return 'blitz';
    if (timeLimit <= 900) return 'rapid';
    return 'classical';
}

async function loadMyGames() {
    if (!userAccount || !gameContract) return;
    
    try {
        console.log('üîÑ Loading user games from blockchain...');
        
        // Get games from blockchain
        const gameIds = await gameContract.getPlayerGames(userAccount);
        
        myCreatedGames = [];
        myJoinedGames = [];
        
        for (const gameId of gameIds) {
            try {
                const gameDetails = await gameContract.getGame(gameId);
                const gameData = {
                    id: parseInt(gameId.toString()),
                    blockchainId: gameId.toString(),
                    type: gameDetails.gameType,
                    creator: gameDetails.player1,
                    player2: gameDetails.player2,
                    stake: parseFloat(ethers.utils.formatEther(gameDetails.stake)),
                    status: getGameStatusFromNumber(gameDetails.status),
                    isReal: true
                };
                
                if (gameDetails.player1.toLowerCase() === userAccount.toLowerCase()) {
                    myCreatedGames.push(gameData);
                } else {
                    myJoinedGames.push(gameData);
                }
            } catch (gameError) {
                console.warn(`Failed to load game ${gameId}:`, gameError);
            }
        }
        
        updateMyActiveGamesList();
        console.log(`‚úÖ Loaded ${myCreatedGames.length} created and ${myJoinedGames.length} joined games`);
        
    } catch (error) {
        logError(error, 'Loading user games');
    }
}

function getGameStatusFromNumber(statusNum) {
    const statuses = ['waiting', 'playing', 'finished', 'cancelled'];
    return statuses[statusNum] || 'unknown';
}

function updateMyActiveGamesList() {
    const container = document.getElementById('myActiveGamesList');
    if (!container) return;
    
    const allMyGames = [...myCreatedGames, ...myJoinedGames]
        .filter(game => game.status === 'waiting' || game.status === 'playing')
        .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
    
    if (allMyGames.length === 0) {
        container.innerHTML = '<div class="no-games">No active games</div>';
        return;
    }
    
    let html = '';
    allMyGames.forEach(game => {
        const isMyGame = game.creator.toLowerCase() === userAccount.toLowerCase();
        const statusClass = game.status === 'playing' ? 'status-your-turn' : 'status-waiting';
        
        html += `
            <div class="my-active-game" onclick="focusOnGame('${game.blockchainId}')">
                <div class="game-quick-info">
                    <div class="game-type-icon">${getGameIcon(game.type)}</div>
                    <div class="game-stake-amount">${game.stake} CORE</div>
                </div>
                <div class="game-status-indicator ${statusClass}">
                    ${isMyGame ? (game.status === 'waiting' ? 'Waiting' : 'Your Turn') : 'Joined'}
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

function getGameIcon(gameType) {
    const icons = { chess: '‚ôüÔ∏è', checkers: '‚ö´', words: 'üìù' };
    return icons[gameType] || 'üéÆ';
}

// Continue with remaining functions...
console.log('‚úÖ Core JavaScript - Enhanced Blockchain Integration Loaded');
</script>
<script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   REAL-TIME MULTIPLAYER & WEBSOCKET INTEGRATION (NEW)
   =========================== */

// ===========================
// REAL-TIME NOTIFICATION SYSTEM
// ===========================

function showRealtimeNotification(type, title, message, actions = []) {
    const container = document.getElementById('notificationContainer');
    if (!container) return;
    
    const notificationId = Date.now().toString();
    
    const notification = document.createElement('div');
    notification.className = `notification ${type} bounce-in`;
    notification.id = `notification-${notificationId}`;
    
    let actionsHtml = '';
    if (actions.length > 0) {
        actionsHtml = '<div class="notification-actions">';
        actions.forEach(action => {
            actionsHtml += `<button class="notification-btn ${action.class || ''}" onclick="${action.onclick}">${action.text}</button>`;
        });
        actionsHtml += '</div>';
    }
    
    notification.innerHTML = `
        <div class="notification-header">
            <div class="notification-title">${title}</div>
            <button class="notification-close" onclick="closeNotification('${notificationId}')">√ó</button>
        </div>
        <div class="notification-body">${message}</div>
        ${actionsHtml}
    `;
    
    container.appendChild(notification);
    
    // Auto-remove after 8 seconds unless it has actions
    if (actions.length === 0) {
        setTimeout(() => {
            closeNotification(notificationId);
        }, 8000);
    }
    
    // Play notification sound
    if (platformSettings.sound) {
        playNotificationSound(type);
    }
    
    return notificationId;
}

function closeNotification(notificationId) {
    const notification = document.getElementById(`notification-${notificationId}`);
    if (notification) {
        notification.style.transform = 'translateX(100%)';
        notification.style.opacity = '0';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }
}

function playNotificationSound(type) {
    try {
        // Create audio context for different notification sounds
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Different frequencies for different notification types
        const frequencies = {
            success: 800,
            info: 600,
            warning: 400,
            danger: 300
        };
        
        oscillator.frequency.setValueAtTime(frequencies[type] || 600, audioContext.currentTime);
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
    } catch (error) {
        console.log('Audio notification failed:', error);
    }
}

// ===========================
// REAL-TIME GAME EVENTS HANDLING
// ===========================

function handleGameJoinedNotification(data) {
    try {
        const { gameId, joiner, creator } = data;
        
        // Check if this is our game that someone joined
        const myGame = myCreatedGames.find(g => g.blockchainId === gameId || g.id.toString() === gameId);
        
        if (myGame && userAccount && creator.toLowerCase() === userAccount.toLowerCase()) {
            // Someone joined our game!
            const joinerDisplay = joiner.substring(0, 6) + '...' + joiner.substring(38);
            
            showRealtimeNotification('success', 'Player Joined!', 
                `${joinerDisplay} joined your ${myGame.type} game!`, [
                {
                    text: 'Start Game',
                    class: 'primary',
                    onclick: `startGameFromNotification('${gameId}')`
                },
                {
                    text: 'View Game',
                    onclick: `focusOnGame('${gameId}')`
                }
            ]);
            
            // Update game status
            myGame.status = 'playing';
            myGame.player2 = joiner;
            myGame.joinedAt = Date.now();
            
            // Update the display
            updateMyActiveGamesList();
            updateGamesDisplay();
            
            // Update user status
            updateUserGameStatus('In Game');
        }
        
        // Update the global games list
        const globalGame = globalGamesList.find(g => 
            g.blockchainId === gameId || g.id.toString() === gameId
        );
        
        if (globalGame) {
            globalGame.status = 'playing';
            globalGame.player2 = joiner;
            globalGame.joinedAt = Date.now();
            updateGamesDisplay();
        }
        
    } catch (error) {
        logError(error, 'Game joined notification handling');
    }
}

function handleGameMoveUpdate(data) {
    try {
        const { gameId, player, moveData, gameState } = data;
        
        // Check if this is one of our active games
        const myGame = [...myCreatedGames, ...myJoinedGames].find(g => 
            (g.blockchainId === gameId || g.id.toString() === gameId) && 
            g.status === 'playing'
        );
        
        if (myGame) {
            const isMyTurn = player.toLowerCase() !== userAccount.toLowerCase();
            
            if (isMyTurn) {
                showRealtimeNotification('info', 'Your Turn!', 
                    `Opponent made a move in ${myGame.type} game`, [
                    {
                        text: 'Play Now',
                        class: 'primary',
                        onclick: `resumeGame('${gameId}')`
                    }
                ]);
                
                // Update user status
                updateUserGameStatus('Your Turn');
            }
            
            // Update game state if we have the game window open
            updateActiveGameState(gameId, moveData, gameState);
        }
        
    } catch (error) {
        logError(error, 'Game move update handling');
    }
}

function handleGameFinishedUpdate(data) {
    try {
        const { gameId, winner, payout, gameType } = data;
        
        // Check if this was our game
        const myGame = [...myCreatedGames, ...myJoinedGames].find(g => 
            g.blockchainId === gameId || g.id.toString() === gameId
        );
        
        if (myGame) {
            const isWinner = winner.toLowerCase() === userAccount.toLowerCase();
            
            if (isWinner) {
                showRealtimeNotification('success', 'üéâ You Won!', 
                    `Congratulations! You earned ${payout} CORE from ${gameType}!`, [
                    {
                        text: 'Claim Winnings',
                        class: 'primary',
                        onclick: `claimWinnings('${gameId}')`
                    }
                ]);
                
                // Update balance (will be confirmed when claimed)
                playerStats.gamesWon++;
                playerStats.currentStreak++;
                if (playerStats.currentStreak > playerStats.bestStreak) {
                    playerStats.bestStreak = playerStats.currentStreak;
                }
            } else {
                showRealtimeNotification('info', 'Game Finished', 
                    `Your ${gameType} game has ended. Better luck next time!`);
                
                playerStats.currentStreak = 0;
            }
            
            playerStats.gamesPlayed++;
            updatePlayerStats();
            saveUserData();
            
            // Update game status
            myGame.status = 'finished';
            myGame.winner = winner;
            myGame.payout = payout;
            myGame.finishedAt = Date.now();
            
            updateMyActiveGamesList();
        }
        
        // Remove from global games list
        globalGamesList = globalGamesList.filter(g => 
            g.blockchainId !== gameId && g.id.toString() !== gameId
        );
        updateGamesDisplay();
        
        // Update user status back to available
        updateUserGameStatus('Available');
        
    } catch (error) {
        logError(error, 'Game finished update handling');
    }
}

function handleGameInvitation(data) {
    try {
        const { gameId, inviter, gameType, stake } = data;
        
        // Store invitation
        gameInvitations.set(gameId, data);
        
        const inviterDisplay = inviter.substring(0, 6) + '...' + inviter.substring(38);
        
        showRealtimeNotification('info', 'Game Invitation!', 
            `${inviterDisplay} invited you to play ${gameType} (${stake} CORE)`, [
            {
                text: 'Accept',
                class: 'primary',
                onclick: `acceptGameInvitation('${gameId}')`
            },
            {
                text: 'Decline',
                onclick: `declineGameInvitation('${gameId}')`
            }
        ]);
        
    } catch (error) {
        logError(error, 'Game invitation handling');
    }
}

// ===========================
// ENHANCED GAME ACTIONS
// ===========================

function startGameFromNotification(gameId) {
    try {
        const game = myCreatedGames.find(g => 
            g.blockchainId === gameId || g.id.toString() === gameId
        );
        
        if (game) {
            startRealMultiplayerGame(gameId, game.type);
        }
        
    } catch (error) {
        logError(error, 'Starting game from notification');
    }
}

function focusOnGame(gameId) {
    try {
        // Switch to my games section and highlight the specific game
        showSection('mygames');
        
        setTimeout(() => {
            const gameElement = document.querySelector(`[data-game-id="${gameId}"]`);
            if (gameElement) {
                gameElement.scrollIntoView({ behavior: 'smooth' });
                gameElement.classList.add('highlighted');
                
                setTimeout(() => {
                    gameElement.classList.remove('highlighted');
                }, 3000);
            }
        }, 500);
        
    } catch (error) {
        logError(error, 'Focusing on game');
    }
}

function resumeGame(gameId) {
    try {
        const game = [...myCreatedGames, ...myJoinedGames].find(g => 
            g.blockchainId === gameId || g.id.toString() === gameId
        );
        
        if (game) {
            startRealMultiplayerGame(gameId, game.type);
        }
        
    } catch (error) {
        logError(error, 'Resuming game');
    }
}

async function claimWinnings(gameId) {
    try {
        if (!gameContract || !userAccount) {
            throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
        }
        
        showTransactionStatus('üîÑ Claiming winnings...', '');
        
        const tx = await gameContract.claimWinnings(gameId);
        
        showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
        
        const receipt = await tx.wait();
        
        if (receipt.status === 1) {
            // Calculate claimed amount from events
            const claimEvent = receipt.events?.find(event => event.event === 'WinningsClaimed');
            
            if (claimEvent) {
                const amount = parseFloat(ethers.utils.formatEther(claimEvent.args.amount));
                currentBalance += amount;
                playerStats.totalEarned += amount;
                
                updateBalanceDisplay();
                updatePlayerStats();
                saveUserData();
                
                showTransactionStatus(`‚úÖ Successfully claimed ${amount.toFixed(4)} CORE!`, tx.hash);
            } else {
                showTransactionStatus('‚úÖ Winnings claimed successfully!', tx.hash);
            }
        } else {
            throw new BlockchainError('Claim transaction failed', 'CLAIM_TX_FAILED', tx.hash);
        }
        
    } catch (error) {
        logError(error, 'Claiming winnings');
        showTransactionStatus('‚ùå Failed to claim winnings: ' + error.message, '');
    }
}

function acceptGameInvitation(gameId) {
    try {
        const invitation = gameInvitations.get(gameId);
        if (!invitation) return;
        
        // Show join confirmation modal
        showGameJoinModal(invitation);
        
    } catch (error) {
        logError(error, 'Accepting game invitation');
    }
}

function declineGameInvitation(gameId) {
    try {
        gameInvitations.delete(gameId);
        
        // Notify inviter via WebSocket
        if (webSocket && webSocket.readyState === WebSocket.OPEN) {
            webSocket.send(JSON.stringify({
                type: 'invitationDeclined',
                gameId,
                decliner: userAccount
            }));
        }
        
        showRealtimeNotification('info', 'Invitation Declined', 
            'Game invitation declined');
        
    } catch (error) {
        logError(error, 'Declining game invitation');
    }
}

// ===========================
// REAL MULTIPLAYER GAME START
// ===========================

async function startRealMultiplayerGame(gameId, gameType) {
    try {
        console.log(`üéÆ Starting real multiplayer ${gameType} game: ${gameId}`);
        
        // Get latest game state from blockchain
        const gameDetails = await gameContract.getGame(gameId);
        
        if (gameDetails.status.toString() !== '1') { // 1 = playing
            throw new GameError('Game is not in playing state', 'GAME_NOT_PLAYING');
        }
        
        const isCreator = gameDetails.player1.toLowerCase() === userAccount.toLowerCase();
        const opponent = isCreator ? gameDetails.player2 : gameDetails.player1;
        
        // Open game window
        openGameWindow(gameType);
        
        // Initialize game with real multiplayer
        multiplayerSession = {
            gameId: gameId.toString(),
            gameType,
            isCreator,
            opponent,
            moves: [],
            currentTurn: isCreator ? userAccount : opponent,
            startTime: Date.now()
        };
        
        // Get game history if any
        try {
            const moves = await gameContract.getGameMoves(gameId);
            if (moves.length > 0) {
                multiplayerSession.moves = moves.map(move => JSON.parse(move));
                await restoreGameState(gameType, multiplayerSession.moves);
            }
        } catch (historyError) {
            console.log('No move history found, starting fresh game');
        }
        
        // Initialize the appropriate game
        switch(gameType) {
            case 'chess':
                initializeRealTimeChess(multiplayerSession);
                break;
            case 'checkers':
                initializeRealTimeCheckers(multiplayerSession);
                break;
            case 'words':
                initializeRealTimeWords(multiplayerSession);
                break;
        }
        
        // Update user status
        updateUserGameStatus('In Game');
        
        // Set up real-time game sync
        setupGameSync(gameId);
        
        console.log('‚úÖ Real multiplayer game started successfully');
        
    } catch (error) {
        logError(error, 'Starting real multiplayer game');
        showTransactionStatus('‚ùå Failed to start game: ' + error.message, '');
    }
}

function setupGameSync(gameId) {
    // Listen for real-time updates for this specific game
    if (webSocket && webSocket.readyState === WebSocket.OPEN) {
        webSocket.send(JSON.stringify({
            type: 'joinGameRoom',
            gameId: gameId.toString(),
            player: userAccount
        }));
    }
}

// ===========================
// REAL-TIME MOVE SUBMISSION
// ===========================

async function submitRealTimeMove(gameId, moveData) {
    try {
        if (!gameContract || !userAccount) {
            throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
        }
        
        console.log('üì§ Submitting move to blockchain:', moveData);
        
        // Encode move data
        const encodedMove = ethers.utils.toUtf8Bytes(JSON.stringify(moveData));
        
        // Submit to blockchain
        const tx = await gameContract.submitMove(gameId, encodedMove, {
            gasLimit: 100000
        });
        
        // Don't wait for confirmation, send to real-time immediately
        if (webSocket && webSocket.readyState === WebSocket.OPEN) {
            webSocket.send(JSON.stringify({
                type: 'gameMove',
                gameId: gameId.toString(),
                player: userAccount,
                moveData,
                txHash: tx.hash,
                timestamp: Date.now()
            }));
        }
        
        // Update local game state
        if (multiplayerSession && multiplayerSession.gameId === gameId.toString()) {
            multiplayerSession.moves.push(moveData);
            multiplayerSession.currentTurn = multiplayerSession.opponent;
        }
        
        // Wait for blockchain confirmation in background
        tx.wait().then(receipt => {
            if (receipt.status === 1) {
                console.log('‚úÖ Move confirmed on blockchain');
            } else {
                console.error('‚ùå Move transaction failed');
            }
        }).catch(error => {
            logError(error, 'Move confirmation');
        });
        
        return true;
        
    } catch (error) {
        logError(error, 'Real-time move submission');
        throw error;
    }
}

// ===========================
// GAME STATE MANAGEMENT
// ===========================

function updateActiveGameState(gameId, moveData, gameState) {
    try {
        if (!multiplayerSession || multiplayerSession.gameId !== gameId.toString()) {
            return; // Not our active game
        }
        
        // Apply the move to current game state
        applyMoveToGame(multiplayerSession.gameType, moveData);
        
        // Update turn
        multiplayerSession.currentTurn = multiplayerSession.currentTurn === userAccount ? 
            multiplayerSession.opponent : userAccount;
        
        // Update moves history
        multiplayerSession.moves.push(moveData);
        
        // Update game UI
        updateGameUI(multiplayerSession.gameType, gameState);
        
    } catch (error) {
        logError(error, 'Updating active game state');
    }
}

function applyMoveToGame(gameType, moveData) {
    switch(gameType) {
        case 'chess':
            applyChessMove(moveData);
            break;
        case 'checkers':
            applyCheckersMove(moveData);
            break;
        case 'words':
            applyWordMove(moveData);
            break;
    }
}

async function restoreGameState(gameType, moves) {
    try {
        console.log(`üîÑ Restoring ${gameType} game state from ${moves.length} moves`);
        
        // Reset game to initial state
        switch(gameType) {
            case 'chess':
                initializeChessGame();
                break;
            case 'checkers':
                initializeCheckersGame();
                break;
            case 'words':
                initializeWordGame();
                break;
        }
        
        // Apply each move in sequence
        for (const move of moves) {
            applyMoveToGame(gameType, move);
            // Small delay to show move sequence
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        console.log('‚úÖ Game state restored');
        
    } catch (error) {
        logError(error, 'Restoring game state');
    }
}

// ===========================
// USER STATUS MANAGEMENT
// ===========================

function updateUserGameStatus(status) {
    const statusElement = document.getElementById('userGameStatus');
    if (statusElement) {
        statusElement.textContent = status;
        
        // Update status color
        statusElement.className = '';
        switch(status.toLowerCase()) {
            case 'available':
                statusElement.classList.add('status-available');
                break;
            case 'in game':
                statusElement.classList.add('status-playing');
                break;
            case 'your turn':
                statusElement.classList.add('status-your-turn');
                break;
            default:
                statusElement.classList.add('status-busy');
        }
    }
    
    // Broadcast status to real-time server
    if (webSocket && webSocket.readyState === WebSocket.OPEN && userAccount) {
        webSocket.send(JSON.stringify({
            type: 'statusUpdate',
            player: userAccount,
            status,
            timestamp: Date.now()
        }));
    }
}

function updatePlayerOnlineStatus(data) {
    try {
        const { playersOnline, activeGames } = data;
        
        const playersOnlineEl = document.getElementById('playersOnline');
        const activeGamesEl = document.getElementById('activeGamesCount');
        
        if (playersOnlineEl) playersOnlineEl.textContent = playersOnline || 0;
        if (activeGamesEl) activeGamesEl.textContent = activeGames || 0;
        
    } catch (error) {
        logError(error, 'Updating player online status');
    }
}

// ===========================
// ENHANCED MODAL FUNCTIONS
// ===========================

function showTransactionConfirmation(txDetails) {
    return new Promise((resolve) => {
        const modal = document.getElementById('txConfirmationModal');
        if (!modal) {
            resolve(false);
            return;
        }
        
        // Fill in transaction details
        document.getElementById('txAction').textContent = txDetails.action;
        document.getElementById('txAmount').textContent = txDetails.amount;
        document.getElementById('txGasFee').textContent = txDetails.gasFee;
        document.getElementById('txTotal').textContent = txDetails.total;
        
        modal.classList.remove('hidden');
        
        // Set up confirmation handlers
        window.tempTxResolve = resolve;
    });
}

function confirmTransaction() {
    const modal = document.getElementById('txConfirmationModal');
    if (modal) {
        modal.classList.add('hidden');
    }
    
    if (window.tempTxResolve) {
        window.tempTxResolve(true);
        delete window.tempTxResolve;
    }
}

function cancelTransaction() {
    const modal = document.getElementById('txConfirmationModal');
    if (modal) {
        modal.classList.add('hidden');
    }
    
    if (window.tempTxResolve) {
        window.tempTxResolve(false);
        delete window.tempTxResolve;
    }
}

function showGameJoinConfirmation(gameDetails) {
    return new Promise((resolve) => {
        const modal = document.getElementById('gameJoinModal');
        if (!modal) {
            resolve(false);
            return;
        }
        
        const detailsDiv = document.getElementById('gameJoinDetails');
        if (detailsDiv) {
            const opponentDisplay = gameDetails.opponent.substring(0, 6) + '...' + gameDetails.opponent.substring(38);
            detailsDiv.innerHTML = `
                <div class="join-game-details">
                    <h4>Join ${gameDetails.gameType.toUpperCase()} Game</h4>
                    <div class="detail-item">
                        <span>Game ID:</span>
                        <span>#${gameDetails.gameId}</span>
                    </div>
                    <div class="detail-item">
                        <span>Opponent:</span>
                        <span>${opponentDisplay}</span>
                    </div>
                    <div class="detail-item">
                        <span>Stake:</span>
                        <span>${gameDetails.stake} CORE</span>
                    </div>
                    <div class="detail-item">
                        <span>Total Pot:</span>
                        <span>${(gameDetails.stake * 2).toFixed(4)} CORE</span>
                    </div>
                    <div class="warning-text">
                        <p>‚ö†Ô∏è This will deduct ${gameDetails.stake} CORE from your balance.</p>
                    </div>
                </div>
            `;
        }
        
        modal.classList.remove('hidden');
        
        window.tempJoinResolve = resolve;
    });
}

function confirmJoinGame() {
    const modal = document.getElementById('gameJoinModal');
    if (modal) {
        modal.classList.add('hidden');
    }
    
    if (window.tempJoinResolve) {
        window.tempJoinResolve(true);
        delete window.tempJoinResolve;
    }
}

function closeGameJoinModal() {
    const modal = document.getElementById('gameJoinModal');
    if (modal) {
        modal.classList.add('hidden');
    }
    
    if (window.tempJoinResolve) {
        window.tempJoinResolve(false);
        delete window.tempJoinResolve;
    }
}

// ===========================
// AUTO-REFRESH TOGGLE
// ===========================

function toggleAutoRefresh() {
    const toggle = document.getElementById('autoRefreshToggle');
    if (toggle) {
        autoRefreshEnabled = toggle.checked;
        
        if (autoRefreshEnabled) {
            showRealtimeNotification('success', 'Auto-refresh Enabled', 
                'Games list will update automatically');
        } else {
            showRealtimeNotification('info', 'Auto-refresh Disabled', 
                'You can still refresh manually');
        }
    }
}

// ===========================
// ENHANCED SYNC FUNCTIONS
// ===========================

async function syncGamesList() {
    try {
        if (!autoRefreshEnabled) return;
        
        console.log('üîÑ Syncing games list...');
        
        // If we have WebSocket, don't need to poll
        if (isConnectedToRealtime) {
            return;
        }
        
        // Fallback sync method
        const response = await fetch(BACKUP_SERVER_URL, {
            method: 'GET',
            headers: {
                'X-Master-Key': '$2a$10$GtV1/gAxPuNYbKEoKNghTu9NiX3OyvrEw6ir4vJA2Nu/U7KGAnkC6',
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (data.record && data.record.games) {
                globalGamesList = data.record.games.filter(game => !game.isDemo);
                updateGamesDisplay();
                updateLiveStats();
            }
        }
        
    } catch (error) {
        logError(error, 'Games list sync');
    }
}

// Continue with remaining real-time functions...

console.log('‚úÖ Real-time Multiplayer & WebSocket Integration Loaded');
</script>
<!-- Game Window Components -->
<div class="game-overlay hidden" id="gameOverlay"></div>

<!-- Enhanced Chess Game Window -->
<div class="game-window hidden" id="chessGameWindow">
    <div class="game-window-header">
        <div class="game-window-title">
            ‚ôüÔ∏è Chess Masters 
            <span class="skill-badge skill-gold" id="chessSkillBadge">Gold</span>
            <span class="validation-status validated" title="Blockchain Validated">‚úì</span>
            <span class="realtime-indicator" id="chessRealtimeStatus">üåê Real-time</span>
        </div>
        <div class="game-window-controls">
            <button class="window-btn minimize-btn" onclick="minimizeGame('chess')" title="Minimize">‚àí</button>
            <button class="window-btn close-btn" onclick="closeGame('chess')" title="Close">√ó</button>
        </div>
    </div>
    <div class="game-window-content">
        <div class="game-info-bar">
            <div class="player-info">
                <div class="player-avatar">üë§</div>
                <div class="player-details">
                    <div class="player-name">You (White)</div>
                    <div class="player-rating">Rating: 456</div>
                    <div class="player-status" id="myPlayerStatus">Connected</div>
                </div>
            </div>
            <div class="game-timer">
                <div class="timer white-timer" id="whiteTimer">10:00</div>
                <div class="timer black-timer" id="blackTimer">10:00</div>
            </div>
            <div class="player-info opponent">
                <div class="player-details">
                    <div class="player-name" id="opponentName">Waiting...</div>
                    <div class="player-rating" id="opponentRating">Rating: ?</div>
                    <div class="player-status" id="opponentStatus">Connecting...</div>
                </div>
                <div class="player-avatar">ü§ñ</div>
            </div>
        </div>
        
        <div class="game-status" id="chessStatus">Waiting for opponent...</div>
        <div class="move-counter">Move: <span id="chessMoveCount">1</span></div>
        <div class="chess-board" id="chessBoard"></div>
        
        <div class="game-controls">
            <button class="game-btn" onclick="resignChess()">
                <i class="fas fa-flag"></i> Resign
            </button>
            <button class="game-btn" onclick="drawChess()">
                <i class="fas fa-handshake"></i> Offer Draw
            </button>
            <button class="game-btn" onclick="requestUndo()">
                <i class="fas fa-undo"></i> Request Undo
            </button>
        </div>
        
        <div class="game-chat">
            <h4><i class="fas fa-comments"></i> Game Chat</h4>
            <div class="game-chat-messages" id="chessGameChat">
                <div class="game-chat-message system">
                    <strong>System:</strong> Real-time multiplayer game started!
                </div>
            </div>
            <div class="game-chat-input">
                <input type="text" placeholder="Type a message..." id="chessChatInput" 
                       onkeypress="handleGameChatKeyPress(event, 'chess')" maxlength="100">
                <button onclick="sendGameChatMessage('chess')">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Checkers Game Window -->
<div class="game-window hidden" id="checkersGameWindow">
    <div class="game-window-header">
        <div class="game-window-title">
            ‚ö´ Checkers Pro 
            <span class="skill-badge skill-silver" id="checkersSkillBadge">Silver</span>
            <span class="validation-status validated" title="Blockchain Validated">‚úì</span>
            <span class="realtime-indicator" id="checkersRealtimeStatus">üåê Real-time</span>
        </div>
        <div class="game-window-controls">
            <button class="window-btn minimize-btn" onclick="minimizeGame('checkers')" title="Minimize">‚àí</button>
            <button class="window-btn close-btn" onclick="closeGame('checkers')" title="Close">√ó</button>
        </div>
    </div>
    <div class="game-window-content">
        <div class="game-info-bar">
            <div class="player-info">
                <div class="player-avatar">üî¥</div>
                <div class="player-details">
                    <div class="player-name">You (Red)</div>
                    <div class="player-rating">Rating: 234</div>
                    <div class="player-status">Connected</div>
                </div>
            </div>
            <div class="move-counter">
                <div class="move-count">Move: <span id="moveCount">1</span></div>
                <div class="captured-pieces">
                    <div>Red captured: <span id="redCaptured">0</span></div>
                    <div>Black captured: <span id="blackCaptured">0</span></div>
                </div>
            </div>
            <div class="player-info opponent">
                <div class="player-details">
                    <div class="player-name" id="checkersOpponentName">Waiting...</div>
                    <div class="player-rating" id="checkersOpponentRating">Rating: ?</div>
                    <div class="player-status">Connecting...</div>
                </div>
                <div class="player-avatar">‚ö´</div>
            </div>
        </div>
        
        <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
        <div class="checkers-board" id="checkersBoard"></div>
        
        <div class="game-controls">
            <button class="game-btn" onclick="resignCheckers()">
                <i class="fas fa-flag"></i> Resign
            </button>
            <button class="game-btn" onclick="requestUndo()">
                <i class="fas fa-undo"></i> Request Undo
            </button>
            <button class="game-btn" onclick="showMoveHistory()">
                <i class="fas fa-history"></i> Moves
            </button>
        </div>
        
        <div class="game-chat">
            <h4><i class="fas fa-comments"></i> Game Chat</h4>
            <div class="game-chat-messages" id="checkersGameChat">
                <div class="game-chat-message system">
                    <strong>System:</strong> Real-time checkers game started!
                </div>
            </div>
            <div class="game-chat-input">
                <input type="text" placeholder="Type a message..." id="checkersChatInput" 
                       onkeypress="handleGameChatKeyPress(event, 'checkers')" maxlength="100">
                <button onclick="sendGameChatMessage('checkers')">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Word Game Window -->
<div class="game-window hidden" id="wordGameWindow">
    <div class="game-window-header">
        <div class="game-window-title">
            üìù Word Battle 
            <span class="skill-badge skill-bronze" id="wordSkillBadge">Bronze</span>
            <span class="validation-status validated" title="Blockchain Validated">‚úì</span>
            <span class="realtime-indicator" id="wordRealtimeStatus">üåê Real-time</span>
        </div>
        <div class="game-window-controls">
            <button class="window-btn minimize-btn" onclick="minimizeGame('word')" title="Minimize">‚àí</button>
            <button class="window-btn close-btn" onclick="closeGame('word')" title="Close">√ó</button>
        </div>
    </div>
    <div class="game-window-content">
        <div class="game-info-bar">
            <div class="round-info">
                <div class="round-counter">Round <span id="currentRound">1</span> of 3</div>
                <div class="round-timer">Time: <span id="roundTimer">60</span>s</div>
            </div>
        </div>
        
        <div class="game-status" id="wordStatus">Round 1 of 3 - Your turn!</div>
        
        <div class="word-game">
            <h4 id="wordPrompt" class="word-prompt">Make a word with these letters:</h4>
            <div id="wordLetters" class="word-letters">BLOCKCHAIN</div>
            
            <div class="word-input-container">
                <input type="text" class="word-input" id="wordInput" 
                       placeholder="Enter your word..." maxlength="20" 
                       onkeypress="handleWordInputKeyPress(event)">
                <button class="submit-word-btn" onclick="submitWord()">
                    <i class="fas fa-check"></i> Submit
                </button>
            </div>
            
            <div class="word-validation" id="wordValidation">
                <div class="valid-words">
                    <h5>Valid words found:</h5>
                    <div id="validWordsDisplay"></div>
                </div>
            </div>
            
            <div class="word-score">
                <div class="score-item">
                    <div class="score-label">Your Score</div>
                    <div class="score-value" id="playerScore">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Opponent</div>
                    <div class="score-value" id="opponentScore">0</div>
                </div>
            </div>
        </div>
        
        <div class="game-chat">
            <h4><i class="fas fa-comments"></i> Game Chat</h4>
            <div class="game-chat-messages" id="wordGameChat">
                <div class="game-chat-message system">
                    <strong>System:</strong> Word battle begins!
                </div>
            </div>
            <div class="game-chat-input">
                <input type="text" placeholder="Type a message..." id="wordChatInput" 
                       onkeypress="handleGameChatKeyPress(event, 'word')" maxlength="100">
                <button onclick="sendGameChatMessage('word')">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<script>
/* ===========================
   ENHANCED GAME LOGIC & UI COMPONENTS
   =========================== */

// ===========================
// REAL-TIME CHESS IMPLEMENTATION
// ===========================

function initializeRealTimeChess(session) {
    try {
        const board = document.getElementById('chessBoard');
        if (!board) return;
        
        console.log('üîÑ Initializing real-time chess with session:', session);
        
        board.innerHTML = '';
        
        // Initial chess position
        const initialPosition = [
            ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
            ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
            ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
        ];
        
        chessGameState = {
            board: JSON.parse(JSON.stringify(initialPosition)),
            currentPlayer: 'white',
            selectedSquare: null,
            gameActive: true,
            moveHistory: [],
            lastMove: null,
            isCheck: false,
            isCheckmate: false,
            session: session,
            isMyTurn: session.isCreator // Creator plays white and goes first
        };
        
        // Update opponent info
        updateOpponentInfo('chess', session.opponent);
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                square.dataset.row = row;
                square.dataset.col = col;
                square.textContent = initialPosition[row][col];
                square.onclick = () => handleRealTimeChessClick(row, col);
                
                square.onmouseenter = () => {
                    if (chessGameState.gameActive && chessGameState.isMyTurn) {
                        square.style.boxShadow = 'inset 0 0 10px rgba(78, 205, 196, 0.3)';
                    }
                };
                square.onmouseleave = () => {
                    if (!square.classList.contains('selected')) {
                        square.style.boxShadow = '';
                    }
                };
                
                board.appendChild(square);
            }
        }
        
        updateChessStatus();
        updateGameTurnIndicator('chess');
        
        // Add real-time chat message
        addGameChatMessage('chess', 'System', `Connected to ${session.opponent.substring(0, 6)}...`);
        
        console.log('‚úÖ Real-time chess initialized');
    } catch (error) {
        logError(error, 'Real-time chess initialization');
    }
}

function handleRealTimeChessClick(row, col) {
    if (!chessGameState.gameActive || !chessGameState.isMyTurn) {
        showRealtimeNotification('warning', 'Not Your Turn', 'Please wait for your opponent to move');
        return;
    }
    
    try {
        const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (!square) return;
        
        const piece = chessGameState.board[row][col];
        
        // Clear previous selections and highlights
        document.querySelectorAll('.chess-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
            s.style.boxShadow = '';
        });
        
        if (chessGameState.selectedSquare) {
            const selectedRow = chessGameState.selectedSquare.row;
            const selectedCol = chessGameState.selectedSquare.col;
            const selectedPiece = chessGameState.board[selectedRow][selectedCol];
            
            // Check if this is a valid move
            if (isValidChessMove(selectedRow, selectedCol, row, col)) {
                makeRealTimeChessMove(selectedRow, selectedCol, row, col, selectedPiece);
            }
            
            chessGameState.selectedSquare = null;
        } else if (piece && isPieceOwnedByCurrentPlayer(piece, chessGameState.currentPlayer)) {
            // Select piece if it belongs to current player
            square.classList.add('selected');
            chessGameState.selectedSquare = { row, col };
            showPossibleChessMoves(row, col);
            
            addGameChatMessage('chess', 'You', `Selected ${piece} at ${String.fromCharCode(97 + col)}${8 - row}`);
        }
    } catch (error) {
        logError(error, 'Real-time chess click');
    }
}

async function makeRealTimeChessMove(fromRow, fromCol, toRow, toCol, piece) {
    try {
        // Check for capture
        const capturedPiece = chessGameState.board[toRow][toCol];
        
        // Create move data
        const moveData = {
            from: [fromRow, fromCol],
            to: [toRow, toCol],
            piece: piece,
            captured: capturedPiece,
            timestamp: Date.now(),
            player: userAccount
        };
        
        // Make the move locally first for immediate feedback
        chessGameState.board[toRow][toCol] = piece;
        chessGameState.board[fromRow][fromCol] = '';
        
        // Update display
        const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
        const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
        
        if (fromSquare) fromSquare.textContent = '';
        if (toSquare) toSquare.textContent = piece;
        
        // Animate the move
        if (fromSquare && toSquare) {
            animatePieceMove(fromSquare, toSquare, piece);
        }
        
        // Record move
        const moveNotation = generateMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece);
        chessGameState.moveHistory.push(moveNotation);
        chessGameState.lastMove = moveData;
        
        // Highlight last move
        document.querySelectorAll('.chess-square').forEach(s => s.classList.remove('last-move'));
        if (fromSquare) fromSquare.classList.add('last-move');
        if (toSquare) toSquare.classList.add('last-move');
        
        // Switch players and turn
        chessGameState.currentPlayer = chessGameState.currentPlayer === 'white' ? 'black' : 'white';
        chessGameState.isMyTurn = false; // Wait for opponent's move
        
        // Update move counter
        const moveCountEl = document.getElementById('chessMoveCount');
        if (moveCountEl) {
            moveCountEl.textContent = Math.ceil(chessGameState.moveHistory.length / 2);
        }
        
        addGameChatMessage('chess', 'You', `Moved: ${moveNotation}`);
        updateChessStatus();
        updateGameTurnIndicator('chess');
        
        // Submit move to blockchain and real-time server
        if (chessGameState.session) {
            await submitRealTimeMove(chessGameState.session.gameId, moveData);
        }
        
        // Check for game end conditions
        checkChessGameEnd();
        
    } catch (error) {
        logError(error, 'Making real-time chess move');
        
        // Revert the move on error
        chessGameState.board[fromRow][fromCol] = piece;
        chessGameState.board[toRow][toCol] = capturedPiece;
        
        // Update display
        const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
        const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
        
        if (fromSquare) fromSquare.textContent = piece;
        if (toSquare) toSquare.textContent = capturedPiece;
        
        showRealtimeNotification('danger', 'Move Failed', 'Failed to submit move. Please try again.');
    }
}

function applyChessMove(moveData) {
    try {
        const { from, to, piece, captured } = moveData;
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        
        // Apply move to board state
        chessGameState.board[toRow][toCol] = piece;
        chessGameState.board[fromRow][fromCol] = '';
        
        // Update display
        const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
        const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
        
        if (fromSquare) fromSquare.textContent = '';
        if (toSquare) toSquare.textContent = piece;
        
        // Add to move history
        const moveNotation = generateMoveNotation(fromRow, fromCol, toRow, toCol, piece, captured);
        chessGameState.moveHistory.push(moveNotation);
        
        // Switch turn back to us
        chessGameState.isMyTurn = true;
        chessGameState.currentPlayer = chessGameState.currentPlayer === 'white' ? 'black' : 'white';
        
        updateChessStatus();
        updateGameTurnIndicator('chess');
        
        addGameChatMessage('chess', 'Opponent', `Moved: ${moveNotation}`);
        
        // Update move counter
        const moveCountEl = document.getElementById('chessMoveCount');
        if (moveCountEl) {
            moveCountEl.textContent = Math.ceil(chessGameState.moveHistory.length / 2);
        }
        
    } catch (error) {
        logError(error, 'Applying chess move');
    }
}

// ===========================
// REAL-TIME CHECKERS IMPLEMENTATION
// ===========================

function initializeRealTimeCheckers(session) {
    try {
        const board = document.getElementById('checkersBoard');
        if (!board) return;
        
        console.log('üîÑ Initializing real-time checkers with session:', session);
        
        board.innerHTML = '';
        
        // Initialize checkers board state
        checkersGameState = {
            board: Array(8).fill().map(() => Array(8).fill(null)),
            currentPlayer: 'red',
            selectedSquare: null,
            gameActive: true,
            moveHistory: [],
            mandatoryJumps: [],
            capturedPieces: { red: 0, black: 0 },
            moveCount: 1,
            session: session,
            isMyTurn: session.isCreator // Creator plays red and goes first
        };
        
        // Update opponent info
        updateOpponentInfo('checkers', session.opponent);
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                square.dataset.row = row;
                square.dataset.col = col;
                
                // Add checker pieces on dark squares only
                if ((row + col) % 2 === 1) {
                    if (row < 3) {
                        // Red pieces (top)
                        const piece = createCheckerPiece('red', row, col);
                        square.appendChild(piece);
                        checkersGameState.board[row][col] = 'red';
                    } else if (row > 4) {
                        // Black pieces (bottom)
                        const piece = createCheckerPiece('black', row, col);
                        square.appendChild(piece);
                        checkersGameState.board[row][col] = 'black';
                    }
                }
                
                square.onclick = () => handleRealTimeCheckersClick(row, col);
                board.appendChild(square);
            }
        }
        
        updateCheckersStatus();
        updateGameTurnIndicator('checkers');
        
        // Add real-time chat message
        addGameChatMessage('checkers', 'System', `Connected to ${session.opponent.substring(0, 6)}...`);
        
        console.log('‚úÖ Real-time checkers initialized');
    } catch (error) {
        logError(error, 'Real-time checkers initialization');
    }
}

function handleRealTimeCheckersClick(row, col) {
    if (!checkersGameState.gameActive || !checkersGameState.isMyTurn) {
        showRealtimeNotification('warning', 'Not Your Turn', 'Please wait for your opponent to move');
        return;
    }
    
    try {
        if (checkersGameState.selectedSquare) {
            const selectedRow = checkersGameState.selectedSquare.row;
            const selectedCol = checkersGameState.selectedSquare.col;
            
            if (isValidCheckersMove(selectedRow, selectedCol, row, col)) {
                makeRealTimeCheckersMove(selectedRow, selectedCol, row, col);
            }
            
            // Clear selection
            document.querySelectorAll('.checker-piece').forEach(p => p.classList.remove('selected'));
            checkersGameState.selectedSquare = null;
        }
    } catch (error) {
        logError(error, 'Real-time checkers click');
    }
}

async function makeRealTimeCheckersMove(fromRow, fromCol, toRow, toCol) {
    try {
        const piece = checkersGameState.board[fromRow][fromCol];
        
        // Create move data
        const moveData = {
            from: [fromRow, fromCol],
            to: [toRow, toCol],
            piece: piece,
            timestamp: Date.now(),
            player: userAccount
        };
        
        // Make the move locally
        checkersGameState.board[toRow][toCol] = piece;
        checkersGameState.board[fromRow][fromCol] = null;
        
        // Update display
        const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
        const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
        
        if (fromSquare && toSquare) {
            const pieceElement = fromSquare.querySelector('.checker-piece');
            if (pieceElement) {
                fromSquare.removeChild(pieceElement);
                const newPiece = createCheckerPiece(piece, toRow, toCol);
                toSquare.appendChild(newPiece);
                newPiece.classList.remove('selected');
            }
        }
        
        // Check for king promotion
        if ((piece === 'red' && toRow === 7) || (piece === 'black' && toRow === 0)) {
            const pieceElement = toSquare.querySelector('.checker-piece');
            if (pieceElement) {
                pieceElement.classList.add('king');
                addGameChatMessage('checkers', 'You', `${piece} piece crowned as king!`);
            }
        }
        
        // Record move
        const moveNotation = `(${fromRow},${fromCol}) ‚Üí (${toRow},${toCol})`;
        checkersGameState.moveHistory.push(moveNotation);
        
        // Switch players
        checkersGameState.currentPlayer = checkersGameState.currentPlayer === 'red' ? 'black' : 'red';
        checkersGameState.isMyTurn = false;
        checkersGameState.moveCount++;
        
        updateMoveCounter(checkersGameState.moveCount);
        addGameChatMessage('checkers', 'You', `${piece} moved ${moveNotation}`);
        updateCheckersStatus();
        updateGameTurnIndicator('checkers');
        
        // Submit move to blockchain and real-time server
        if (checkersGameState.session) {
            await submitRealTimeMove(checkersGameState.session.gameId, moveData);
        }
        
        // Check for game end
        checkCheckersGameEnd();
        
    } catch (error) {
        logError(error, 'Making real-time checkers move');
        showRealtimeNotification('danger', 'Move Failed', 'Failed to submit move. Please try again.');
    }
}

function applyCheckersMove(moveData) {
    try {
        const { from, to, piece } = moveData;
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        
        // Apply move to board state
        checkersGameState.board[toRow][toCol] = piece;
        checkersGameState.board[fromRow][fromCol] = null;
        
        // Update display
        const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
        const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
        
        if (fromSquare && toSquare) {
            const pieceElement = fromSquare.querySelector('.checker-piece');
            if (pieceElement) {
                fromSquare.removeChild(pieceElement);
                const newPiece = createCheckerPiece(piece, toRow, toCol);
                toSquare.appendChild(newPiece);
            }
        }
        
        // Switch turn back to us
        checkersGameState.isMyTurn = true;
        checkersGameState.currentPlayer = checkersGameState.currentPlayer === 'red' ? 'black' : 'red';
        checkersGameState.moveCount++;
        
        updateCheckersStatus();
        updateGameTurnIndicator('checkers');
        updateMoveCounter(checkersGameState.moveCount);
        
        const moveNotation = `(${fromRow},${fromCol}) ‚Üí (${toRow},${toCol})`;
        addGameChatMessage('checkers', 'Opponent', `${piece} moved ${moveNotation}`);
        
    } catch (error) {
        logError(error, 'Applying checkers move');
    }
}

// ===========================
// REAL-TIME WORDS IMPLEMENTATION
// ===========================

function initializeRealTimeWords(session) {
    try {
        console.log('üîÑ Initializing real-time word game with session:', session);
        
        wordGameState = {
            currentRound: 1,
            totalRounds: 3,
            timeLeft: 60,
            availableLetters: 'BLOCKCHAIN',
            validWords: [],
            playerScore: 0,
            opponentScore: 0,
            gameActive: true,
            timer: null,
            session: session,
            isMyTurn: session.isCreator // Creator goes first
        };
        
        // Update opponent info (words game doesn't have traditional opponent display)
        updateWordGameUI();
        startWordGameTimer();
        updateGameTurnIndicator('word');
        
        // Add real-time chat message
        addGameChatMessage('word', 'System', `Connected to ${session.opponent.substring(0, 6)}...`);
        
        console.log('‚úÖ Real-time word game initialized');
    } catch (error) {
        logError(error, 'Real-time word game initialization');
    }
}

async function submitRealTimeWord() {
    try {
        const input = document.getElementById('wordInput');
        if (!input || !input.value || !wordGameState.isMyTurn) return;
        
        const word = input.value.trim().toUpperCase();
        if (!word) return;
        
        // Validate word
        if (isValidWord(word)) {
            const score = calculateWordScore(word);
            wordGameState.playerScore += score;
            wordGameState.validWords.push(word);
            
            // Create move data
            const moveData = {
                word: word,
                score: score,
                round: wordGameState.currentRound,
                timestamp: Date.now(),
                player: userAccount
            };
            
            addValidWord(word, score);
            updateWordScores(wordGameState.playerScore, wordGameState.opponentScore);
            
            showRealtimeNotification('success', 'Word Accepted!', `You scored ${score} points for "${word}"`);
            addGameChatMessage('word', 'You', `Played: ${word} (${score} pts)`);
            
            // Switch turn
            wordGameState.isMyTurn = false;
            updateGameTurnIndicator('word');
            
            // Submit to blockchain and real-time server
            if (wordGameState.session) {
                await submitRealTimeMove(wordGameState.session.gameId, moveData);
            }
        } else {
            showRealtimeNotification('warning', 'Invalid Word', `"${word}" is not valid!`);
        }
        
        input.value = '';
    } catch (error) {
        logError(error, 'Real-time word submission');
    }
}

function applyWordMove(moveData) {
    try {
        const { word, score } = moveData;
        
        // Apply opponent's word
        wordGameState.opponentScore += score;
        updateWordScores(wordGameState.playerScore, wordGameState.opponentScore);
        
        // Switch turn back to us
        wordGameState.isMyTurn = true;
        updateGameTurnIndicator('word');
        
        addGameChatMessage('word', 'Opponent', `Played: ${word} (${score} pts)`);
        
    } catch (error) {
        logError(error, 'Applying word move');
    }
}

// ===========================
// ENHANCED UI FUNCTIONS
// ===========================

function updateOpponentInfo(gameType, opponentAddress) {
    const shortAddress = opponentAddress.substring(0, 6) + '...' + opponentAddress.substring(38);
    
    switch(gameType) {
        case 'chess':
            const opponentNameEl = document.getElementById('opponentName');
            const opponentRatingEl = document.getElementById('opponentRating');
            const opponentStatusEl = document.getElementById('opponentStatus');
            
            if (opponentNameEl) opponentNameEl.textContent = shortAddress;
            if (opponentRatingEl) opponentRatingEl.textContent = 'Rating: ???';
            if (opponentStatusEl) opponentStatusEl.textContent = 'Connected';
            break;
            
        case 'checkers':
            const checkersOpponentNameEl = document.getElementById('checkersOpponentName');
            const checkersOpponentRatingEl = document.getElementById('checkersOpponentRating');
            
            if (checkersOpponentNameEl) checkersOpponentNameEl.textContent = shortAddress;
            if (checkersOpponentRatingEl) checkersOpponentRatingEl.textContent = 'Rating: ???';
            break;
    }
}

function updateGameTurnIndicator(gameType) {
    let gameState;
    switch(gameType) {
        case 'chess':
            gameState = chessGameState;
            break;
        case 'checkers':
            gameState = checkersGameState;
            break;
        case 'words':
            gameState = wordGameState;
            break;
        default:
            return;
    }
    
    const statusEl = document.getElementById(gameType + 'Status');
    const realtimeEl = document.getElementById(gameType + 'RealtimeStatus');
    
    if (statusEl) {
        if (gameState.isMyTurn) {
            statusEl.textContent = 'Your turn - Make your move!';
            statusEl.className = 'game-status your-turn';
        } else {
            statusEl.textContent = 'Opponent\'s turn - Please wait...';
            statusEl.className = 'game-status waiting';
        }
    }
    
    if (realtimeEl) {
        if (isConnectedToRealtime) {
            realtimeEl.innerHTML = 'üåê Real-time';
            realtimeEl.className = 'realtime-indicator connected';
        } else {
            realtimeEl.innerHTML = '‚ö†Ô∏è Offline';
            realtimeEl.className = 'realtime-indicator disconnected';
        }
    }
}

function updateGameUI(gameType, gameState) {
    updateGameTurnIndicator(gameType);
    
    // Update any additional UI elements based on game state
    switch(gameType) {
        case 'chess':
            updateChessStatus();
            break;
        case 'checkers':
            updateCheckersStatus();
            break;
        case 'words':
            updateWordGameUI();
            break;
    }
}

// ===========================
// ENHANCED GAME ACTIONS
// ===========================

async function resignChess() {
    try {
        if (!confirm('Are you sure you want to resign? This will forfeit the game and your stake.')) {
            return;
        }
        
        chessGameState.gameActive = false;
        
        if (chessGameState.session && gameContract) {
            // Submit resignation to blockchain
            const resignData = {
                type: 'resignation',
                player: userAccount,
                timestamp: Date.now()
            };
            
            await submitRealTimeMove(chessGameState.session.gameId, resignData);
        }
        
        showRealtimeNotification('info', 'Game Resigned', 'You have resigned the game');
        addGameChatMessage('chess', 'System', 'Game ended by resignation');
        
        setTimeout(() => closeGame('chess'), 2000);
    } catch (error) {
        logError(error, 'Chess resignation');
    }
}

async function resignCheckers() {
    try {
        if (!confirm('Are you sure you want to resign? This will forfeit the game and your stake.')) {
            return;
        }
        
        checkersGameState.gameActive = false;
        
        if (checkersGameState.session && gameContract) {
            const resignData = {
                type: 'resignation',
                player: userAccount,
                timestamp: Date.now()
            };
            
            await submitRealTimeMove(checkersGameState.session.gameId, resignData);
        }
        
        showRealtimeNotification('info', 'Game Resigned', 'You have resigned the game');
        addGameChatMessage('checkers', 'System', 'Game ended by resignation');
        
        setTimeout(() => closeGame('checkers'), 2000);
    } catch (error) {
        logError(error, 'Checkers resignation');
    }
}

// ===========================
// ENHANCED CHAT FUNCTIONS
// ===========================

function handleGameChatKeyPress(event, gameType) {
    if (event.key === 'Enter') {
        sendGameChatMessage(gameType);
    }
}

function sendGameChatMessage(gameType) {
    try {
        const input = document.getElementById(gameType + 'ChatInput');
        if (!input || !input.value.trim()) return;
        
        const message = input.value.trim();
        addGameChatMessage(gameType, 'You', message);
        
        // Send to opponent via real-time if connected
        if (webSocket && webSocket.readyState === WebSocket.OPEN) {
            webSocket.send(JSON.stringify({
                type: 'gameChat',
                gameId: multiplayerSession?.gameId,
                gameType,
                player: userAccount,
                message,
                timestamp: Date.now()
            }));
        }
        
        input.value = '';
    } catch (error) {
        logError(error, 'Sending game chat message');
    }
}

function addGameChatMessage(gameType, sender, message) {
    try {
        const chatContainer = document.getElementById(gameType + 'GameChat');
        if (chatContainer) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'game-chat-message slide-in';
            
            if (sender === 'System') {
                messageDiv.classList.add('system');
            }
            
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Keep only last 20 messages
            while (chatContainer.children.length > 20) {
                chatContainer.removeChild(chatContainer.firstChild);
            }
        }
    } catch (error) {
        logError(error, 'Adding game chat message');
    }
}

// ===========================
// GAME WINDOW MANAGEMENT (ENHANCED)
// ===========================

function openGameWindow(gameType) {
    try {
        console.log('Opening enhanced game window for:', gameType);
        
        setGameActive(gameType, true);
        gameIsMinimized = false;
        
        // Hide other game windows
        document.querySelectorAll('.game-window').forEach(w => w.classList.add('hidden'));
        const overlay = document.getElementById('gameOverlay');
        if (overlay) {
            overlay.classList.remove('hidden', 'minimized');
        }
        
        const windowId = gameType + 'GameWindow';
        const gameWindow = document.getElementById(windowId);
        if (gameWindow) {
            gameWindow.classList.remove('hidden', 'minimized');
            
            // Initialize the appropriate game with a small delay
            setTimeout(() => {
                if (multiplayerSession) {
                    switch(gameType) {
                        case 'chess':
                            initializeRealTimeChess(multiplayerSession);
                            break;
                        case 'checkers':
                            initializeRealTimeCheckers(multiplayerSession);
                            break;
                        case 'word':
                            initializeRealTimeWords(multiplayerSession);
                            break;
                    }
                } else {
                    // Fallback to regular initialization
                    switch(gameType) {
                        case 'chess':
                            initializeChessGame();
                            break;
                        case 'checkers':
                            initializeCheckersGame();
                            break;
                        case 'word':
                            initializeWordGame();
                            break;
                    }
                }
            }, 100);
        }
    } catch (error) {
        logError(error, 'Opening enhanced game window');
    }
}

// Original game logic functions remain the same but enhanced...
// (Including all the chess, checkers, word game logic from the original code)

console.log('‚úÖ Enhanced Game Logic & UI Components Loaded');
</script>

<!-- Enhanced CSS for game components -->
<style>
/* ===========================
   ENHANCED GAME COMPONENT STYLES
   =========================== */

.realtime-indicator {
    padding: 0.2rem 0.5rem;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: bold;
    margin-left: 0.5rem;
}

.realtime-indicator.connected {
    background: rgba(0, 255, 136, 0.3);
    color: #00ff88;
}

.realtime-indicator.disconnected {
    background: rgba(255, 193, 7, 0.3);
    color: #f1c40f;
}

.game-status.your-turn {
    background: rgba(0, 255, 136, 0.1);
    border-color: rgba(0, 255, 136, 0.3);
    color: #00ff88;
    animation: pulse 2s infinite;
}

.game-status.waiting {
    background: rgba(255, 193, 7, 0.1);
    border-color: rgba(255, 193, 7, 0.3);
    color: #f1c40f;
}

.player-status {
    font-size: 0.8rem;
    margin-top: 0.2rem;
}

.status-available {
    color: #00ff88;
}

.status-playing {
    color: #f39c12;
}

.status-your-turn {
    color: #ff6b6b;
    animation: blink 1s infinite;
}

.status-busy {
    color: #666;
}

.highlighted {
    background: rgba(78, 205, 196, 0.2) !important;
    border: 2px solid var(--accent) !important;
    animation: glow 1s ease-in-out 3;
}

.join-game-details {
    background: var(--glass);
    border-radius: 10px;
    padding: 1.5rem;
    border: 1px solid var(--glass-border);
}

.warning-text {
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    border-radius: 5px;
    padding: 0.5rem;
    margin-top: 1rem;
    font-size: 0.9rem;
}

/* Enhanced chess board */
.chess-square.your-turn:hover {
    box-shadow: inset 0 0 15px rgba(78, 205, 196, 0.5) !important;
}

.chess-square.disabled {
    cursor: not-allowed;
    opacity: 0.6;
}

/* Enhanced checkers board */
.checker-piece.your-turn {
    box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
}

.checker-piece.disabled {
    cursor: not-allowed;
    opacity: 0.6;
}

/* Word game enhancements */
.word-input:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
}

.submit-word-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
}

/* Real-time status indicators */
.connection-indicator-banner.realtime {
    background: rgba(0, 255, 136, 0.1);
    border-color: rgba(0, 255, 136, 0.3);
    color: #00ff88;
}

.connection-indicator-banner.realtime::before {
    content: 'üåê ';
}

/* Enhanced responsiveness */
@media (max-width: 768px) {
    .realtime-indicator {
        display: none;
    }
    
    .game-window {
        min-width: 95vw;
        max-width: 95vw;
    }
    
    .game-info-bar {
        flex-direction: column;
        gap: 1rem;
    }
    
    .join-game-details {
        padding: 1rem;
    }
}

/* All original CSS styles from the platform remain the same... */
</style>
<script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   COMPLETE UI MANAGEMENT & FINAL INTEGRATION
   =========================== */

// ===========================
// ENHANCED NAVIGATION & SECTION MANAGEMENT
// ===========================

function showSection(section) {
    try {
        // Check if navigation is allowed
        if (isGameActive && !gameIsMinimized && section !== currentSection) {
            showRealtimeNotification('warning', 'Game Active', 'Please finish or minimize your current game before navigating');
            return;
        }
        
        // Hide all sections
        document.querySelectorAll('[id$="Section"]').forEach(el => {
            if (el && el.id !== section + 'Section') {
                el.classList.add('hidden');
            }
        });
        
        // Show target section
        const targetSection = document.getElementById(section + 'Section');
        if (targetSection) {
            targetSection.classList.remove('hidden');
            
            // Load section content dynamically
            loadSectionContent(section);
        }
        
        // Update navigation
        document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
        
        // Find and activate the clicked nav item
        const clickedItem = Array.from(document.querySelectorAll('.nav-item')).find(item => 
            item.textContent.toLowerCase().includes(section.toLowerCase())
        );
        if (clickedItem) {
            clickedItem.classList.add('active');
        }
        
        currentSection = section;
        
        // Section-specific initialization
        switch(section) {
            case 'lobby':
                refreshLobby();
                break;
            case 'profile':
                updatePlayerStats();
                loadGameHistory();
                break;
            case 'settings':
                loadSettingsUI();
                break;
            case 'mygames':
                loadMyGamesSection();
                break;
            case 'tournaments':
                loadTournamentsSection();
                break;
            case 'create':
                loadCreateGameSection();
                break;
        }
        
    } catch (error) {
        logError(error, 'Section navigation');
    }
}

function loadSectionContent(section) {
    try {
        const targetSection = document.getElementById(section + 'Section');
        if (!targetSection) return;
        
        // Only load content if section is empty
        if (targetSection.innerHTML.trim() === '') {
            targetSection.innerHTML = getSectionHTML(section);
        }
    } catch (error) {
        logError(error, 'Loading section content');
    }
}

function getSectionHTML(section) {
    switch(section) {
        case 'create':
            return getCreateGameHTML();
        case 'mygames':
            return getMyGamesHTML();
        case 'tournaments':
            return getTournamentsHTML();
        case 'profile':
            return getProfileHTML();
        case 'settings':
            return getSettingsHTML();
        default:
            return '';
    }
}

// ===========================
// ENHANCED SECTION HTML GENERATORS
// ===========================

function getCreateGameHTML() {
    return `
        <div class="create-game-section">
            <h2>üéÆ Create Real Blockchain Game</h2>
            <div class="info-banner">
                <p><strong>üî• Create real games with CORE tokens!</strong></p>
                <p>Your stake will be locked in the smart contract until the game ends.</p>
            </div>
            
            <div class="game-type-selector">
                <div class="game-type-card" data-type="chess" onclick="selectGameType('chess')">
                    <div class="game-icon">‚ôüÔ∏è</div>
                    <h3>Chess Masters</h3>
                    <p>Strategic blockchain chess with real stakes</p>
                    <small>5-30 minutes per game</small>
                    <div class="game-features">
                        <span class="feature-tag">Real-time</span>
                        <span class="feature-tag">Blockchain</span>
                    </div>
                </div>
                <div class="game-type-card" data-type="checkers" onclick="selectGameType('checkers')">
                    <div class="game-icon">‚ö´</div>
                    <h3>Checkers Pro</h3>
                    <p>Fast-paced checkers with instant payouts</p>
                    <small>3-15 minutes per game</small>
                    <div class="game-features">
                        <span class="feature-tag">Quick</span>
                        <span class="feature-tag">Skill-based</span>
                    </div>
                </div>
                <div class="game-type-card" data-type="words" onclick="selectGameType('words')">
                    <div class="game-icon">üìù</div>
                    <h3>Word Battle</h3>
                    <p>Vocabulary competition with crypto stakes</p>
                    <small>1-3 minutes per round</small>
                    <div class="game-features">
                        <span class="feature-tag">Brain Game</span>
                        <span class="feature-tag">Multi-round</span>
                    </div>
                </div>
            </div>
            
            <div class="stake-settings">
                <div class="stake-input-group">
                    <label for="gameStake">üí∞ Stake Amount (CORE)</label>
                    <input type="number" class="stake-input" id="gameStake" 
                           placeholder="Enter stake amount (min 0.01 CORE)" 
                           min="0.01" step="0.01" value="0.1"
                           oninput="updateCreateButton()">
                    <div class="stake-info">
                        <div class="info-item">
                            <span>Winner takes:</span>
                            <span class="highlight" id="winnerAmount">0.194 CORE</span>
                        </div>
                        <div class="info-item">
                            <span>Platform fee (3%):</span>
                            <span id="platformFee">0.006 CORE</span>
                        </div>
                        <div class="info-item">
                            <span>Total pot:</span>
                            <span id="totalPot">0.2 CORE</span>
                        </div>
                    </div>
                </div>
                
                <div class="quick-stake-buttons">
                    <button class="quick-stake-btn" onclick="setQuickStake(0.01)">0.01</button>
                    <button class="quick-stake-btn" onclick="setQuickStake(0.05)">0.05</button>
                    <button class="quick-stake-btn" onclick="setQuickStake(0.1)">0.1</button>
                    <button class="quick-stake-btn" onclick="setQuickStake(0.5)">0.5</button>
                    <button class="quick-stake-btn" onclick="setQuickStake(1.0)">1.0</button>
                </div>
            </div>

            <div class="advanced-settings">
                <h4>‚öôÔ∏è Game Settings</h4>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label>Time Control</label>
                        <select id="timeControl" class="setting-select">
                            <option value="180">Blitz (3+0)</option>
                            <option value="300">Blitz (5+3)</option>
                            <option value="600" selected>Rapid (10+5)</option>
                            <option value="1800">Classical (30+0)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Skill Matching</label>
                        <select id="skillMatching" class="setting-select">
                            <option value="any">Any Skill Level</option>
                            <option value="similar" selected>Similar (¬±100)</option>
                            <option value="exact">Exact (¬±50)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Game Privacy</label>
                        <select id="gamePrivacy" class="setting-select">
                            <option value="public" selected>Public Game</option>
                            <option value="private">Private (Invite Only)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <button class="create-btn" id="createGameBtn" onclick="createRealGame()" disabled>
                <i class="fas fa-plus"></i> Select Game Type & Enter Stake
            </button>
            
            <div class="balance-check">
                <p>Your balance: <span id="createBalance">0.00 CORE</span></p>
                <p class="small-text">Make sure you have enough CORE to cover the stake + gas fees</p>
            </div>
        </div>
    `;
}

function getMyGamesHTML() {
    return `
        <div class="my-games-section">
            <h2>üé≤ My Games</h2>
            
            <div class="games-tabs">
                <button class="tab-btn active" onclick="switchMyGamesTab('active')" id="activeTab">
                    üéÆ Active Games
                </button>
                <button class="tab-btn" onclick="switchMyGamesTab('created')" id="createdTab">
                    ‚ûï Created Games
                </button>
                <button class="tab-btn" onclick="switchMyGamesTab('joined')" id="joinedTab">
                    ü§ù Joined Games
                </button>
                <button class="tab-btn" onclick="switchMyGamesTab('history')" id="historyTab">
                    üìú Game History
                </button>
            </div>
            
            <div class="tab-content">
                <div id="activeGamesTab" class="tab-pane active">
                    <div class="games-grid" id="activeGamesList">
                        <div class="no-games">No active games</div>
                    </div>
                </div>
                
                <div id="createdGamesTab" class="tab-pane hidden">
                    <div class="games-grid" id="createdGamesList">
                        <div class="no-games">No created games</div>
                    </div>
                </div>
                
                <div id="joinedGamesTab" class="tab-pane hidden">
                    <div class="games-grid" id="joinedGamesList">
                        <div class="no-games">No joined games</div>
                    </div>
                </div>
                
                <div id="historyTab" class="tab-pane hidden">
                    <div class="history-filters">
                        <select id="historyFilter" class="filter-select" onchange="filterGameHistory()">
                            <option value="all">All Games</option>
                            <option value="won">Won Games</option>
                            <option value="lost">Lost Games</option>
                            <option value="chess">Chess Only</option>
                            <option value="checkers">Checkers Only</option>
                            <option value="words">Word Games Only</option>
                        </select>
                    </div>
                    <div class="games-history" id="gamesHistoryList">
                        <div class="no-games">No game history</div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function getTournamentsHTML() {
    return `
        <div class="tournament-section">
            <h2>üèÜ Live Tournaments</h2>
            
            <div class="tournament-stats">
                <div class="stat-card">
                    <div class="stat-value">3</div>
                    <div class="stat-label">Active Tournaments</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">127</div>
                    <div class="stat-label">Total Players</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">95</div>
                    <div class="stat-label">CORE Prize Pool</div>
                </div>
            </div>
            
            <div class="tournament-cards">
                <div class="tournament-card">
                    <div class="tournament-header">
                        <div class="tournament-title">üèÜ Weekly Chess Championship</div>
                        <div class="tournament-prize">üí∞ 50 CORE Prize Pool</div>
                    </div>
                    
                    <div class="tournament-info">
                        <div class="tournament-detail">
                            <div class="detail-label">Players</div>
                            <div class="detail-value" style="color: #4ecdc4; font-weight: bold;">16/32</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Entry Fee</div>
                            <div class="detail-value" style="color: #f39c12; font-weight: bold;">2.0 CORE</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Format</div>
                            <div class="detail-value">Single Elimination</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Starts In</div>
                            <div class="detail-value" id="tournament1Timer">2h 15m</div>
                        </div>
                    </div>
                    
                    <button class="join-btn" onclick="joinTournament('chess_weekly')">
                        <i class="fas fa-trophy"></i> Join Tournament (2.0 CORE)
                    </button>
                </div>
                
                <div class="tournament-card">
                    <div class="tournament-header">
                        <div class="tournament-title">‚ö° Speed Checkers Blitz</div>
                        <div class="tournament-prize">üí∞ 25 CORE Prize Pool</div>
                    </div>
                    
                    <div class="tournament-info">
                        <div class="tournament-detail">
                            <div class="detail-label">Players</div>
                            <div class="detail-value" style="color: #4ecdc4; font-weight: bold;">8/16</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Entry Fee</div>
                            <div class="detail-value" style="color: #f39c12; font-weight: bold;">1.0 CORE</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Format</div>
                            <div class="detail-value">Swiss System</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Time Control</div>
                            <div class="detail-value">3+2 mins</div>
                        </div>
                    </div>
                    
                    <button class="join-btn" onclick="joinTournament('checkers_blitz')">
                        <i class="fas fa-bolt"></i> Join Blitz (1.0 CORE)
                    </button>
                </div>

                <div class="tournament-card">
                    <div class="tournament-header">
                        <div class="tournament-title">üìù Word Masters Cup</div>
                        <div class="tournament-prize">üí∞ 15 CORE Prize Pool</div>
                    </div>
                    
                    <div class="tournament-info">
                        <div class="tournament-detail">
                            <div class="detail-label">Players</div>
                            <div class="detail-value" style="color: #4ecdc4; font-weight: bold;">12/24</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Entry Fee</div>
                            <div class="detail-value" style="color: #f39c12; font-weight: bold;">0.5 CORE</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Rounds</div>
                            <div class="detail-value">5 Rounds</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Starts In</div>
                            <div class="detail-value" id="tournament3Timer">45m</div>
                        </div>
                    </div>
                    
                    <button class="join-btn" onclick="joinTournament('word_masters')">
                        <i class="fas fa-pen"></i> Join Tournament (0.5 CORE)
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getProfileHTML() {
    return `
        <div class="profile-section">
            <div class="profile-header">
                <div class="profile-avatar">
                    <i class="fas fa-user-circle"></i>
                </div>
                <div class="profile-info">
                    <h2>Player Profile</h2>
                    <p class="wallet-address" id="profileWalletAddress">Connect wallet to view profile</p>
                    <div class="profile-status">
                        <span class="status-indicator" id="profileStatus">Available</span>
                    </div>
                </div>
            </div>

            <div class="profile-stats">
                <h3>üìä Player Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="profileGamesPlayed">0</div>
                        <div class="stat-label">Games Played</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileGamesWon">0</div>
                        <div class="stat-label">Games Won</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileTotalEarned">0.0000</div>
                        <div class="stat-label">CORE Earned</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileWinRate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileCurrentStreak">0</div>
                        <div class="stat-label">Current Streak</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileBestStreak">0</div>
                        <div class="stat-label">Best Streak</div>
                    </div>
                </div>
            </div>
            
            <div class="skill-ratings">
                <h3>üéØ Skill Ratings</h3>
                <div class="ratings-grid">
                    <div class="rating-card">
                        <div class="rating-icon">‚ôüÔ∏è</div>
                        <div class="rating-info">
                            <div class="rating-level gold">Gold</div>
                            <div class="rating-points">Chess: <span id="chessRating">456</span></div>
                        </div>
                        <div class="rating-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 60%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="rating-card">
                        <div class="rating-icon">‚ö´</div>
                        <div class="rating-info">
                            <div class="rating-level silver">Silver</div>
                            <div class="rating-points">Checkers: <span id="checkersRating">234</span></div>
                        </div>
                        <div class="rating-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 40%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="rating-card">
                        <div class="rating-icon">üìù</div>
                        <div class="rating-info">
                            <div class="rating-level bronze">Bronze</div>
                            <div class="rating-points">Words: <span id="wordsRating">89</span></div>
                        </div>
                        <div class="rating-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 20%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="achievements">
                <h3>üèÜ Achievements</h3>
                <div class="achievements-grid">
                    <div class="achievement-card earned">
                        <div class="achievement-icon">ü•á</div>
                        <div class="achievement-info">
                            <div class="achievement-name">First Victory</div>
                            <div class="achievement-desc">Win your first game</div>
                        </div>
                    </div>
                    <div class="achievement-card earned">
                        <div class="achievement-icon">üíé</div>
                        <div class="achievement-info">
                            <div class="achievement-name">High Roller</div>
                            <div class="achievement-desc">Stake 10+ CORE in a game</div>
                        </div>
                    </div>
                    <div class="achievement-card locked">
                        <div class="achievement-icon">üèÜ</div>
                        <div class="achievement-info">
                            <div class="achievement-name">Tournament Winner</div>
                            <div class="achievement-desc">Win a tournament</div>
                        </div>
                    </div>
                    <div class="achievement-card locked">
                        <div class="achievement-icon">üî•</div>
                        <div class="achievement-info">
                            <div class="achievement-name">Hot Streak</div>
                            <div class="achievement-desc">Win 10 games in a row</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function getSettingsHTML() {
    return `
        <div class="settings-section">
            <h2>‚öôÔ∏è Platform Settings</h2>
            
            <div class="settings-groups">
                <div class="settings-group">
                    <h3>üéÆ Game Settings</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Real-time Multiplayer</h4>
                                <p>Enable real-time game synchronization</p>
                            </div>
                            <div class="settings-toggle active" id="realtimeEnabledToggle" onclick="toggleSetting('realtimeEnabled')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Auto-join Games</h4>
                                <p>Automatically join games when available</p>
                            </div>
                            <div class="settings-toggle" id="autoJoinToggle" onclick="toggleSetting('autoJoin')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Sound Effects</h4>
                                <p>Enable game sound effects and notifications</p>
                            </div>
                            <div class="settings-toggle active" id="soundToggle" onclick="toggleSetting('sound')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Show Animations</h4>
                                <p>Enable board animations and effects</p>
                            </div>
                            <div class="settings-toggle active" id="animationsToggle" onclick="toggleSetting('animations')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Default Stake Amount</h4>
                                <p>Set your preferred stake amount</p>
                            </div>
                            <input type="number" class="settings-input" id="defaultStake" placeholder="0.01" min="0.01" step="0.01" value="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>üîî Notifications</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Game Invitations</h4>
                                <p>Notify when invited to games</p>
                            </div>
                            <div class="settings-toggle active" id="gameInvitesToggle" onclick="toggleSetting('gameInvites')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Transaction Updates</h4>
                                <p>Notify on blockchain transactions</p>
                            </div>
                            <div class="settings-toggle active" id="txNotificationsToggle" onclick="toggleSetting('txNotifications')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Game Opponent Moves</h4>
                                <p>Notify when opponent makes a move</p>
                            </div>
                            <div class="settings-toggle active" id="moveNotificationsToggle" onclick="toggleSetting('moveNotifications')"></div>
                        </div>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>üîí Security & Privacy</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Auto-lock Wallet</h4>
                                <p>Automatically disconnect after inactivity</p>
                            </div>
                            <div class="settings-toggle active" id="autoLockToggle" onclick="toggleSetting('autoLock')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Session Timeout (minutes)</h4>
                                <p>Auto-disconnect time</p>
                            </div>
                            <input type="number" class="settings-input" id="sessionTimeout" placeholder="30" min="5" max="120" value="30">
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Hide Balance</h4>
                                <p>Hide wallet balance from display</p>
                            </div>
                            <div class="settings-toggle" id="hideBalanceToggle" onclick="toggleSetting('hideBalance')"></div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>‚ö° Advanced</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Gas Price Priority</h4>
                                <p>Transaction speed preference</p>
                            </div>
                            <select class="settings-input" id="gasPriority">
                                <option value="slow">Slow (Low Fee)</option>
                                <option value="standard" selected>Standard</option>
                                <option value="fast">Fast (High Fee)</option>
                            </select>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Server-Side Validation</h4>
                                <p>Enable move validation on server</p>
                            </div>
                            <div class="settings-toggle active" id="serverValidationToggle" onclick="toggleSetting('serverValidation')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Anti-Bot Challenges</h4>
                                <p>Show verification challenges before games</p>
                            </div>
                            <div class="settings-toggle active" id="antiBotToggle" onclick="toggleSetting('antiBot')"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="settings-actions">
                <button class="settings-button" onclick="saveSettings()">
                    <i class="fas fa-save"></i> Save Settings
                </button>
                <button class="settings-button" onclick="resetSettings()">
                    <i class="fas fa-undo"></i> Reset to Default
                </button>
                <button class="settings-button" onclick="exportSettings()">
                    <i class="fas fa-download"></i> Export Settings
                </button>
                <button class="settings-button danger-button" onclick="clearAllData()">
                    <i class="fas fa-trash"></i> Clear All Data
                </button>
            </div>
        </div>
    `;
}

// ===========================
// ENHANCED GAME CREATION FUNCTIONS
// ===========================

function selectGameType(type) {
    try {
        selectedGameType = type;
        
        // Update UI
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        const selectedCard = document.querySelector(`[data-type="${type}"]`);
        if (selectedCard) {
            selectedCard.classList.add('selected');
        }
        
        updateCreateButton();
        updateStakeCalculations();
    } catch (error) {
        logError(error, 'Game type selection');
    }
}

function setQuickStake(amount) {
    try {
        const stakeInput = document.getElementById('gameStake');
        if (stakeInput) {
            stakeInput.value = amount;
            updateCreateButton();
            updateStakeCalculations();
        }
    } catch (error) {
        logError(error, 'Quick stake setting');
    }
}

function updateCreateButton() {
    try {
        const btn = document.getElementById('createGameBtn');
        const stakeInput = document.getElementById('gameStake');
        const balanceEl = document.getElementById('createBalance');
        
        if (!btn || !stakeInput) return;
        
        if (balanceEl) {
            balanceEl.textContent = currentBalance.toFixed(4) + ' CORE';
        }
        
        const stake = parseFloat(stakeInput.value);
        
        if (selectedGameType && stake >= 0.01) {
            if (currentBalance >= stake + 0.01) { // Account for gas fees
                btn.disabled = false;
                btn.innerHTML = `<i class="fas fa-rocket"></i> Create ${selectedGameType.toUpperCase()} Game (${stake} CORE)`;
                btn.className = 'create-btn';
            } else {
                btn.disabled = true;
                btn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Insufficient Balance`;
                btn.className = 'create-btn disabled';
            }
        } else if (selectedGameType && !stake) {
            btn.disabled = true;
            btn.innerHTML = `<i class="fas fa-coins"></i> Enter Stake Amount`;
        } else if (!selectedGameType && stake >= 0.01) {
            btn.disabled = true;
            btn.innerHTML = `<i class="fas fa-gamepad"></i> Select Game Type`;
        } else {
            btn.disabled = true;
            btn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type & Enter Stake`;
        }
    } catch (error) {
        logError(error, 'Create button update');
    }
}

function updateStakeCalculations() {
    try {
        const stakeInput = document.getElementById('gameStake');
        const winnerAmountEl = document.getElementById('winnerAmount');
        const platformFeeEl = document.getElementById('platformFee');
        const totalPotEl = document.getElementById('totalPot');
        
        if (!stakeInput || !winnerAmountEl || !platformFeeEl || !totalPotEl) return;
        
        const stake = parseFloat(stakeInput.value) || 0;
        const totalPot = stake * 2;
        const platformFee = totalPot * 0.03;
        const winnerAmount = totalPot - platformFee;
        
        winnerAmountEl.textContent = winnerAmount.toFixed(4) + ' CORE';
        platformFeeEl.textContent = platformFee.toFixed(4) + ' CORE';
        totalPotEl.textContent = totalPot.toFixed(4) + ' CORE';
    } catch (error) {
        logError(error, 'Stake calculations update');
    }
}

async function createRealGame() {
    try {
        const stakeInput = document.getElementById('gameStake');
        const timeControlInput = document.getElementById('timeControl');
        
        if (!stakeInput || !selectedGameType) {
            showRealtimeNotification('warning', 'Invalid Input', 'Please select a game type and enter stake amount');
            return;
        }
        
        const stakeAmount = parseFloat(stakeInput.value);
        const timeLimit = parseInt(timeControlInput?.value || '600');
        
        if (!validateStakeAndWallet(stakeAmount)) {
            return;
        }
        
        // Show anti-bot challenge if enabled
        if (platformSettings.antiBot) {
            const antiBotPassed = await showAntiBotChallenge();
            if (!antiBotPassed) {
                showRealtimeNotification('danger', 'Verification Failed', 'Anti-bot verification required');
                return;
            }
        }
        
        // Create the real blockchain game
        const gameId = await createRealBlockchainGame(selectedGameType, stakeAmount, timeLimit);
        
        showRealtimeNotification('success', 'Game Created!', 
            `Your ${selectedGameType} game is now live in the lobby!`, [
            {
                text: 'View in Lobby',
                class: 'primary',
                onclick: `showSection('lobby')`
            }
        ]);
        
        // Clear form
        stakeInput.value = '';
        selectedGameType = null;
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        updateCreateButton();
        updateStakeCalculations();
        
        // Update my games
        await loadMyGames();
        
        // Switch to lobby to see the created game
        setTimeout(() => showSection('lobby'), 1000);
        
    } catch (error) {
        logError(error, 'Real game creation');
        showRealtimeNotification('danger', 'Game Creation Failed', error.message);
    }
}

// ===========================
// MY GAMES SECTION MANAGEMENT
// ===========================

function loadMyGamesSection() {
    try {
        loadMyGames();
        switchMyGamesTab('active');
    } catch (error) {
        logError(error, 'Loading my games section');
    }
}

function switchMyGamesTab(tabName) {
    try {
        // Update tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(tabName + 'Tab').classList.add('active');
        
        // Update tab content
        document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.add('hidden'));
        document.getElementById(tabName + 'GamesTab').classList.remove('hidden');
        
        // Load appropriate content
        switch(tabName) {
            case 'active':
                loadActiveGames();
                break;
            case 'created':
                loadCreatedGames();
                break;
            case 'joined':
                loadJoinedGames();
                break;
            case 'history':
                loadGameHistory();
                break;
        }
    } catch (error) {
        logError(error, 'Switching my games tab');
    }
}

function loadActiveGames() {
    try {
        const container = document.getElementById('activeGamesList');
        if (!container) return;
        
        const activeGames = [...myCreatedGames, ...myJoinedGames]
            .filter(game => game.status === 'waiting' || game.status === 'playing');
        
        if (activeGames.length === 0) {
            container.innerHTML = '<div class="no-games">No active games</div>';
            return;
        }
        
        let html = '';
        activeGames.forEach(game => {
            const isCreator = game.creator.toLowerCase() === userAccount.toLowerCase();
            html += createMyGameHTML(game, isCreator);
        });
        
        container.innerHTML = html;
    } catch (error) {
        logError(error, 'Loading active games');
    }
}

function loadCreatedGames() {
    try {
        const container = document.getElementById('createdGamesList');
        if (!container) return;
        
        if (myCreatedGames.length === 0) {
            container.innerHTML = '<div class="no-games">No created games</div>';
            return;
        }
        
        let html = '';
        myCreatedGames.forEach(game => {
            html += createMyGameHTML(game, true);
        });
        
        container.innerHTML = html;
    } catch (error) {
        logError(error, 'Loading created games');
    }
}

function loadJoinedGames() {
    try {
        const container = document.getElementById('joinedGamesList');
        if (!container) return;
        
        if (myJoinedGames.length === 0) {
            container.innerHTML = '<div class="no-games">No joined games</div>';
            return;
        }
        
        let html = '';
        myJoinedGames.forEach(game => {
            html += createMyGameHTML(game, false);
        });
        
        container.innerHTML = html;
    } catch (error) {
        logError(error, 'Loading joined games');
    }
}

function createMyGameHTML(game, isCreator) {
    const statusClass = game.status === 'playing' ? 'status-playing' : 
                       game.status === 'waiting' ? 'status-waiting' : 'status-finished';
    
    const gameIcon = getGameIcon(game.type);
    const createdDate = new Date(game.createdAt || Date.now()).toLocaleDateString();
    
    return `
        <div class="my-game-card" data-game-id="${game.blockchainId || game.id}">
            <div class="game-card-header">
                <div class="game-type">
                    <span class="game-icon">${gameIcon}</span>
                    <span class="game-name">${game.type.toUpperCase()}</span>
                </div>
                <div class="game-status ${statusClass}">${game.status.toUpperCase()}</div>
            </div>
            
            <div class="game-card-details">
                <div class="detail-row">
                    <span>Role:</span>
                    <span>${isCreator ? 'Creator' : 'Joiner'}</span>
                </div>
                <div class="detail-row">
                    <span>Stake:</span>
                    <span>${game.stake} CORE</span>
                </div>
                <div class="detail-row">
                    <span>Created:</span>
                    <span>${createdDate}</span>
                </div>
                ${game.player2 ? `
                <div class="detail-row">
                    <span>Opponent:</span>
                    <span>${game.player2.substring(0, 6)}...${game.player2.substring(38)}</span>
                </div>` : ''}
            </div>
            
            <div class="game-card-actions">
                ${game.status === 'playing' ? `
                    <button class="action-btn primary" onclick="resumeGame('${game.blockchainId || game.id}')">
                        <i class="fas fa-play"></i> Resume Game
                    </button>
                ` : game.status === 'waiting' && isCreator ? `
                    <button class="action-btn secondary" onclick="cancelGame('${game.blockchainId || game.id}')">
                        <i class="fas fa-times"></i> Cancel Game
                    </button>
                ` : game.status === 'finished' ? `
                    <button class="action-btn info" onclick="viewGameDetails('${game.blockchainId || game.id}')">
                        <i class="fas fa-eye"></i> View Details
                    </button>
                ` : ''}
            </div>
        </div>
    `;
}

// ===========================
// ENHANCED FILTERS AND UTILITIES
// ===========================

function applyFilters() {
    try {
        const gameTypeFilter = document.getElementById('gameTypeFilter')?.value || 'all';
        const stakeFilter = document.getElementById('stakeFilter')?.value || 'all';
        const skillFilter = document.getElementById('skillFilter')?.value || 'all';
        
        currentGameFilters = {
            gameType: gameTypeFilter,
            stakeRange: stakeFilter,
            skillLevel: skillFilter
        };
        
        updateGamesDisplay();
        
        showRealtimeNotification('info', 'Filters Applied', 
            `Showing ${gameTypeFilter} games, ${stakeFilter} stakes, ${skillFilter} skill`);
    } catch (error) {
        logError(error, 'Applying filters');
    }
}

function shouldShowGame(game) {
    try {
        // Game type filter
        if (currentGameFilters.gameType !== 'all' && game.type !== currentGameFilters.gameType) {
            return false;
        }
        
        // Stake range filter
        if (currentGameFilters.stakeRange !== 'all') {
            const stake = game.stake || 0;
            switch(currentGameFilters.stakeRange) {
                case 'low':
                    if (stake > 0.1) return false;
                    break;
                case 'medium':
                    if (stake <= 0.1 || stake > 1.0) return false;
                    break;
                case 'high':
                    if (stake <= 1.0) return false;
                    break;
            }
        }
        
        // Skill level filter
        if (currentGameFilters.skillLevel !== 'all' && game.skillLevel !== currentGameFilters.skillLevel) {
            return false;
        }
        
        return true;
    } catch (error) {
        logError(error, 'Game filtering');
        return true;
    }
}

function updateGamesDisplay() {
    try {
        const gamesList = document.getElementById('gamesList');
        const noGames = document.getElementById('noGames');
        
        if (!gamesList || !noGames) return;
        
        // Filter games
        const filteredGames = globalGamesList.filter(game => 
            game.status === 'waiting' && shouldShowGame(game)
        );
        
        if (filteredGames.length === 0) {
            gamesList.innerHTML = '';
            noGames.classList.remove('hidden');
            return;
        }
        
        noGames.classList.add('hidden');
        
        let gamesHTML = '';
        
        // Real-time connection status
        gamesHTML += `
            <div class="connection-status-banner ${isConnectedToRealtime ? 'realtime' : 'offline'}">
                ${isConnectedToRealtime ? 
                    'üåê Real-time lobby - Games update instantly' : 
                    '‚ö†Ô∏è Offline mode - Refresh manually for updates'
                }
            </div>
        `;
        
        // Show filtered games
        filteredGames.forEach(game => {
            gamesHTML += createGameHTML(game);
        });
        
        gamesList.innerHTML = gamesHTML;
        
        // Update stats
        updateLiveStats();
        
    } catch (error) {
        logError(error, 'Games display update');
    }
}

function createGameHTML(game) {
    try {
        const gameIcons = { chess: '‚ôüÔ∏è', checkers: '‚ö´', words: 'üìù' };
        const gameNames = { chess: 'Chess Masters', checkers: 'Checkers Pro', words: 'Word Battle' };
        
        const timeAgo = Math.floor((Date.now() - (game.createdAt || Date.now())) / 60000);
        const creator = game.creator === userAccount ? 'You' : 
                       typeof game.creator === 'string' && game.creator.startsWith('0x') ? 
                       game.creator.substring(0, 6) + '...' + game.creator.substring(38) :
                       game.creator;
        
        const canJoin = userAccount && 
                       game.creator !== userAccount && 
                       game.status === 'waiting' && 
                       currentBalance >= game.stake;

        const skillBadgeClass = `skill-${game.skillLevel}`;
        const validationIcon = game.isReal ? '‚úÖ' : '‚ö†Ô∏è';
        const validationTitle = game.isReal ? 'Blockchain Validated' : 'Demo Game';
        
        const realTag = game.isReal ? '<span class="real-tag">REAL</span>' : '<span class="demo-tag">DEMO</span>';
        
        return `
            <div class="game-entry fade-in ${game.isReal ? 'real-game' : 'demo-game'}">
                <div class="game-header">
                    <div class="game-title">
                        ${gameIcons[game.type]} ${gameNames[game.type]} #${game.id}
                        <span class="skill-badge ${skillBadgeClass}">${game.skillLevel?.toUpperCase()}</span>
                        <span class="validation-status" title="${validationTitle}">
                            ${validationIcon}
                        </span>
                        ${realTag}
                    </div>
                    <div class="game-status status-waiting">
                        WAITING
                    </div>
                </div>
                
                <div class="game-details">
                    <div class="detail-item">
                        <div class="detail-label">Creator</div>
                        <div class="detail-value">${creator}</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Stake</div>
                        <div class="detail-value">${game.stake} CORE</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Prize Pool</div>
                        <div class="detail-value">${(game.stake * 2 * 0.97).toFixed(4)} CORE</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Created</div>
                        <div class="detail-value">${timeAgo}m ago</div>
                    </div>
                </div>
                
                ${getGameActionButton(game, canJoin)}
            </div>
        `;
    } catch (error) {
        logError(error, 'Creating game HTML');
        return '';
    }
}

function getGameActionButton(game, canJoin) {
    if (canJoin && game.isReal) {
        return `
            <button class="join-btn real-join" onclick="joinRealGame('${game.blockchainId || game.id}', ${game.stake})">
                <i class="fas fa-rocket"></i> Join Real Game (${game.stake} CORE)
            </button>
        `;
    } else if (canJoin && !game.isReal) {
        return `
            <button class="join-btn demo-join" onclick="joinGame(${game.id}, ${game.stake})">
                <i class="fas fa-play"></i> Try Demo Game
            </button>
        `;
    } else if (game.creator === userAccount) {
        return `
            <button class="join-btn waiting" disabled>
                <i class="fas fa-clock"></i> Waiting for Opponent
            </button>
        `;
    } else if (!userAccount) {
        return `
            <button class="join-btn disabled" disabled>
                <i class="fas fa-wallet"></i> Connect Wallet to Join
            </button>
        `;
    } else if (currentBalance < game.stake) {
        return `
            <button class="join-btn disabled" disabled>
                <i class="fas fa-coins"></i> Insufficient Balance
            </button>
        `;
    } else {
        return `
            <button class="join-btn disabled" disabled>
                <i class="fas fa-users"></i> Game Full
            </button>
        `;
    }
}

// ===========================
// REAL GAME JOINING
// ===========================

async function joinRealGame(gameId, stakeAmount) {
    try {
        console.log('üéÆ Joining real blockchain game:', gameId);
        
        if (!userAccount) {
            showRealtimeNotification('warning', 'Wallet Required', 'Please connect your wallet to join games');
            return;
        }
        
        if (currentBalance < stakeAmount) {
            showRealtimeNotification('warning', 'Insufficient Balance', 'You need more CORE to join this game');
            return;
        }
        
        // Show anti-bot challenge if enabled
        if (platformSettings.antiBot) {
            const antiBotPassed = await showAntiBotChallenge();
            if (!antiBotPassed) {
                showRealtimeNotification('danger', 'Verification Failed', 'Anti-bot verification required');
                return;
            }
        }
        
        // Join the real blockchain game
        await joinRealBlockchainGame(gameId, stakeAmount);
        
        // Refresh displays
        await loadMyGames();
        await refreshLobby();
        
    } catch (error) {
        logError(error, 'Joining real game');
        showRealtimeNotification('danger', 'Join Failed', error.message);
    }
}

// ===========================
// ENHANCED UTILITY FUNCTIONS
// ===========================

function validateStakeAndWallet(stakeAmount) {
    if (!userAccount) {
        showRealtimeNotification('warning', 'Wallet Required', 'Please connect your wallet first');
        return false;
    }
    
    if (!stakeAmount || stakeAmount < 0.01) {
        showRealtimeNotification('warning', 'Invalid Stake', 'Please enter a valid stake amount (minimum 0.01 CORE)');
        return false;
    }
    
    if (stakeAmount > currentBalance) {
        showRealtimeNotification('warning', 'Insufficient Balance', 'You don\'t have enough CORE for this stake');
        return false;
    }
    
    return true;
}

async function refreshLobby() {
    try {
        console.log('üîÑ Refreshing lobby...');
        
        // Sync with server if available
        if (isConnectedToRealtime) {
            // Request fresh data via WebSocket
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                webSocket.send(JSON.stringify({
                    type: 'requestGamesList',
                    timestamp: Date.now()
                }));
            }
        } else {
            // Fallback sync
            await syncGamesList();
        }
        
        // Update UI components
        updateGamesDisplay();
        updateLiveStats();
        
        console.log('‚úÖ Lobby refreshed successfully');
        
    } catch (error) {
        logError(error, 'Lobby refresh');
    }
}

function updateLiveStats() {
    try {
        const realGames = globalGamesList.filter(game => game.isReal);
        const totalGames = realGames.length;
        const totalVolume = realGames.reduce((sum, game) => sum + (game.stake || 0), 0);
        const onlinePlayers = totalGames > 0 ? 
            totalGames * 2 + Math.floor(Math.random() * 20) + 10 : 
            Math.floor(Math.random() * 50) + 5;
        
        const totalPlayersEl = document.getElementById('totalPlayers');
        const totalGamesEl = document.getElementById('totalGames');
        const totalVolumeEl = document.getElementById('totalVolume');
        
        if (totalPlayersEl) totalPlayersEl.textContent = onlinePlayers;
        if (totalGamesEl) totalGamesEl.textContent = totalGames;
        if (totalVolumeEl) totalVolumeEl.textContent = totalVolume.toFixed(2);
        
        // Update activity feed
        if (totalGames !== (window.lastGameCount || 0)) {
            if (totalGames > (window.lastGameCount || 0)) {
                addActivityFeedItem(`üéÆ New real game created! Total: ${totalGames}`);
            }
            window.lastGameCount = totalGames;
        }
    } catch (error) {
        logError(error, 'Live stats update');
    }
}

// ===========================
// FINAL INITIALIZATION
// ===========================

async function initializePlatform() {
    console.log('üöÄ Initializing Complete CrossRealm Gaming Platform...');
    
    try {
        // Check age verification first
        if (!checkAgeVerification()) {
            return;
        }
        
        // Load settings
        loadSettings();
        
        // Initialize blockchain
        await measureAsyncPerformance('Blockchain Init', () => initializeBlockchain());
        
        // Auto-connect if previously connected
        try {
            if (sessionStorage.getItem('walletConnected') === 'true') {
                setTimeout(async () => {
                    try {
                        await connectWallet();
                    } catch (error) {
                        logError(error, 'Auto-connect');
                        try {
                            sessionStorage.removeItem('walletConnected');
                        } catch (e) {
                            console.log('Failed to clear session:', e);
                        }
                    }
                }, 1000);
            }
        } catch (error) {
            console.log('Session storage not available:', error);
        }
        
        // Initial data load
        await refreshLobby();
        
        // Add initial activity items
        addActivityFeedItem('üöÄ Real-time multiplayer platform initialized');
        addActivityFeedItem('üîó Connected to Core Blockchain');
        addActivityFeedItem('üéÆ Real blockchain games available!');
        addActivityFeedItem('üõ°Ô∏è Anti-bot protection active');
        addActivityFeedItem('‚ö° Server validation enabled');
        
        console.log('‚úÖ Complete platform initialization finished!');
        
    } catch (error) {
        logError(error, 'Platform initialization');
        showRealtimeNotification('danger', 'Initialization Failed', 'Platform failed to initialize: ' + error.message);
    }
}

// ===========================
// EVENT HANDLERS AND FINAL SETUP
// ===========================

// Initialize platform when page loads
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('üéÆ CrossRealm Gaming Platform Loading...');
        
        await measureAsyncPerformance('Platform Initialization', initializePlatform);
        
        // Attach event listeners
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const transactionStatus = document.getElementById('transactionStatus');
        
        if (connectBtn) {
            connectBtn.addEventListener('click', connectWallet);
        }
        
        if (disconnectBtn) {
            disconnectBtn.addEventListener('click', disconnectWallet);
        }
        
        if (transactionStatus) {
            transactionStatus.addEventListener('click', () => {
                transactionStatus.classList.remove('show');
            });
        }
        
        // Add balance update listener
        const stakeInputs = document.querySelectorAll('.stake-input');
        stakeInputs.forEach(input => {
            input.addEventListener('input', updateStakeCalculations);
        });
        
        console.log('üöÄ CrossRealm Platform Ready with Real Blockchain Integration!');
        
    } catch (error) {
        logError(error, 'Platform initialization');
        showRealtimeNotification('danger', 'Platform Error', 'Platform initialization failed. Retrying...');
        
        // Retry initialization once
        setTimeout(() => {
            try {
                initializePlatform();
            } catch (retryError) {
                logError(retryError, 'Platform initialization retry');
            }
        }, 3000);
    }
});

// Window events
window.addEventListener('beforeunload', () => {
    try {
        saveUserData();
        saveSettings();
        
        // Close WebSocket connection
        if (webSocket) {
            webSocket.close();
        }
        
        if (userAccount) {
            try {
                sessionStorage.setItem('walletConnected', 'true');
            } catch (error) {
                console.log('Session storage not available:', error);
            }
        } else {
            try {
                sessionStorage.removeItem('walletConnected');
            } catch (error) {
                console.log('Session storage not available:', error);
            }
        }
    } catch (error) {
        logError(error, 'Window beforeunload');
    }
});

// Handle visibility change for performance optimization
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Page is hidden, reduce update frequency
        if (syncInterval) {
            clearInterval(syncInterval);
        }
    } else {
        // Page is visible, resume normal updates
        if (autoRefreshEnabled && !isConnectedToRealtime) {
            setupFallbackSync();
        }
    }
});

console.log('‚úÖ Complete UI Management & Final Integration Loaded Successfully');
console.log('üéâ CROSSREALM GAMING PLATFORM FULLY LOADED WITH REAL BLOCKCHAIN INTEGRATION!');
</script>

<!-- Enhanced CSS for final components -->
<style>
/* ===========================
   FINAL COMPONENT STYLES
   =========================== */

.real-tag {
    background: rgba(0, 255, 136, 0.3);
    color: #00ff88;
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    font-size: 0.7rem;
    font-weight: bold;
    margin-left: 0.5rem;
}

.demo-tag {
    background: #666;
    color: #ccc;
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    font-size: 0.7rem;
    margin-left: 0.5rem;
}

.game-entry.real-game {
    border-color: rgba(0, 255, 136, 0.5);
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
}

.join-btn.real-join {
    background: linear-gradient(45deg, #00ff88, #00cc6a);
    color: #000;
    font-weight: bold;
}

.join-btn.demo-join {
    background: linear-gradient(45deg, #666, #777);
}

.stake-settings {
    background: var(--glass);
    border-radius: 15px;
    padding: 2rem;
    margin: 2rem 0;
    border: 2px solid rgba(0, 255, 136, 0.3);
}

.stake-input-group {
    margin-bottom: 1.5rem;
}

.stake-info {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin-top: 1rem;
}

.info-item {
    display: flex;
    justify-content: space-between;
    margin: 0.5rem 0;
}

.highlight {
    color: #00ff88;
    font-weight: bold;
}

.quick-stake-buttons {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.quick-stake-btn {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 8px;
    padding: 0.5rem 1rem;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
}

.quick-stake-btn:hover {
    background: rgba(0, 255, 136, 0.2);
    border-color: #00ff88;
}

.balance-check {
    text-align: center;
    margin-top: 1rem;
    padding: 1rem;
    background: rgba(255, 193, 7, 0.1);
    border-radius: 10px;
    border: 1px solid rgba(255, 193, 7, 0.3);
}

.small-text {
    font-size: 0.8rem;
    color: #aaa;
}

.games-tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 2rem;
    border-bottom: 2px solid var(--glass-border);
}

.tab-btn {
    background: none;
    border: none;
    padding: 1rem 1.5rem;
    color: #aaa;
    cursor: pointer;
    transition: all 0.3s ease;
    border-bottom: 3px solid transparent;
}

.tab-btn.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
}

.tab-btn:hover {
    color: white;
}

.tab-pane {
    animation: fadeIn 0.3s ease-out;
}

.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
}

.my-game-card {
    background: var(--glass);
    border: 2px solid var(--glass-border);
    border-radius: 15px;
    padding: 1.5rem;
    transition: all 0.3s ease;
}

.my-game-card:hover {
    border-color: var(--accent);
    transform: translateY(-3px);
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
}

.game-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

.game-type {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.game-card-details {
    margin: 1rem 0;
}

.detail-row {
    display: flex;
    justify-content: space-between;
    padding: 0.3rem 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.detail-row:last-child {
    border-bottom: none;
}

.game-card-actions {
    margin-top: 1rem;
}

.action-btn {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    padding: 0.8rem 1.2rem;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
}

.action-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
}

.action-btn.secondary {
    background: linear-gradient(45deg, #666, #777);
}

.action-btn.info {
    background: linear-gradient(45deg, #3498db, #2980b9);
}

.connection-status-banner {
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    border-radius: 8px;
    padding: 0.8rem;
    margin-bottom: 1rem;
    text-align: center;
    font-weight: bold;
}

.connection-status-banner.realtime {
    background: rgba(0, 255, 136, 0.1);
    border-color: rgba(0, 255, 136, 0.3);
    color: #00ff88;
}

.settings-toggle {
    width: 50px;
    height: 25px;
    background: #666;
    border-radius: 25px;
    position: relative;
    cursor: pointer;
    transition: all 0.3s ease;
}

.settings-toggle.active {
    background: var(--accent);
}

.settings-toggle::before {
    content: '';
    position: absolute;
    width: 21px;
    height: 21px;
    border-radius: 50%;
    background: white;
    top: 2px;
    left: 2px;
    transition: all 0.3s ease;
}

.settings-toggle.active::before {
    transform: translateX(25px);
}

.settings-button {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 0.5rem;
}

.settings-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
}

.settings-button.danger-button {
    background: linear-gradient(45deg, var(--danger), #c0392b);
}

.feature-tag {
    background: rgba(78, 205, 196, 0.2);
    border: 1px solid rgba(78, 205, 196, 0.4);
    border-radius: 10px;
    padding: 0.2rem 0.5rem;
    font-size: 0.7rem;
    color: var(--accent);
    margin: 0.2rem;
}

.game-features {
    display: flex;
    flex-wrap: wrap;
    margin-top: 0.5rem;
}

/* Responsive enhancements */
@media (max-width: 768px) {
    .games-grid {
        grid-template-columns: 1fr;
    }
    
    .quick-stake-buttons {
        justify-content: center;
    }
    
    .games-tabs {
        flex-wrap: wrap;
    }
    
    .tab-btn {
        padding: 0.8rem 1rem;
        font-size: 0.9rem;
    }
}
</style>

</body>
</html>
