<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="CrossRealm Gaming - Blockchain gaming platform on Core Network">
    <meta name="keywords" content="blockchain gaming, Core Network, cryptocurrency games, chess, checkers">
    <meta name="author" content="CrossRealm Gaming">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>CrossRealm Gaming - Blockchain Gaming on Core Network</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" integrity="sha512-JNGbhLCEQuKMUOdNuY3iDeApC5A3VdMGGqLfGKFqN4iIdFJX3J0sEF8HWjKgw9LhJHQ8Qj9K4i2kGY1tCXKSMQ==" crossorigin="anonymous"></script>
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎮</text></svg>">
</head>
<body>
    <div class="background-overlay"></div>
    
    <!-- Enhanced Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-content">
            <div class="logo-loading">
                <i class="fas fa-dice-d20 logo-icon"></i>
                <h1>CROSSREALM</h1>
            </div>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <div class="loading-status" id="loadingStatus">Initializing platform...</div>
            <div style="margin-top: 20px; font-size: 12px; color: #888; text-align: center;">
                <div id="debugInfo">Loading...</div>
                <button id="emergencyBypass" style="margin-top: 10px; padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; display: none; font-size: 11px;">
                    Emergency Bypass (Dev)
                </button>
                <div id="loadingTimer" style="margin-top: 5px; font-size: 10px;">Time: <span id="timerCount">0</span>s</div>
            </div>
        </div>
    </div>

    <!-- Enhanced Age Verification Modal -->
    <div class="modal-overlay" id="ageVerificationModal" style="display: none;">
        <div class="modal-content verification-modal">
            <div class="modal-header">
                <h2><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h2>
            </div>
            <div class="modal-body">
                <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
                <div class="warning-box">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
                </div>
                <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-success" id="ageVerifyYes" data-action="verify-age" data-value="true">I am 18+</button>
                <button class="btn btn-danger" id="ageVerifyNo" data-action="verify-age" data-value="false">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Anti-Bot Challenge Modal -->
    <div class="modal-overlay" id="antiBotModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-shield-alt"></i> Human Verification</h3>
            </div>
            <div class="modal-body">
                <p>Please complete this challenge to continue:</p>
                <div class="captcha-container">
                    <div class="captcha-instructions" id="captchaInstructions">
                        Select all squares containing chess pieces
                    </div>
                    <div class="captcha-grid" id="captchaGrid">
                        <!-- Grid will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="verifyCaptchaBtn" disabled>Verify</button>
                <button class="btn btn-secondary" id="refreshCaptchaBtn">New Challenge</button>
            </div>
        </div>
    </div>

    <!-- Game Invitation Modal -->
    <div class="modal-overlay hidden" id="gameInvitationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-gamepad"></i> Game Invitation</h3>
            </div>
            <div class="modal-body">
                <p id="invitationMessage">Player wants to join your game!</p>
                <div class="invitation-details" id="invitationDetails"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-success" data-action="accept-invitation">Accept</button>
                <button class="btn btn-danger" data-action="decline-invitation">Decline</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Notification System -->
    <div class="notification-container" id="notificationContainer">
        <!-- Notifications will be populated by JavaScript -->
    </div>

    <!-- Enhanced Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div class="tx-message" id="txMessage">Processing...</div>
        <div class="tx-hash" id="txHash"></div>
        <button class="tx-close" id="txClose">&times;</button>
    </div>

    <!-- Enhanced Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <i class="fas fa-dice-d20 logo-icon"></i>
                <h1>CROSSREALM</h1>
            </div>
            
            <nav class="nav-menu" id="navMenu">
                <button class="nav-item active" data-section="lobby">
                    <i class="fas fa-home"></i> Lobby
                </button>
                <button class="nav-item" data-section="create">
                    <i class="fas fa-plus"></i> Create Game
                </button>
                <button class="nav-item" data-section="games">
                    <i class="fas fa-gamepad"></i> Games
                </button>
                <button class="nav-item" data-section="tournaments">
                    <i class="fas fa-trophy"></i> Tournaments
                </button>
                <button class="nav-item" data-section="profile">
                    <i class="fas fa-user"></i> Profile
                </button>
                <button class="nav-item" data-section="settings">
                    <i class="fas fa-cog"></i> Settings
                </button>
            </nav>
            
            <div class="live-indicator">
                <div class="pulse-dot"></div>
                <span>LIVE ON CORE</span>
            </div>
            
            <div class="wallet-section">
                <div class="wallet-info">
                    <div class="connection-status" id="connectionStatus">
                        <span class="status-indicator offline"></span>
                        <span class="status-text">Not Connected</span>
                    </div>
                    <div class="balance" id="balanceDisplay">0.0000 CORE</div>
                </div>
                <button class="btn btn-primary" id="connectBtn">
                    <i class="fas fa-plug"></i> Connect Wallet
                </button>
                <button class="btn btn-secondary hidden" id="disconnectBtn">
                    <i class="fas fa-sign-out-alt"></i> Disconnect
                </button>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Enhanced Sidebar -->
        <aside class="sidebar">
            <!-- Smart Contract Status -->
            <div class="widget contract-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-file-contract"></i> Smart Contract</h3>
                </div>
                <div class="widget-content">
                    <div class="contract-address" id="contractAddress">
                        <span class="address-text">0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A</span>
                        <button class="btn-copy" data-copy-target="contract-address">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                    <div class="contract-status" id="contractStatus">
                        <span class="status-indicator pending"></span>
                        <span>Connecting...</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="connectionProgress"></div>
                    </div>
                </div>
            </div>

            <!-- Server Status -->
            <div class="widget server-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-server"></i> Server Status</h3>
                </div>
                <div class="widget-content">
                    <div class="server-status" id="serverStatus">
                        <span class="status-indicator pending"></span>
                        <span>Connecting...</span>
                    </div>
                    <div class="server-details">
                        <div class="detail-row">
                            <span class="detail-label">Latency:</span>
                            <span class="detail-value" id="serverLatency">--ms</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Last Sync:</span>
                            <span class="detail-value" id="lastSync">Never</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Status:</span>
                            <span class="detail-value" id="serverStatusText">Offline</span>
                        </div>
                    </div>
                    <button class="btn btn-sm btn-primary" id="testConnectionBtn">
                        <i class="fas fa-wifi"></i> Test Connection
                    </button>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="widget stats-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-chart-line"></i> Live Stats</h3>
                </div>
                <div class="widget-content">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="onlinePlayersCount">0</div>
                            <div class="stat-label">Online Players</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="activeGamesCount">0</div>
                            <div class="stat-label">Active Games</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalVolumeCount">0</div>
                            <div class="stat-label">CORE Volume</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- My Active Games -->
            <div class="widget my-games-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-gamepad"></i> My Active Games</h3>
                </div>
                <div class="widget-content">
                    <div class="my-games-list" id="myActiveGamesList">
                        <div class="no-games">
                            <i class="fas fa-ghost"></i>
                            <p>No active games</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activity Feed -->
            <div class="widget activity-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-fire"></i> Recent Activity</h3>
                </div>
                <div class="widget-content">
                    <div class="activity-feed" id="activityFeed">
                        <div class="activity-item">
                            <i class="fas fa-rocket"></i>
                            <span>Platform initialized</span>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="content-area">
            <!-- Enhanced Sections will be dynamically loaded here -->
            <section id="lobbySection" class="section-content active">
                <!-- Lobby content will be loaded by JavaScript -->
            </section>
            <section id="createSection" class="section-content">
                <!-- Create game content will be loaded by JavaScript -->
            </section>
            <section id="gamesSection" class="section-content">
                <!-- Games content will be loaded by JavaScript -->
            </section>
            <section id="tournamentsSection" class="section-content">
                <!-- Tournaments content will be loaded by JavaScript -->
            </section>
            <section id="profileSection" class="section-content">
                <!-- Profile content will be loaded by JavaScript -->
            </section>
            <section id="settingsSection" class="section-content">
                <!-- Settings content will be loaded by JavaScript -->
            </section>
        </main>
    </div>

    <!-- Enhanced Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4><i class="fas fa-dice-d20"></i> CrossRealm</h4>
                <p>Premier blockchain gaming platform on Core Network. Play, compete, and earn with provably fair games.</p>
                <div class="social-links">
                    <a href="#" class="social-link" aria-label="Twitter">
                        <i class="fab fa-twitter"></i>
                    </a>
                    <a href="#" class="social-link" aria-label="Discord">
                        <i class="fab fa-discord"></i>
                    </a>
                    <a href="#" class="social-link" aria-label="GitHub">
                        <i class="fab fa-github"></i>
                    </a>
                </div>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-gamepad"></i> Games</h4>
                <ul>
                    <li><a href="#" data-section="games">Chess Masters</a></li>
                    <li><a href="#" data-section="games">Checkers Pro</a></li>
                    <li><a href="#" data-section="games">Word Battle</a></li>
                    <li><a href="#" data-section="tournaments">Tournaments</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-link"></i> Blockchain</h4>
                <ul>
                    <li><a href="https://scan.coredao.org" target="_blank" rel="noopener noreferrer">Core Explorer</a></li>
                    <li><a href="https://coredao.org" target="_blank" rel="noopener noreferrer">Core Network</a></li>
                    <li><a href="#" data-action="show-contract">Smart Contract</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-info-circle"></i> Support</h4>
                <ul>
                    <li><a href="#" data-action="show-help">Help Center</a></li>
                    <li><a href="#" data-action="show-terms">Terms of Service</a></li>
                    <li><a href="#" data-action="show-privacy">Privacy Policy</a></li>
                    <li><a href="#" data-action="show-fairplay">Fair Play</a></li>
                </ul>
            </div>
        </div>
        
        <div class="footer-bottom">
            <p>&copy; 2025 CrossRealm Gaming Platform. All rights reserved.</p>
            <p>Built on <strong>Core Blockchain</strong> • Licensed Gaming Platform • 18+ Only</p>
            <p>Contract: 0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A (Verified ✅)</p>
        </div>
    </footer>

    <!-- Game Overlay -->
    <div class="game-overlay hidden" id="gameOverlay"></div>

    <!-- Chess Game Window -->
    <div class="game-window hidden" id="chessGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">
                ♟️ Chess Masters 
                <span class="skill-badge skill-gold" id="chessSkillBadge">Gold</span>
                <span class="validation-status validated" title="Server Validated">✓</span>
            </div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('chess')" title="Minimize">−</button>
                <button class="window-btn close-btn" onclick="closeGame('chess')" title="Close">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-info-bar">
                <div class="player-info">
                    <div class="player-avatar">👤</div>
                    <div class="player-details">
                        <div class="player-name" id="chessPlayer1Name">You (White)</div>
                        <div class="player-rating">Rating: 456</div>
                    </div>
                </div>
                <div class="game-timer">
                    <div class="timer white-timer" id="whiteTimer">10:00</div>
                    <div class="timer black-timer" id="blackTimer">10:00</div>
                </div>
                <div class="player-info opponent">
                    <div class="player-details">
                        <div class="player-name" id="chessPlayer2Name">Waiting for opponent...</div>
                        <div class="player-rating">Rating: ---</div>
                    </div>
                    <div class="player-avatar">🤖</div>
                </div>
            </div>
            
            <div class="game-status" id="chessStatus">Waiting for opponent...</div>
            <div class="chess-board" id="chessBoard"></div>
            
            <div class="game-controls">
                <button class="game-btn" onclick="resignChess()">
                    <i class="fas fa-flag"></i> Resign
                </button>
                <button class="game-btn" onclick="drawChess()">
                    <i class="fas fa-handshake"></i> Offer Draw
                </button>
                <button class="game-btn" onclick="requestUndo()">
                    <i class="fas fa-undo"></i> Request Undo
                </button>
            </div>
            
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">
                    <i class="fas fa-comments"></i> Game Chat
                </h4>
                <div class="game-chat-messages" id="chessGameChat">
                    <div class="game-chat-message system">
                        <strong>System:</strong> Game started! Good luck!
                    </div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="chessChatInput" 
                           onkeypress="handleGameChatKeyPress(event, 'chess')" maxlength="100">
                    <button onclick="sendGameChatMessage('chess')">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <style>
/* ===========================
   CROSSREALM GAMING PLATFORM
   COMPLETE CSS STYLING WITH PERFORMANCE & SECURITY FIXES
   =========================== */

/* CSS Custom Properties for Better Theming */
:root {
    /* Color Palette */
    --color-primary: #4e54c8;
    --color-primary-dark: #363a9e;
    --color-secondary: #f39c12;
    --color-accent: #4ecdc4;
    --color-accent-dark: #44a08d;
    --color-success: #2ecc71;
    --color-warning: #f1c40f;
    --color-danger: #e74c3c;
    --color-info: #3498db;
    
    /* Background Colors */
    --bg-primary: #1a1c2c;
    --bg-secondary: #2c3e50;
    --bg-surface: rgba(255, 255, 255, 0.05);
    --bg-glass: rgba(255, 255, 255, 0.1);
    --bg-overlay: rgba(0, 0, 0, 0.8);
    
    /* Text Colors */
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --text-muted: #888888;
    
    /* Border Colors */
    --border-primary: rgba(255, 255, 255, 0.2);
    --border-accent: rgba(78, 205, 196, 0.5);
    
    /* Spacing */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    --spacing-xxl: 3rem;
    
    /* Border Radius */
    --radius-sm: 4px;
    --radius-md: 8px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    --radius-pill: 50px;
    
    /* Shadows */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.2);
    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.3);
    --shadow-glow: 0 0 20px rgba(78, 205, 196, 0.3);
    
    /* Animation Timing */
    --transition-fast: 0.15s ease-out;
    --transition-normal: 0.3s ease-out;
    --transition-slow: 0.5s ease-out;
    
    /* Z-index Scale */
    --z-background: -1;
    --z-base: 0;
    --z-elevated: 10;
    --z-dropdown: 100;
    --z-sticky: 200;
    --z-fixed: 300;
    --z-modal-backdrop: 900;
    --z-modal: 1000;
    --z-notification: 1100;
    --z-tooltip: 1200;
}

/* CSS Reset & Base Styles */
*,
*::before,
*::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    scroll-behavior: smooth;
}

body {
    font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
    background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
    overflow-x: hidden;
    position: relative;
}

/* Performance Optimizations */
* {
    will-change: auto;
}

.loading-screen,
.modal-overlay,
.notification,
.game-window {
    will-change: transform, opacity;
}

/* Accessibility Improvements */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Focus Styles for Accessibility */
button:focus,
input:focus,
select:focus,
textarea:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
}

/* Background Overlay */
.background-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(circle at 20% 50%, rgba(78, 205, 196, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(78, 84, 200, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(243, 156, 18, 0.05) 0%, transparent 50%);
    z-index: var(--z-background);
    pointer-events: none;
}

/* ===========================
   LOADING SCREEN
   =========================== */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: var(--z-modal);
    backdrop-filter: blur(10px);
}

.loading-content {
    text-align: center;
    max-width: 400px;
    padding: var(--spacing-xl);
}

.logo-loading {
    margin-bottom: var(--spacing-xl);
}

.logo-loading .logo-icon {
    font-size: 4rem;
    color: var(--color-accent);
    margin-bottom: var(--spacing-md);
    animation: pulse 2s infinite;
}

.logo-loading h1 {
    font-size: 2.5rem;
    background: linear-gradient(45deg, var(--color-primary), var(--color-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.loading-bar {
    width: 100%;
    height: 4px;
    background: var(--bg-surface);
    border-radius: var(--radius-pill);
    overflow: hidden;
    margin-bottom: var(--spacing-md);
}

.loading-progress {
    height: 100%;
    background: linear-gradient(90deg, var(--color-accent), var(--color-primary));
    width: 0%;
    transition: width var(--transition-normal);
    border-radius: var(--radius-pill);
}

.loading-status {
    color: var(--text-secondary);
    font-size: 0.9rem;
}

/* ===========================
   UTILITY CLASSES
   =========================== */
.hidden { display: none !important; }
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* Text Utilities */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

/* Spacing Utilities */
.mt-0 { margin-top: 0; }
.mt-1 { margin-top: var(--spacing-sm); }
.mt-2 { margin-top: var(--spacing-md); }
.mt-3 { margin-top: var(--spacing-lg); }

.mb-0 { margin-bottom: 0; }
.mb-1 { margin-bottom: var(--spacing-sm); }
.mb-2 { margin-bottom: var(--spacing-md); }
.mb-3 { margin-bottom: var(--spacing-lg); }

/* ===========================
   BUTTON SYSTEM
   =========================== */
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    border: none;
    border-radius: var(--radius-md);
    font-size: 0.9rem;
    font-weight: 600;
    text-decoration: none;
    cursor: pointer;
    transition: all var(--transition-fast);
    position: relative;
    overflow: hidden;
    min-height: 44px; /* Accessibility minimum touch target */
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

.btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left var(--transition-normal);
}

.btn:hover:not(:disabled)::before {
    left: 100%;
}

.btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.btn:active:not(:disabled) {
    transform: translateY(0);
}

/* Button Variants */
.btn-primary {
    background: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark));
    color: white;
}

.btn-secondary {
    background: var(--bg-surface);
    color: var(--text-primary);
    border: 1px solid var(--border-primary);
}

.btn-success {
    background: linear-gradient(135deg, var(--color-success), #27ae60);
    color: white;
}

.btn-danger {
    background: linear-gradient(135deg, var(--color-danger), #c0392b);
    color: white;
}

.btn-warning {
    background: linear-gradient(135deg, var(--color-warning), var(--color-secondary));
    color: var(--bg-primary);
}

.btn-accent {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    color: white;
}

/* Button Sizes */
.btn-sm {
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: 0.8rem;
    min-height: 36px;
}

.btn-lg {
    padding: var(--spacing-md) var(--spacing-xl);
    font-size: 1.1rem;
    min-height: 52px;
}

.btn-copy {
    padding: var(--spacing-xs);
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    min-height: 32px;
    width: 32px;
}

.btn-block {
    width: 100%;
}

/* ===========================
   MODAL SYSTEM (FIXED)
   =========================== */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: var(--z-modal-backdrop);
    backdrop-filter: blur(5px);
    animation: fadeIn var(--transition-normal) ease-out;
}

.modal-content {
    background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
    border: 2px solid var(--color-accent);
    border-radius: var(--radius-xl);
    padding: 0;
    max-width: 90vw;
    max-height: 90vh;
    overflow: hidden;
    box-shadow: var(--shadow-lg);
    animation: slideInScale var(--transition-normal) ease-out;
    position: relative;
    z-index: var(--z-modal);
}

.modal-header {
    padding: var(--spacing-lg);
    border-bottom: 1px solid var(--border-primary);
    background: rgba(78, 205, 196, 0.1);
}

.modal-header h2,
.modal-header h3 {
    margin: 0;
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.modal-body {
    padding: var(--spacing-lg);
}

.modal-footer {
    padding: var(--spacing-lg);
    border-top: 1px solid var(--border-primary);
    display: flex;
    gap: var(--spacing-md);
    justify-content: center;
    background: var(--bg-surface);
}

.verification-modal {
    max-width: 500px;
}

.warning-box {
    background: rgba(241, 196, 15, 0.1);
    border: 1px solid rgba(241, 196, 15, 0.3);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin: var(--spacing-md) 0;
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-sm);
}

.warning-box i {
    color: var(--color-warning);
    margin-top: 2px;
    flex-shrink: 0;
}

/* ===========================
   CAPTCHA SYSTEM
   =========================== */
.captcha-container {
    text-align: center;
}

.captcha-instructions {
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-sm);
    background: var(--bg-surface);
    border-radius: var(--radius-md);
    font-weight: 600;
    color: var(--color-warning);
}

.captcha-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-sm);
    max-width: 240px;
    margin: 0 auto var(--spacing-md);
}

.captcha-tile {
    aspect-ratio: 1;
    background: var(--bg-surface);
    border: 2px solid var(--border-primary);
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all var(--transition-fast);
    user-select: none;
}

.captcha-tile:hover {
    background: rgba(78, 205, 196, 0.1);
    border-color: var(--color-accent);
}

.captcha-tile.selected {
    background: rgba(78, 205, 196, 0.2);
    border-color: var(--color-accent);
    box-shadow: var(--shadow-glow);
}

/* ===========================
   NOTIFICATION SYSTEM (ENHANCED)
   =========================== */
.notification-container {
    position: fixed;
    top: 80px;
    right: var(--spacing-md);
    z-index: var(--z-notification);
    max-width: 380px;
    pointer-events: none;
}

.notification {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 28, 44, 0.95));
    backdrop-filter: blur(15px);
    border: 2px solid var(--color-accent);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    animation: slideInRight var(--transition-normal) ease-out;
    pointer-events: auto;
    cursor: pointer;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
}

.notification::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 4px;
    height: 100%;
    background: var(--color-accent);
}

.notification.success {
    border-color: var(--color-success);
}

.notification.success::before {
    background: var(--color-success);
}

.notification.warning {
    border-color: var(--color-warning);
}

.notification.warning::before {
    background: var(--color-warning);
}

.notification.error {
    border-color: var(--color-danger);
}

.notification.error::before {
    background: var(--color-danger);
}

.notification-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: var(--spacing-sm);
}

.notification-title {
    font-weight: 600;
    color: var(--color-accent);
    font-size: 0.9rem;
}

.notification-close {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color var(--transition-fast);
}

.notification-close:hover {
    color: var(--text-primary);
}

.notification-message {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
    margin-bottom: var(--spacing-sm);
}

.notification-actions {
    display: flex;
    gap: var(--spacing-sm);
    justify-content: flex-end;
}

.notification-btn {
    padding: var(--spacing-xs) var(--spacing-sm);
    background: var(--color-accent);
    border: none;
    border-radius: var(--radius-sm);
    color: white;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all var(--transition-fast);
}

.notification-btn:hover {
    background: var(--color-accent-dark);
    transform: translateY(-1px);
}

.notification-btn.secondary {
    background: var(--bg-surface);
    color: var(--text-primary);
}

/* ===========================
   TRANSACTION STATUS
   =========================== */
.transaction-status {
    position: fixed;
    bottom: var(--spacing-md);
    right: var(--spacing-md);
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(15px);
    border: 1px solid var(--color-accent);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    min-width: 300px;
    max-width: 400px;
    z-index: var(--z-notification);
    transform: translateX(120%);
    transition: transform var(--transition-normal);
    box-shadow: var(--shadow-lg);
}

.transaction-status.show {
    transform: translateX(0);
}

.tx-message {
    color: var(--text-primary);
    margin-bottom: var(--spacing-sm);
    font-weight: 500;
}

.tx-hash {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: var(--color-accent);
    word-break: break-all;
    margin-bottom: var(--spacing-sm);
}

.tx-close {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-sm);
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* ===========================
   HEADER STYLES
   =========================== */
.header {
    position: sticky;
    top: 0;
    z-index: var(--z-sticky);
    background: rgba(26, 28, 44, 0.95);
    backdrop-filter: blur(15px);
    border-bottom: 1px solid var(--border-primary);
    padding: var(--spacing-md);
}

.header-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-md);
    max-width: 1400px;
    margin: 0 auto;
}

.logo {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    flex-shrink: 0;
}

.logo-icon {
    font-size: 2rem;
    color: var(--color-accent);
    animation: pulse 3s infinite;
}

.logo h1 {
    font-size: 1.5rem;
    background: linear-gradient(45deg, var(--color-primary), var(--color-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight: 800;
}

.nav-menu {
    display: flex;
    gap: var(--spacing-sm);
    align-items: center;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    padding: var(--spacing-xs) 0;
}

.nav-menu::-webkit-scrollbar {
    display: none;
}

.nav-item {
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-fast);
    white-space: nowrap;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
}

.nav-item:hover {
    background: rgba(78, 205, 196, 0.1);
    border-color: var(--color-accent);
    transform: translateY(-2px);
}

.nav-item.active {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    border-color: var(--color-accent);
    color: white;
}

.nav-item.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}

.nav-item.game-minimized {
    opacity: 0.8;
    cursor: pointer;
    pointer-events: auto;
    border: 1px dashed rgba(78, 205, 196, 0.5);
}

.live-indicator {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    padding: var(--spacing-xs) var(--spacing-sm);
    background: linear-gradient(135deg, var(--color-success), #27ae60);
    border-radius: var(--radius-pill);
    color: white;
    font-size: 0.8rem;
    font-weight: 600;
    flex-shrink: 0;
}

.pulse-dot {
    width: 8px;
    height: 8px;
    background: white;
    border-radius: 50%;
    animation: pulse 1.5s infinite;
}

.wallet-section {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    flex-shrink: 0;
}

.wallet-info {
    text-align: right;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    font-size: 0.85rem;
    margin-bottom: var(--spacing-xs);
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.status-indicator.online {
    background: var(--color-success);
    animation: pulse 2s infinite;
}

.status-indicator.offline {
    background: var(--color-danger);
}

.status-indicator.pending {
    background: var(--color-warning);
    animation: blink 1s infinite;
}

.balance {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-accent);
    font-family: 'Courier New', monospace;
}

/* ===========================
   MAIN LAYOUT
   =========================== */
.main-container {
    display: flex;
    min-height: calc(100vh - 80px);
    max-width: 1400px;
    margin: 0 auto;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
}

.sidebar {
    width: 320px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.sidebar::-webkit-scrollbar {
    width: 6px;
}

.sidebar::-webkit-scrollbar-track {
    background: var(--bg-surface);
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.5);
}

.content-area {
    flex: 1;
    min-width: 0;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.content-area::-webkit-scrollbar {
    width: 6px;
}

.content-area::-webkit-scrollbar-track {
    background: var(--bg-surface);
    border-radius: 3px;
}

.content-area::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 3px;
}

.content-area::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.5);
}

.section-content {
    display: none;
    animation: fadeIn var(--transition-normal) ease-out;
}

.section-content.active {
    display: block;
}

/* ===========================
   WIDGET SYSTEM
   =========================== */
.widget {
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    transition: all var(--transition-fast);
}

.widget:hover {
    border-color: var(--border-accent);
    box-shadow: var(--shadow-sm);
}

.widget-header {
    padding: var(--spacing-md);
    background: rgba(78, 205, 196, 0.05);
    border-bottom: 1px solid var(--border-primary);
}

.widget-header h3 {
    margin: 0;
    font-size: 1rem;
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.widget-content {
    padding: var(--spacing-md);
}

/* Contract Widget */
.contract-address {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    background: var(--bg-primary);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
}

.address-text {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: var(--text-secondary);
    flex: 1;
    word-break: break-all;
}

.contract-status,
.server-status {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    font-size: 0.9rem;
}

.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--bg-primary);
    border-radius: var(--radius-pill);
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--color-accent), var(--color-primary));
    width: 0%;
    transition: width var(--transition-normal);
    border-radius: var(--radius-pill);
}

/* Server Widget */
.server-details {
    margin: var(--spacing-sm) 0;
}

.detail-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xs) 0;
    font-size: 0.85rem;
}

.detail-label {
    color: var(--text-muted);
}

.detail-value {
    color: var(--color-accent);
    font-weight: 500;
}

/* Stats Widget */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: var(--spacing-md);
}

.stat-item {
    text-align: center;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-accent);
    display: block;
    line-height: 1;
}

.stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: var(--spacing-xs);
    line-height: 1.2;
}

/* My Games Widget */
.my-games-list {
    max-height: 200px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.my-games-list::-webkit-scrollbar {
    width: 4px;
}

.my-games-list::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

.my-games-list::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 2px;
}

.my-game-item {
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
}

.my-game-item:hover {
    background: rgba(78, 205, 196, 0.05);
    border-color: var(--color-accent);
    transform: translateX(2px);
}

.my-game-item:last-child {
    margin-bottom: 0;
}

.no-games {
    text-align: center;
    padding: var(--spacing-xl);
    color: var(--text-muted);
}

.no-games i {
    font-size: 2rem;
    margin-bottom: var(--spacing-sm);
    opacity: 0.5;
}

/* Activity Widget */
.activity-feed {
    max-height: 150px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.activity-feed::-webkit-scrollbar {
    width: 4px;
}

.activity-feed::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

.activity-feed::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 2px;
}

.activity-item {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-xs) 0;
    font-size: 0.85rem;
    color: var(--text-secondary);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.activity-item:last-child {
    border-bottom: none;
}

.activity-item i {
    color: var(--color-accent);
    width: 16px;
    flex-shrink: 0;
}

/* ===========================
   CONTENT SECTIONS
   =========================== */
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-xl);
    padding-bottom: var(--spacing-md);
    border-bottom: 1px solid var(--border-primary);
}

.section-header h2 {
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: var(--spacing-lg);
    padding: var(--spacing-md) 0;
}

.game-card {
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    transition: all var(--transition-fast);
    cursor: pointer;
}

.game-card:hover {
    border-color: var(--color-accent);
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
}

.game-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-md);
    background: rgba(78, 205, 196, 0.05);
    border-bottom: 1px solid var(--border-primary);
}

.game-type {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-weight: 600;
    color: var(--color-accent);
}

.game-skill {
    font-size: 0.85rem;
    font-weight: 500;
}

.game-card-body {
    padding: var(--spacing-md);
}

.game-stake {
    text-align: center;
    margin-bottom: var(--spacing-md);
}

.stake-amount {
    display: block;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-accent);
    font-family: 'Courier New', monospace;
}

.stake-label {
    font-size: 0.8rem;
    color: var(--text-muted);
}

.game-info {
    margin-bottom: var(--spacing-md);
}

.info-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xs) 0;
    font-size: 0.9rem;
}

.info-label {
    color: var(--text-muted);
}

.info-value {
    color: var(--text-primary);
    font-weight: 500;
}

.game-card-footer {
    padding: var(--spacing-md);
    padding-top: 0;
}

/* ===========================
   ANIMATIONS & KEYFRAMES
   =========================== */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideInRight {
    from {
        opacity: 0;
        transform: translateX(100%);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes slideInScale {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes pulse {
    0%, 100% { 
        transform: scale(1); 
        opacity: 1; 
    }
    50% { 
        transform: scale(1.05); 
        opacity: 0.8; 
    }
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ===========================
   RESPONSIVE DESIGN
   =========================== */
@media (max-width: 1024px) {
    .main-container {
        flex-direction: column;
        gap: var(--spacing-md);
    }
    
    .sidebar {
        width: 100%;
        max-height: none;
        order: 2;
    }
    
    .content-area {
        order: 1;
        max-height: none;
    }
    
    .header-content {
        flex-wrap: wrap;
        gap: var(--spacing-sm);
    }
    
    .wallet-section {
        order: -1;
        width: 100%;
        justify-content: space-between;
    }
}

@media (max-width: 768px) {
    .main-container {
        padding: var(--spacing-sm);
    }
    
    .header {
        padding: var(--spacing-sm);
    }
    
    .header-content {
        flex-direction: column;
        align-items: stretch;
        gap: var(--spacing-sm);
    }
    
    .logo {
        justify-content: center;
    }
    
    .nav-menu {
        justify-content: center;
        overflow-x: auto;
        padding: var(--spacing-sm) 0;
    }
    
    .wallet-section {
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .notification-container {
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        max-width: none;
    }
    
    .modal-content {
        margin: var(--spacing-md);
        max-width: none;
    }
}

@media (max-width: 480px) {
    .logo h1 {
        font-size: 1.2rem;
    }
    
    .logo-icon {
        font-size: 1.5rem;
    }
    
    .nav-item {
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 0.8rem;
    }
    
    .btn {
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 0.8rem;
    }
    
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .captcha-grid {
        max-width: 180px;
    }
    
    .captcha-tile {
        font-size: 1.2rem;
    }
}
</style>
<script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   CORE JAVASCRIPT - STATE MANAGEMENT & SECURITY LAYER (FIXED)
   =========================== */

'use strict';

// ===========================
// CONSTANTS & CONFIGURATION
// ===========================

const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = "0x45c"; // Core Blockchain Chain ID
const JSONBIN_API_KEY = '$2a$10$GtV1/gAxPuNYbKEoKNghTu9NiX3OyvrEw6ir4vJA2Nu/U7KGAnkC6';
const JSONBIN_ACCESS_KEY = '$2a$10$Ppx.2Z91xbnEF57ad1FmZOIkkmy.0QJbB8b1.IP561Z.px8smIRBe';
const JSONBIN_BIN_ID = '686ea4c0c264cf03d2e83902';
const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

// Smart Contract ABI (Enhanced for real token games)
const GAME_CONTRACT_ABI = [
    "function createGame(string memory gameType, uint256 timeLimit) external payable returns (uint256)",
    "function joinGame(uint256 gameId) external payable",
    "function submitMove(uint256 gameId, bytes memory moveData) external",
    "function finalizeGame(uint256 gameId, address winner) external",
    "function claimWinnings(uint256 gameId) external",
    "function refundStake(uint256 gameId) external",
    "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint256 status, string memory gameType)",
    "function getTotalGames() external view returns (uint256)",
    "function getPlayerGames(address player) external view returns (uint256[] memory)",
    "function owner() external view returns (address)",
    "function paused() external view returns (bool)",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint256 stake, string gameType)",
    "event GameJoined(uint256 indexed gameId, address indexed player)",
    "event GameFinalized(uint256 indexed gameId, address indexed winner, uint256 payout)",
    "event MoveSubmitted(uint256 indexed gameId, address indexed player, bytes moveData)"
];

// ===========================
// SECURE CONFIGURATION MANAGER
// ===========================

class ConfigManager {
    constructor() {
        this.config = {
            // Blockchain Configuration
            CORE_CHAIN_ID: '0x45c',
            CORE_RPC_URL: 'https://rpc.coredao.org',
            CORE_EXPLORER_URL: 'https://scan.coredao.org',
            CONTRACT_ADDRESS: GAME_CONTRACT_ADDRESS,
            
            // API Configuration
            API_BASE_URL: '/api',
            JSONBIN_URL: JSONBIN_URL,
            JSONBIN_API_KEY: JSONBIN_API_KEY,
            JSONBIN_ACCESS_KEY: JSONBIN_ACCESS_KEY,
            
            // Rate Limiting
            MAX_REQUESTS_PER_MINUTE: 30,
            MAX_GAMES_PER_HOUR: 10,
            MAX_TRANSACTIONS_PER_MINUTE: 5,
            
            // Security Settings
            ENABLE_ANTI_BOT: true,
            ENABLE_RATE_LIMITING: true,
            ENABLE_INPUT_VALIDATION: true,
            SESSION_TIMEOUT: 30 * 60 * 1000, // 30 minutes
            
            // Game Settings
            MIN_STAKE_AMOUNT: 0.01,
            MAX_STAKE_AMOUNT: 100,
            PLATFORM_FEE_PERCENTAGE: 3,
            
            // Performance Settings
            MAX_CHAT_MESSAGES: 100,
            MAX_ACTIVITY_ITEMS: 20,
            CLEANUP_INTERVAL: 5 * 60 * 1000, // 5 minutes
            
            // Development mode settings
            DEV_MODE: false,
            BYPASS_VERIFICATION: false,
            DEBUG_LOGGING: true
        };
    }
    
    get(key) {
        return this.config[key];
    }
    
    set(key, value) {
        if (this.config.hasOwnProperty(key)) {
            this.config[key] = value;
        } else {
            throw new Error(`Configuration key '${key}' does not exist`);
        }
    }
}

// Global Configuration Instance
const Config = new ConfigManager();

// ===========================
// ENHANCED ERROR HANDLING SYSTEM
// ===========================

class GameError extends Error {
    constructor(message, code = 'GAME_ERROR', details = {}) {
        super(message);
        this.name = 'GameError';
        this.code = code;
        this.details = details;
        this.timestamp = new Date().toISOString();
        this.stack = (new Error()).stack;
    }
}

class ErrorManager {
    constructor() {
        this.errorLog = [];
        this.maxErrors = 50;
        this.setupGlobalErrorHandlers();
    }
    
    setupGlobalErrorHandlers() {
        window.addEventListener('error', (event) => {
            this.logError(new GameError(
                event.message,
                'RUNTIME_ERROR',
                {
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    stack: event.error?.stack
                }
            ));
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            this.logError(new GameError(
                'Unhandled Promise Rejection',
                'PROMISE_ERROR',
                { reason: event.reason }
            ));
            event.preventDefault();
        });
    }
    
    logError(error, context = 'Unknown') {
        const errorEntry = {
            id: Date.now() + Math.random(),
            error: error,
            context: context,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href,
            userAccount: StateManager.get('userAccount')
        };
        
        this.errorLog.push(errorEntry);
        
        // Keep only recent errors
        if (this.errorLog.length > this.maxErrors) {
            this.errorLog = this.errorLog.slice(-this.maxErrors);
        }
        
        if (Config.get('DEBUG_LOGGING')) {
            console.error('🚨 Game Error:', errorEntry);
        }
        
        // Send to analytics if available
        if (typeof gtag !== 'undefined') {
            gtag('event', 'exception', {
                description: `${context}: ${error.message}`,
                fatal: false
            });
        }
        
        // Show user-friendly notification for critical errors
        if (error.code === 'RUNTIME_ERROR' || error.code === 'BLOCKCHAIN_ERROR') {
            if (window.NotificationManager) {
                NotificationManager.show(
                    'System Error',
                    'Something went wrong. Please try again.',
                    'error',
                    5000
                );
            }
        }
    }
    
    getRecentErrors(count = 10) {
        return this.errorLog.slice(-count);
    }
    
    clearErrors() {
        this.errorLog = [];
    }
}

// ===========================
// ENHANCED STATE MANAGEMENT SYSTEM
// ===========================

class StateManager {
    constructor() {
        this.state = new Map();
        this.listeners = new Map();
        this.initialized = false;
        
        // Initialize default state
        this.initializeDefaultState();
    }
    
    initializeDefaultState() {
        const defaultState = {
            // User State
            userAccount: null,
            userBalance: 0,
            isWalletConnected: false,
            walletProvider: null,
            
            // Platform State
            currentSection: 'lobby',
            isLoading: false,
            isServerConnected: false,
            serverLatency: 0,
            lastSyncTime: null,
            
            // Verification states
            isAgeVerified: false,
            isAntiBotVerified: false,
            isPlatformInitialized: false,
            initializationStartTime: Date.now(),
            
            // Game State
            activeGames: new Map(),
            myActiveGames: new Map(),
            gameInvitations: new Map(),
            currentGameSessions: new Map(),
            selectedGameType: null,
            
            // Settings
            platformSettings: {
                autoJoin: false,
                soundEnabled: true,
                animationsEnabled: true,
                defaultStake: 0.1,
                gameInvites: true,
                txNotifications: true,
                chatNotifications: false,
                hideBalance: false,
                developerMode: false,
                realTimeSync: true
            },
            
            // Player Stats
            playerStats: {
                gamesPlayed: 0,
                gamesWon: 0,
                totalEarned: 0,
                winRate: 0
            },
            
            // Skill Ratings
            skillRatings: {
                chess: 100,
                checkers: 100,
                words: 100
            }
        };
        
        // Set default state
        Object.entries(defaultState).forEach(([key, value]) => {
            this.state.set(key, value);
        });
        
        this.initialized = true;
    }
    
    get(key) {
        if (!this.state.has(key)) {
            console.warn(`State key '${key}' does not exist`);
            return null;
        }
        return this.state.get(key);
    }
    
    set(key, value) {
        const oldValue = this.state.get(key);
        this.state.set(key, value);
        
        // Notify listeners
        if (this.listeners.has(key)) {
            this.listeners.get(key).forEach(callback => {
                try {
                    callback(value, oldValue);
                } catch (error) {
                    ErrorManager.logError(error, `State listener for ${key}`);
                }
            });
        }
        
        // Auto-save certain state changes
        if (['platformSettings', 'playerStats', 'skillRatings'].includes(key)) {
            this.saveToStorage(key, value);
        }
        
        // Log important state changes
        if (Config.get('DEBUG_LOGGING')) {
            console.log(`📊 State: ${key} = ${value}`);
        }
    }
    
    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, new Set());
        }
        this.listeners.get(key).add(callback);
        
        // Return unsubscribe function
        return () => {
            if (this.listeners.has(key)) {
                this.listeners.get(key).delete(callback);
            }
        };
    }
    
    update(key, updater) {
        const currentValue = this.get(key);
        const newValue = updater(currentValue);
        this.set(key, newValue);
    }
    
    saveToStorage(key, value) {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                const storageKey = `crossrealm_${key}_${userAccount}`;
                localStorage.setItem(storageKey, JSON.stringify(value));
            }
        } catch (error) {
            console.warn('Failed to save to storage:', error);
        }
    }
    
    loadFromStorage(key) {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                const storageKey = `crossrealm_${key}_${userAccount}`;
                const stored = localStorage.getItem(storageKey);
                if (stored) {
                    return JSON.parse(stored);
                }
            }
        } catch (error) {
            console.warn('Failed to load from storage:', error);
        }
        return null;
    }
    
    clearUserData() {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                ['platformSettings', 'playerStats', 'skillRatings'].forEach(key => {
                    const storageKey = `crossrealm_${key}_${userAccount}`;
                    localStorage.removeItem(storageKey);
                });
            }
        } catch (error) {
            console.warn('Failed to clear user data:', error);
        }
    }
    
    getSnapshot() {
        const snapshot = {};
        this.state.forEach((value, key) => {
            snapshot[key] = value;
        });
        return snapshot;
    }
    
    // Emergency reset for development
    emergencyReset() {
        console.warn('🚨 Emergency state reset triggered');
        sessionStorage.clear();
        this.state.clear();
        this.initializeDefaultState();
        window.location.reload();
    }
}

// Global State Manager Instance
const StateManager = new StateManager();

// ===========================
// ENHANCED SECURITY MANAGER
// ===========================

class SecurityManager {
    constructor() {
        this.requestCounts = new Map();
        this.suspiciousActivity = 0;
        this.blockedIPs = new Set();
        this.sessionStartTime = Date.now();
        
        this.setupSecurityMonitoring();
    }
    
    setupSecurityMonitoring() {
        // Monitor for developer tools (only if not in dev mode)
        if (!Config.get('DEV_MODE')) {
            this.monitorDevTools();
        }
        
        // Monitor for suspicious key combinations
        this.monitorKeyboardEvents();
        
        // Monitor for page visibility changes
        this.monitorPageVisibility();
        
        // Periodic security checks
        setInterval(() => {
            this.performSecurityCheck();
        }, 60000); // Every minute
    }
    
    monitorDevTools() {
        const threshold = 160;
        let devToolsOpen = false;
        
        setInterval(() => {
            const widthThreshold = window.outerWidth - window.innerWidth > threshold;
            const heightThreshold = window.outerHeight - window.innerHeight > threshold;
            
            if ((widthThreshold || heightThreshold) && !devToolsOpen) {
                devToolsOpen = true;
                this.handleDevToolsDetection();
            } else if (!widthThreshold && !heightThreshold && devToolsOpen) {
                devToolsOpen = false;
            }
        }, 500);
    }
    
    monitorKeyboardEvents() {
        document.addEventListener('keydown', (event) => {
            const isDeveloperMode = StateManager.get('platformSettings')?.developerMode || Config.get('DEV_MODE');
            
            if (!isDeveloperMode) {
                // Block common developer tools shortcuts
                if ((event.ctrlKey || event.metaKey) && 
                    ['I', 'J', 'U', 'K'].includes(event.key.toUpperCase())) {
                    event.preventDefault();
                    this.logSuspiciousActivity('Developer tools access attempt');
                }
                
                // Block F12
                if (event.key === 'F12') {
                    event.preventDefault();
                    this.logSuspiciousActivity('F12 developer tools attempt');
                }
            }
        });
        
        // Prevent right-click in production
        document.addEventListener('contextmenu', (event) => {
            const isDeveloperMode = StateManager.get('platformSettings')?.developerMode || Config.get('DEV_MODE');
            if (!isDeveloperMode) {
                event.preventDefault();
            }
        });
    }
    
    monitorPageVisibility() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden - pause sensitive operations
                this.pauseSensitiveOperations();
            } else {
                // Page is visible - resume operations
                this.resumeSensitiveOperations();
            }
        });
    }
    
    handleDevToolsDetection() {
        const isDeveloperMode = StateManager.get('platformSettings')?.developerMode || Config.get('DEV_MODE');
        
        if (!isDeveloperMode) {
            this.logSuspiciousActivity('Developer tools detected');
            
            const activeGames = StateManager.get('currentGameSessions');
            if (activeGames && activeGames.size > 0 && window.NotificationManager) {
                NotificationManager.show(
                    'Security Alert',
                    'Developer tools detected during active game. Game paused for security.',
                    'warning',
                    0
                );
                
                // Pause active games
                this.pauseActiveGames();
            }
        }
    }
    
    checkRateLimit(action, limit = null, window = 60000) {
        if (!Config.get('ENABLE_RATE_LIMITING')) {
            return true;
        }
        
        // Use default limits based on action type
        if (!limit) {
            const limits = {
                'api_request': Config.get('MAX_REQUESTS_PER_MINUTE'),
                'game_creation': Config.get('MAX_GAMES_PER_HOUR') / 60,
                'transaction': Config.get('MAX_TRANSACTIONS_PER_MINUTE'),
                'default': 10
            };
            limit = limits[action] || limits.default;
        }
        
        const now = Date.now();
        const userAccount = StateManager.get('userAccount') || 'anonymous';
        const key = `${action}_${userAccount}`;
        
        if (!this.requestCounts.has(key)) {
            this.requestCounts.set(key, []);
        }
        
        const requests = this.requestCounts.get(key);
        
        // Remove old requests outside the window
        const validRequests = requests.filter(time => now - time < window);
        
        if (validRequests.length >= limit) {
            this.logSuspiciousActivity(`Rate limit exceeded for ${action}`);
            return false;
        }
        
        validRequests.push(now);
        this.requestCounts.set(key, validRequests);
        
        return true;
    }
    
    validateInput(input, type, options = {}) {
        if (!Config.get('ENABLE_INPUT_VALIDATION')) {
            return { valid: true, sanitized: input };
        }
        
        try {
            switch (type) {
                case 'stake_amount':
                    return this.validateStakeAmount(input);
                case 'game_type':
                    return this.validateGameType(input);
                case 'wallet_address':
                    return this.validateWalletAddress(input);
                case 'string':
                    return this.validateString(input, options);
                case 'number':
                    return this.validateNumber(input, options);
                default:
                    return { valid: false, error: 'Unknown validation type' };
            }
        } catch (error) {
            ErrorManager.logError(error, 'Input validation');
            return { valid: false, error: 'Validation error' };
        }
    }
    
    validateStakeAmount(amount) {
        const numAmount = parseFloat(amount);
        
        if (isNaN(numAmount)) {
            return { valid: false, error: 'Stake amount must be a number' };
        }
        
        if (numAmount < Config.get('MIN_STAKE_AMOUNT')) {
            return { valid: false, error: `Minimum stake is ${Config.get('MIN_STAKE_AMOUNT')} CORE` };
        }
        
        if (numAmount > Config.get('MAX_STAKE_AMOUNT')) {
            return { valid: false, error: `Maximum stake is ${Config.get('MAX_STAKE_AMOUNT')} CORE` };
        }
        
        return { valid: true, sanitized: numAmount };
    }
    
    validateGameType(gameType) {
        const validTypes = ['chess', 'checkers', 'words'];
        
        if (!validTypes.includes(gameType)) {
            return { valid: false, error: 'Invalid game type' };
        }
        
        return { valid: true, sanitized: gameType };
    }
    
    validateWalletAddress(address) {
        if (typeof address !== 'string') {
            return { valid: false, error: 'Address must be a string' };
        }
        
        if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            return { valid: false, error: 'Invalid wallet address format' };
        }
        
        return { valid: true, sanitized: address.toLowerCase() };
    }
    
    validateString(input, options = {}) {
        const {
            minLength = 0,
            maxLength = 1000,
            allowHTML = false,
            allowSpecialChars = true
        } = options;
        
        if (typeof input !== 'string') {
            return { valid: false, error: 'Input must be a string' };
        }
        
        if (input.length < minLength) {
            return { valid: false, error: `Minimum length is ${minLength}` };
        }
        
        if (input.length > maxLength) {
            return { valid: false, error: `Maximum length is ${maxLength}` };
        }
        
        let sanitized = input;
        
        if (!allowHTML) {
            sanitized = sanitized.replace(/[<>]/g, '');
        }
        
        if (!allowSpecialChars) {
            sanitized = sanitized.replace(/[^\w\s]/g, '');
        }
        
        return { valid: true, sanitized: sanitized.trim() };
    }
    
    validateNumber(input, options = {}) {
        const {
            min = -Infinity,
            max = Infinity,
            integer = false
        } = options;
        
        const num = Number(input);
        
        if (isNaN(num)) {
            return { valid: false, error: 'Input must be a number' };
        }
        
        if (integer && !Number.isInteger(num)) {
            return { valid: false, error: 'Input must be an integer' };
        }
        
        if (num < min) {
            return { valid: false, error: `Minimum value is ${min}` };
        }
        
        if (num > max) {
            return { valid: false, error: `Maximum value is ${max}` };
        }
        
        return { valid: true, sanitized: num };
    }
    
    logSuspiciousActivity(activity) {
        this.suspiciousActivity++;
        
        const logEntry = {
            activity,
            timestamp: new Date().toISOString(),
            userAccount: StateManager.get('userAccount'),
            userAgent: navigator.userAgent,
            url: window.location.href,
            suspiciousCount: this.suspiciousActivity
        };
        
        if (Config.get('DEBUG_LOGGING')) {
            console.warn('🚨 Suspicious Activity:', logEntry);
        }
        
        ErrorManager.logError(
            new GameError('Suspicious activity detected', 'SECURITY_ALERT', logEntry),
            'Security'
        );
        
        if (this.suspiciousActivity >= 5 && window.NotificationManager) {
            NotificationManager.show(
                'Security Warning',
                'Multiple security alerts detected. Account may be temporarily restricted.',
                'error',
                0
            );
        }
    }
    
    pauseSensitiveOperations() {
        // Implementation for pausing sensitive operations
        if (Config.get('DEBUG_LOGGING')) {
            console.log('🛡️ Pausing sensitive operations');
        }
    }
    
    resumeSensitiveOperations() {
        // Implementation for resuming sensitive operations
        if (Config.get('DEBUG_LOGGING')) {
            console.log('🛡️ Resuming sensitive operations');
        }
    }
    
    pauseActiveGames() {
        const activeGames = StateManager.get('currentGameSessions');
        if (activeGames) {
            activeGames.forEach((session, gameId) => {
                if (session.syncInterval) {
                    clearInterval(session.syncInterval);
                    session.paused = true;
                }
            });
        }
    }
    
    performSecurityCheck() {
        // Check session timeout
        const sessionAge = Date.now() - this.sessionStartTime;
        const sessionTimeout = Config.get('SESSION_TIMEOUT');
        
        if (sessionAge > sessionTimeout) {
            this.handleSessionTimeout();
        }
        
        // Clean up old rate limit entries
        this.cleanupRateLimits();
    }
    
    handleSessionTimeout() {
        if (window.NotificationManager) {
            NotificationManager.show(
                'Session Expired',
                'Your session has expired for security. Please reconnect your wallet.',
                'warning',
                0
            );
        }
        
        // Disconnect wallet and clear sensitive data
        if (window.WalletManager) {
            WalletManager.disconnect();
        }
    }
    
    cleanupRateLimits() {
        const now = Date.now();
        const window = 3600000; // 1 hour
        
        this.requestCounts.forEach((requests, key) => {
            const validRequests = requests.filter(time => now - time < window);
            if (validRequests.length === 0) {
                this.requestCounts.delete(key);
            } else {
                this.requestCounts.set(key, validRequests);
            }
        });
    }
}

// ===========================
// ENHANCED NOTIFICATION MANAGER
// ===========================

class NotificationManager {
    constructor() {
        this.notifications = new Map();
        this.container = null;
        this.maxNotifications = 5;
        
        // Initialize after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initialize());
        } else {
            this.initialize();
        }
    }
    
    initialize() {
        this.container = document.getElementById('notificationContainer');
        if (!this.container) {
            console.warn('Notification container not found');
        }
    }
    
    show(title, message, type = 'info', duration = 5000, actions = null) {
        // Fallback if container not ready
        if (!this.container) {
            console.log(`Notification: ${title} - ${message}`);
            return null;
        }
        
        const id = Date.now() + Math.random();
        const notification = this.createNotificationElement(id, title, message, type, actions);
        
        // Limit number of notifications
        if (this.notifications.size >= this.maxNotifications) {
            const oldestId = this.notifications.keys().next().value;
            this.remove(oldestId);
        }
        
        this.notifications.set(id, notification);
        this.container.appendChild(notification);
        
        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(() => {
                this.remove(id);
            }, duration);
        }
        
        return id;
    }
    
    createNotificationElement(id, title, message, type, actions) {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.id = `notification-${id}`;
        notification.dataset.created = Date.now().toString();
        
        const iconMap = {
            info: 'fas fa-info-circle',
            success: 'fas fa-check-circle',
            warning: 'fas fa-exclamation-triangle',
            error: 'fas fa-times-circle'
        };
        
        notification.innerHTML = `
            <div class="notification-header">
                <div class="notification-title">
                    <i class="${iconMap[type]}"></i>
                    ${this.escapeHtml(title)}
                </div>
                <button class="notification-close" onclick="NotificationManager.remove('${id}')">
                    &times;
                </button>
            </div>
            <div class="notification-message">
                ${this.escapeHtml(message)}
            </div>
            ${actions ? `<div class="notification-actions">${actions}</div>` : ''}
        `;
        
        return notification;
    }
    
    remove(id) {
        const notification = this.notifications.get(id);
        if (notification && notification.parentNode) {
            notification.style.animation = 'slideInRight 0.3s ease-out reverse';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                this.notifications.delete(id);
            }, 300);
        }
    }
    
    clear() {
        this.notifications.forEach((notification, id) => {
            this.remove(id);
        });
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// ===========================
// PERFORMANCE MONITOR
// ===========================

class PerformanceMonitor {
    constructor() {
        this.metrics = new Map();
        this.observers = new Map();
        this.startTime = performance.now();
        
        this.setupPerformanceObservers();
    }
    
    setupPerformanceObservers() {
        try {
            // Monitor long tasks
            if ('PerformanceObserver' in window) {
                const longTaskObserver = new PerformanceObserver((list) => {
                    list.getEntries().forEach((entry) => {
                        if (entry.duration > 50) {
                            if (Config.get('DEBUG_LOGGING')) {
                                console.warn(`⚠️ Long task: ${entry.duration.toFixed(2)}ms`);
                            }
                            
                            ErrorManager.logError(
                                new GameError(
                                    `Long task detected: ${entry.duration}ms`,
                                    'PERFORMANCE_WARNING'
                                ),
                                'Performance'
                            );
                        }
                    });
                });
                
                longTaskObserver.observe({ entryTypes: ['longtask'] });
                this.observers.set('longtask', longTaskObserver);
            }
        } catch (error) {
            console.warn('Performance observers not supported:', error);
        }
    }
    
    startMeasure(name) {
        this.metrics.set(name, performance.now());
        return name;
    }
    
    endMeasure(name) {
        const startTime = this.metrics.get(name);
        if (startTime) {
            const duration = performance.now() - startTime;
            this.metrics.delete(name);
            
            if (Config.get('DEBUG_LOGGING')) {
                console.log(`📊 ${name}: ${duration.toFixed(2)}ms`);
            }
            
            // Log slow operations
            if (duration > 1000) {
                console.warn(`⚠️ Slow operation: ${name} took ${duration.toFixed(2)}ms`);
            }
            
            return duration;
        }
        return null;
    }
    
    getMemoryUsage() {
        if ('memory' in performance) {
            return {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
            };
        }
        return null;
    }
    
    cleanup() {
        this.observers.forEach(observer => observer.disconnect());
        this.observers.clear();
        this.metrics.clear();
    }
}

// ===========================
// ENHANCED UTILITY FUNCTIONS
// ===========================

class Utils {
    static async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    static throttle(func, limit) {
        let inThrottle;
        return function executedFunction(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    static formatCurrency(amount, decimals = 4) {
        return parseFloat(amount).toFixed(decimals);
    }
    
    static formatTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);
        
        if (seconds < 60) return `${seconds}s ago`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
        return `${Math.floor(seconds / 86400)}d ago`;
    }
    
    static generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    static copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            return navigator.clipboard.writeText(text);
        } else {
            return this.fallbackCopyToClipboard(text);
        }
    }
    
    static fallbackCopyToClipboard(text) {
        return new Promise((resolve, reject) => {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);
                if (successful) {
                    resolve();
                } else {
                    reject(new Error('Copy command failed'));
                }
            } catch (err) {
                document.body.removeChild(textArea);
                reject(err);
            }
        });
    }
    
    static validateEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }
    
    static sanitizeHtml(html) {
        const div = document.createElement('div');
        div.textContent = html;
        return div.innerHTML;
    }
    
    static isOnline() {
        return navigator.onLine;
    }
    
    static isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    
    static getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    static shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
    
    // Emergency helpers for development
    static emergencyBypass() {
        console.warn('🚨 Emergency bypass triggered');
        Config.set('DEV_MODE', true);
        Config.set('BYPASS_VERIFICATION', true);
        sessionStorage.setItem('ageVerified', 'true');
        sessionStorage.setItem('antiBotVerified', 'true');
        StateManager.set('isAgeVerified', true);
        StateManager.set('isAntiBotVerified', true);
        
        // Trigger platform initialization
        if (window.PlatformManager) {
            PlatformManager.initializePlatform();
        }
    }
    
    static getInitializationTime() {
        const startTime = StateManager.get('initializationStartTime');
        return Date.now() - startTime;
    }
}

// ===========================
// LIFECYCLE MANAGER
// ===========================

class LifecycleManager {
    constructor() {
        this.cleanupTasks = new Set();
        this.setupLifecycleHandlers();
        this.initializationTimer = null;
        this.setupEmergencyHandlers();
    }
    
    setupLifecycleHandlers() {
        window.addEventListener('beforeunload', () => {
            this.performCleanup();
        });
        
        window.addEventListener('pagehide', () => {
            this.performCleanup();
        });
        
        // Periodic cleanup
        setInterval(() => {
            this.performPeriodicCleanup();
        }, Config.get('CLEANUP_INTERVAL'));
    }
    
    // Setup emergency handlers for stuck initialization
    setupEmergencyHandlers() {
        // Start initialization timer
        this.initializationTimer = setTimeout(() => {
            this.handleStuckInitialization();
        }, 30000); // 30 seconds timeout
        
        // Show emergency bypass after 10 seconds if not initialized
        setTimeout(() => {
            this.showEmergencyBypass();
        }, 10000);
    }
    
    handleStuckInitialization() {
        if (!StateManager.get('isPlatformInitialized')) {
            console.error('🚨 Platform initialization appears to be stuck');
            
            const debugInfo = {
                ageVerified: StateManager.get('isAgeVerified'),
                antiBotVerified: StateManager.get('isAntiBotVerified'),
                platformInitialized: StateManager.get('isPlatformInitialized'),
                initTime: Utils.getInitializationTime(),
                errors: ErrorManager.getRecentErrors(5)
            };
            
            console.log('🔍 Debug info:', debugInfo);
            
            // Show emergency bypass
            this.showEmergencyBypass(true);
        }
    }
    
    showEmergencyBypass(force = false) {
        if (!StateManager.get('isPlatformInitialized') || force) {
            const bypassBtn = document.getElementById('emergencyBypass');
            if (bypassBtn) {
                bypassBtn.style.display = 'block';
                bypassBtn.onclick = () => {
                    Utils.emergencyBypass();
                };
            }
        }
    }
    
    clearInitializationTimer() {
        if (this.initializationTimer) {
            clearTimeout(this.initializationTimer);
            this.initializationTimer = null;
        }
    }
    
    addCleanupTask(task) {
        this.cleanupTasks.add(task);
    }
    
    removeCleanupTask(task) {
        this.cleanupTasks.delete(task);
    }
    
    performCleanup() {
        if (Config.get('DEBUG_LOGGING')) {
            console.log('🧹 Performing cleanup...');
        }
        
        try {
            this.cleanupTasks.forEach(task => {
                try {
                    task();
                } catch (error) {
                    console.error('Cleanup task failed:', error);
                }
            });
            
            // Clear intervals and timeouts
            this.clearAllIntervals();
            
            // Disconnect observers
            PerformanceMonitor.cleanup();
            
            this.clearInitializationTimer();
            
            if (Config.get('DEBUG_LOGGING')) {
                console.log('✅ Cleanup completed');
            }
        } catch (error) {
            console.error('❌ Cleanup failed:', error);
        }
    }
    
    performPeriodicCleanup() {
        // Clean up old notifications
        if (window.NotificationManager) {
            NotificationManager.notifications.forEach((notification, id) => {
                const age = Date.now() - parseInt(notification.dataset.created || '0');
                if (age > 300000) { // 5 minutes
                    NotificationManager.remove(id);
                }
            });
        }
        
        // Clean up old errors
        if (ErrorManager.errorLog.length > 20) {
            ErrorManager.errorLog = ErrorManager.errorLog.slice(-20);
        }
        
        // Clean up old metrics
        PerformanceMonitor.metrics.clear();
    }
    
    clearAllIntervals() {
        // Get all interval IDs and clear them
        const intervalId = setInterval(() => {}, 1000);
        for (let i = 1; i <= intervalId; i++) {
            clearInterval(i);
        }
    }
}

// ===========================
// GLOBAL INSTANCES & INITIALIZATION
// ===========================

// Initialize global managers
const ErrorManager = new ErrorManager();
const SecurityManager = new SecurityManager();
const NotificationManager = new NotificationManager();
const PerformanceMonitor = new PerformanceMonitor();
const LifecycleManager = new LifecycleManager();

// Export utilities to global scope for use in other sections
window.StateManager = StateManager;
window.ErrorManager = ErrorManager;
window.SecurityManager = SecurityManager;
window.NotificationManager = NotificationManager;
window.PerformanceMonitor = PerformanceMonitor;
window.LifecycleManager = LifecycleManager;
window.Utils = Utils;
window.Config = Config;
window.GameError = GameError;

// Initialize loading timer in DOM
document.addEventListener('DOMContentLoaded', () => {
    let timerCount = 0;
    const timerInterval = setInterval(() => {
        timerCount++;
        const timerElement = document.getElementById('timerCount');
        if (timerElement) {
            timerElement.textContent = timerCount;
        }
        
        // Auto-bypass after 60 seconds of no progress
        if (timerCount >= 60 && !StateManager.get('isPlatformInitialized')) {
            clearInterval(timerInterval);
            console.warn('🚨 Auto-triggering emergency bypass after 60 seconds');
            Utils.emergencyBypass();
        }
    }, 1000);
    
    // Clear timer when platform initializes
    StateManager.subscribe('isPlatformInitialized', (initialized) => {
        if (initialized) {
            clearInterval(timerInterval);
            LifecycleManager.clearInitializationTimer();
        }
    });
});

console.log('✅ Core JavaScript - State Management & Security (FIXED) Loaded');
</script>
<script>
  /* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 4: BLOCKCHAIN INTEGRATION & WALLET MANAGEMENT
   =========================== */

'use strict';

// ===========================
// BLOCKCHAIN PROVIDER MANAGER
// ===========================

class BlockchainProvider {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.contract = null;
        this.isConnected = false;
        this.chainId = null;
        this.blockNumber = null;
        this.gasPrice = null;
        
        this.setupEventListeners();
        this.startProviderMonitoring();
    }
    
    async initialize() {
        try {
            if (typeof window.ethereum !== 'undefined') {
                this.provider = new ethers.providers.Web3Provider(window.ethereum);
                
                // Listen for account changes
                window.ethereum.on('accountsChanged', (accounts) => {
                    this.handleAccountChange(accounts);
                });
                
                // Listen for chain changes
                window.ethereum.on('chainChanged', (chainId) => {
                    this.handleChainChange(chainId);
                });
                
                // Listen for connection
                window.ethereum.on('connect', (connectInfo) => {
                    this.handleConnect(connectInfo);
                });
                
                // Listen for disconnection
                window.ethereum.on('disconnect', (error) => {
                    this.handleDisconnect(error);
                });
                
                return true;
            } else {
                throw new GameError('No Web3 provider found', 'NO_PROVIDER');
            }
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.initialize');
            return false;
        }
    }
    
    async connect() {
        try {
            if (!this.provider) {
                throw new GameError('Provider not initialized', 'PROVIDER_NOT_INITIALIZED');
            }
            
            // Request account access
            const accounts = await window.ethereum.request({
                method: 'eth_requestAccounts'
            });
            
            if (accounts.length === 0) {
                throw new GameError('No accounts available', 'NO_ACCOUNTS');
            }
            
            // Switch to Core Network if needed
            await this.ensureCorrectNetwork();
            
            // Get signer
            this.signer = this.provider.getSigner();
            const address = await this.signer.getAddress();
            
            // Initialize contract
            this.contract = new ethers.Contract(
                Config.get('CONTRACT_ADDRESS'),
                GAME_CONTRACT_ABI,
                this.signer
            );
            
            // Get network info
            const network = await this.provider.getNetwork();
            this.chainId = network.chainId;
            
            // Get current block
            this.blockNumber = await this.provider.getBlockNumber();
            
            // Get gas price
            this.gasPrice = await this.provider.getGasPrice();
            
            this.isConnected = true;
            
            // Update state
            StateManager.set('userAccount', address);
            StateManager.set('isWalletConnected', true);
            StateManager.set('walletProvider', 'metamask');
            
            // Get balance
            await this.updateBalance();
            
            // Start balance monitoring
            this.startBalanceMonitoring();
            
            return { success: true, address };
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.connect');
            return { success: false, error: error.message };
        }
    }
    
    async ensureCorrectNetwork() {
        try {
            const currentChainId = await window.ethereum.request({
                method: 'eth_chainId'
            });
            
            const targetChainId = Config.get('CORE_CHAIN_ID');
            
            if (currentChainId !== targetChainId) {
                try {
                    // Try to switch to Core Network
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: targetChainId }]
                    });
                } catch (switchError) {
                    // If switch fails, try to add the network
                    if (switchError.code === 4902) {
                        await this.addCoreNetwork();
                    } else {
                        throw switchError;
                    }
                }
            }
        } catch (error) {
            throw new GameError(
                'Failed to switch to Core Network',
                'NETWORK_SWITCH_FAILED',
                { originalError: error }
            );
        }
    }
    
    async addCoreNetwork() {
        try {
            await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                    chainId: Config.get('CORE_CHAIN_ID'),
                    chainName: 'Core Blockchain',
                    rpcUrls: [Config.get('CORE_RPC_URL')],
                    nativeCurrency: {
                        name: 'CORE',
                        symbol: 'CORE',
                        decimals: 18
                    },
                    blockExplorerUrls: [Config.get('CORE_EXPLORER_URL')]
                }]
            });
        } catch (error) {
            throw new GameError(
                'Failed to add Core Network',
                'NETWORK_ADD_FAILED',
                { originalError: error }
            );
        }
    }
    
    async updateBalance() {
        try {
            if (!this.isConnected || !this.signer) return;
            
            const address = await this.signer.getAddress();
            const balance = await this.provider.getBalance(address);
            const balanceInEther = ethers.utils.formatEther(balance);
            
            StateManager.set('userBalance', parseFloat(balanceInEther));
            
            return balanceInEther;
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.updateBalance');
            return null;
        }
    }
    
    startBalanceMonitoring() {
        // Update balance every 30 seconds
        this.balanceInterval = setInterval(async () => {
            await this.updateBalance();
        }, 30000);
        
        LifecycleManager.addCleanupTask(() => {
            if (this.balanceInterval) {
                clearInterval(this.balanceInterval);
            }
        });
    }
    
    startProviderMonitoring() {
        // Monitor provider health every 60 seconds
        this.providerInterval = setInterval(async () => {
            await this.checkProviderHealth();
        }, 60000);
        
        LifecycleManager.addCleanupTask(() => {
            if (this.providerInterval) {
                clearInterval(this.providerInterval);
            }
        });
    }
    
    async checkProviderHealth() {
        try {
            if (!this.provider) return;
            
            const currentBlock = await this.provider.getBlockNumber();
            
            if (currentBlock === this.blockNumber) {
                // Block hasn't changed - might be connection issue
                console.warn('⚠️ Blockchain connection may be stale');
            } else {
                this.blockNumber = currentBlock;
            }
            
            // Update gas price
            this.gasPrice = await this.provider.getGasPrice();
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.checkProviderHealth');
            
            // Try to reconnect if connection lost
            if (this.isConnected) {
                NotificationManager.show(
                    'Connection Issue',
                    'Blockchain connection lost. Attempting to reconnect...',
                    'warning',
                    5000
                );
                
                await this.reconnect();
            }
        }
    }
    
    async reconnect() {
        try {
            this.isConnected = false;
            StateManager.set('isWalletConnected', false);
            
            await Utils.sleep(2000); // Wait 2 seconds
            
            const result = await this.connect();
            
            if (result.success) {
                NotificationManager.show(
                    'Reconnected',
                    'Blockchain connection restored',
                    'success',
                    3000
                );
            }
            
            return result;
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.reconnect');
            return { success: false, error: error.message };
        }
    }
    
    async disconnect() {
        try {
            this.isConnected = false;
            this.provider = null;
            this.signer = null;
            this.contract = null;
            this.chainId = null;
            
            // Clear intervals
            if (this.balanceInterval) {
                clearInterval(this.balanceInterval);
                this.balanceInterval = null;
            }
            
            // Update state
            StateManager.set('userAccount', null);
            StateManager.set('userBalance', 0);
            StateManager.set('isWalletConnected', false);
            StateManager.set('walletProvider', null);
            
            return { success: true };
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.disconnect');
            return { success: false, error: error.message };
        }
    }
    
    setupEventListeners() {
        // Listen for state changes
        StateManager.subscribe('isWalletConnected', (connected) => {
            this.updateConnectionUI(connected);
        });
        
        StateManager.subscribe('userBalance', (balance) => {
            this.updateBalanceUI(balance);
        });
    }
    
    updateConnectionUI(connected) {
        const statusIndicator = document.querySelector('.connection-status .status-indicator');
        const statusText = document.querySelector('.connection-status .status-text');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        
        if (statusIndicator) {
            statusIndicator.className = `status-indicator ${connected ? 'online' : 'offline'}`;
        }
        
        if (statusText) {
            statusText.textContent = connected ? 'Connected' : 'Not Connected';
        }
        
        if (connectBtn) {
            connectBtn.classList.toggle('hidden', connected);
        }
        
        if (disconnectBtn) {
            disconnectBtn.classList.toggle('hidden', !connected);
        }
    }
    
    updateBalanceUI(balance) {
        const balanceDisplay = document.getElementById('balanceDisplay');
        if (balanceDisplay) {
            balanceDisplay.textContent = `${Utils.formatCurrency(balance)} CORE`;
        }
    }
    
    handleAccountChange(accounts) {
        if (accounts.length === 0) {
            // User disconnected wallet
            this.disconnect();
            NotificationManager.show(
                'Wallet Disconnected',
                'Your wallet has been disconnected',
                'warning',
                5000
            );
        } else if (accounts[0] !== StateManager.get('userAccount')) {
            // User switched accounts
            NotificationManager.show(
                'Account Changed',
                'Wallet account has changed. Reconnecting...',
                'info',
                5000
            );
            
            this.reconnect();
        }
    }
    
    handleChainChange(chainId) {
        const targetChainId = Config.get('CORE_CHAIN_ID');
        
        if (chainId !== targetChainId) {
            NotificationManager.show(
                'Wrong Network',
                'Please switch to Core Network to continue playing',
                'warning',
                0
            );
            
            this.disconnect();
        } else {
            NotificationManager.show(
                'Network Connected',
                'Connected to Core Network',
                'success',
                3000
            );
            
            this.reconnect();
        }
    }
    
    handleConnect(connectInfo) {
        console.log('🔗 Wallet connected:', connectInfo);
    }
    
    handleDisconnect(error) {
        console.log('🔌 Wallet disconnected:', error);
        this.disconnect();
        
        NotificationManager.show(
            'Wallet Disconnected',
            'Your wallet connection was lost',
            'error',
            5000
        );
    }
    
    // Smart Contract Methods
    async createGame(gameType, timeLimit, stakeAmount) {
        try {
            if (!SecurityManager.checkRateLimit('game_creation')) {
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT');
            }
            
            const validation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
            if (!validation.valid) {
                throw new GameError(validation.error, 'VALIDATION_ERROR');
            }
            
            const gameTypeValidation = SecurityManager.validateInput(gameType, 'game_type');
            if (!gameTypeValidation.valid) {
                throw new GameError(gameTypeValidation.error, 'VALIDATION_ERROR');
            }
            
            if (!this.contract) {
                throw new GameError('Contract not initialized', 'CONTRACT_NOT_INITIALIZED');
            }
            
            const stakeWei = ethers.utils.parseEther(validation.sanitized.toString());
            
            // Estimate gas
            const gasEstimate = await this.contract.estimateGas.createGame(
                gameTypeValidation.sanitized,
                timeLimit,
                { value: stakeWei }
            );
            
            // Add 20% buffer to gas estimate
            const gasLimit = gasEstimate.mul(120).div(100);
            
            const tx = await this.contract.createGame(
                gameTypeValidation.sanitized,
                timeLimit,
                {
                    value: stakeWei,
                    gasLimit: gasLimit,
                    gasPrice: this.gasPrice
                }
            );
            
            return { success: true, transaction: tx };
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.createGame');
            return { success: false, error: error.message };
        }
    }
    
    async joinGame(gameId, stakeAmount) {
        try {
            if (!SecurityManager.checkRateLimit('transaction')) {
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT');
            }
            
            const validation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
            if (!validation.valid) {
                throw new GameError(validation.error, 'VALIDATION_ERROR');
            }
            
            if (!this.contract) {
                throw new GameError('Contract not initialized', 'CONTRACT_NOT_INITIALIZED');
            }
            
            const stakeWei = ethers.utils.parseEther(validation.sanitized.toString());
            
            const gasEstimate = await this.contract.estimateGas.joinGame(gameId, {
                value: stakeWei
            });
            
            const gasLimit = gasEstimate.mul(120).div(100);
            
            const tx = await this.contract.joinGame(gameId, {
                value: stakeWei,
                gasLimit: gasLimit,
                gasPrice: this.gasPrice
            });
            
            return { success: true, transaction: tx };
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.joinGame');
            return { success: false, error: error.message };
        }
    }
    
    async submitMove(gameId, moveData) {
        try {
            if (!SecurityManager.checkRateLimit('transaction')) {
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT');
            }
            
            if (!this.contract) {
                throw new GameError('Contract not initialized', 'CONTRACT_NOT_INITIALIZED');
            }
            
            const encodedMove = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(JSON.stringify(moveData)));
            
            const gasEstimate = await this.contract.estimateGas.submitMove(gameId, encodedMove);
            const gasLimit = gasEstimate.mul(120).div(100);
            
            const tx = await this.contract.submitMove(gameId, encodedMove, {
                gasLimit: gasLimit,
                gasPrice: this.gasPrice
            });
            
            return { success: true, transaction: tx };
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.submitMove');
            return { success: false, error: error.message };
        }
    }
    
    async finalizeGame(gameId, winner) {
        try {
            if (!SecurityManager.checkRateLimit('transaction')) {
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT');
            }
            
            const addressValidation = SecurityManager.validateInput(winner, 'wallet_address');
            if (!addressValidation.valid) {
                throw new GameError(addressValidation.error, 'VALIDATION_ERROR');
            }
            
            if (!this.contract) {
                throw new GameError('Contract not initialized', 'CONTRACT_NOT_INITIALIZED');
            }
            
            const gasEstimate = await this.contract.estimateGas.finalizeGame(
                gameId,
                addressValidation.sanitized
            );
            
            const gasLimit = gasEstimate.mul(120).div(100);
            
            const tx = await this.contract.finalizeGame(
                gameId,
                addressValidation.sanitized,
                {
                    gasLimit: gasLimit,
                    gasPrice: this.gasPrice
                }
            );
            
            return { success: true, transaction: tx };
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.finalizeGame');
            return { success: false, error: error.message };
        }
    }
    
    async getGame(gameId) {
        try {
            if (!this.contract) {
                throw new GameError('Contract not initialized', 'CONTRACT_NOT_INITIALIZED');
            }
            
            const game = await this.contract.getGame(gameId);
            
            return {
                success: true,
                game: {
                    player1: game[0],
                    player2: game[1],
                    stake: ethers.utils.formatEther(game[2]),
                    status: game[3].toNumber(),
                    gameType: game[4]
                }
            };
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.getGame');
            return { success: false, error: error.message };
        }
    }
    
    async getPlayerGames(playerAddress = null) {
        try {
            if (!this.contract) {
                throw new GameError('Contract not initialized', 'CONTRACT_NOT_INITIALIZED');
            }
            
            const address = playerAddress || await this.signer.getAddress();
            const gameIds = await this.contract.getPlayerGames(address);
            
            return { success: true, gameIds: gameIds.map(id => id.toNumber()) };
            
        } catch (error) {
            ErrorManager.logError(error, 'BlockchainProvider.getPlayerGames');
            return { success: false, error: error.message };
        }
    }
}

// ===========================
// ENHANCED WALLET MANAGER
// ===========================

class WalletManager {
    constructor() {
        this.blockchainProvider = new BlockchainProvider();
        this.connectionAttempts = 0;
        this.maxConnectionAttempts = 3;
        
        this.setupEventHandlers();
    }
    
    async initialize() {
        try {
            const initialized = await this.blockchainProvider.initialize();
            
            if (initialized) {
                // Check if user was previously connected
                this.checkPreviousConnection();
            }
            
            return initialized;
        } catch (error) {
            ErrorManager.logError(error, 'WalletManager.initialize');
            return false;
        }
    }
    
    checkPreviousConnection() {
        // Check if user was connected in a previous session
        const wasConnected = localStorage.getItem('crossrealm_wallet_connected');
        
        if (wasConnected === 'true' && window.ethereum) {
            // Auto-connect if user was previously connected
            setTimeout(() => {
                this.connect();
            }, 1000);
        }
    }
    
    async connect() {
        try {
            this.connectionAttempts++;
            
            if (this.connectionAttempts > this.maxConnectionAttempts) {
                throw new GameError(
                    'Maximum connection attempts exceeded',
                    'MAX_ATTEMPTS_EXCEEDED'
                );
            }
            
            // Check if MetaMask is installed
            if (typeof window.ethereum === 'undefined') {
                this.showInstallMetaMaskModal();
                return { success: false, error: 'MetaMask not found' };
            }
            
            const result = await this.blockchainProvider.connect();
            
            if (result.success) {
                this.connectionAttempts = 0;
                localStorage.setItem('crossrealm_wallet_connected', 'true');
                
                NotificationManager.show(
                    'Wallet Connected',
                    `Connected to ${result.address.substring(0, 6)}...${result.address.substring(38)}`,
                    'success',
                    5000
                );
                
                // Load user settings
                this.loadUserSettings();
                
                // Update UI
                this.updateConnectionStatus(true);
            } else {
                NotificationManager.show(
                    'Connection Failed',
                    result.error,
                    'error',
                    5000
                );
            }
            
            return result;
            
        } catch (error) {
            ErrorManager.logError(error, 'WalletManager.connect');
            
            NotificationManager.show(
                'Connection Error',
                'Failed to connect wallet. Please try again.',
                'error',
                5000
            );
            
            return { success: false, error: error.message };
        }
    }
    
    async disconnect() {
        try {
            const result = await this.blockchainProvider.disconnect();
            
            if (result.success) {
                localStorage.removeItem('crossrealm_wallet_connected');
                
                NotificationManager.show(
                    'Wallet Disconnected',
                    'Your wallet has been disconnected',
                    'info',
                    3000
                );
                
                // Clear user data
                StateManager.clearUserData();
                
                // Update UI
                this.updateConnectionStatus(false);
            }
            
            return result;
            
        } catch (error) {
            ErrorManager.logError(error, 'WalletManager.disconnect');
            return { success: false, error: error.message };
        }
    }
    
    loadUserSettings() {
        const userAccount = StateManager.get('userAccount');
        if (!userAccount) return;
        
        // Load user settings from storage
        ['platformSettings', 'playerStats', 'skillRatings'].forEach(key => {
            const stored = StateManager.loadFromStorage(key);
            if (stored) {
                StateManager.set(key, stored);
            }
        });
    }
    
    showInstallMetaMaskModal() {
        const modalHtml = `
            <div class="modal-overlay" id="installMetaMaskModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3><i class="fab fa-ethereum"></i> Wallet Required</h3>
                    </div>
                    <div class="modal-body">
                        <p>You need a Web3 wallet to play CrossRealm games with real CORE tokens.</p>
                        <div style="text-align: center; margin: 20px 0;">
                            <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🦊</text></svg>" 
                                 alt="MetaMask" style="width: 64px; height: 64px;">
                        </div>
                        <p>MetaMask is a secure wallet that allows you to:</p>
                        <ul style="text-align: left; margin: 15px 0;">
                            <li>Store and manage your CORE tokens</li>
                            <li>Play games with real token stakes</li>
                            <li>Receive instant settlements</li>
                            <li>Maintain full control of your funds</li>
                        </ul>
                    </div>
                    <div class="modal-footer">
                        <a href="https://metamask.io" target="_blank" class="btn btn-primary">
                            <i class="fas fa-download"></i> Install MetaMask
                        </a>
                        <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    updateConnectionStatus(connected) {
        // Update contract status widget
        const contractStatus = document.getElementById('contractStatus');
        if (contractStatus) {
            const indicator = contractStatus.querySelector('.status-indicator');
            const text = contractStatus.querySelector('span:last-child');
            
            if (indicator) {
                indicator.className = `status-indicator ${connected ? 'online' : 'offline'}`;
            }
            
            if (text) {
                text.textContent = connected ? 'Connected' : 'Disconnected';
            }
        }
        
        // Update connection progress
        const connectionProgress = document.getElementById('connectionProgress');
        if (connectionProgress) {
            connectionProgress.style.width = connected ? '100%' : '0%';
        }
    }
    
    setupEventHandlers() {
        // Connect button
        document.addEventListener('click', (event) => {
            if (event.target.id === 'connectBtn' || 
                event.target.closest('#connectBtn')) {
                event.preventDefault();
                this.connect();
            }
        });
        
        // Disconnect button
        document.addEventListener('click', (event) => {
            if (event.target.id === 'disconnectBtn' || 
                event.target.closest('#disconnectBtn')) {
                event.preventDefault();
                this.disconnect();
            }
        });
        
        // Contract address copy
        document.addEventListener('click', (event) => {
            if (event.target.closest('[data-copy-target="contract-address"]')) {
                event.preventDefault();
                Utils.copyToClipboard(Config.get('CONTRACT_ADDRESS')).then(() => {
                    NotificationManager.show(
                        'Copied',
                        'Contract address copied to clipboard',
                        'success',
                        3000
                    );
                }).catch(() => {
                    NotificationManager.show(
                        'Copy Failed',
                        'Failed to copy to clipboard',
                        'error',
                        3000
                    );
                });
            }
        });
        
        // Test connection button
        document.addEventListener('click', (event) => {
            if (event.target.id === 'testConnectionBtn' || 
                event.target.closest('#testConnectionBtn')) {
                event.preventDefault();
                this.testConnection();
            }
        });
    }
    
    async testConnection() {
        try {
            const testBtn = document.getElementById('testConnectionBtn');
            if (testBtn) {
                testBtn.disabled = true;
                testBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            }
            
            const startTime = performance.now();
            
            if (this.blockchainProvider.isConnected) {
                await this.blockchainProvider.updateBalance();
                await this.blockchainProvider.checkProviderHealth();
                
                const latency = Math.round(performance.now() - startTime);
                
                // Update latency display
                const serverLatency = document.getElementById('serverLatency');
                if (serverLatency) {
                    serverLatency.textContent = `${latency}ms`;
                }
                
                // Update last sync
                const lastSync = document.getElementById('lastSync');
                if (lastSync) {
                    lastSync.textContent = new Date().toLocaleTimeString();
                }
                
                NotificationManager.show(
                    'Connection Test',
                    `Connection is healthy. Latency: ${latency}ms`,
                    'success',
                    5000
                );
            } else {
                NotificationManager.show(
                    'Connection Test',
                    'No active connection found',
                    'warning',
                    5000
                );
            }
            
        } catch (error) {
            ErrorManager.logError(error, 'WalletManager.testConnection');
            
            NotificationManager.show(
                'Connection Test Failed',
                'Connection test failed. Check your network.',
                'error',
                5000
            );
        } finally {
            const testBtn = document.getElementById('testConnectionBtn');
            if (testBtn) {
                testBtn.disabled = false;
                testBtn.innerHTML = '<i class="fas fa-wifi"></i> Test Connection';
            }
        }
    }
    
    // Game-specific methods
    async createGame(gameType, timeLimit, stakeAmount) {
        if (!this.blockchainProvider.isConnected) {
            NotificationManager.show(
                'Wallet Required',
                'Please connect your wallet to create a game',
                'warning',
                5000
            );
            return { success: false, error: 'Wallet not connected' };
        }
        
        return await this.blockchainProvider.createGame(gameType, timeLimit, stakeAmount);
    }
    
    async joinGame(gameId, stakeAmount) {
        if (!this.blockchainProvider.isConnected) {
            NotificationManager.show(
                'Wallet Required',
                'Please connect your wallet to join a game',
                'warning',
                5000
            );
            return { success: false, error: 'Wallet not connected' };
        }
        
        return await this.blockchainProvider.joinGame(gameId, stakeAmount);
    }
    
    async submitMove(gameId, moveData) {
        if (!this.blockchainProvider.isConnected) {
            return { success: false, error: 'Wallet not connected' };
        }
        
        return await this.blockchainProvider.submitMove(gameId, moveData);
    }
    
    async finalizeGame(gameId, winner) {
        if (!this.blockchainProvider.isConnected) {
            return { success: false, error: 'Wallet not connected' };
        }
        
        return await this.blockchainProvider.finalizeGame(gameId, winner);
    }
    
    async getGame(gameId) {
        if (!this.blockchainProvider.isConnected) {
            return { success: false, error: 'Wallet not connected' };
        }
        
        return await this.blockchainProvider.getGame(gameId);
    }
    
    async getPlayerGames(playerAddress = null) {
        if (!this.blockchainProvider.isConnected) {
            return { success: false, error: 'Wallet not connected' };
        }
        
        return await this.blockchainProvider.getPlayerGames(playerAddress);
    }
    
    getBalance() {
        return StateManager.get('userBalance') || 0;
    }
    
    getAddress() {
        return StateManager.get('userAccount');
    }
    
    isConnected() {
        return StateManager.get('isWalletConnected') || false;
    }
}

// ===========================
// TRANSACTION MANAGER
// ===========================

class TransactionManager {
    constructor() {
        this.pendingTransactions = new Map();
        this.completedTransactions = new Map();
        this.maxStoredTransactions = 50;
        
        this.setupTransactionMonitoring();
    }
    
    async submitTransaction(type, params, options = {}) {
        try {
            const txId = Utils.generateId();
            
            // Show transaction status
            this.showTransactionStatus(txId, 'pending', 'Processing transaction...');
            
            let result;
            
            switch (type) {
                case 'create_game':
                    result = await WalletManager.createGame(
                        params.gameType,
                        params.timeLimit,
                        params.stakeAmount
                    );
                    break;
                    
                case 'join_game':
                    result = await WalletManager.joinGame(
                        params.gameId,
                        params.stakeAmount
                    );
                    break;
                    
                case 'submit_move':
                    result = await WalletManager.submitMove(
                        params.gameId,
                        params.moveData
                    );
                    break;
                    
                case 'finalize_game':
                    result = await WalletManager.finalizeGame(
                        params.gameId,
                        params.winner
                    );
                    break;
                    
                default:
                    throw new GameError(`Unknown transaction type: ${type}`, 'UNKNOWN_TX_TYPE');
            }
            
            if (result.success) {
                const transaction = {
                    id: txId,
                    type: type,
                    params: params,
                    hash: result.transaction.hash,
                    timestamp: Date.now(),
                    status: 'pending',
                    confirmations: 0
                };
                
                this.pendingTransactions.set(txId, transaction);
                
                // Monitor transaction
                this.monitorTransaction(transaction);
                
                return { success: true, transactionId: txId, hash: result.transaction.hash };
            } else {
                this.hideTransactionStatus();
                return result;
            }
            
        } catch (error) {
            this.hideTransactionStatus();
            ErrorManager.logError(error, 'TransactionManager.submitTransaction');
            return { success: false, error: error.message };
        }
    }
    
    async monitorTransaction(transaction) {
        try {
            const provider = WalletManager.blockchainProvider.provider;
            
            if (!provider) {
                throw new GameError('Provider not available', 'NO_PROVIDER');
            }
            
            // Wait for transaction receipt
            const receipt = await provider.waitForTransaction(transaction.hash);
            
            if (receipt.status === 1) {
                // Transaction successful
                transaction.status = 'confirmed';
                transaction.confirmations = receipt.confirmations;
                transaction.gasUsed = receipt.gasUsed.toString();
                transaction.blockNumber = receipt.blockNumber;
                
                this.pendingTransactions.delete(transaction.id);
                this.completedTransactions.set(transaction.id, transaction);
                
                this.showTransactionStatus(
                    transaction.id,
                    'success',
                    'Transaction confirmed!',
                    transaction.hash
                );
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    this.hideTransactionStatus();
                }, 5000);
                
                // Trigger event for the specific transaction type
                this.handleTransactionConfirmed(transaction);
                
            } else {
                // Transaction failed
                transaction.status = 'failed';
                
                this.pendingTransactions.delete(transaction.id);
                
                this.showTransactionStatus(
                    transaction.id,
                    'error',
                    'Transaction failed',
                    transaction.hash
                );
                
                NotificationManager.show(
                    'Transaction Failed',
                    'Your transaction was reverted. Please try again.',
                    'error',
                    5000
                );
            }
            
        } catch (error) {
            ErrorManager.logError(error, 'TransactionManager.monitorTransaction');
            
            transaction.status = 'error';
            this.pendingTransactions.delete(transaction.id);
            
            this.showTransactionStatus(
                transaction.id,
                'error',
                'Transaction error',
                transaction.hash
            );
        }
    }
    
    handleTransactionConfirmed(transaction) {
        switch (transaction.type) {
            case 'create_game':
                NotificationManager.show(
                    'Game Created',
                    'Your game has been created successfully!',
                    'success',
                    5000
                );
                
                // Refresh game list
                if (window.GameManager) {
                    GameManager.refreshGamesList();
                }
                break;
                
            case 'join_game':
                NotificationManager.show(
                    'Game Joined',
                    'You have successfully joined the game!',
                    'success',
                    5000
                );
                
                // Start game if it's ready
                if (window.GameManager) {
                    GameManager.checkGameStart(transaction.params.gameId);
                }
                break;
                
            case 'submit_move':
                // Move submitted - game will handle the rest
                break;
                
            case 'finalize_game':
                NotificationManager.show(
                    'Game Finalized',
                    'Game has been finalized and winnings distributed!',
                    'success',
                    5000
                );
                
                // Update balance
                WalletManager.blockchainProvider.updateBalance();
                break;
        }
    }
    
    showTransactionStatus(id, status, message, hash = null) {
        const statusElement = document.getElementById('transactionStatus');
        const messageElement = document.getElementById('txMessage');
        const hashElement = document.getElementById('txHash');
        
        if (statusElement && messageElement) {
            messageElement.textContent = message;
            
            if (hash && hashElement) {
                const explorerUrl = `${Config.get('CORE_EXPLORER_URL')}/tx/${hash}`;
                hashElement.innerHTML = `
                    <a href="${explorerUrl}" target="_blank" rel="noopener noreferrer">
                        View on Explorer: ${hash.substring(0, 10)}...${hash.substring(hash.length - 8)}
                    </a>
                `;
            } else if (hashElement) {
                hashElement.innerHTML = '';
            }
            
            statusElement.className = `transaction-status show ${status}`;
        }
    }
    
    hideTransactionStatus() {
        const statusElement = document.getElementById('transactionStatus');
        if (statusElement) {
            statusElement.classList.remove('show');
        }
    }
    
    setupTransactionMonitoring() {
        // Close button for transaction status
        document.addEventListener('click', (event) => {
            if (event.target.id === 'txClose' || 
                event.target.closest('#txClose')) {
                this.hideTransactionStatus();
            }
        });
        
        // Cleanup old completed transactions periodically
        setInterval(() => {
            this.cleanupOldTransactions();
        }, 300000); // Every 5 minutes
    }
    
    cleanupOldTransactions() {
        const now = Date.now();
        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
        
        this.completedTransactions.forEach((transaction, id) => {
            if (now - transaction.timestamp > maxAge) {
                this.completedTransactions.delete(id);
            }
        });
        
        // Limit stored transactions
        if (this.completedTransactions.size > this.maxStoredTransactions) {
            const sortedTransactions = [...this.completedTransactions.entries()]
                .sort((a, b) => b[1].timestamp - a[1].timestamp);
            
            const toKeep = sortedTransactions.slice(0, this.maxStoredTransactions);
            
            this.completedTransactions.clear();
            toKeep.forEach(([id, transaction]) => {
                this.completedTransactions.set(id, transaction);
            });
        }
    }
    
    getTransactionHistory(limit = 20) {
        const allTransactions = [
            ...this.pendingTransactions.values(),
            ...this.completedTransactions.values()
        ];
        
        return allTransactions
            .sort((a, b) => b.timestamp - a.timestamp)
            .slice(0, limit);
    }
    
    getPendingTransactions() {
        return [...this.pendingTransactions.values()];
    }
}

// ===========================
// GLOBAL INSTANCES
// ===========================

// Initialize managers
const WalletManager = new WalletManager();
const TransactionManager = new TransactionManager();

// Export to global scope
window.WalletManager = WalletManager;
window.TransactionManager = TransactionManager;
window.BlockchainProvider = BlockchainProvider;

console.log('✅ Section 4: Blockchain Integration & Wallet Management Loaded');
</script>
<script>
  /* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 5: MAIN CONTENT SECTIONS & UI MANAGEMENT
   =========================== */

'use strict';

// ===========================
// NAVIGATION MANAGER
// ===========================

class NavigationManager {
    constructor() {
        this.currentSection = 'lobby';
        this.sectionHistory = ['lobby'];
        this.maxHistorySize = 10;
        
        this.setupEventHandlers();
        this.initializeNavigation();
    }
    
    initializeNavigation() {
        // Set initial active section
        this.showSection('lobby');
        this.updateActiveNavItem('lobby');
    }
    
    setupEventHandlers() {
        // Navigation menu click handlers
        document.addEventListener('click', (event) => {
            const navItem = event.target.closest('.nav-item[data-section]');
            if (navItem && !navItem.classList.contains('disabled')) {
                event.preventDefault();
                const section = navItem.dataset.section;
                this.navigateToSection(section);
            }
        });
        
        // Browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            if (event.state && event.state.section) {
                this.showSection(event.state.section, false);
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey || event.metaKey) {
                this.handleKeyboardShortcuts(event);
            }
        });
    }
    
    handleKeyboardShortcuts(event) {
        const shortcuts = {
            '1': 'lobby',
            '2': 'create',
            '3': 'games',
            '4': 'tournaments',
            '5': 'profile',
            '6': 'chat',
            '7': 'settings'
        };
        
        if (shortcuts[event.key]) {
            event.preventDefault();
            this.navigateToSection(shortcuts[event.key]);
        }
    }
    
    navigateToSection(sectionName) {
        if (sectionName === this.currentSection) return;
        
        // Check if section requires wallet connection
        if (['create', 'games', 'tournaments'].includes(sectionName) && 
            !StateManager.get('isWalletConnected')) {
            
            NotificationManager.show(
                'Wallet Required',
                'Please connect your wallet to access this section',
                'warning',
                5000
            );
            return;
        }
        
        // Add to history
        this.addToHistory(sectionName);
        
        // Update browser history
        history.pushState({ section: sectionName }, '', `#${sectionName}`);
        
        // Show section
        this.showSection(sectionName);
        
        // Update navigation
        this.updateActiveNavItem(sectionName);
        
        // Update state
        StateManager.set('currentSection', sectionName);
        
        if (Config.get('DEBUG_LOGGING')) {
            console.log(`🧭 Navigated to: ${sectionName}`);
        }
    }
    
    showSection(sectionName, updateHistory = true) {
        // Hide all sections
        document.querySelectorAll('.section-content').forEach(section => {
            section.classList.remove('active');
        });
        
        // Show target section
        const targetSection = document.getElementById(`${sectionName}Section`);
        if (targetSection) {
            targetSection.classList.add('active');
            
            // Load section content if needed
            this.loadSectionContent(sectionName);
        }
        
        this.currentSection = sectionName;
    }
    
    updateActiveNavItem(sectionName) {
        // Remove active class from all nav items
        document.querySelectorAll('.nav-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Add active class to current section
        const activeItem = document.querySelector(`.nav-item[data-section="${sectionName}"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
    
    addToHistory(section) {
        this.sectionHistory.push(section);
        
        if (this.sectionHistory.length > this.maxHistorySize) {
            this.sectionHistory = this.sectionHistory.slice(-this.maxHistorySize);
        }
    }
    
    goBack() {
        if (this.sectionHistory.length > 1) {
            this.sectionHistory.pop(); // Remove current
            const previousSection = this.sectionHistory[this.sectionHistory.length - 1];
            this.navigateToSection(previousSection);
        }
    }
    
    loadSectionContent(sectionName) {
        switch (sectionName) {
            case 'lobby':
                LobbySection.render();
                break;
            case 'create':
                CreateGameSection.render();
                break;
            case 'games':
                GamesSection.render();
                break;
            case 'tournaments':
                TournamentsSection.render();
                break;
            case 'profile':
                ProfileSection.render();
                break;
            case 'chat':
                ChatSection.render();
                break;
            case 'settings':
                SettingsSection.render();
                break;
        }
    }
    
    disableNavigation(sectionName) {
        const navItem = document.querySelector(`.nav-item[data-section="${sectionName}"]`);
        if (navItem) {
            navItem.classList.add('disabled');
        }
    }
    
    enableNavigation(sectionName) {
        const navItem = document.querySelector(`.nav-item[data-section="${sectionName}"]`);
        if (navItem) {
            navItem.classList.remove('disabled');
        }
    }
}

// ===========================
// LOBBY SECTION
// ===========================

class LobbySection {
    static render() {
        const container = document.getElementById('lobbySection');
        if (!container) return;
        
        container.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-home"></i> Welcome to CrossRealm</h2>
                <div class="header-actions">
                    <button class="btn btn-accent" onclick="NavigationManager.navigateToSection('create')">
                        <i class="fas fa-plus"></i> Create Game
                    </button>
                </div>
            </div>
            
            <div class="lobby-content">
                <div class="welcome-banner">
                    <div class="banner-content">
                        <div class="banner-text">
                            <h3>Real-time Blockchain Gaming</h3>
                            <p>Play chess, checkers, and word games with real CORE token stakes. Instant settlements, provably fair gameplay, and competitive tournaments.</p>
                            <div class="banner-stats">
                                <div class="stat">
                                    <span class="stat-number" id="lobbyPlayersOnline">0</span>
                                    <span class="stat-label">Players Online</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-number" id="lobbyActiveGames">0</span>
                                    <span class="stat-label">Active Games</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-number" id="lobbyTotalVolume">0</span>
                                    <span class="stat-label">CORE Volume</span>
                                </div>
                            </div>
                        </div>
                        <div class="banner-visual">
                            <div class="floating-icons">
                                <i class="fas fa-chess-king"></i>
                                <i class="fas fa-coins"></i>
                                <i class="fas fa-trophy"></i>
                                <i class="fas fa-bolt"></i>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="lobby-grid">
                    <div class="lobby-card quick-games">
                        <div class="card-header">
                            <h3><i class="fas fa-zap"></i> Quick Games</h3>
                            <button class="btn btn-sm btn-primary" onclick="LobbySection.refreshQuickGames()">
                                <i class="fas fa-sync-alt"></i> Refresh
                            </button>
                        </div>
                        <div class="card-content">
                            <div class="quick-games-list" id="quickGamesList">
                                <div class="loading-placeholder">
                                    <i class="fas fa-spinner fa-spin"></i>
                                    <span>Loading available games...</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="lobby-card featured-tournaments">
                        <div class="card-header">
                            <h3><i class="fas fa-trophy"></i> Featured Tournaments</h3>
                            <button class="btn btn-sm btn-accent" onclick="NavigationManager.navigateToSection('tournaments')">
                                View All
                            </button>
                        </div>
                        <div class="card-content">
                            <div class="tournaments-list" id="featuredTournamentsList">
                                <div class="tournament-item">
                                    <div class="tournament-info">
                                        <h4>Weekly Chess Championship</h4>
                                        <p>Prize Pool: 100 CORE</p>
                                        <div class="tournament-meta">
                                            <span><i class="fas fa-users"></i> 24/32 players</span>
                                            <span><i class="fas fa-clock"></i> Starts in 2h 15m</span>
                                        </div>
                                    </div>
                                    <button class="btn btn-sm btn-success">Join</button>
                                </div>
                                
                                <div class="tournament-item">
                                    <div class="tournament-info">
                                        <h4>Speed Checkers Arena</h4>
                                        <p>Prize Pool: 50 CORE</p>
                                        <div class="tournament-meta">
                                            <span><i class="fas fa-users"></i> 8/16 players</span>
                                            <span><i class="fas fa-clock"></i> Starts in 45m</span>
                                        </div>
                                    </div>
                                    <button class="btn btn-sm btn-success">Join</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="lobby-card recent-activity">
                        <div class="card-header">
                            <h3><i class="fas fa-history"></i> Recent Activity</h3>
                        </div>
                        <div class="card-content">
                            <div class="activity-timeline" id="recentActivityTimeline">
                                <!-- Activity items will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="lobby-card platform-stats">
                        <div class="card-header">
                            <h3><i class="fas fa-chart-bar"></i> Platform Statistics</h3>
                        </div>
                        <div class="card-content">
                            <div class="stats-dashboard">
                                <div class="stat-card">
                                    <div class="stat-icon"><i class="fas fa-gamepad"></i></div>
                                    <div class="stat-info">
                                        <div class="stat-value" id="totalGamesPlayed">0</div>
                                        <div class="stat-name">Games Played</div>
                                    </div>
                                </div>
                                
                                <div class="stat-card">
                                    <div class="stat-icon"><i class="fas fa-coins"></i></div>
                                    <div class="stat-info">
                                        <div class="stat-value" id="totalValueLocked">0</div>
                                        <div class="stat-name">CORE Locked</div>
                                    </div>
                                </div>
                                
                                <div class="stat-card">
                                    <div class="stat-icon"><i class="fas fa-users"></i></div>
                                    <div class="stat-info">
                                        <div class="stat-value" id="totalPlayers">0</div>
                                        <div class="stat-name">Total Players</div>
                                    </div>
                                </div>
                                
                                <div class="stat-card">
                                    <div class="stat-icon"><i class="fas fa-trophy"></i></div>
                                    <div class="stat-info">
                                        <div class="stat-value" id="activeTournaments">0</div>
                                        <div class="stat-name">Tournaments</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Load initial data
        this.loadQuickGames();
        this.loadRecentActivity();
        this.loadPlatformStats();
    }
    
    static async loadQuickGames() {
        try {
            const quickGamesList = document.getElementById('quickGamesList');
            if (!quickGamesList) return;
            
            // Simulate loading quick games
            await Utils.sleep(1000);
            
            const mockGames = [
                {
                    id: 1,
                    type: 'chess',
                    stake: '0.1',
                    player: '0x742d...a85f',
                    timeLimit: 600,
                    skillLevel: 'Intermediate'
                },
                {
                    id: 2,
                    type: 'checkers',
                    stake: '0.05',
                    player: '0x8b3c...2d1e',
                    timeLimit: 300,
                    skillLevel: 'Beginner'
                },
                {
                    id: 3,
                    type: 'words',
                    stake: '0.2',
                    player: '0x1a2b...9f8e',
                    timeLimit: 900,
                    skillLevel: 'Advanced'
                }
            ];
            
            quickGamesList.innerHTML = mockGames.map(game => `
                <div class="quick-game-item" data-game-id="${game.id}">
                    <div class="game-icon">
                        <i class="fas fa-${this.getGameIcon(game.type)}"></i>
                    </div>
                    <div class="game-info">
                        <div class="game-title">${game.type.charAt(0).toUpperCase() + game.type.slice(1)}</div>
                        <div class="game-details">
                            <span class="stake">${game.stake} CORE</span>
                            <span class="skill">${game.skillLevel}</span>
                        </div>
                        <div class="game-meta">
                            <span><i class="fas fa-user"></i> ${game.player}</span>
                            <span><i class="fas fa-clock"></i> ${Math.floor(game.timeLimit / 60)}min</span>
                        </div>
                    </div>
                    <button class="btn btn-sm btn-primary" onclick="LobbySection.joinQuickGame(${game.id})">
                        Join Game
                    </button>
                </div>
            `).join('');
            
        } catch (error) {
            ErrorManager.logError(error, 'LobbySection.loadQuickGames');
        }
    }
    
    static getGameIcon(gameType) {
        const icons = {
            chess: 'chess-king',
            checkers: 'chess-board',
            words: 'spell-check'
        };
        return icons[gameType] || 'gamepad';
    }
    
    static async loadRecentActivity() {
        try {
            const timeline = document.getElementById('recentActivityTimeline');
            if (!timeline) return;
            
            await Utils.sleep(500);
            
            const mockActivity = [
                {
                    type: 'game_completed',
                    player: '0x742d...a85f',
                    game: 'Chess',
                    amount: '0.2',
                    time: Date.now() - 300000
                },
                {
                    type: 'tournament_win',
                    player: '0x8b3c...2d1e',
                    tournament: 'Speed Checkers',
                    amount: '5.0',
                    time: Date.now() - 900000
                },
                {
                    type: 'game_created',
                    player: '0x1a2b...9f8e',
                    game: 'Words',
                    amount: '0.1',
                    time: Date.now() - 1800000
                }
            ];
            
            timeline.innerHTML = mockActivity.map(activity => `
                <div class="activity-item">
                    <div class="activity-icon">
                        <i class="fas fa-${this.getActivityIcon(activity.type)}"></i>
                    </div>
                    <div class="activity-content">
                        <div class="activity-description">
                            ${this.formatActivityDescription(activity)}
                        </div>
                        <div class="activity-time">
                            ${Utils.formatTimeAgo(activity.time)}
                        </div>
                    </div>
                </div>
            `).join('');
            
        } catch (error) {
            ErrorManager.logError(error, 'LobbySection.loadRecentActivity');
        }
    }
    
    static getActivityIcon(type) {
        const icons = {
            game_completed: 'check-circle',
            tournament_win: 'trophy',
            game_created: 'plus-circle',
            player_joined: 'user-plus'
        };
        return icons[type] || 'info-circle';
    }
    
    static formatActivityDescription(activity) {
        switch (activity.type) {
            case 'game_completed':
                return `<strong>${activity.player}</strong> won ${activity.amount} CORE in ${activity.game}`;
            case 'tournament_win':
                return `<strong>${activity.player}</strong> won ${activity.tournament} tournament (${activity.amount} CORE)`;
            case 'game_created':
                return `<strong>${activity.player}</strong> created ${activity.game} game (${activity.amount} CORE stake)`;
            default:
                return 'Unknown activity';
        }
    }
    
    static async loadPlatformStats() {
        try {
            await Utils.sleep(800);
            
            // Simulate loading platform statistics
            const stats = {
                totalGamesPlayed: 1247,
                totalValueLocked: 834.56,
                totalPlayers: 892,
                activeTournaments: 7
            };
            
            // Animate stat counters
            this.animateStatCounter('totalGamesPlayed', stats.totalGamesPlayed);
            this.animateStatCounter('totalValueLocked', stats.totalValueLocked, true);
            this.animateStatCounter('totalPlayers', stats.totalPlayers);
            this.animateStatCounter('activeTournaments', stats.activeTournaments);
            
        } catch (error) {
            ErrorManager.logError(error, 'LobbySection.loadPlatformStats');
        }
    }
    
    static animateStatCounter(elementId, targetValue, isCurrency = false) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const startValue = 0;
        const duration = 2000;
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const currentValue = startValue + (targetValue - startValue) * easeOutQuart;
            
            if (isCurrency) {
                element.textContent = currentValue.toFixed(2);
            } else {
                element.textContent = Math.floor(currentValue).toLocaleString();
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    static async refreshQuickGames() {
        const refreshBtn = document.querySelector('.quick-games .btn');
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        }
        
        await this.loadQuickGames();
        
        if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh';
        }
        
        NotificationManager.show(
            'Games Refreshed',
            'Quick games list has been updated',
            'success',
            3000
        );
    }
    
    static async joinQuickGame(gameId) {
        if (!StateManager.get('isWalletConnected')) {
            NotificationManager.show(
                'Wallet Required',
                'Please connect your wallet to join games',
                'warning',
                5000
            );
            return;
        }
        
        try {
            // Show confirmation modal or redirect to game
            NotificationManager.show(
                'Joining Game',
                `Joining game ${gameId}...`,
                'info',
                3000
            );
            
            // Here you would implement the actual game joining logic
            
        } catch (error) {
            ErrorManager.logError(error, 'LobbySection.joinQuickGame');
        }
    }
}

// ===========================
// CREATE GAME SECTION
// ===========================

class CreateGameSection {
    static render() {
        const container = document.getElementById('createSection');
        if (!container) return;
        
        container.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-plus"></i> Create New Game</h2>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="NavigationManager.navigateToSection('lobby')">
                        <i class="fas fa-arrow-left"></i> Back to Lobby
                    </button>
                </div>
            </div>
            
            <div class="create-game-content">
                <div class="game-creation-wizard">
                    <div class="wizard-steps">
                        <div class="step active" data-step="1">
                            <div class="step-number">1</div>
                            <div class="step-title">Game Type</div>
                        </div>
                        <div class="step" data-step="2">
                            <div class="step-number">2</div>
                            <div class="step-title">Settings</div>
                        </div>
                        <div class="step" data-step="3">
                            <div class="step-number">3</div>
                            <div class="step-title">Stake</div>
                        </div>
                        <div class="step" data-step="4">
                            <div class="step-number">4</div>
                            <div class="step-title">Confirm</div>
                        </div>
                    </div>
                    
                    <div class="wizard-content">
                        <div class="step-content active" id="step1Content">
                            <h3>Choose Game Type</h3>
                            <p>Select the type of game you want to create</p>
                            
                            <div class="game-type-grid">
                                <div class="game-type-card" data-game="chess">
                                    <div class="game-icon">
                                        <i class="fas fa-chess-king"></i>
                                    </div>
                                    <h4>Chess</h4>
                                    <p>Classic strategy game with full rule support</p>
                                    <div class="game-features">
                                        <span class="feature"><i class="fas fa-clock"></i> 5-60 min</span>
                                        <span class="feature"><i class="fas fa-star"></i> All Levels</span>
                                    </div>
                                </div>
                                
                                <div class="game-type-card" data-game="checkers">
                                    <div class="game-icon">
                                        <i class="fas fa-chess-board"></i>
                                    </div>
                                    <h4>Checkers</h4>
                                    <p>Fast-paced strategic board game</p>
                                    <div class="game-features">
                                        <span class="feature"><i class="fas fa-clock"></i> 3-30 min</span>
                                        <span class="feature"><i class="fas fa-star"></i> Beginner+</span>
                                    </div>
                                </div>
                                
                                <div class="game-type-card" data-game="words">
                                    <div class="game-icon">
                                        <i class="fas fa-spell-check"></i>
                                    </div>
                                    <h4>Word Battle</h4>
                                    <p>Competitive word-building game</p>
                                    <div class="game-features">
                                        <span class="feature"><i class="fas fa-clock"></i> 5-20 min</span>
                                        <span class="feature"><i class="fas fa-star"></i> All Levels</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="step-content" id="step2Content">
                            <h3>Game Settings</h3>
                            <p>Configure your game preferences</p>
                            
                            <div class="settings-form">
                                <div class="form-group">
                                    <label for="timeLimit">Time Limit per Move</label>
                                    <select id="timeLimit" class="form-control">
                                        <option value="30">30 seconds</option>
                                        <option value="60">1 minute</option>
                                        <option value="300" selected>5 minutes</option>
                                        <option value="600">10 minutes</option>
                                        <option value="900">15 minutes</option>
                                        <option value="1800">30 minutes</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="skillLevel">Skill Level</label>
                                    <select id="skillLevel" class="form-control">
                                        <option value="beginner">Beginner</option>
                                        <option value="intermediate" selected>Intermediate</option>
                                        <option value="advanced">Advanced</option>
                                        <option value="expert">Expert</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="gameVisibility">Game Visibility</label>
                                    <select id="gameVisibility" class="form-control">
                                        <option value="public" selected>Public (Anyone can join)</option>
                                        <option value="private">Private (Invite only)</option>
                                    </select>
                                </div>
                                
                                <div class="form-group checkbox-group">
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="allowSpectators" checked>
                                        <span class="checkmark"></span>
                                        Allow spectators
                                    </label>
                                </div>
                                
                                <div class="form-group checkbox-group">
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="enableChat" checked>
                                        <span class="checkmark"></span>
                                        Enable in-game chat
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <div class="step-content" id="step3Content">
                            <h3>Set Game Stake</h3>
                            <p>Choose how much CORE to stake on this game</p>
                            
                            <div class="stake-settings">
                                <div class="current-balance">
                                    <div class="balance-label">Your Balance</div>
                                    <div class="balance-amount" id="currentBalance">0.0000 CORE</div>
                                </div>
                                
                                <div class="stake-input-group">
                                    <label for="stakeAmount">Stake Amount</label>
                                    <div class="input-with-buttons">
                                        <input type="number" id="stakeAmount" class="form-control" 
                                               placeholder="0.1" min="0.01" max="100" step="0.01">
                                        <span class="input-suffix">CORE</span>
                                    </div>
                                    <div class="quick-amounts">
                                        <button class="btn btn-sm btn-secondary" onclick="CreateGameSection.setStakeAmount(0.01)">0.01</button>
                                        <button class="btn btn-sm btn-secondary" onclick="CreateGameSection.setStakeAmount(0.1)">0.1</button>
                                        <button class="btn btn-sm btn-secondary" onclick="CreateGameSection.setStakeAmount(0.5)">0.5</button>
                                        <button class="btn btn-sm btn-secondary" onclick="CreateGameSection.setStakeAmount(1.0)">1.0</button>
                                        <button class="btn btn-sm btn-secondary" onclick="CreateGameSection.setStakeAmount(5.0)">5.0</button>
                                    </div>
                                </div>
                                
                                <div class="stake-info">
                                    <div class="info-row">
                                        <span class="label">Your Stake:</span>
                                        <span class="value" id="yourStake">0.0000 CORE</span>
                                    </div>
                                    <div class="info-row">
                                        <span class="label">Opponent Stake:</span>
                                        <span class="value" id="opponentStake">0.0000 CORE</span>
                                    </div>
                                    <div class="info-row">
                                        <span class="label">Platform Fee (${Config.get('PLATFORM_FEE_PERCENTAGE')}%):</span>
                                        <span class="value" id="platformFee">0.0000 CORE</span>
                                    </div>
                                    <div class="info-row total">
                                        <span class="label">Winner Receives:</span>
                                        <span class="value" id="winnerAmount">0.0000 CORE</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="step-content" id="step4Content">
                            <h3>Confirm Game Creation</h3>
                            <p>Review your game settings before creating</p>
                            
                            <div class="game-summary">
                                <div class="summary-card">
                                    <h4>Game Details</h4>
                                    <div class="detail-grid">
                                        <div class="detail-item">
                                            <span class="label">Game Type:</span>
                                            <span class="value" id="summaryGameType">-</span>
                                        </div>
                                        <div class="detail-item">
                                            <span class="label">Time Limit:</span>
                                            <span class="value" id="summaryTimeLimit">-</span>
                                        </div>
                                        <div class="detail-item">
                                            <span class="label">Skill Level:</span>
                                            <span class="value" id="summarySkillLevel">-</span>
                                        </div>
                                        <div class="detail-item">
                                            <span class="label">Visibility:</span>
                                            <span class="value" id="summaryVisibility">-</span>
                                        </div>
                                        <div class="detail-item">
                                            <span class="label">Stake Amount:</span>
                                            <span class="value" id="summaryStakeAmount">-</span>
                                        </div>
                                        <div class="detail-item">
                                            <span class="label">Winner Gets:</span>
                                            <span class="value highlight" id="summaryWinnerAmount">-</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="terms-agreement">
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="agreeTerms" required>
                                        <span class="checkmark"></span>
                                        I agree to the <a href="#" onclick="SettingsSection.showTerms()">Terms of Service</a> 
                                        and understand that this involves real CORE token stakes
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="wizard-navigation">
                        <button class="btn btn-secondary" id="prevStepBtn" onclick="CreateGameSection.previousStep()" disabled>
                            <i class="fas fa-arrow-left"></i> Previous
                        </button>
                        
                        <button class="btn btn-primary" id="nextStepBtn" onclick="CreateGameSection.nextStep()">
                            Next <i class="fas fa-arrow-right"></i>
                        </button>
                        
                        <button class="btn btn-success" id="createGameBtn" onclick="CreateGameSection.createGame()" style="display: none;">
                            <i class="fas fa-plus"></i> Create Game
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        this.initializeWizard();
        this.setupEventHandlers();
    }
    
    static initializeWizard() {
        this.currentStep = 1;
        this.gameData = {
            gameType: null,
            timeLimit: 300,
            skillLevel: 'intermediate',
            visibility: 'public',
            allowSpectators: true,
            enableChat: true,
            stakeAmount: 0.1
        };
        
        // Update balance display
        this.updateBalanceDisplay();
        
        // Set default values
        document.getElementById('stakeAmount').value = this.gameData.stakeAmount;
        this.calculateStakeInfo();
    }
    
    static setupEventHandlers() {
        // Game type selection
        document.addEventListener('click', (event) => {
            const gameCard = event.target.closest('.game-type-card');
            if (gameCard) {
                this.selectGameType(gameCard.dataset.game);
            }
        });
        
        // Stake amount input
        const stakeInput = document.getElementById('stakeAmount');
        if (stakeInput) {
            stakeInput.addEventListener('input', () => {
                this.calculateStakeInfo();
            });
        }
        
        // Form inputs
        ['timeLimit', 'skillLevel', 'gameVisibility', 'allowSpectators', 'enableChat'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', () => {
                    this.updateGameData();
                });
            }
        });
    }
    
    static selectGameType(gameType) {
        // Remove previous selection
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Add selection to clicked card
        const selectedCard = document.querySelector(`[data-game="${gameType}"]`);
        if (selectedCard) {
            selectedCard.classList.add('selected');
            this.gameData.gameType = gameType;
            StateManager.set('selectedGameType', gameType);
        }
    }
    
    static updateGameData() {
        this.gameData.timeLimit = parseInt(document.getElementById('timeLimit').value);
        this.gameData.skillLevel = document.getElementById('skillLevel').value;
        this.gameData.visibility = document.getElementById('gameVisibility').value;
        this.gameData.allowSpectators = document.getElementById('allowSpectators').checked;
        this.gameData.enableChat = document.getElementById('enableChat').checked;
    }
    
    static updateBalanceDisplay() {
        const balance = StateManager.get('userBalance') || 0;
        const balanceElement = document.getElementById('currentBalance');
        if (balanceElement) {
            balanceElement.textContent = `${Utils.formatCurrency(balance)} CORE`;
        }
    }
    
    static setStakeAmount(amount) {
        const stakeInput = document.getElementById('stakeAmount');
        if (stakeInput) {
            stakeInput.value = amount;
            this.calculateStakeInfo();
        }
    }
    
    static calculateStakeInfo() {
        const stakeAmount = parseFloat(document.getElementById('stakeAmount').value) || 0;
        const platformFeeRate = Config.get('PLATFORM_FEE_PERCENTAGE') / 100;
        const totalStake = stakeAmount * 2;
        const platformFee = totalStake * platformFeeRate;
        const winnerAmount = totalStake - platformFee;
        
        // Update displays
        document.getElementById('yourStake').textContent = `${Utils.formatCurrency(stakeAmount)} CORE`;
        document.getElementById('opponentStake').textContent = `${Utils.formatCurrency(stakeAmount)} CORE`;
        document.getElementById('platformFee').textContent = `${Utils.formatCurrency(platformFee)} CORE`;
        document.getElementById('winnerAmount').textContent = `${Utils.formatCurrency(winnerAmount)} CORE`;
        
        this.gameData.stakeAmount = stakeAmount;
    }
    
    static nextStep() {
        if (this.validateCurrentStep()) {
            this.currentStep++;
            this.updateWizardDisplay();
            
            if (this.currentStep === 4) {
                this.updateSummary();
            }
        }
    }
    
    static previousStep() {
        if (this.currentStep > 1) {
            this.currentStep--;
            this.updateWizardDisplay();
        }
    }
    
    static validateCurrentStep() {
        switch (this.currentStep) {
            case 1:
                if (!this.gameData.gameType) {
                    NotificationManager.show(
                        'Selection Required',
                        'Please select a game type',
                        'warning',
                        3000
                    );
                    return false;
                }
                break;
                
            case 2:
                this.updateGameData();
                break;
                
            case 3:
                const stakeAmount = parseFloat(document.getElementById('stakeAmount').value);
                const userBalance = StateManager.get('userBalance') || 0;
                
                if (!stakeAmount || stakeAmount < Config.get('MIN_STAKE_AMOUNT')) {
                    NotificationManager.show(
                        'Invalid Stake',
                        `Minimum stake is ${Config.get('MIN_STAKE_AMOUNT')} CORE`,
                        'warning',
                        3000
                    );
                    return false;
                }
                
                if (stakeAmount > Config.get('MAX_STAKE_AMOUNT')) {
                    NotificationManager.show(
                        'Invalid Stake',
                        `Maximum stake is ${Config.get('MAX_STAKE_AMOUNT')} CORE`,
                        'warning',
                        3000
                    );
                    return false;
                }
                
                if (stakeAmount > userBalance) {
                    NotificationManager.show(
                        'Insufficient Balance',
                        'You do not have enough CORE tokens for this stake',
                        'error',
                        5000
                    );
                    return false;
                }
                break;
                
            case 4:
                if (!document.getElementById('agreeTerms').checked) {
                    NotificationManager.show(
                        'Agreement Required',
                        'Please agree to the terms of service',
                        'warning',
                        3000
                    );
                    return false;
                }
                break;
        }
        
        return true;
    }
    
    static updateWizardDisplay() {
        // Update step indicators
        document.querySelectorAll('.step').forEach((step, index) => {
            step.classList.toggle('active', index + 1 === this.currentStep);
            step.classList.toggle('completed', index + 1 < this.currentStep);
        });
        
        // Update step content
        document.querySelectorAll('.step-content').forEach((content, index) => {
            content.classList.toggle('active', index + 1 === this.currentStep);
        });
        
        // Update navigation buttons
        const prevBtn = document.getElementById('prevStepBtn');
        const nextBtn = document.getElementById('nextStepBtn');
        const createBtn = document.getElementById('createGameBtn');
        
        if (prevBtn) prevBtn.disabled = this.currentStep === 1;
        
        if (nextBtn && createBtn) {
            if (this.currentStep === 4) {
                nextBtn.style.display = 'none';
                createBtn.style.display = 'inline-flex';
            } else {
                nextBtn.style.display = 'inline-flex';
                createBtn.style.display = 'none';
            }
        }
    }
    
    static updateSummary() {
        const timeLabels = {
            30: '30 seconds',
            60: '1 minute',
            300: '5 minutes',
            600: '10 minutes',
            900: '15 minutes',
            1800: '30 minutes'
        };
        
        document.getElementById('summaryGameType').textContent = 
            this.gameData.gameType?.charAt(0).toUpperCase() + this.gameData.gameType?.slice(1) || '-';
        document.getElementById('summaryTimeLimit').textContent = 
            timeLabels[this.gameData.timeLimit] || '-';
        document.getElementById('summarySkillLevel').textContent = 
            this.gameData.skillLevel?.charAt(0).toUpperCase() + this.gameData.skillLevel?.slice(1) || '-';
        document.getElementById('summaryVisibility').textContent = 
            this.gameData.visibility?.charAt(0).toUpperCase() + this.gameData.visibility?.slice(1) || '-';
        document.getElementById('summaryStakeAmount').textContent = 
            `${Utils.formatCurrency(this.gameData.stakeAmount)} CORE`;
        
        // Calculate winner amount
        const totalStake = this.gameData.stakeAmount * 2;
        const platformFee = totalStake * (Config.get('PLATFORM_FEE_PERCENTAGE') / 100);
        const winnerAmount = totalStake - platformFee;
        
        document.getElementById('summaryWinnerAmount').textContent = 
            `${Utils.formatCurrency(winnerAmount)} CORE`;
    }
    
    static async createGame() {
        try {
            if (!this.validateCurrentStep()) return;
            
            const createBtn = document.getElementById('createGameBtn');
            if (createBtn) {
                createBtn.disabled = true;
                createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating Game...';
            }
            
            const result = await TransactionManager.submitTransaction('create_game', {
                gameType: this.gameData.gameType,
                timeLimit: this.gameData.timeLimit,
                stakeAmount: this.gameData.stakeAmount
            });
            
            if (result.success) {
                NotificationManager.show(
                    'Game Creation Started',
                    'Your game is being created on the blockchain...',
                    'info',
                    5000
                );
                
                // Navigate back to lobby after a delay
                setTimeout(() => {
                    NavigationManager.navigateToSection('lobby');
                }, 2000);
                
            } else {
                NotificationManager.show(
                    'Creation Failed',
                    result.error || 'Failed to create game',
                    'error',
                    5000
                );
            }
            
        } catch (error) {
            ErrorManager.logError(error, 'CreateGameSection.createGame');
            
            NotificationManager.show(
                'Creation Error',
                'An error occurred while creating the game',
                'error',
                5000
            );
        } finally {
            const createBtn = document.getElementById('createGameBtn');
            if (createBtn) {
                createBtn.disabled = false;
                createBtn.innerHTML = '<i class="fas fa-plus"></i> Create Game';
            }
        }
    }
}

// ===========================
// GLOBAL INSTANCES
// ===========================

const NavigationManager = new NavigationManager();

// Export to global scope
window.NavigationManager = NavigationManager;
window.LobbySection = LobbySection;
window.CreateGameSection = CreateGameSection;

console.log('✅ Section 5: Main Content Sections & UI Management Loaded');
</script>
<script>
  /* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 6: REMAINING SECTIONS & PLATFORM INITIALIZATION
   =========================== */

'use strict';

// ===========================
// GAMES SECTION
// ===========================

class GamesSection {
    static render() {
        const container = document.getElementById('gamesSection');
        if (!container) return;
        
        container.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-gamepad"></i> Active Games</h2>
                <div class="header-actions">
                    <button class="btn btn-accent" onclick="NavigationManager.navigateToSection('create')">
                        <i class="fas fa-plus"></i> Create Game
                    </button>
                    <button class="btn btn-secondary" onclick="GamesSection.refreshGames()">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
            </div>
            
            <div class="games-content">
                <div class="games-filters">
                    <div class="filter-group">
                        <label>Game Type:</label>
                        <select id="gameTypeFilter" onchange="GamesSection.applyFilters()">
                            <option value="">All Games</option>
                            <option value="chess">Chess</option>
                            <option value="checkers">Checkers</option>
                            <option value="words">Word Battle</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label>Stake Range:</label>
                        <select id="stakeFilter" onchange="GamesSection.applyFilters()">
                            <option value="">Any Stake</option>
                            <option value="0-0.1">0 - 0.1 CORE</option>
                            <option value="0.1-1">0.1 - 1 CORE</option>
                            <option value="1-10">1 - 10 CORE</option>
                            <option value="10+">10+ CORE</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label>Skill Level:</label>
                        <select id="skillFilter" onchange="GamesSection.applyFilters()">
                            <option value="">All Levels</option>
                            <option value="beginner">Beginner</option>
                            <option value="intermediate">Intermediate</option>
                            <option value="advanced">Advanced</option>
                            <option value="expert">Expert</option>
                        </select>
                    </div>
                </div>
                
                <div class="games-grid" id="gamesGrid">
                    <div class="loading-placeholder">
                        <i class="fas fa-spinner fa-spin"></i>
                        <span>Loading available games...</span>
                    </div>
                </div>
            </div>
        `;
        
        this.loadGames();
    }
    
    static async loadGames() {
        try {
            const grid = document.getElementById('gamesGrid');
            if (!grid) return;
            
            await Utils.sleep(1000);
            
            const mockGames = [
                {
                    id: 1,
                    type: 'chess',
                    creator: '0x742d...a85f',
                    stake: 0.5,
                    timeLimit: 600,
                    skillLevel: 'intermediate',
                    status: 'waiting',
                    created: Date.now() - 300000
                },
                {
                    id: 2,
                    type: 'checkers',
                    creator: '0x8b3c...2d1e',
                    stake: 0.1,
                    timeLimit: 300,
                    skillLevel: 'beginner',
                    status: 'waiting',
                    created: Date.now() - 600000
                },
                {
                    id: 3,
                    type: 'words',
                    creator: '0x1a2b...9f8e',
                    stake: 1.0,
                    timeLimit: 900,
                    skillLevel: 'advanced',
                    status: 'in_progress',
                    player2: '0x5c6d...3f4e',
                    created: Date.now() - 1200000
                }
            ];
            
            grid.innerHTML = mockGames.map(game => this.createGameCard(game)).join('');
            
        } catch (error) {
            ErrorManager.logError(error, 'GamesSection.loadGames');
        }
    }
    
    static createGameCard(game) {
        const gameIcons = {
            chess: 'chess-king',
            checkers: 'chess-board',
            words: 'spell-check'
        };
        
        const statusColors = {
            waiting: 'warning',
            in_progress: 'info',
            completed: 'success'
        };
        
        const actionButton = game.status === 'waiting' 
            ? `<button class="btn btn-primary" onclick="GamesSection.joinGame(${game.id})">Join Game</button>`
            : game.status === 'in_progress' 
                ? `<button class="btn btn-info" onclick="GamesSection.spectateGame(${game.id})">Spectate</button>`
                : `<button class="btn btn-secondary" disabled>Completed</button>`;
        
        return `
            <div class="game-card" data-game-id="${game.id}" data-type="${game.type}" 
                 data-stake="${game.stake}" data-skill="${game.skillLevel}">
                <div class="game-card-header">
                    <div class="game-type">
                        <i class="fas fa-${gameIcons[game.type]}"></i>
                        ${game.type.charAt(0).toUpperCase() + game.type.slice(1)}
                    </div>
                    <div class="game-status ${statusColors[game.status]}">
                        ${game.status.replace('_', ' ').toUpperCase()}
                    </div>
                </div>
                
                <div class="game-card-body">
                    <div class="game-stake">
                        <span class="stake-amount">${Utils.formatCurrency(game.stake)}</span>
                        <span class="stake-label">CORE Stake</span>
                    </div>
                    
                    <div class="game-info">
                        <div class="info-row">
                            <span class="info-label">Creator:</span>
                            <span class="info-value">${game.creator}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Time Limit:</span>
                            <span class="info-value">${Math.floor(game.timeLimit / 60)} min</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Skill Level:</span>
                            <span class="info-value">${game.skillLevel}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Created:</span>
                            <span class="info-value">${Utils.formatTimeAgo(game.created)}</span>
                        </div>
                        ${game.player2 ? `
                        <div class="info-row">
                            <span class="info-label">Opponent:</span>
                            <span class="info-value">${game.player2}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
                
                <div class="game-card-footer">
                    ${actionButton}
                </div>
            </div>
        `;
    }
    
    static async joinGame(gameId) {
        if (!StateManager.get('isWalletConnected')) {
            NotificationManager.show(
                'Wallet Required',
                'Please connect your wallet to join games',
                'warning',
                5000
            );
            return;
        }
        
        // Implementation for joining a game would go here
        NotificationManager.show(
            'Joining Game',
            `Joining game ${gameId}...`,
            'info',
            3000
        );
    }
    
    static spectateGame(gameId) {
        NotificationManager.show(
            'Spectate Mode',
            'Opening game in spectate mode...',
            'info',
            3000
        );
    }
    
    static applyFilters() {
        const gameTypeFilter = document.getElementById('gameTypeFilter').value;
        const stakeFilter = document.getElementById('stakeFilter').value;
        const skillFilter = document.getElementById('skillFilter').value;
        
        const gameCards = document.querySelectorAll('.game-card');
        
        gameCards.forEach(card => {
            let show = true;
            
            if (gameTypeFilter && card.dataset.type !== gameTypeFilter) {
                show = false;
            }
            
            if (skillFilter && card.dataset.skill !== skillFilter) {
                show = false;
            }
            
            if (stakeFilter) {
                const stake = parseFloat(card.dataset.stake);
                const [min, max] = this.parseStakeRange(stakeFilter);
                if (stake < min || (max && stake > max)) {
                    show = false;
                }
            }
            
            card.style.display = show ? 'block' : 'none';
        });
    }
    
    static parseStakeRange(range) {
        if (range === '0-0.1') return [0, 0.1];
        if (range === '0.1-1') return [0.1, 1];
        if (range === '1-10') return [1, 10];
        if (range === '10+') return [10, null];
        return [0, null];
    }
    
    static async refreshGames() {
        const refreshBtn = document.querySelector('.games-content .btn-secondary');
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        }
        
        await this.loadGames();
        
        if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh';
        }
        
        NotificationManager.show(
            'Games Refreshed',
            'Games list has been updated',
            'success',
            3000
        );
    }
}

// ===========================
// TOURNAMENTS SECTION
// ===========================

class TournamentsSection {
    static render() {
        const container = document.getElementById('tournamentsSection');
        if (!container) return;
        
        container.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-trophy"></i> Tournaments</h2>
                <div class="header-actions">
                    <button class="btn btn-accent" onclick="TournamentsSection.createTournament()">
                        <i class="fas fa-plus"></i> Create Tournament
                    </button>
                </div>
            </div>
            
            <div class="tournaments-content">
                <div class="tournament-tabs">
                    <button class="tab-btn active" onclick="TournamentsSection.showTab('active')">
                        <i class="fas fa-play"></i> Active Tournaments
                    </button>
                    <button class="tab-btn" onclick="TournamentsSection.showTab('upcoming')">
                        <i class="fas fa-clock"></i> Upcoming
                    </button>
                    <button class="tab-btn" onclick="TournamentsSection.showTab('completed')">
                        <i class="fas fa-check"></i> Completed
                    </button>
                </div>
                
                <div class="tab-content active" id="activeTab">
                    <div class="tournaments-grid" id="activeTournaments">
                        <div class="loading-placeholder">
                            <i class="fas fa-spinner fa-spin"></i>
                            <span>Loading tournaments...</span>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="upcomingTab">
                    <div class="tournaments-grid" id="upcomingTournaments"></div>
                </div>
                
                <div class="tab-content" id="completedTab">
                    <div class="tournaments-grid" id="completedTournaments"></div>
                </div>
            </div>
        `;
        
        this.loadTournaments();
    }
    
    static async loadTournaments() {
        await Utils.sleep(800);
        
        const mockTournaments = {
            active: [
                {
                    id: 1,
                    name: 'Weekly Chess Championship',
                    game: 'chess',
                    prizePool: 100,
                    players: 24,
                    maxPlayers: 32,
                    startTime: Date.now() + 8100000, // 2h 15m
                    status: 'registering'
                }
            ],
            upcoming: [
                {
                    id: 2,
                    name: 'Speed Checkers Arena',
                    game: 'checkers',
                    prizePool: 50,
                    players: 8,
                    maxPlayers: 16,
                    startTime: Date.now() + 2700000, // 45m
                    status: 'upcoming'
                }
            ],
            completed: [
                {
                    id: 3,
                    name: 'Word Masters Tournament',
                    game: 'words',
                    prizePool: 75,
                    players: 16,
                    maxPlayers: 16,
                    startTime: Date.now() - 86400000, // 1 day ago
                    status: 'completed',
                    winner: '0x742d...a85f'
                }
            ]
        };
        
        Object.keys(mockTournaments).forEach(tab => {
            const container = document.getElementById(`${tab}Tournaments`);
            if (container) {
                container.innerHTML = mockTournaments[tab].map(tournament => 
                    this.createTournamentCard(tournament)
                ).join('');
            }
        });
    }
    
    static createTournamentCard(tournament) {
        const gameIcons = {
            chess: 'chess-king',
            checkers: 'chess-board',
            words: 'spell-check'
        };
        
        let actionButton = '';
        let timeInfo = '';
        
        if (tournament.status === 'registering' || tournament.status === 'upcoming') {
            const timeUntilStart = tournament.startTime - Date.now();
            const hours = Math.floor(timeUntilStart / 3600000);
            const minutes = Math.floor((timeUntilStart % 3600000) / 60000);
            timeInfo = `Starts in ${hours}h ${minutes}m`;
            actionButton = `<button class="btn btn-success">Join Tournament</button>`;
        } else if (tournament.status === 'completed') {
            timeInfo = `Completed ${Utils.formatTimeAgo(tournament.startTime)}`;
            actionButton = `<button class="btn btn-secondary" disabled>View Results</button>`;
        }
        
        return `
            <div class="tournament-card">
                <div class="tournament-header">
                    <div class="tournament-game">
                        <i class="fas fa-${gameIcons[tournament.game]}"></i>
                        ${tournament.game.charAt(0).toUpperCase() + tournament.game.slice(1)}
                    </div>
                    <div class="tournament-status ${tournament.status}">
                        ${tournament.status.toUpperCase()}
                    </div>
                </div>
                
                <div class="tournament-body">
                    <h3>${tournament.name}</h3>
                    
                    <div class="tournament-prize">
                        <span class="prize-amount">${tournament.prizePool}</span>
                        <span class="prize-label">CORE Prize Pool</span>
                    </div>
                    
                    <div class="tournament-info">
                        <div class="info-row">
                            <span class="info-label">Players:</span>
                            <span class="info-value">${tournament.players}/${tournament.maxPlayers}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Time:</span>
                            <span class="info-value">${timeInfo}</span>
                        </div>
                        ${tournament.winner ? `
                        <div class="info-row">
                            <span class="info-label">Winner:</span>
                            <span class="info-value">${tournament.winner}</span>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div class="tournament-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${(tournament.players / tournament.maxPlayers) * 100}%"></div>
                        </div>
                        <span class="progress-text">${tournament.players}/${tournament.maxPlayers} players</span>
                    </div>
                </div>
                
                <div class="tournament-footer">
                    ${actionButton}
                </div>
            </div>
        `;
    }
    
    static showTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[onclick="TournamentsSection.showTab('${tabName}')"]`).classList.add('active');
        
        // Update tab content
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(`${tabName}Tab`).classList.add('active');
    }
    
    static createTournament() {
        NotificationManager.show(
            'Coming Soon',
            'Tournament creation will be available in the next update',
            'info',
            5000
        );
    }
}

// ===========================
// PROFILE SECTION
// ===========================

class ProfileSection {
    static render() {
        const container = document.getElementById('profileSection');
        if (!container) return;
        
        const userAccount = StateManager.get('userAccount');
        const playerStats = StateManager.get('playerStats');
        const skillRatings = StateManager.get('skillRatings');
        
        container.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-user"></i> Player Profile</h2>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="ProfileSection.exportProfile()">
                        <i class="fas fa-download"></i> Export Data
                    </button>
                </div>
            </div>
            
            <div class="profile-content">
                <div class="profile-grid">
                    <div class="profile-card user-info">
                        <div class="card-header">
                            <h3><i class="fas fa-id-card"></i> User Information</h3>
                        </div>
                        <div class="card-content">
                            <div class="user-avatar">
                                <div class="avatar-placeholder">
                                    <i class="fas fa-user"></i>
                                </div>
                            </div>
                            <div class="user-details">
                                <div class="detail-row">
                                    <span class="label">Wallet Address:</span>
                                    <span class="value">${userAccount ? `${userAccount.substring(0, 6)}...${userAccount.substring(38)}` : 'Not connected'}</span>
                                </div>
                                <div class="detail-row">
                                    <span class="label">Member Since:</span>
                                    <span class="value">${new Date().toLocaleDateString()}</span>
                                </div>
                                <div class="detail-row">
                                    <span class="label">Total Balance:</span>
                                    <span class="value">${Utils.formatCurrency(StateManager.get('userBalance') || 0)} CORE</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="profile-card game-stats">
                        <div class="card-header">
                            <h3><i class="fas fa-chart-bar"></i> Game Statistics</h3>
                        </div>
                        <div class="card-content">
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <div class="stat-value">${playerStats?.gamesPlayed || 0}</div>
                                    <div class="stat-label">Games Played</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${playerStats?.gamesWon || 0}</div>
                                    <div class="stat-label">Games Won</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${((playerStats?.winRate || 0) * 100).toFixed(1)}%</div>
                                    <div class="stat-label">Win Rate</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${Utils.formatCurrency(playerStats?.totalEarned || 0)}</div>
                                    <div class="stat-label">CORE Earned</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="profile-card skill-ratings">
                        <div class="card-header">
                            <h3><i class="fas fa-star"></i> Skill Ratings</h3>
                        </div>
                        <div class="card-content">
                            <div class="skill-list">
                                <div class="skill-item">
                                    <div class="skill-info">
                                        <span class="skill-name">
                                            <i class="fas fa-chess-king"></i> Chess
                                        </span>
                                        <span class="skill-rating">${skillRatings?.chess || 100}</span>
                                    </div>
                                    <div class="skill-bar">
                                        <div class="skill-progress" style="width: ${Math.min((skillRatings?.chess || 100) / 20, 100)}%"></div>
                                    </div>
                                </div>
                                
                                <div class="skill-item">
                                    <div class="skill-info">
                                        <span class="skill-name">
                                            <i class="fas fa-chess-board"></i> Checkers
                                        </span>
                                        <span class="skill-rating">${skillRatings?.checkers || 100}</span>
                                    </div>
                                    <div class="skill-bar">
                                        <div class="skill-progress" style="width: ${Math.min((skillRatings?.checkers || 100) / 20, 100)}%"></div>
                                    </div>
                                </div>
                                
                                <div class="skill-item">
                                    <div class="skill-info">
                                        <span class="skill-name">
                                            <i class="fas fa-spell-check"></i> Word Battle
                                        </span>
                                        <span class="skill-rating">${skillRatings?.words || 100}</span>
                                    </div>
                                    <div class="skill-bar">
                                        <div class="skill-progress" style="width: ${Math.min((skillRatings?.words || 100) / 20, 100)}%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="profile-card recent-games">
                        <div class="card-header">
                            <h3><i class="fas fa-history"></i> Recent Games</h3>
                        </div>
                        <div class="card-content">
                            <div class="recent-games-list" id="recentGamesList">
                                <div class="no-games">
                                    <i class="fas fa-ghost"></i>
                                    <p>No recent games</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        this.loadRecentGames();
    }
    
    static async loadRecentGames() {
        // This would typically load from blockchain or API
        const recentGamesList = document.getElementById('recentGamesList');
        if (!recentGamesList) return;
        
        // Mock data for demonstration
        const mockGames = [];
        
        if (mockGames.length === 0) {
            recentGamesList.innerHTML = `
                <div class="no-games">
                    <i class="fas fa-ghost"></i>
                    <p>No recent games found</p>
                    <button class="btn btn-primary" onclick="NavigationManager.navigateToSection('create')">
                        Create Your First Game
                    </button>
                </div>
            `;
        }
    }
    
    static exportProfile() {
        const profileData = {
            userAccount: StateManager.get('userAccount'),
            playerStats: StateManager.get('playerStats'),
            skillRatings: StateManager.get('skillRatings'),
            platformSettings: StateManager.get('platformSettings'),
            exportDate: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(profileData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `crossrealm-profile-${Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        NotificationManager.show(
            'Profile Exported',
            'Your profile data has been downloaded',
            'success',
            3000
        );
    }
}

// ===========================
// CHAT SECTION
// ===========================

class ChatSection {
    static render() {
        const container = document.getElementById('chatSection');
        if (!container) return;
        
        container.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-comments"></i> Global Chat</h2>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="ChatSection.clearChat()">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                </div>
            </div>
            
            <div class="chat-content">
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="system-message">
                            <i class="fas fa-info-circle"></i>
                            Welcome to CrossRealm Global Chat! Be respectful and follow community guidelines.
                        </div>
                    </div>
                    
                    <div class="chat-input-container">
                        <div class="chat-input-wrapper">
                            <input type="text" id="chatInput" class="chat-input" 
                                   placeholder="Type your message..." maxlength="200"
                                   ${!StateManager.get('isWalletConnected') ? 'disabled' : ''}>
                            <button class="btn btn-primary" id="sendChatBtn" 
                                    onclick="ChatSection.sendMessage()"
                                    ${!StateManager.get('isWalletConnected') ? 'disabled' : ''}>
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                        ${!StateManager.get('isWalletConnected') ? 
                            '<div class="chat-notice">Connect your wallet to participate in chat</div>' : 
                            '<div class="chat-notice">Press Enter to send • 200 character limit</div>'
                        }
                    </div>
                </div>
                
                <div class="chat-sidebar">
                    <div class="online-users">
                        <div class="sidebar-header">
                            <h4><i class="fas fa-users"></i> Online Players</h4>
                            <span class="user-count" id="onlineUserCount">0</span>
                        </div>
                        <div class="users-list" id="onlineUsersList">
                            <div class="loading-placeholder">
                                <i class="fas fa-spinner fa-spin"></i>
                                <span>Loading users...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        this.setupChatHandlers();
        this.loadOnlineUsers();
        this.startChatPolling();
    }
    
    static setupChatHandlers() {
        const chatInput = document.getElementById('chatInput');
        if (chatInput) {
            chatInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.sendMessage();
                }
            });
        }
    }
    
    static sendMessage() {
        if (!StateManager.get('isWalletConnected')) {
            NotificationManager.show(
                'Wallet Required',
                'Please connect your wallet to use chat',
                'warning',
                3000
            );
            return;
        }
        
        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();
        
        if (!message) return;
        
        // Rate limiting
        if (!SecurityManager.checkRateLimit('chat_message', 5, 60000)) {
            NotificationManager.show(
                'Rate Limited',
                'You are sending messages too quickly',
                'warning',
                3000
            );
            return;
        }
        
        // Input validation
        const validation = SecurityManager.validateInput(message, 'string', {
            maxLength: 200,
            allowHTML: false
        });
        
        if (!validation.valid) {
            NotificationManager.show(
                'Invalid Message',
                validation.error,
                'error',
                3000
            );
            return;
        }
        
        // Add message to chat
        this.addChatMessage(
            StateManager.get('userAccount'),
            validation.sanitized,
            Date.now(),
            'user'
        );
        
        // Clear input
        chatInput.value = '';
    }
    
    static addChatMessage(sender, message, timestamp, type = 'user') {
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) return;
        
        const messageElement = document.createElement('div');
        messageElement.className = `chat-message ${type}`;
        
        const senderDisplay = sender === StateManager.get('userAccount') 
            ? 'You' 
            : `${sender.substring(0, 6)}...${sender.substring(38)}`;
        
        messageElement.innerHTML = `
            <div class="message-header">
                <span class="message-sender">${senderDisplay}</span>
                <span class="message-time">${new Date(timestamp).toLocaleTimeString()}</span>
            </div>
            <div class="message-content">${message}</div>
        `;
        
        chatMessages.appendChild(messageElement);
        
        // Auto-scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // Limit messages
        const messages = chatMessages.querySelectorAll('.chat-message');
        const maxMessages = Config.get('MAX_CHAT_MESSAGES');
        
        if (messages.length > maxMessages) {
            const toRemove = messages.length - maxMessages;
            for (let i = 0; i < toRemove; i++) {
                messages[i].remove();
            }
        }
    }
    
    static async loadOnlineUsers() {
        const usersList = document.getElementById('onlineUsersList');
        const userCount = document.getElementById('onlineUserCount');
        
        if (!usersList || !userCount) return;
        
        await Utils.sleep(1000);
        
        const mockUsers = [
            '0x742d...a85f',
            '0x8b3c...2d1e',
            '0x1a2b...9f8e',
            '0x5c6d...3f4e'
        ];
        
        userCount.textContent = mockUsers.length;
        
        usersList.innerHTML = mockUsers.map(user => `
            <div class="user-item">
                <div class="user-avatar">
                    <i class="fas fa-user"></i>
                </div>
                <div class="user-info">
                    <div class="user-name">${user}</div>
                    <div class="user-status online">Online</div>
                </div>
            </div>
        `).join('');
    }
    
    static startChatPolling() {
        // In a real implementation, this would poll for new messages
        // For demo purposes, we'll add some mock messages
        setTimeout(() => {
            this.addChatMessage(
                '0x742d...a85f',
                'Welcome to CrossRealm! Great to see more players joining.',
                Date.now() - 60000
            );
        }, 5000);
        
        setTimeout(() => {
            this.addChatMessage(
                '0x8b3c...2d1e',
                'Anyone up for a quick chess game?',
                Date.now() - 30000
            );
        }, 10000);
    }
    
    static clearChat() {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
            chatMessages.innerHTML = `
                <div class="system-message">
                    <i class="fas fa-info-circle"></i>
                    Chat cleared locally. Welcome to CrossRealm Global Chat!
                </div>
            `;
        }
    }
}

// ===========================
// SETTINGS SECTION
// ===========================

class SettingsSection {
    static render() {
        const container = document.getElementById('settingsSection');
        if (!container) return;
        
        const settings = StateManager.get('platformSettings') || {};
        
        container.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-cog"></i> Settings</h2>
                <div class="header-actions">
                    <button class="btn btn-success" onclick="SettingsSection.saveSettings()">
                        <i class="fas fa-save"></i> Save Settings
                    </button>
                    <button class="btn btn-secondary" onclick="SettingsSection.resetSettings()">
                        <i class="fas fa-undo"></i> Reset to Default
                    </button>
                </div>
            </div>
            
            <div class="settings-content">
                <div class="settings-tabs">
                    <button class="tab-btn active" onclick="SettingsSection.showTab('general')">
                        <i class="fas fa-cog"></i> General
                    </button>
                    <button class="tab-btn" onclick="SettingsSection.showTab('notifications')">
                        <i class="fas fa-bell"></i> Notifications
                    </button>
                    <button class="tab-btn" onclick="SettingsSection.showTab('privacy')">
                        <i class="fas fa-shield-alt"></i> Privacy & Security
                    </button>
                    <button class="tab-btn" onclick="SettingsSection.showTab('about')">
                        <i class="fas fa-info-circle"></i> About
                    </button>
                </div>
                
                <div class="tab-content active" id="generalTab">
                    <div class="settings-group">
                        <h3><i class="fas fa-gamepad"></i> Game Preferences</h3>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="autoJoin" ${settings.autoJoin ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Auto-join compatible games
                            </label>
                            <p class="setting-description">Automatically join games that match your skill level and stake preferences</p>
                        </div>
                        
                        <div class="setting-item">
                            <label class="setting-label">Default Stake Amount</label>
                            <div class="input-group">
                                <input type="number" id="defaultStake" value="${settings.defaultStake || 0.1}" 
                                       min="0.01" max="100" step="0.01">
                                <span class="input-suffix">CORE</span>
                            </div>
                            <p class="setting-description">Default stake amount when creating new games</p>
                        </div>
                    </div>
                    
                    <div class="settings-group">
                        <h3><i class="fas fa-desktop"></i> Interface</h3>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="soundEnabled" ${settings.soundEnabled ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Enable sound effects
                            </label>
                        </div>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="animationsEnabled" ${settings.animationsEnabled ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Enable animations
                            </label>
                        </div>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="hideBalance" ${settings.hideBalance ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Hide balance in header
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="notificationsTab">
                    <div class="settings-group">
                        <h3><i class="fas fa-bell"></i> Notification Preferences</h3>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="gameInvites" ${settings.gameInvites ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Game invitations
                            </label>
                        </div>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="txNotifications" ${settings.txNotifications ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Transaction notifications
                            </label>
                        </div>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="chatNotifications" ${settings.chatNotifications ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Chat notifications
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="privacyTab">
                    <div class="settings-group">
                        <h3><i class="fas fa-shield-alt"></i> Privacy & Security</h3>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="realTimeSync" ${settings.realTimeSync ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Real-time game synchronization
                            </label>
                            <p class="setting-description">Sync game state in real-time for faster gameplay</p>
                        </div>
                        
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="developerMode" ${settings.developerMode ? 'checked' : ''}>
                                <span class="checkmark"></span>
                                Developer mode
                            </label>
                            <p class="setting-description">Enable developer tools and debug features</p>
                        </div>
                        
                        <div class="setting-item">
                            <button class="btn btn-danger" onclick="SettingsSection.clearAllData()">
                                <i class="fas fa-trash"></i> Clear All Data
                            </button>
                            <p class="setting-description">Remove all stored settings and game data</p>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="aboutTab">
                    <div class="settings-group">
                        <h3><i class="fas fa-info-circle"></i> About CrossRealm</h3>
                        
                        <div class="about-info">
                            <div class="about-logo">
                                <i class="fas fa-dice-d20"></i>
                                <h2>CrossRealm Gaming</h2>
                            </div>
                            
                            <div class="about-details">
                                <p><strong>Version:</strong> 1.0.0</p>
                                <p><strong>Network:</strong> Core Blockchain</p>
                                <p><strong>Contract:</strong> ${Config.get('CONTRACT_ADDRESS')}</p>
                                <p><strong>Built:</strong> ${new Date().toLocaleDateString()}</p>
                            </div>
                            
                            <div class="about-links">
                                <a href="#" class="btn btn-secondary" onclick="SettingsSection.showTerms()">
                                    <i class="fas fa-file-contract"></i> Terms of Service
                                </a>
                                <a href="#" class="btn btn-secondary" onclick="SettingsSection.showPrivacy()">
                                    <i class="fas fa-user-shield"></i> Privacy Policy
                                </a>
                                <a href="https://github.com" target="_blank" class="btn btn-secondary">
                                    <i class="fab fa-github"></i> Source Code
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        this.setupSettingsHandlers();
    }
    
    static setupSettingsHandlers() {
        // Auto-save on changes
        const settingsInputs = [
            'autoJoin', 'defaultStake', 'soundEnabled', 'animationsEnabled',
            'hideBalance', 'gameInvites', 'txNotifications', 'chatNotifications',
            'realTimeSync', 'developerMode'
        ];
        
        settingsInputs.forEach(inputId => {
            const element = document.getElementById(inputId);
            if (element) {
                element.addEventListener('change', () => {
                    this.updateSettingsPreview();
                });
            }
        });
    }
    
    static updateSettingsPreview() {
        // Update settings preview in real-time
        const hideBalance = document.getElementById('hideBalance').checked;
        const balanceDisplay = document.getElementById('balanceDisplay');
        
        if (balanceDisplay) {
            balanceDisplay.style.display = hideBalance ? 'none' : 'block';
        }
        
        const developerMode = document.getElementById('developerMode').checked;
        Config.set('DEV_MODE', developerMode);
    }
    
    static showTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.settings-tabs .tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[onclick="SettingsSection.showTab('${tabName}')"]`).classList.add('active');
        
        // Update tab content
        document.querySelectorAll('.settings-content .tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(`${tabName}Tab`).classList.add('active');
    }
    
    static saveSettings() {
        try {
            const newSettings = {
                autoJoin: document.getElementById('autoJoin').checked,
                defaultStake: parseFloat(document.getElementById('defaultStake').value),
                soundEnabled: document.getElementById('soundEnabled').checked,
                animationsEnabled: document.getElementById('animationsEnabled').checked,
                hideBalance: document.getElementById('hideBalance').checked,
                gameInvites: document.getElementById('gameInvites').checked,
                txNotifications: document.getElementById('txNotifications').checked,
                chatNotifications: document.getElementById('chatNotifications').checked,
                realTimeSync: document.getElementById('realTimeSync').checked,
                developerMode: document.getElementById('developerMode').checked
            };
            
            StateManager.set('platformSettings', newSettings);
            
            NotificationManager.show(
                'Settings Saved',
                'Your preferences have been saved successfully',
                'success',
                3000
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'SettingsSection.saveSettings');
            
            NotificationManager.show(
                'Save Failed',
                'Failed to save settings. Please try again.',
                'error',
                5000
            );
        }
    }
    
    static resetSettings() {
        if (confirm('Are you sure you want to reset all settings to default?')) {
            const defaultSettings = {
                autoJoin: false,
                soundEnabled: true,
                animationsEnabled: true,
                defaultStake: 0.1,
                gameInvites: true,
                txNotifications: true,
                chatNotifications: false,
                hideBalance: false,
                developerMode: false,
                realTimeSync: true
            };
            
            StateManager.set('platformSettings', defaultSettings);
            this.render(); // Re-render with default values
            
            NotificationManager.show(
                'Settings Reset',
                'All settings have been reset to default values',
                'info',
                3000
            );
        }
    }
    
    static clearAllData() {
        if (confirm('This will permanently delete all your settings and game data. Are you sure?')) {
            try {
                StateManager.clearUserData();
                localStorage.clear();
                sessionStorage.clear();
                
                NotificationManager.show(
                    'Data Cleared',
                    'All data has been cleared. The page will reload.',
                    'success',
                    3000
                );
                
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
                
            } catch (error) {
                ErrorManager.logError(error, 'SettingsSection.clearAllData');
                
                NotificationManager.show(
                    'Clear Failed',
                    'Failed to clear data. Please try again.',
                    'error',
                    5000
                );
            }
        }
    }
    
    static showTerms() {
        NotificationManager.show(
            'Terms of Service',
            'Terms of Service modal would open here',
            'info',
            3000
        );
    }
    
    static showPrivacy() {
        NotificationManager.show(
            'Privacy Policy',
            'Privacy Policy modal would open here',
            'info',
            3000
        );
    }
}

// ===========================
// PLATFORM INITIALIZATION MANAGER
// ===========================

class PlatformManager {
    constructor() {
        this.initializationSteps = [
            { name: 'Loading core systems...', duration: 1000 },
            { name: 'Initializing blockchain provider...', duration: 1500 },
            { name: 'Connecting to Core Network...', duration: 2000 },
            { name: 'Loading smart contract...', duration: 1000 },
            { name: 'Setting up real-time systems...', duration: 1500 },
            { name: 'Preparing user interface...', duration: 1000 },
            { name: 'Finalizing platform...', duration: 500 }
        ];
        
        this.currentStep = 0;
        this.isInitialized = false;
    }
    
    async initializePlatform() {
        try {
            console.log('🚀 Starting CrossRealm platform initialization...');
            
            // Check if bypassing verification
            if (Config.get('BYPASS_VERIFICATION')) {
                console.log('⚠️ Bypassing verification checks');
                this.skipToInitialization();
                return;
            }
            
            // Step 1: Age verification
            if (!StateManager.get('isAgeVerified')) {
                await this.showAgeVerification();
            }
            
            // Step 2: Anti-bot verification
            if (!StateManager.get('isAntiBotVerified')) {
                await this.showAntiBotVerification();
            }
            
            // Step 3: Initialize platform systems
            await this.runInitializationSequence();
            
        } catch (error) {
            ErrorManager.logError(error, 'PlatformManager.initializePlatform');
            this.handleInitializationError(error);
        }
    }
    
    async showAgeVerification() {
        return new Promise((resolve) => {
            const modal = document.getElementById('ageVerificationModal');
            if (modal) {
                modal.style.display = 'flex';
                
                const handleVerification = (event) => {
                    const button = event.target.closest('[data-action="verify-age"]');
                    if (button) {
                        const isVerified = button.dataset.value === 'true';
                        
                        if (isVerified) {
                            StateManager.set('isAgeVerified', true);
                            sessionStorage.setItem('ageVerified', 'true');
                            modal.style.display = 'none';
                            resolve();
                        } else {
                            window.location.href = 'https://www.google.com';
                        }
                        
                        document.removeEventListener('click', handleVerification);
                    }
                };
                
                document.addEventListener('click', handleVerification);
            }
        });
    }
    
    async showAntiBotVerification() {
        return new Promise((resolve) => {
            const modal = document.getElementById('antiBotModal');
            if (modal) {
                modal.style.display = 'flex';
                this.generateCaptcha();
                
                const verifyBtn = document.getElementById('verifyCaptchaBtn');
                const refreshBtn = document.getElementById('refreshCaptchaBtn');
                
                const handleVerification = () => {
                    if (this.verifyCaptcha()) {
                        StateManager.set('isAntiBotVerified', true);
                        sessionStorage.setItem('antiBotVerified', 'true');
                        modal.style.display = 'none';
                        resolve();
                    } else {
                        NotificationManager.show(
                            'Verification Failed',
                            'Please try again',
                            'error',
                            3000
                        );
                        this.generateCaptcha();
                    }
                };
                
                const handleRefresh = () => {
                    this.generateCaptcha();
                };
                
                verifyBtn.addEventListener('click', handleVerification);
                refreshBtn.addEventListener('click', handleRefresh);
            }
        });
    }
    
    generateCaptcha() {
        const grid = document.getElementById('captchaGrid');
        if (!grid) return;
        
        const icons = [
            'fas fa-chess-king', 'fas fa-chess-queen', 'fas fa-chess-rook',
            'fas fa-chess-bishop', 'fas fa-chess-knight', 'fas fa-chess-pawn',
            'fas fa-star', 'fas fa-heart', 'fas fa-diamond'
        ];
        
        // Random selection of chess pieces (correct answers)
        const correctIcons = icons.slice(0, 6);
        this.correctTiles = new Set();
        
        grid.innerHTML = '';
        
        for (let i = 0; i < 9; i++) {
            const tile = document.createElement('div');
            tile.className = 'captcha-tile';
            tile.dataset.index = i;
            
            // 60% chance for chess piece, 40% for other icons
            const isChessPiece = Math.random() < 0.6;
            
            if (isChessPiece) {
                const icon = correctIcons[Math.floor(Math.random() * correctIcons.length)];
                tile.innerHTML = `<i class="${icon}"></i>`;
                this.correctTiles.add(i);
            } else {
                const icon = icons[6 + Math.floor(Math.random() * 3)];
                tile.innerHTML = `<i class="${icon}"></i>`;
            }
            
            tile.addEventListener('click', () => {
                tile.classList.toggle('selected');
                this.updateCaptchaButton();
            });
            
            grid.appendChild(tile);
        }
    }
    
    updateCaptchaButton() {
        const verifyBtn = document.getElementById('verifyCaptchaBtn');
        const selectedTiles = document.querySelectorAll('.captcha-tile.selected');
        
        if (verifyBtn) {
            verifyBtn.disabled = selectedTiles.length === 0;
        }
    }
    
    verifyCaptcha() {
        const selectedTiles = document.querySelectorAll('.captcha-tile.selected');
        const selectedIndices = new Set();
        
        selectedTiles.forEach(tile => {
            selectedIndices.add(parseInt(tile.dataset.index));
        });
        
        // Check if selection matches correct tiles
        if (selectedIndices.size !== this.correctTiles.size) {
            return false;
        }
        
        for (const index of selectedIndices) {
            if (!this.correctTiles.has(index)) {
                return false;
            }
        }
        
        return true;
    }
    
    async runInitializationSequence() {
        const loadingStatus = document.getElementById('loadingStatus');
        const loadingProgress = document.getElementById('loadingProgress');
        
        for (let i = 0; i < this.initializationSteps.length; i++) {
            const step = this.initializationSteps[i];
            
            if (loadingStatus) {
                loadingStatus.textContent = step.name;
            }
            
            if (loadingProgress) {
                const progress = ((i + 1) / this.initializationSteps.length) * 100;
                loadingProgress.style.width = `${progress}%`;
            }
            
            // Simulate step execution
            await Utils.sleep(step.duration);
            
            // Actually initialize systems
            switch (i) {
                case 1: // Initialize blockchain provider
                    await WalletManager.initialize();
                    break;
                case 3: // Load smart contract
                    this.updateContractStatus();
                    break;
                case 4: // Set up real-time systems
                    this.startRealTimeUpdates();
                    break;
            }
        }
        
        // Mark as initialized
        StateManager.set('isPlatformInitialized', true);
        this.isInitialized = true;
        
        // Hide loading screen
        this.hideLoadingScreen();
        
        console.log('✅ CrossRealm platform initialization completed');
    }
    
    skipToInitialization() {
        StateManager.set('isAgeVerified', true);
        StateManager.set('isAntiBotVerified', true);
        this.runInitializationSequence();
    }
    
    updateContractStatus() {
        const contractStatus = document.getElementById('contractStatus');
        if (contractStatus) {
            const indicator = contractStatus.querySelector('.status-indicator');
            const text = contractStatus.querySelector('span:last-child');
            
            if (indicator) {
                indicator.className = 'status-indicator online';
            }
            
            if (text) {
                text.textContent = 'Contract Loaded';
            }
        }
    }
    
    startRealTimeUpdates() {
        // Update live statistics
        this.updateLiveStats();
        
        // Start periodic updates
        setInterval(() => {
            this.updateLiveStats();
        }, 30000); // Every 30 seconds
        
        // Update server status
        const serverStatus = document.getElementById('serverStatus');
        if (serverStatus) {
            const indicator = serverStatus.querySelector('.status-indicator');
            const text = serverStatus.querySelector('span:last-child');
            
            if (indicator) {
                indicator.className = 'status-indicator online';
            }
            
            if (text) {
                text.textContent = 'Connected';
            }
        }
    }
    
    updateLiveStats() {
        // Simulate live statistics
        const stats = {
            onlinePlayersCount: Utils.getRandomInt(50, 200),
            activeGamesCount: Utils.getRandomInt(10, 50),
            totalVolumeCount: (Math.random() * 1000 + 500).toFixed(2),
            settlementsCount: Utils.getRandomInt(100, 500)
        };
        
        Object.entries(stats).forEach(([key, value]) => {
            const element = document.getElementById(key);
            if (element) {
                element.textContent = value;
            }
        });
    }
    
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.style.animation = 'fadeOut 0.5s ease-out forwards';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
    }
    
    handleInitializationError(error) {
        console.error('❌ Platform initialization failed:', error);
        
        const debugInfo = document.getElementById('debugInfo');
        if (debugInfo) {
            debugInfo.textContent = `Error: ${error.message}`;
            debugInfo.style.color = '#e74c3c';
        }
        
        // Show emergency bypass
        LifecycleManager.showEmergencyBypass(true);
        
        NotificationManager.show(
            'Initialization Failed',
            'Platform failed to initialize. Please refresh the page.',
            'error',
            0
        );
    }
}

// ===========================
// GLOBAL INSTANCES & INITIALIZATION
// ===========================

const GamesSection = GamesSection;
const TournamentsSection = TournamentsSection;
const ProfileSection = ProfileSection;
const ChatSection = ChatSection;
const SettingsSection = SettingsSection;
const PlatformManager = new PlatformManager();

// Export to global scope
window.GamesSection = GamesSection;
window.TournamentsSection = TournamentsSection;
window.ProfileSection = ProfileSection;
window.ChatSection = ChatSection;
window.SettingsSection = SettingsSection;
window.PlatformManager = PlatformManager;

// Initialize platform when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    // Check if already verified in session
    if (sessionStorage.getItem('ageVerified') === 'true') {
        StateManager.set('isAgeVerified', true);
    }
    
    if (sessionStorage.getItem('antiBotVerified') === 'true') {
        StateManager.set('isAntiBotVerified', true);
    }
    
    // Start platform initialization
    PlatformManager.initializePlatform();
});

// Add CSS for loading fade out animation
const style = document.createElement('style');
style.textContent = `
@keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
}
`;
document.head.appendChild(style);

console.log('✅ Section 6: Remaining Sections & Platform Initialization Loaded');
console.log('🎮 CrossRealm Gaming Platform - All Systems Loaded');
</script>
</body>
</html>
