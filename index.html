<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="CrossRealm Gaming - Blockchain gaming platform on Core Network">
    <meta name="keywords" content="blockchain gaming, Core Network, cryptocurrency games, chess, checkers">
    <meta name="author" content="CrossRealm Gaming">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; img-src 'self' data: https:; connect-src 'self' https://api.jsonbin.io https://rpc.coredao.org https://scan.coredao.org; font-src 'self' https://cdnjs.cloudflare.com;">
    <title>CrossRealm Gaming - Blockchain Gaming on Core Network</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" integrity="sha512-JNGbhLCEQuKMUOdNuY3iDeApC5A3VdMGGqLfGKFqN4iIdFJX3J0sEF8HWjKgw9LhJHQ8Qj9K4i2kGY1tCXKSMQ==" crossorigin="anonymous"></script>
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎮</text></svg>">
</head>
<body>
    <div class="background-overlay"></div>
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-content">
            <div class="logo-loading">
                <i class="fas fa-dice-d20 logo-icon"></i>
                <h1>CROSSREALM</h1>
            </div>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <div class="loading-status" id="loadingStatus">Initializing platform...</div>
        </div>
    </div>

    <!-- Age Verification Modal -->
    <div class="modal-overlay" id="ageVerificationModal">
        <div class="modal-content verification-modal">
            <div class="modal-header">
                <h2><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h2>
            </div>
            <div class="modal-body">
                <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
                <div class="warning-box">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
                </div>
                <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-success" data-action="verify-age" data-value="true">I am 18+</button>
                <button class="btn btn-danger" data-action="verify-age" data-value="false">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Anti-Bot Challenge Modal -->
    <div class="modal-overlay hidden" id="antiBotModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-shield-alt"></i> Human Verification</h3>
            </div>
            <div class="modal-body">
                <p>Please complete this challenge to continue:</p>
                <div class="captcha-container">
                    <div class="captcha-instructions" id="captchaInstructions">
                        Select all squares containing chess pieces
                    </div>
                    <div class="captcha-grid" id="captchaGrid">
                        <!-- Grid will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="verifyCaptchaBtn" disabled>Verify</button>
                <button class="btn btn-secondary" id="refreshCaptchaBtn">New Challenge</button>
            </div>
        </div>
    </div>

    <!-- Notification System -->
    <div class="notification-container" id="notificationContainer">
        <!-- Notifications will be populated by JavaScript -->
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div class="tx-message" id="txMessage">Processing...</div>
        <div class="tx-hash" id="txHash"></div>
        <button class="tx-close" id="txClose">&times;</button>
    </div>

    <!-- Game Invitation Modal -->
    <div class="modal-overlay hidden" id="gameInvitationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-gamepad"></i> Game Invitation</h3>
            </div>
            <div class="modal-body">
                <p id="invitationMessage">Player wants to join your game!</p>
                <div class="invitation-details" id="invitationDetails"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-success" data-action="accept-invitation">Accept</button>
                <button class="btn btn-danger" data-action="decline-invitation">Decline</button>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <i class="fas fa-dice-d20 logo-icon"></i>
                <h1>CROSSREALM</h1>
            </div>
            
            <nav class="nav-menu" id="navMenu">
                <button class="nav-item active" data-section="lobby">
                    <i class="fas fa-home"></i> Lobby
                </button>
                <button class="nav-item" data-section="create">
                    <i class="fas fa-plus"></i> Create Game
                </button>
                <button class="nav-item" data-section="games">
                    <i class="fas fa-gamepad"></i> Games
                </button>
                <button class="nav-item" data-section="tournaments">
                    <i class="fas fa-trophy"></i> Tournaments
                </button>
                <button class="nav-item" data-section="profile">
                    <i class="fas fa-user"></i> Profile
                </button>
                <button class="nav-item" data-section="settings">
                    <i class="fas fa-cog"></i> Settings
                </button>
            </nav>
            
            <div class="live-indicator">
                <div class="pulse-dot"></div>
                <span>LIVE ON CORE</span>
            </div>
            
            <div class="wallet-section">
                <div class="wallet-info">
                    <div class="connection-status" id="connectionStatus">
                        <span class="status-indicator offline"></span>
                        <span class="status-text">Not Connected</span>
                    </div>
                    <div class="balance" id="balanceDisplay">0.0000 CORE</div>
                </div>
                <button class="btn btn-primary" id="connectBtn">
                    <i class="fas fa-plug"></i> Connect Wallet
                </button>
                <button class="btn btn-secondary hidden" id="disconnectBtn">
                    <i class="fas fa-sign-out-alt"></i> Disconnect
                </button>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Smart Contract Status -->
            <div class="widget contract-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-file-contract"></i> Smart Contract</h3>
                </div>
                <div class="widget-content">
                    <div class="contract-address" id="contractAddress">
                        <span class="address-text">Loading...</span>
                        <button class="btn-copy" data-copy-target="contract-address">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                    <div class="contract-status" id="contractStatus">
                        <span class="status-indicator pending"></span>
                        <span>Connecting...</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="connectionProgress"></div>
                    </div>
                </div>
            </div>

            <!-- Server Status -->
            <div class="widget server-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-server"></i> Server Status</h3>
                </div>
                <div class="widget-content">
                    <div class="server-status" id="serverStatus">
                        <span class="status-indicator pending"></span>
                        <span>Connecting...</span>
                    </div>
                    <div class="server-details">
                        <div class="detail-row">
                            <span class="detail-label">Latency:</span>
                            <span class="detail-value" id="serverLatency">--ms</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Last Sync:</span>
                            <span class="detail-value" id="lastSync">Never</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Status:</span>
                            <span class="detail-value" id="serverStatusText">Offline</span>
                        </div>
                    </div>
                    <button class="btn btn-sm btn-primary" id="testConnectionBtn">
                        <i class="fas fa-wifi"></i> Test Connection
                    </button>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="widget stats-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-chart-line"></i> Live Stats</h3>
                </div>
                <div class="widget-content">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="onlinePlayersCount">0</div>
                            <div class="stat-label">Online Players</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="activeGamesCount">0</div>
                            <div class="stat-label">Active Games</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalVolumeCount">0</div>
                            <div class="stat-label">CORE Volume</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- My Active Games -->
            <div class="widget my-games-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-gamepad"></i> My Active Games</h3>
                </div>
                <div class="widget-content">
                    <div class="my-games-list" id="myActiveGamesList">
                        <div class="no-games">
                            <i class="fas fa-ghost"></i>
                            <p>No active games</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activity Feed -->
            <div class="widget activity-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-fire"></i> Recent Activity</h3>
                </div>
                <div class="widget-content">
                    <div class="activity-feed" id="activityFeed">
                        <div class="activity-item">
                            <i class="fas fa-rocket"></i>
                            <span>Platform initialized</span>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="content-area">
            <!-- Sections will be dynamically loaded here -->
            <section id="lobbySection" class="section-content active">
                <!-- Lobby content will be loaded by JavaScript -->
            </section>
            <section id="createSection" class="section-content">
                <!-- Create game content will be loaded by JavaScript -->
            </section>
            <section id="gamesSection" class="section-content">
                <!-- Games content will be loaded by JavaScript -->
            </section>
            <section id="tournamentsSection" class="section-content">
                <!-- Tournaments content will be loaded by JavaScript -->
            </section>
            <section id="profileSection" class="section-content">
                <!-- Profile content will be loaded by JavaScript -->
            </section>
            <section id="settingsSection" class="section-content">
                <!-- Settings content will be loaded by JavaScript -->
            </section>
        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4><i class="fas fa-dice-d20"></i> CrossRealm</h4>
                <p>Premier blockchain gaming platform on Core Network. Play, compete, and earn with provably fair games.</p>
                <div class="social-links">
                    <a href="#" class="social-link" aria-label="Twitter">
                        <i class="fab fa-twitter"></i>
                    </a>
                    <a href="#" class="social-link" aria-label="Discord">
                        <i class="fab fa-discord"></i>
                    </a>
                    <a href="#" class="social-link" aria-label="GitHub">
                        <i class="fab fa-github"></i>
                    </a>
                </div>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-gamepad"></i> Games</h4>
                <ul>
                    <li><a href="#" data-section="games">Chess Masters</a></li>
                    <li><a href="#" data-section="games">Checkers Pro</a></li>
                    <li><a href="#" data-section="games">Word Battle</a></li>
                    <li><a href="#" data-section="tournaments">Tournaments</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-link"></i> Blockchain</h4>
                <ul>
                    <li><a href="https://scan.coredao.org" target="_blank" rel="noopener noreferrer">Core Explorer</a></li>
                    <li><a href="https://coredao.org" target="_blank" rel="noopener noreferrer">Core Network</a></li>
                    <li><a href="#" data-action="show-contract">Smart Contract</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-info-circle"></i> Support</h4>
                <ul>
                    <li><a href="#" data-action="show-help">Help Center</a></li>
                    <li><a href="#" data-action="show-terms">Terms of Service</a></li>
                    <li><a href="#" data-action="show-privacy">Privacy Policy</a></li>
                    <li><a href="#" data-action="show-fairplay">Fair Play</a></li>
                </ul>
            </div>
        </div>
        
        <div class="footer-bottom">
            <p>&copy; 2025 CrossRealm Gaming Platform. All rights reserved.</p>
            <p>Built on <strong>Core Blockchain</strong> • Licensed Gaming Platform • 18+ Only</p>
        </div>
    </footer>
  <style>
/* ===========================
   CROSSREALM GAMING PLATFORM
   COMPLETE CSS STYLING WITH PERFORMANCE & SECURITY FIXES
   =========================== */

/* CSS Custom Properties for Better Theming */
:root {
    /* Color Palette */
    --color-primary: #4e54c8;
    --color-primary-dark: #363a9e;
    --color-secondary: #f39c12;
    --color-accent: #4ecdc4;
    --color-accent-dark: #44a08d;
    --color-success: #2ecc71;
    --color-warning: #f1c40f;
    --color-danger: #e74c3c;
    --color-info: #3498db;
    
    /* Background Colors */
    --bg-primary: #1a1c2c;
    --bg-secondary: #2c3e50;
    --bg-surface: rgba(255, 255, 255, 0.05);
    --bg-glass: rgba(255, 255, 255, 0.1);
    --bg-overlay: rgba(0, 0, 0, 0.8);
    
    /* Text Colors */
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --text-muted: #888888;
    
    /* Border Colors */
    --border-primary: rgba(255, 255, 255, 0.2);
    --border-accent: rgba(78, 205, 196, 0.5);
    
    /* Spacing */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    --spacing-xxl: 3rem;
    
    /* Border Radius */
    --radius-sm: 4px;
    --radius-md: 8px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    --radius-pill: 50px;
    
    /* Shadows */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.2);
    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.3);
    --shadow-glow: 0 0 20px rgba(78, 205, 196, 0.3);
    
    /* Animation Timing */
    --transition-fast: 0.15s ease-out;
    --transition-normal: 0.3s ease-out;
    --transition-slow: 0.5s ease-out;
    
    /* Z-index Scale */
    --z-background: -1;
    --z-base: 0;
    --z-elevated: 10;
    --z-dropdown: 100;
    --z-sticky: 200;
    --z-fixed: 300;
    --z-modal-backdrop: 900;
    --z-modal: 1000;
    --z-notification: 1100;
    --z-tooltip: 1200;
}

/* CSS Reset & Base Styles */
*,
*::before,
*::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    scroll-behavior: smooth;
}

body {
    font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
    background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
    overflow-x: hidden;
    position: relative;
}

/* Performance Optimizations */
* {
    will-change: auto;
}

.loading-screen,
.modal-overlay,
.notification,
.game-window {
    will-change: transform, opacity;
}

/* Accessibility Improvements */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Focus Styles for Accessibility */
button:focus,
input:focus,
select:focus,
textarea:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
}

/* Background Overlay */
.background-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(circle at 20% 50%, rgba(78, 205, 196, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(78, 84, 200, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(243, 156, 18, 0.05) 0%, transparent 50%);
    z-index: var(--z-background);
    pointer-events: none;
}

/* ===========================
   LOADING SCREEN
   =========================== */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: var(--z-modal);
    backdrop-filter: blur(10px);
}

.loading-content {
    text-align: center;
    max-width: 400px;
    padding: var(--spacing-xl);
}

.logo-loading {
    margin-bottom: var(--spacing-xl);
}

.logo-loading .logo-icon {
    font-size: 4rem;
    color: var(--color-accent);
    margin-bottom: var(--spacing-md);
    animation: pulse 2s infinite;
}

.logo-loading h1 {
    font-size: 2.5rem;
    background: linear-gradient(45deg, var(--color-primary), var(--color-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.loading-bar {
    width: 100%;
    height: 4px;
    background: var(--bg-surface);
    border-radius: var(--radius-pill);
    overflow: hidden;
    margin-bottom: var(--spacing-md);
}

.loading-progress {
    height: 100%;
    background: linear-gradient(90deg, var(--color-accent), var(--color-primary));
    width: 0%;
    transition: width var(--transition-normal);
    border-radius: var(--radius-pill);
}

.loading-status {
    color: var(--text-secondary);
    font-size: 0.9rem;
}

/* ===========================
   UTILITY CLASSES
   =========================== */
.hidden { display: none !important; }
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* Text Utilities */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

/* Spacing Utilities */
.mt-0 { margin-top: 0; }
.mt-1 { margin-top: var(--spacing-sm); }
.mt-2 { margin-top: var(--spacing-md); }
.mt-3 { margin-top: var(--spacing-lg); }

.mb-0 { margin-bottom: 0; }
.mb-1 { margin-bottom: var(--spacing-sm); }
.mb-2 { margin-bottom: var(--spacing-md); }
.mb-3 { margin-bottom: var(--spacing-lg); }

/* ===========================
   BUTTON SYSTEM
   =========================== */
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    border: none;
    border-radius: var(--radius-md);
    font-size: 0.9rem;
    font-weight: 600;
    text-decoration: none;
    cursor: pointer;
    transition: all var(--transition-fast);
    position: relative;
    overflow: hidden;
    min-height: 44px; /* Accessibility minimum touch target */
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

.btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left var(--transition-normal);
}

.btn:hover:not(:disabled)::before {
    left: 100%;
}

.btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.btn:active:not(:disabled) {
    transform: translateY(0);
}

/* Button Variants */
.btn-primary {
    background: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark));
    color: white;
}

.btn-secondary {
    background: var(--bg-surface);
    color: var(--text-primary);
    border: 1px solid var(--border-primary);
}

.btn-success {
    background: linear-gradient(135deg, var(--color-success), #27ae60);
    color: white;
}

.btn-danger {
    background: linear-gradient(135deg, var(--color-danger), #c0392b);
    color: white;
}

.btn-warning {
    background: linear-gradient(135deg, var(--color-warning), var(--color-secondary));
    color: var(--bg-primary);
}

.btn-accent {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    color: white;
}

/* Button Sizes */
.btn-sm {
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: 0.8rem;
    min-height: 36px;
}

.btn-lg {
    padding: var(--spacing-md) var(--spacing-xl);
    font-size: 1.1rem;
    min-height: 52px;
}

.btn-copy {
    padding: var(--spacing-xs);
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    min-height: 32px;
    width: 32px;
}

/* ===========================
   MODAL SYSTEM
   =========================== */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: var(--z-modal-backdrop);
    backdrop-filter: blur(5px);
    animation: fadeIn var(--transition-normal) ease-out;
}

.modal-content {
    background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
    border: 2px solid var(--color-accent);
    border-radius: var(--radius-xl);
    padding: 0;
    max-width: 90vw;
    max-height: 90vh;
    overflow: hidden;
    box-shadow: var(--shadow-lg);
    animation: slideInScale var(--transition-normal) ease-out;
    position: relative;
    z-index: var(--z-modal);
}

.modal-header {
    padding: var(--spacing-lg);
    border-bottom: 1px solid var(--border-primary);
    background: rgba(78, 205, 196, 0.1);
}

.modal-header h2,
.modal-header h3 {
    margin: 0;
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.modal-body {
    padding: var(--spacing-lg);
}

.modal-footer {
    padding: var(--spacing-lg);
    border-top: 1px solid var(--border-primary);
    display: flex;
    gap: var(--spacing-md);
    justify-content: center;
    background: var(--bg-surface);
}

.verification-modal {
    max-width: 500px;
}

.warning-box {
    background: rgba(241, 196, 15, 0.1);
    border: 1px solid rgba(241, 196, 15, 0.3);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin: var(--spacing-md) 0;
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-sm);
}

.warning-box i {
    color: var(--color-warning);
    margin-top: 2px;
    flex-shrink: 0;
}

/* ===========================
   CAPTCHA SYSTEM
   =========================== */
.captcha-container {
    text-align: center;
}

.captcha-instructions {
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-sm);
    background: var(--bg-surface);
    border-radius: var(--radius-md);
    font-weight: 600;
    color: var(--color-warning);
}

.captcha-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-sm);
    max-width: 240px;
    margin: 0 auto var(--spacing-md);
}

.captcha-tile {
    aspect-ratio: 1;
    background: var(--bg-surface);
    border: 2px solid var(--border-primary);
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all var(--transition-fast);
    user-select: none;
}

.captcha-tile:hover {
    background: rgba(78, 205, 196, 0.1);
    border-color: var(--color-accent);
}

.captcha-tile.selected {
    background: rgba(78, 205, 196, 0.2);
    border-color: var(--color-accent);
    box-shadow: var(--shadow-glow);
}

/* ===========================
   NOTIFICATION SYSTEM
   =========================== */
.notification-container {
    position: fixed;
    top: 80px;
    right: var(--spacing-md);
    z-index: var(--z-notification);
    max-width: 380px;
    pointer-events: none;
}

.notification {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 28, 44, 0.95));
    backdrop-filter: blur(15px);
    border: 2px solid var(--color-accent);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    animation: slideInRight var(--transition-normal) ease-out;
    pointer-events: auto;
    cursor: pointer;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
}

.notification::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 4px;
    height: 100%;
    background: var(--color-accent);
}

.notification.success {
    border-color: var(--color-success);
}

.notification.success::before {
    background: var(--color-success);
}

.notification.warning {
    border-color: var(--color-warning);
}

.notification.warning::before {
    background: var(--color-warning);
}

.notification.error {
    border-color: var(--color-danger);
}

.notification.error::before {
    background: var(--color-danger);
}

.notification-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: var(--spacing-sm);
}

.notification-title {
    font-weight: 600;
    color: var(--color-accent);
    font-size: 0.9rem;
}

.notification-close {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color var(--transition-fast);
}

.notification-close:hover {
    color: var(--text-primary);
}

.notification-message {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
    margin-bottom: var(--spacing-sm);
}

.notification-actions {
    display: flex;
    gap: var(--spacing-sm);
    justify-content: flex-end;
}

.notification-btn {
    padding: var(--spacing-xs) var(--spacing-sm);
    background: var(--color-accent);
    border: none;
    border-radius: var(--radius-sm);
    color: white;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all var(--transition-fast);
}

.notification-btn:hover {
    background: var(--color-accent-dark);
    transform: translateY(-1px);
}

.notification-btn.secondary {
    background: var(--bg-surface);
    color: var(--text-primary);
}

/* ===========================
   TRANSACTION STATUS
   =========================== */
.transaction-status {
    position: fixed;
    bottom: var(--spacing-md);
    right: var(--spacing-md);
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(15px);
    border: 1px solid var(--color-accent);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    min-width: 300px;
    max-width: 400px;
    z-index: var(--z-notification);
    transform: translateX(120%);
    transition: transform var(--transition-normal);
    box-shadow: var(--shadow-lg);
}

.transaction-status.show {
    transform: translateX(0);
}

.tx-message {
    color: var(--text-primary);
    margin-bottom: var(--spacing-sm);
    font-weight: 500;
}

.tx-hash {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: var(--color-accent);
    word-break: break-all;
    margin-bottom: var(--spacing-sm);
}

.tx-close {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-sm);
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* ===========================
   HEADER STYLES
   =========================== */
.header {
    position: sticky;
    top: 0;
    z-index: var(--z-sticky);
    background: rgba(26, 28, 44, 0.95);
    backdrop-filter: blur(15px);
    border-bottom: 1px solid var(--border-primary);
    padding: var(--spacing-md);
}

.header-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-md);
    max-width: 1400px;
    margin: 0 auto;
}

.logo {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    flex-shrink: 0;
}

.logo-icon {
    font-size: 2rem;
    color: var(--color-accent);
    animation: pulse 3s infinite;
}

.logo h1 {
    font-size: 1.5rem;
    background: linear-gradient(45deg, var(--color-primary), var(--color-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight: 800;
}

.nav-menu {
    display: flex;
    gap: var(--spacing-sm);
    align-items: center;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    padding: var(--spacing-xs) 0;
}

.nav-menu::-webkit-scrollbar {
    display: none;
}

.nav-item {
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-fast);
    white-space: nowrap;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
}

.nav-item:hover {
    background: rgba(78, 205, 196, 0.1);
    border-color: var(--color-accent);
    transform: translateY(-2px);
}

.nav-item.active {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    border-color: var(--color-accent);
    color: white;
}

.nav-item.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}

.live-indicator {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    padding: var(--spacing-xs) var(--spacing-sm);
    background: linear-gradient(135deg, var(--color-success), #27ae60);
    border-radius: var(--radius-pill);
    color: white;
    font-size: 0.8rem;
    font-weight: 600;
    flex-shrink: 0;
}

.pulse-dot {
    width: 8px;
    height: 8px;
    background: white;
    border-radius: 50%;
    animation: pulse 1.5s infinite;
}

.wallet-section {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    flex-shrink: 0;
}

.wallet-info {
    text-align: right;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    font-size: 0.85rem;
    margin-bottom: var(--spacing-xs);
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.status-indicator.online {
    background: var(--color-success);
    animation: pulse 2s infinite;
}

.status-indicator.offline {
    background: var(--color-danger);
}

.status-indicator.pending {
    background: var(--color-warning);
    animation: blink 1s infinite;
}

.balance {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-accent);
    font-family: 'Courier New', monospace;
}

/* ===========================
   MAIN LAYOUT
   =========================== */
.main-container {
    display: flex;
    min-height: calc(100vh - 80px);
    max-width: 1400px;
    margin: 0 auto;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
}

.sidebar {
    width: 320px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.sidebar::-webkit-scrollbar {
    width: 6px;
}

.sidebar::-webkit-scrollbar-track {
    background: var(--bg-surface);
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.5);
}

.content-area {
    flex: 1;
    min-width: 0;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.content-area::-webkit-scrollbar {
    width: 6px;
}

.content-area::-webkit-scrollbar-track {
    background: var(--bg-surface);
    border-radius: 3px;
}

.content-area::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 3px;
}

.content-area::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.5);
}

.section-content {
    display: none;
    animation: fadeIn var(--transition-normal) ease-out;
}

.section-content.active {
    display: block;
}

/* ===========================
   WIDGET SYSTEM
   =========================== */
.widget {
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    transition: all var(--transition-fast);
}

.widget:hover {
    border-color: var(--border-accent);
    box-shadow: var(--shadow-sm);
}

.widget-header {
    padding: var(--spacing-md);
    background: rgba(78, 205, 196, 0.05);
    border-bottom: 1px solid var(--border-primary);
}

.widget-header h3 {
    margin: 0;
    font-size: 1rem;
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.widget-content {
    padding: var(--spacing-md);
}

/* Contract Widget */
.contract-address {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    background: var(--bg-primary);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
}

.address-text {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: var(--text-secondary);
    flex: 1;
    word-break: break-all;
}

.contract-status,
.server-status {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    font-size: 0.9rem;
}

.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--bg-primary);
    border-radius: var(--radius-pill);
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--color-accent), var(--color-primary));
    width: 0%;
    transition: width var(--transition-normal);
    border-radius: var(--radius-pill);
}

/* Server Widget */
.server-details {
    margin: var(--spacing-sm) 0;
}

.detail-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xs) 0;
    font-size: 0.85rem;
}

.detail-label {
    color: var(--text-muted);
}

.detail-value {
    color: var(--color-accent);
    font-weight: 500;
}

/* Stats Widget */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: var(--spacing-md);
}

.stat-item {
    text-align: center;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-accent);
    display: block;
    line-height: 1;
}

.stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: var(--spacing-xs);
    line-height: 1.2;
}

/* My Games Widget */
.my-games-list {
    max-height: 200px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.my-games-list::-webkit-scrollbar {
    width: 4px;
}

.my-games-list::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

.my-games-list::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 2px;
}

.my-game-item {
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
}

.my-game-item:hover {
    background: rgba(78, 205, 196, 0.05);
    border-color: var(--color-accent);
    transform: translateX(2px);
}

.my-game-item:last-child {
    margin-bottom: 0;
}

.no-games {
    text-align: center;
    padding: var(--spacing-xl);
    color: var(--text-muted);
}

.no-games i {
    font-size: 2rem;
    margin-bottom: var(--spacing-sm);
    opacity: 0.5;
}

/* Activity Widget */
.activity-feed {
    max-height: 150px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.activity-feed::-webkit-scrollbar {
    width: 4px;
}

.activity-feed::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

.activity-feed::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 2px;
}

.activity-item {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-xs) 0;
    font-size: 0.85rem;
    color: var(--text-secondary);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.activity-item:last-child {
    border-bottom: none;
}

.activity-item i {
    color: var(--color-accent);
    width: 16px;
    flex-shrink: 0;
}

/* ===========================
   FOOTER STYLES
   =========================== */
.footer {
    background: var(--bg-primary);
    border-top: 1px solid var(--border-primary);
    padding: var(--spacing-xxl) var(--spacing-md) var(--spacing-xl);
    margin-top: var(--spacing-xxl);
}

.footer-content {
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: var(--spacing-xl);
}

.footer-section h4 {
    color: var(--color-accent);
    margin-bottom: var(--spacing-md);
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.footer-section p {
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: var(--spacing-md);
}

.footer-section ul {
    list-style: none;
}

.footer-section ul li {
    margin-bottom: var(--spacing-sm);
}

.footer-section a {
    color: var(--text-secondary);
    text-decoration: none;
    transition: color var(--transition-fast);
    cursor: pointer;
}

.footer-section a:hover {
    color: var(--color-accent);
}

.social-links {
    display: flex;
    gap: var(--spacing-md);
    margin-top: var(--spacing-md);
}

.social-link {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    background: var(--bg-surface);
    border-radius: 50%;
    color: var(--color-accent);
    text-decoration: none;
    transition: all var(--transition-fast);
}

.social-link:hover {
    background: var(--color-accent);
    color: white;
    transform: translateY(-2px);
}

.footer-bottom {
    text-align: center;
    padding-top: var(--spacing-xl);
    margin-top: var(--spacing-xl);
    border-top: 1px solid var(--border-primary);
    color: var(--text-muted);
    font-size: 0.9rem;
    line-height: 1.6;
}

/* ===========================
   RESPONSIVE DESIGN
   =========================== */
@media (max-width: 1024px) {
    .main-container {
        flex-direction: column;
        gap: var(--spacing-md);
    }
    
    .sidebar {
        width: 100%;
        max-height: none;
        order: 2;
    }
    
    .content-area {
        order: 1;
        max-height: none;
    }
    
    .header-content {
        flex-wrap: wrap;
        gap: var(--spacing-sm);
    }
    
    .wallet-section {
        order: -1;
        width: 100%;
        justify-content: space-between;
    }
}

@media (max-width: 768px) {
    .main-container {
        padding: var(--spacing-sm);
    }
    
    .header {
        padding: var(--spacing-sm);
    }
    
    .header-content {
        flex-direction: column;
        align-items: stretch;
        gap: var(--spacing-sm);
    }
    
    .logo {
        justify-content: center;
    }
    
    .nav-menu {
        justify-content: center;
        overflow-x: auto;
        padding: var(--spacing-sm) 0;
    }
    
    .wallet-section {
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .notification-container {
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        max-width: none;
    }
    
    .modal-content {
        margin: var(--spacing-md);
        max-width: none;
    }
    
    .footer-content {
        grid-template-columns: 1fr;
        text-align: center;
    }
}

@media (max-width: 480px) {
    .logo h1 {
        font-size: 1.2rem;
    }
    
    .logo-icon {
        font-size: 1.5rem;
    }
    
    .nav-item {
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 0.8rem;
    }
    
    .btn {
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 0.8rem;
    }
    
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .captcha-grid {
        max-width: 180px;
    }
    
    .captcha-tile {
        font-size: 1.2rem;
    }
}

/* ===========================
   ANIMATIONS
   =========================== */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideInRight {
    from {
        opacity: 0;
        transform: translateX(100%);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes slideInScale {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes pulse {
    0%, 100% { 
        transform: scale(1); 
        opacity: 1; 
    }
    50% { 
        transform: scale(1.05); 
        opacity: 0.8; 
    }
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ===========================
   PRINT STYLES
   =========================== */
@media print {
    .header,
    .sidebar,
    .footer,
    .notification-container,
    .transaction-status,
    .modal-overlay {
        display: none !important;
    }
    
    .main-container {
        flex-direction: column;
        padding: 0;
    }
    
    .content-area {
        max-height: none;
        overflow: visible;
    }
    
    body {
        background: white !important;
        color: black !important;
    }
}

/* ===========================
   HIGH CONTRAST MODE
   =========================== */
@media (prefers-contrast: high) {
    :root {
        --bg-surface: rgba(255, 255, 255, 0.15);
        --border-primary: rgba(255, 255, 255, 0.4);
        --text-secondary: #e0e0e0;
    }
    
    .btn {
        border: 2px solid currentColor;
    }
    
    .notification,
    .modal-content,
    .widget {
        border-width: 3px;
    }
}
    /* ===========================
   CROSSREALM GAMING PLATFORM
   ADDITIONAL GAME-SPECIFIC STYLES
   =========================== */

/* ===========================
   GAME CARDS (LOBBY)
   =========================== */
.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: var(--spacing-lg);
    padding: var(--spacing-md) 0;
}

.game-card {
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    transition: all var(--transition-fast);
    cursor: pointer;
}

.game-card:hover {
    border-color: var(--color-accent);
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
}

.game-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-md);
    background: rgba(78, 205, 196, 0.05);
    border-bottom: 1px solid var(--border-primary);
}

.game-type {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-weight: 600;
    color: var(--color-accent);
}

.game-skill {
    font-size: 0.85rem;
    font-weight: 500;
}

.game-card-body {
    padding: var(--spacing-md);
}

.game-stake {
    text-align: center;
    margin-bottom: var(--spacing-md);
}

.stake-amount {
    display: block;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-accent);
    font-family: 'Courier New', monospace;
}

.stake-label {
    font-size: 0.8rem;
    color: var(--text-muted);
}

.game-info {
    margin-bottom: var(--spacing-md);
}

.info-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xs) 0;
    font-size: 0.9rem;
}

.info-label {
    color: var(--text-muted);
}

.info-value {
    color: var(--text-primary);
    font-weight: 500;
}

.game-card-footer {
    padding: var(--spacing-md);
    padding-top: 0;
}

/* ===========================
   GAME CREATION FORM
   =========================== */
.create-game-form {
    max-width: 600px;
    margin: 0 auto;
    padding: var(--spacing-xl);
    background: var(--bg-surface);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-primary);
}

.form-group {
    margin-bottom: var(--spacing-lg);
}

.form-group label {
    display: block;
    margin-bottom: var(--spacing-sm);
    font-weight: 600;
    color: var(--color-accent);
}

.form-control {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    background: var(--bg-primary);
    color: var(--text-primary);
    font-size: 1rem;
    transition: all var(--transition-fast);
}

.form-control:focus {
    border-color: var(--color-accent);
    outline: none;
    box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
}

.form-control.valid {
    border-color: var(--color-success);
}

.form-control.invalid {
    border-color: var(--color-danger);
}

.game-type-selector {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: var(--spacing-md);
}

.game-type-btn {
    padding: var(--spacing-lg);
    background: var(--bg-primary);
    border: 2px solid var(--border-primary);
    border-radius: var(--radius-lg);
    color: var(--text-primary);
    text-align: center;
    cursor: pointer;
    transition: all var(--transition-fast);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--spacing-sm);
}

.game-type-btn:hover {
    background: rgba(78, 205, 196, 0.1);
    border-color: var(--color-accent);
    transform: translateY(-2px);
}

.game-type-btn.selected {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    border-color: var(--color-accent);
    color: white;
}

.game-type-btn i {
    font-size: 2rem;
}

.game-type-btn span {
    font-weight: 600;
}

/* ===========================
   CHESS GAME STYLES
   =========================== */
.chess-game-container {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-lg);
    max-width: 800px;
    margin: 0 auto;
}

.chess-players {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-md);
    background: var(--bg-surface);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-primary);
}

.player-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--spacing-sm);
}

.player-name {
    font-weight: 600;
    color: var(--text-primary);
}

.player-timer {
    font-family: 'Courier New', monospace;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--color-accent);
    padding: var(--spacing-xs) var(--spacing-sm);
    background: var(--bg-primary);
    border-radius: var(--radius-sm);
}

.chess-board-container {
    display: flex;
    justify-content: center;
    padding: var(--spacing-md);
    background: var(--bg-surface);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-primary);
}

.chess-board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 0;
    width: 480px;
    height: 480px;
    border: 3px solid var(--color-accent);
    border-radius: var(--radius-md);
    overflow: hidden;
}

.chess-square {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    cursor: pointer;
    transition: all var(--transition-fast);
    user-select: none;
    position: relative;
}

.chess-square.light {
    background: #f0d9b5;
    color: #8b4513;
}

.chess-square.dark {
    background: #b58863;
    color: #654321;
}

.chess-square:hover {
    box-shadow: inset 0 0 0 3px rgba(78, 205, 196, 0.5);
}

.chess-square.selected {
    box-shadow: inset 0 0 0 3px var(--color-accent);
    background-color: rgba(78, 205, 196, 0.3) !important;
}

.chess-square.last-move {
    box-shadow: inset 0 0 0 2px var(--color-warning);
}

.chess-square.in-check {
    background-color: rgba(231, 76, 60, 0.3) !important;
    animation: pulse 1s infinite;
}

.chess-square.possible-move::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    background: rgba(78, 205, 196, 0.6);
    border-radius: 50%;
}

.chess-controls {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
    background: var(--bg-surface);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-primary);
}

.game-status {
    text-align: center;
    padding: var(--spacing-md);
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.game-status.check {
    color: var(--color-warning);
}

.game-status.checkmate {
    color: var(--color-danger);
}

.chess-actions {
    display: flex;
    gap: var(--spacing-sm);
    justify-content: center;
}

.move-history {
    margin-top: var(--spacing-md);
}

.move-history h4 {
    color: var(--color-accent);
    margin-bottom: var(--spacing-sm);
}

.moves-list {
    max-height: 200px;
    overflow-y: auto;
    padding: var(--spacing-sm);
    background: var(--bg-primary);
    border-radius: var(--radius-sm);
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.move-pair {
    display: flex;
    gap: var(--spacing-sm);
    padding: var(--spacing-xs) 0;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.move-number {
    color: var(--text-muted);
    min-width: 30px;
}

.white-move,
.black-move {
    color: var(--text-primary);
    min-width: 60px;
}

.no-moves {
    text-align: center;
    color: var(--text-muted);
    font-style: italic;
}

/* ===========================
   GAME WINDOWS
   =========================== */
.game-window {
    position: relative;
    background: var(--bg-surface);
    border: 2px solid var(--color-accent);
    border-radius: var(--radius-lg);
    margin-bottom: var(--spacing-lg);
    overflow: hidden;
    animation: slideInScale 0.3s ease-out;
}

.game-window-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-md);
    background: rgba(78, 205, 196, 0.1);
    border-bottom: 1px solid var(--border-primary);
}

.game-window-header h3 {
    margin: 0;
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.game-window-controls {
    display: flex;
    gap: var(--spacing-xs);
}

.game-window-content {
    padding: var(--spacing-lg);
    min-height: 300px;
}

.no-active-games {
    text-align: center;
    padding: var(--spacing-xxl);
    color: var(--text-muted);
}

.no-active-games i {
    font-size: 4rem;
    margin-bottom: var(--spacing-lg);
    opacity: 0.5;
}

.no-active-games h3 {
    margin-bottom: var(--spacing-md);
    color: var(--text-secondary);
}

/* ===========================
   STATISTICS DISPLAY
   =========================== */
.stat-card {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
    background: var(--bg-primary);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-primary);
    transition: all var(--transition-fast);
}

.stat-card:hover {
    border-color: var(--color-accent);
    transform: translateY(-2px);
}

.stat-icon {
    font-size: 1.5rem;
    color: var(--color-accent);
    width: 40px;
    text-align: center;
}

.stat-info {
    flex: 1;
}

.stat-info .stat-value {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--color-accent);
    display: block;
    line-height: 1;
}

.stat-info .stat-label {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-top: var(--spacing-xs);
}

/* ===========================
   PROFILE STYLES
   =========================== */
.player-identity {
    display: flex;
    align-items: center;
    gap: var(--spacing-lg);
    margin-bottom: var(--spacing-xl);
    padding: var(--spacing-lg);
    background: var(--bg-surface);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-primary);
}

.avatar-circle {
    width: 80px;
    height: 80px;
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.8rem;
    font-weight: 700;
    color: white;
}

.player-info h3 {
    margin: 0 0 var(--spacing-sm) 0;
    color: var(--text-primary);
    font-family: 'Courier New', monospace;
    word-break: break-all;
}

.player-badges {
    display: flex;
    gap: var(--spacing-sm);
}

.badge {
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-pill);
    font-size: 0.75rem;
    font-weight: 600;
    background: var(--color-accent);
    color: white;
}

.badge.verified {
    background: var(--color-success);
}

.badge.blockchain {
    background: var(--color-info);
}

/* ===========================
   LOADING & ERROR STATES
   =========================== */
.loading-placeholder,
.error-placeholder,
.no-games-available {
    text-align: center;
    padding: var(--spacing-xxl);
    color: var(--text-muted);
}

.loading-placeholder i,
.error-placeholder i,
.no-games-available i {
    font-size: 3rem;
    margin-bottom: var(--spacing-lg);
    opacity: 0.5;
}

.error-placeholder {
    color: var(--color-danger);
}

.error-state {
    text-align: center;
    padding: var(--spacing-xxl);
}

.error-state i {
    margin-bottom: var(--spacing-lg);
}

.error-state h2 {
    color: var(--color-danger);
    margin-bottom: var(--spacing-md);
}

/* ===========================
   RESPONSIVE ADJUSTMENTS
   =========================== */
@media (max-width: 768px) {
    .chess-board {
        width: 320px;
        height: 320px;
    }
    
    .chess-square {
        font-size: 1.5rem;
    }
    
    .chess-game-container {
        gap: var(--spacing-md);
    }
    
    .chess-players {
        flex-direction: column;
        gap: var(--spacing-md);
    }
    
    .games-grid {
        grid-template-columns: 1fr;
    }
    
    .game-type-selector {
        grid-template-columns: 1fr;
    }
    
    .chess-actions {
        flex-direction: column;
        align-items: stretch;
    }
    
    .player-identity {
        flex-direction: column;
        text-align: center;
    }
}

@media (max-width: 480px) {
    .chess-board {
        width: 280px;
        height: 280px;
    }
    
    .chess-square {
        font-size: 1.2rem;
    }
    
    .stat-card {
        flex-direction: column;
        text-align: center;
    }
}

/* ===========================
   ANIMATION UTILITIES
   =========================== */
.no-animations * {
    animation: none !important;
    transition: none !important;
}

/* ===========================
   SKILLS & SETTINGS
   =========================== */
.skills-list,
.settings-list {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
}

.skill-item,
.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-md);
    background: var(--bg-primary);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-primary);
}

.skill-name {
    font-weight: 500;
    color: var(--text-primary);
}

.skill-rating {
    font-weight: 700;
    color: var(--color-accent);
    font-family: 'Courier New', monospace;
}

.setting-item label {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    cursor: pointer;
    margin: 0;
    font-weight: 500;
}

.setting-item input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: var(--color-accent);
}

.skills-preview {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
}

.skill-preview-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xs) var(--spacing-sm);
    background: var(--bg-primary);
    border-radius: var(--radius-sm);
    font-size: 0.9rem;
}

.settings-actions {
    display: flex;
    gap: var(--spacing-md);
    justify-content: center;
    margin-top: var(--spacing-xl);
}

/* ===========================
   TOURNAMENTS PLACEHOLDER
   =========================== */
.tournaments-placeholder {
    text-align: center;
    padding: var(--spacing-xxl);
    background: var(--bg-surface);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-primary);
}

.tournaments-placeholder i {
    font-size: 4rem;
    color: var(--color-accent);
    margin-bottom: var(--spacing-lg);
}

.tournaments-placeholder h3 {
    color: var(--color-accent);
    margin-bottom: var(--spacing-md);
}
</style>
  <script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   CORE JAVASCRIPT - STATE MANAGEMENT & SECURITY LAYER
   =========================== */

'use strict';

// ===========================
// SECURITY & CONFIGURATION
// ===========================

// Secure Configuration Manager
class ConfigManager {
    constructor() {
        this.config = {
            // Blockchain Configuration
            CORE_CHAIN_ID: '0x45c',
            CORE_RPC_URL: 'https://rpc.coredao.org',
            CORE_EXPLORER_URL: 'https://scan.coredao.org',
            CONTRACT_ADDRESS: '0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A',
            
            // API Configuration (Proxied for security)
            API_BASE_URL: '/api', // This would proxy to your backend
            JSONBIN_PROXY_URL: '/api/jsonbin', // Secure proxy endpoint
            
            // Rate Limiting
            MAX_REQUESTS_PER_MINUTE: 30,
            MAX_GAMES_PER_HOUR: 10,
            MAX_TRANSACTIONS_PER_MINUTE: 5,
            
            // Security Settings
            ENABLE_ANTI_BOT: true,
            ENABLE_RATE_LIMITING: true,
            ENABLE_INPUT_VALIDATION: true,
            SESSION_TIMEOUT: 30 * 60 * 1000, // 30 minutes
            
            // Game Settings
            MIN_STAKE_AMOUNT: 0.01,
            MAX_STAKE_AMOUNT: 100,
            PLATFORM_FEE_PERCENTAGE: 3,
            
            // Performance Settings
            MAX_CHAT_MESSAGES: 100,
            MAX_ACTIVITY_ITEMS: 20,
            CLEANUP_INTERVAL: 5 * 60 * 1000, // 5 minutes
        };
    }
    
    get(key) {
        return this.config[key];
    }
    
    set(key, value) {
        if (this.config.hasOwnProperty(key)) {
            this.config[key] = value;
        } else {
            throw new Error(`Configuration key '${key}' does not exist`);
        }
    }
}

// Global Configuration Instance
const Config = new ConfigManager();

// ===========================
// ENHANCED ERROR HANDLING SYSTEM
// ===========================

class GameError extends Error {
    constructor(message, code = 'GAME_ERROR', details = {}) {
        super(message);
        this.name = 'GameError';
        this.code = code;
        this.details = details;
        this.timestamp = new Date().toISOString();
        this.stack = (new Error()).stack;
    }
}

class ErrorManager {
    constructor() {
        this.errorLog = [];
        this.maxErrors = 50;
        this.setupGlobalErrorHandlers();
    }
    
    setupGlobalErrorHandlers() {
        window.addEventListener('error', (event) => {
            this.logError(new GameError(
                event.message,
                'RUNTIME_ERROR',
                {
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    stack: event.error?.stack
                }
            ));
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            this.logError(new GameError(
                'Unhandled Promise Rejection',
                'PROMISE_ERROR',
                { reason: event.reason }
            ));
            event.preventDefault();
        });
    }
    
    logError(error, context = 'Unknown') {
        const errorEntry = {
            id: Date.now() + Math.random(),
            error: error,
            context: context,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href,
            userAccount: StateManager.get('userAccount')
        };
        
        this.errorLog.push(errorEntry);
        
        // Keep only recent errors
        if (this.errorLog.length > this.maxErrors) {
            this.errorLog = this.errorLog.slice(-this.maxErrors);
        }
        
        console.error('🚨 Game Error:', errorEntry);
        
        // Send to analytics if available
        if (typeof gtag !== 'undefined') {
            gtag('event', 'exception', {
                description: `${context}: ${error.message}`,
                fatal: false
            });
        }
        
        // Show user-friendly notification for critical errors
        if (error.code === 'RUNTIME_ERROR' || error.code === 'BLOCKCHAIN_ERROR') {
            NotificationManager.show(
                'System Error',
                'Something went wrong. Please try again.',
                'error',
                5000
            );
        }
    }
    
    getRecentErrors(count = 10) {
        return this.errorLog.slice(-count);
    }
    
    clearErrors() {
        this.errorLog = [];
    }
}

// ===========================
// SECURE STATE MANAGEMENT SYSTEM
// ===========================

class StateManager {
    constructor() {
        this.state = new Map();
        this.listeners = new Map();
        this.initialized = false;
        
        // Initialize default state
        this.initializeDefaultState();
    }
    
    initializeDefaultState() {
        const defaultState = {
            // User State
            userAccount: null,
            userBalance: 0,
            isWalletConnected: false,
            walletProvider: null,
            
            // Platform State
            currentSection: 'lobby',
            isLoading: false,
            isServerConnected: false,
            serverLatency: 0,
            lastSyncTime: null,
            
            // Game State
            activeGames: new Map(),
            myActiveGames: new Map(),
            gameInvitations: new Map(),
            currentGameSessions: new Map(),
            selectedGameType: null,
            
            // Settings
            platformSettings: {
                autoJoin: false,
                soundEnabled: true,
                animationsEnabled: true,
                defaultStake: 0.1,
                gameInvites: true,
                txNotifications: true,
                chatNotifications: false,
                hideBalance: false,
                developerMode: false,
                realTimeSync: true
            },
            
            // Player Stats
            playerStats: {
                gamesPlayed: 0,
                gamesWon: 0,
                totalEarned: 0,
                winRate: 0
            },
            
            // Skill Ratings
            skillRatings: {
                chess: 100,
                checkers: 100,
                words: 100
            }
        };
        
        // Set default state
        Object.entries(defaultState).forEach(([key, value]) => {
            this.state.set(key, value);
        });
        
        this.initialized = true;
    }
    
    get(key) {
        if (!this.state.has(key)) {
            console.warn(`State key '${key}' does not exist`);
            return null;
        }
        return this.state.get(key);
    }
    
    set(key, value) {
        const oldValue = this.state.get(key);
        this.state.set(key, value);
        
        // Notify listeners
        if (this.listeners.has(key)) {
            this.listeners.get(key).forEach(callback => {
                try {
                    callback(value, oldValue);
                } catch (error) {
                    ErrorManager.logError(error, `State listener for ${key}`);
                }
            });
        }
        
        // Auto-save certain state changes
        if (['platformSettings', 'playerStats', 'skillRatings'].includes(key)) {
            this.saveToStorage(key, value);
        }
    }
    
    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, new Set());
        }
        this.listeners.get(key).add(callback);
        
        // Return unsubscribe function
        return () => {
            if (this.listeners.has(key)) {
                this.listeners.get(key).delete(callback);
            }
        };
    }
    
    update(key, updater) {
        const currentValue = this.get(key);
        const newValue = updater(currentValue);
        this.set(key, newValue);
    }
    
    saveToStorage(key, value) {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                const storageKey = `crossrealm_${key}_${userAccount}`;
                localStorage.setItem(storageKey, JSON.stringify(value));
            }
        } catch (error) {
            console.warn('Failed to save to storage:', error);
        }
    }
    
    loadFromStorage(key) {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                const storageKey = `crossrealm_${key}_${userAccount}`;
                const stored = localStorage.getItem(storageKey);
                if (stored) {
                    return JSON.parse(stored);
                }
            }
        } catch (error) {
            console.warn('Failed to load from storage:', error);
        }
        return null;
    }
    
    clearUserData() {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                ['platformSettings', 'playerStats', 'skillRatings'].forEach(key => {
                    const storageKey = `crossrealm_${key}_${userAccount}`;
                    localStorage.removeItem(storageKey);
                });
            }
        } catch (error) {
            console.warn('Failed to clear user data:', error);
        }
    }
    
    getSnapshot() {
        const snapshot = {};
        this.state.forEach((value, key) => {
            snapshot[key] = value;
        });
        return snapshot;
    }
}

// Global State Manager Instance
const StateManager = new StateManager();

// ===========================
// SECURITY MANAGER
// ===========================

class SecurityManager {
    constructor() {
        this.requestCounts = new Map();
        this.suspiciousActivity = 0;
        this.blockedIPs = new Set();
        this.sessionStartTime = Date.now();
        
        this.setupSecurityMonitoring();
    }
    
    setupSecurityMonitoring() {
        // Monitor for developer tools
        this.monitorDevTools();
        
        // Monitor for suspicious key combinations
        this.monitorKeyboardEvents();
        
        // Monitor for page visibility changes
        this.monitorPageVisibility();
        
        // Periodic security checks
        setInterval(() => {
            this.performSecurityCheck();
        }, 60000); // Every minute
    }
    
    monitorDevTools() {
        const threshold = 160;
        let devToolsOpen = false;
        
        setInterval(() => {
            const widthThreshold = window.outerWidth - window.innerWidth > threshold;
            const heightThreshold = window.outerHeight - window.innerHeight > threshold;
            
            if ((widthThreshold || heightThreshold) && !devToolsOpen) {
                devToolsOpen = true;
                this.handleDevToolsDetection();
            } else if (!widthThreshold && !heightThreshold && devToolsOpen) {
                devToolsOpen = false;
            }
        }, 500);
    }
    
    monitorKeyboardEvents() {
        document.addEventListener('keydown', (event) => {
            const isDeveloperMode = StateManager.get('platformSettings')?.developerMode;
            
            if (!isDeveloperMode) {
                // Block common developer tools shortcuts
                if ((event.ctrlKey || event.metaKey) && 
                    ['I', 'J', 'U', 'K'].includes(event.key.toUpperCase())) {
                    event.preventDefault();
                    this.logSuspiciousActivity('Developer tools access attempt');
                }
                
                // Block F12
                if (event.key === 'F12') {
                    event.preventDefault();
                    this.logSuspiciousActivity('F12 developer tools attempt');
                }
            }
        });
        
        // Prevent right-click in production
        document.addEventListener('contextmenu', (event) => {
            const isDeveloperMode = StateManager.get('platformSettings')?.developerMode;
            if (!isDeveloperMode) {
                event.preventDefault();
            }
        });
    }
    
    monitorPageVisibility() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden - pause sensitive operations
                this.pauseSensitiveOperations();
            } else {
                // Page is visible - resume operations
                this.resumeSensitiveOperations();
            }
        });
    }
    
    handleDevToolsDetection() {
        const isDeveloperMode = StateManager.get('platformSettings')?.developerMode;
        
        if (!isDeveloperMode) {
            this.logSuspiciousActivity('Developer tools detected');
            
            const activeGames = StateManager.get('currentGameSessions');
            if (activeGames && activeGames.size > 0) {
                NotificationManager.show(
                    'Security Alert',
                    'Developer tools detected during active game. Game paused for security.',
                    'warning',
                    0
                );
                
                // Pause active games
                this.pauseActiveGames();
            }
        }
    }
    
    checkRateLimit(action, limit = null, window = 60000) {
        if (!Config.get('ENABLE_RATE_LIMITING')) {
            return true;
        }
        
        // Use default limits based on action type
        if (!limit) {
            const limits = {
                'api_request': Config.get('MAX_REQUESTS_PER_MINUTE'),
                'game_creation': Config.get('MAX_GAMES_PER_HOUR') / 60,
                'transaction': Config.get('MAX_TRANSACTIONS_PER_MINUTE'),
                'default': 10
            };
            limit = limits[action] || limits.default;
        }
        
        const now = Date.now();
        const userAccount = StateManager.get('userAccount') || 'anonymous';
        const key = `${action}_${userAccount}`;
        
        if (!this.requestCounts.has(key)) {
            this.requestCounts.set(key, []);
        }
        
        const requests = this.requestCounts.get(key);
        
        // Remove old requests outside the window
        const validRequests = requests.filter(time => now - time < window);
        
        if (validRequests.length >= limit) {
            this.logSuspiciousActivity(`Rate limit exceeded for ${action}`);
            return false;
        }
        
        validRequests.push(now);
        this.requestCounts.set(key, validRequests);
        
        return true;
    }
    
    validateInput(input, type, options = {}) {
        if (!Config.get('ENABLE_INPUT_VALIDATION')) {
            return { valid: true, sanitized: input };
        }
        
        try {
            switch (type) {
                case 'stake_amount':
                    return this.validateStakeAmount(input);
                case 'game_type':
                    return this.validateGameType(input);
                case 'wallet_address':
                    return this.validateWalletAddress(input);
                case 'string':
                    return this.validateString(input, options);
                case 'number':
                    return this.validateNumber(input, options);
                default:
                    return { valid: false, error: 'Unknown validation type' };
            }
        } catch (error) {
            ErrorManager.logError(error, 'Input validation');
            return { valid: false, error: 'Validation error' };
        }
    }
    
    validateStakeAmount(amount) {
        const numAmount = parseFloat(amount);
        
        if (isNaN(numAmount)) {
            return { valid: false, error: 'Stake amount must be a number' };
        }
        
        if (numAmount < Config.get('MIN_STAKE_AMOUNT')) {
            return { valid: false, error: `Minimum stake is ${Config.get('MIN_STAKE_AMOUNT')} CORE` };
        }
        
        if (numAmount > Config.get('MAX_STAKE_AMOUNT')) {
            return { valid: false, error: `Maximum stake is ${Config.get('MAX_STAKE_AMOUNT')} CORE` };
        }
        
        return { valid: true, sanitized: numAmount };
    }
    
    validateGameType(gameType) {
        const validTypes = ['chess', 'checkers', 'words'];
        
        if (!validTypes.includes(gameType)) {
            return { valid: false, error: 'Invalid game type' };
        }
        
        return { valid: true, sanitized: gameType };
    }
    
    validateWalletAddress(address) {
        if (typeof address !== 'string') {
            return { valid: false, error: 'Address must be a string' };
        }
        
        if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            return { valid: false, error: 'Invalid wallet address format' };
        }
        
        return { valid: true, sanitized: address.toLowerCase() };
    }
    
    validateString(input, options = {}) {
        const {
            minLength = 0,
            maxLength = 1000,
            allowHTML = false,
            allowSpecialChars = true
        } = options;
        
        if (typeof input !== 'string') {
            return { valid: false, error: 'Input must be a string' };
        }
        
        if (input.length < minLength) {
            return { valid: false, error: `Minimum length is ${minLength}` };
        }
        
        if (input.length > maxLength) {
            return { valid: false, error: `Maximum length is ${maxLength}` };
        }
        
        let sanitized = input;
        
        if (!allowHTML) {
            sanitized = sanitized.replace(/[<>]/g, '');
        }
        
        if (!allowSpecialChars) {
            sanitized = sanitized.replace(/[^\w\s]/g, '');
        }
        
        return { valid: true, sanitized: sanitized.trim() };
    }
    
    validateNumber(input, options = {}) {
        const {
            min = -Infinity,
            max = Infinity,
            integer = false
        } = options;
        
        const num = Number(input);
        
        if (isNaN(num)) {
            return { valid: false, error: 'Input must be a number' };
        }
        
        if (integer && !Number.isInteger(num)) {
            return { valid: false, error: 'Input must be an integer' };
        }
        
        if (num < min) {
            return { valid: false, error: `Minimum value is ${min}` };
        }
        
        if (num > max) {
            return { valid: false, error: `Maximum value is ${max}` };
        }
        
        return { valid: true, sanitized: num };
    }
    
    logSuspiciousActivity(activity) {
        this.suspiciousActivity++;
        
        const logEntry = {
            activity,
            timestamp: new Date().toISOString(),
            userAccount: StateManager.get('userAccount'),
            userAgent: navigator.userAgent,
            url: window.location.href,
            suspiciousCount: this.suspiciousActivity
        };
        
        console.warn('🚨 Suspicious Activity:', logEntry);
        ErrorManager.logError(
            new GameError('Suspicious activity detected', 'SECURITY_ALERT', logEntry),
            'Security'
        );
        
        if (this.suspiciousActivity >= 5) {
            NotificationManager.show(
                'Security Warning',
                'Multiple security alerts detected. Account may be temporarily restricted.',
                'error',
                0
            );
        }
    }
    
    pauseSensitiveOperations() {
        // Implementation for pausing sensitive operations
        console.log('🛡️ Pausing sensitive operations');
    }
    
    resumeSensitiveOperations() {
        // Implementation for resuming sensitive operations
        console.log('🛡️ Resuming sensitive operations');
    }
    
    pauseActiveGames() {
        const activeGames = StateManager.get('currentGameSessions');
        if (activeGames) {
            activeGames.forEach((session, gameId) => {
                if (session.syncInterval) {
                    clearInterval(session.syncInterval);
                    session.paused = true;
                }
            });
        }
    }
    
    performSecurityCheck() {
        // Check session timeout
        const sessionAge = Date.now() - this.sessionStartTime;
        const sessionTimeout = Config.get('SESSION_TIMEOUT');
        
        if (sessionAge > sessionTimeout) {
            this.handleSessionTimeout();
        }
        
        // Clean up old rate limit entries
        this.cleanupRateLimits();
    }
    
    handleSessionTimeout() {
        NotificationManager.show(
            'Session Expired',
            'Your session has expired for security. Please reconnect your wallet.',
            'warning',
            0
        );
        
        // Disconnect wallet and clear sensitive data
        if (window.WalletManager) {
            WalletManager.disconnect();
        }
    }
    
    cleanupRateLimits() {
        const now = Date.now();
        const window = 3600000; // 1 hour
        
        this.requestCounts.forEach((requests, key) => {
            const validRequests = requests.filter(time => now - time < window);
            if (validRequests.length === 0) {
                this.requestCounts.delete(key);
            } else {
                this.requestCounts.set(key, validRequests);
            }
        });
    }
}

// ===========================
// NOTIFICATION MANAGER
// ===========================

class NotificationManager {
    constructor() {
        this.notifications = new Map();
        this.container = null;
        this.maxNotifications = 5;
        
        // Initialize after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initialize());
        } else {
            this.initialize();
        }
    }
    
    initialize() {
        this.container = document.getElementById('notificationContainer');
        if (!this.container) {
            console.warn('Notification container not found');
        }
    }
    
    show(title, message, type = 'info', duration = 5000, actions = null) {
        if (!this.container) {
            console.warn('Cannot show notification: container not initialized');
            return null;
        }
        
        const id = Date.now() + Math.random();
        const notification = this.createNotificationElement(id, title, message, type, actions);
        
        // Limit number of notifications
        if (this.notifications.size >= this.maxNotifications) {
            const oldestId = this.notifications.keys().next().value;
            this.remove(oldestId);
        }
        
        this.notifications.set(id, notification);
        this.container.appendChild(notification);
        
        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(() => {
                this.remove(id);
            }, duration);
        }
        
        return id;
    }
    
    createNotificationElement(id, title, message, type, actions) {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.id = `notification-${id}`;
        notification.dataset.created = Date.now().toString();
        
        const iconMap = {
            info: 'fas fa-info-circle',
            success: 'fas fa-check-circle',
            warning: 'fas fa-exclamation-triangle',
            error: 'fas fa-times-circle'
        };
        
        notification.innerHTML = `
            <div class="notification-header">
                <div class="notification-title">
                    <i class="${iconMap[type]}"></i>
                    ${this.escapeHtml(title)}
                </div>
                <button class="notification-close" onclick="NotificationManager.remove('${id}')">
                    &times;
                </button>
            </div>
            <div class="notification-message">
                ${this.escapeHtml(message)}
            </div>
            ${actions ? `<div class="notification-actions">${actions}</div>` : ''}
        `;
        
        return notification;
    }
    
    remove(id) {
        const notification = this.notifications.get(id);
        if (notification && notification.parentNode) {
            notification.style.animation = 'slideInRight 0.3s ease-out reverse';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                this.notifications.delete(id);
            }, 300);
        }
    }
    
    clear() {
        this.notifications.forEach((notification, id) => {
            this.remove(id);
        });
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// ===========================
// PERFORMANCE MONITOR
// ===========================

class PerformanceMonitor {
    constructor() {
        this.metrics = new Map();
        this.observers = new Map();
        this.startTime = performance.now();
        
        this.setupPerformanceObservers();
    }
    
    setupPerformanceObservers() {
        try {
            // Monitor long tasks
            if ('PerformanceObserver' in window) {
                const longTaskObserver = new PerformanceObserver((list) => {
                    list.getEntries().forEach((entry) => {
                        if (entry.duration > 50) {
                            console.warn(`⚠️ Long task: ${entry.duration.toFixed(2)}ms`);
                            
                            ErrorManager.logError(
                                new GameError(
                                    `Long task detected: ${entry.duration}ms`,
                                    'PERFORMANCE_WARNING'
                                ),
                                'Performance'
                            );
                        }
                    });
                });
                
                longTaskObserver.observe({ entryTypes: ['longtask'] });
                this.observers.set('longtask', longTaskObserver);
            }
        } catch (error) {
            console.warn('Performance observers not supported:', error);
        }
    }
    
    startMeasure(name) {
        this.metrics.set(name, performance.now());
        return name;
    }
    
    endMeasure(name) {
        const startTime = this.metrics.get(name);
        if (startTime) {
            const duration = performance.now() - startTime;
            this.metrics.delete(name);
            
            console.log(`📊 ${name}: ${duration.toFixed(2)}ms`);
            
            // Log slow operations
            if (duration > 1000) {
                console.warn(`⚠️ Slow operation: ${name} took ${duration.toFixed(2)}ms`);
            }
            
            return duration;
        }
        return null;
    }
    
    getMemoryUsage() {
        if ('memory' in performance) {
            return {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
            };
        }
        return null;
    }
    
    cleanup() {
        this.observers.forEach(observer => observer.disconnect());
        this.observers.clear();
        this.metrics.clear();
    }
}

// ===========================
// UTILITY FUNCTIONS
// ===========================

class Utils {
    static async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    static throttle(func, limit) {
        let inThrottle;
        return function executedFunction(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    static formatCurrency(amount, decimals = 4) {
        return parseFloat(amount).toFixed(decimals);
    }
    
    static formatTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);
        
        if (seconds < 60) return `${seconds}s ago`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
        return `${Math.floor(seconds / 86400)}d ago`;
    }
    
    static generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    static copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            return navigator.clipboard.writeText(text);
        } else {
            return this.fallbackCopyToClipboard(text);
        }
    }
    
    static fallbackCopyToClipboard(text) {
        return new Promise((resolve, reject) => {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);
                if (successful) {
                    resolve();
                } else {
                    reject(new Error('Copy command failed'));
                }
            } catch (err) {
                document.body.removeChild(textArea);
                reject(err);
            }
        });
    }
    
    static validateEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }
    
    static sanitizeHtml(html) {
        const div = document.createElement('div');
        div.textContent = html;
        return div.innerHTML;
    }
    
    static isOnline() {
        return navigator.onLine;
    }
    
    static isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    
    static getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    static shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
}

// ===========================
// GLOBAL INSTANCES
// ===========================

// Initialize global managers
const ErrorManager = new ErrorManager();
const SecurityManager = new SecurityManager();
const NotificationManager = new NotificationManager();
const PerformanceMonitor = new PerformanceMonitor();

// ===========================
// CLEANUP AND LIFECYCLE
// ===========================

class LifecycleManager {
    constructor() {
        this.cleanupTasks = new Set();
        this.setupLifecycleHandlers();
    }
    
    setupLifecycleHandlers() {
        window.addEventListener('beforeunload', () => {
            this.performCleanup();
        });
        
        window.addEventListener('pagehide', () => {
            this.performCleanup();
        });
        
        // Periodic cleanup
        setInterval(() => {
            this.performPeriodicCleanup();
        }, Config.get('CLEANUP_INTERVAL'));
    }
    
    addCleanupTask(task) {
        this.cleanupTasks.add(task);
    }
    
    removeCleanupTask(task) {
        this.cleanupTasks.delete(task);
    }
    
    performCleanup() {
        console.log('🧹 Performing cleanup...');
        
        try {
            this.cleanupTasks.forEach(task => {
                try {
                    task();
                } catch (error) {
                    console.error('Cleanup task failed:', error);
                }
            });
            
            // Clear intervals and timeouts
            this.clearAllIntervals();
            
            // Disconnect observers
            PerformanceMonitor.cleanup();
            
            console.log('✅ Cleanup completed');
        } catch (error) {
            console.error('❌ Cleanup failed:', error);
        }
    }
    
    performPeriodicCleanup() {
        // Clean up old notifications
        NotificationManager.notifications.forEach((notification, id) => {
            const age = Date.now() - parseInt(notification.dataset.created || '0');
            if (age > 300000) { // 5 minutes
                NotificationManager.remove(id);
            }
        });
        
        // Clean up old errors
        if (ErrorManager.errorLog.length > 20) {
            ErrorManager.errorLog = ErrorManager.errorLog.slice(-20);
        }
        
        // Clean up old metrics
        PerformanceMonitor.metrics.clear();
    }
    
    clearAllIntervals() {
        // Get all interval IDs and clear them
        const intervalId = setInterval(() => {}, 1000);
        for (let i = 1; i <= intervalId; i++) {
            clearInterval(i);
        }
    }
}

const LifecycleManager = new LifecycleManager();

// Export utilities to global scope for use in other sections
window.StateManager = StateManager;
window.ErrorManager = ErrorManager;
window.SecurityManager = SecurityManager;
window.NotificationManager = NotificationManager;
window.PerformanceMonitor = PerformanceMonitor;
window.LifecycleManager = LifecycleManager;
window.Utils = Utils;
window.Config = Config;
window.GameError = GameError;

console.log('✅ Core JavaScript - State Management & Security Loaded');
</script>
  <script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   BLOCKCHAIN & WALLET INTEGRATION WITH SECURITY FIXES
   =========================== */

'use strict';

// ===========================
// BLOCKCHAIN MANAGER
// ===========================

class BlockchainManager {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.contract = null;
        this.network = null;
        this.gasPrice = null;
        
        this.contractABI = [
            "function createGame(string memory gameType, uint256 timeLimit) external payable returns (uint256)",
            "function joinGame(uint256 gameId) external payable",
            "function submitMove(uint256 gameId, bytes memory moveData) external",
            "function finalizeGame(uint256 gameId, address winner) external",
            "function claimWinnings(uint256 gameId) external",
            "function refundStake(uint256 gameId) external",
            "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint256 status, string memory gameType)",
            "function getTotalGames() external view returns (uint256)",
            "function getPlayerGames(address player) external view returns (uint256[] memory)",
            "function owner() external view returns (address)",
            "function paused() external view returns (bool)",
            "event GameCreated(uint256 indexed gameId, address indexed creator, uint256 stake, string gameType)",
            "event GameJoined(uint256 indexed gameId, address indexed player)",
            "event GameFinalized(uint256 indexed gameId, address indexed winner, uint256 payout)",
            "event MoveSubmitted(uint256 indexed gameId, address indexed player, bytes moveData)"
        ];
        
        this.isInitialized = false;
    }
    
    async initialize() {
        try {
            if (this.isInitialized) {
                return true;
            }
            
            PerformanceMonitor.startMeasure('blockchain_init');
            
            // Check if Web3 provider is available
            if (typeof window.ethereum === 'undefined') {
                console.log('🔍 No Web3 provider detected - running in demo mode');
                this.initializeDemoMode();
                return true;
            }
            
            // Initialize Web3 provider
            this.provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            
            // Get network information
            this.network = await this.provider.getNetwork();
            console.log('🌐 Network detected:', this.network);
            
            // Validate network
            if (this.network.chainId !== parseInt(Config.get('CORE_CHAIN_ID'), 16)) {
                console.warn('⚠️ Wrong network detected, continuing in demo mode');
                this.initializeDemoMode();
                return true;
            }
            
            // Get gas price
            try {
                this.gasPrice = await this.provider.getGasPrice();
                console.log('⛽ Gas price:', ethers.utils.formatUnits(this.gasPrice, 'gwei'), 'gwei');
            } catch (error) {
                console.warn('Failed to get gas price:', error);
                this.gasPrice = ethers.utils.parseUnits('20', 'gwei'); // Fallback
            }
            
            // Initialize contract (read-only initially)
            this.contract = new ethers.Contract(
                Config.get('CONTRACT_ADDRESS'),
                this.contractABI,
                this.provider
            );
            
            // Verify contract exists
            try {
                await this.contract.owner();
                console.log('✅ Smart contract verified');
            } catch (error) {
                console.warn('⚠️ Contract verification failed, using demo mode');
                this.initializeDemoMode();
                return true;
            }
            
            this.isInitialized = true;
            
            // Setup event listeners
            this.setupEventListeners();
            
            PerformanceMonitor.endMeasure('blockchain_init');
            
            StateManager.set('contractStatus', 'connected');
            this.updateContractStatus('connected', 'Connected to Core Network');
            
            return true;
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain initialization');
            this.initializeDemoMode();
            return false;
        }
    }
    
    initializeDemoMode() {
        console.log('🎮 Initializing demo mode');
        this.isInitialized = true;
        StateManager.set('contractStatus', 'demo');
        this.updateContractStatus('demo', 'Demo Mode - No Real Transactions');
    }
    
    setupEventListeners() {
        if (!this.contract) return;
        
        try {
            // Listen for game creation events
            this.contract.on('GameCreated', (gameId, creator, stake, gameType, event) => {
                console.log('🎮 Game Created:', { gameId: gameId.toString(), creator, stake: ethers.utils.formatEther(stake), gameType });
                
                NotificationManager.show(
                    'Game Created',
                    `New ${gameType} game created with ${ethers.utils.formatEther(stake)} CORE stake`,
                    'success'
                );
            });
            
            // Listen for game join events
            this.contract.on('GameJoined', (gameId, player, event) => {
                console.log('👥 Game Joined:', { gameId: gameId.toString(), player });
                
                NotificationManager.show(
                    'Player Joined',
                    `Player joined game #${gameId.toString()}`,
                    'info'
                );
            });
            
            // Listen for game finalization events
            this.contract.on('GameFinalized', (gameId, winner, payout, event) => {
                console.log('🏆 Game Finalized:', { gameId: gameId.toString(), winner, payout: ethers.utils.formatEther(payout) });
                
                const userAccount = StateManager.get('userAccount');
                if (userAccount && winner.toLowerCase() === userAccount.toLowerCase()) {
                    NotificationManager.show(
                        'You Won!',
                        `Congratulations! You won ${ethers.utils.formatEther(payout)} CORE`,
                        'success',
                        0
                    );
                }
            });
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain event listeners setup');
        }
    }
    
    async estimateGas(transaction) {
        try {
            if (!this.contract || !this.signer) {
                return ethers.utils.parseUnits('21000', 'wei'); // Default gas limit
            }
            
            const gasEstimate = await this.contract.estimateGas[transaction.method](...transaction.params, {
                value: transaction.value || 0
            });
            
            // Add 20% buffer for gas estimation
            return gasEstimate.mul(120).div(100);
            
        } catch (error) {
            ErrorManager.logError(error, 'Gas estimation');
            return ethers.utils.parseUnits('500000', 'wei'); // Fallback gas limit
        }
    }
    
    async createGameOnChain(gameType, stakeAmount, timeLimit = 600) {
        try {
            if (!this.validateGameCreation(gameType, stakeAmount)) {
                throw new GameError('Invalid game parameters', 'VALIDATION_ERROR');
            }
            
            // Rate limiting check
            if (!SecurityManager.checkRateLimit('game_creation', 5, 3600000)) { // 5 games per hour
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT_ERROR');
            }
            
            // Check if we have a signer (wallet connected)
            if (!this.signer) {
                throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
            }
            
            const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
            
            // Estimate gas
            const gasLimit = await this.estimateGas({
                method: 'createGame',
                params: [gameType, timeLimit],
                value: stakeWei
            });
            
            console.log('🔥 Creating game on blockchain...', {
                gameType,
                stake: stakeAmount,
                gasLimit: gasLimit.toString()
            });
            
            // Create transaction
            const tx = await this.contract.createGame(gameType, timeLimit, {
                value: stakeWei,
                gasLimit: gasLimit,
                gasPrice: this.gasPrice
            });
            
            console.log('📤 Transaction submitted:', tx.hash);
            
            // Show transaction status
            TransactionManager.showTransaction(
                'Creating game...',
                tx.hash,
                'Game creation transaction submitted'
            );
            
            // Wait for confirmation
            const receipt = await tx.wait();
            console.log('✅ Transaction confirmed:', receipt);
            
            // Extract game ID from events
            const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
            const gameId = gameCreatedEvent?.args?.gameId?.toString();
            
            if (!gameId) {
                throw new GameError('Failed to extract game ID from transaction', 'BLOCKCHAIN_ERROR');
            }
            
            TransactionManager.showTransaction(
                'Game created successfully!',
                tx.hash,
                `Game #${gameId} created on blockchain`
            );
            
            return {
                gameId: parseInt(gameId),
                transactionHash: tx.hash,
                blockNumber: receipt.blockNumber,
                gasUsed: receipt.gasUsed.toString()
            };
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain game creation');
            
            if (error.code === 'INSUFFICIENT_FUNDS') {
                throw new GameError('Insufficient CORE balance', 'INSUFFICIENT_FUNDS');
            } else if (error.code === 'USER_REJECTED') {
                throw new GameError('Transaction rejected by user', 'USER_REJECTED');
            } else if (error.code === 4001) {
                throw new GameError('Transaction rejected by user', 'USER_REJECTED');
            }
            
            throw error;
        }
    }
    
    async joinGameOnChain(gameId, stakeAmount) {
        try {
            if (!this.signer) {
                throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
            }
            
            // Rate limiting check
            if (!SecurityManager.checkRateLimit('game_join', 10, 3600000)) { // 10 joins per hour
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT_ERROR');
            }
            
            const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
            
            // Validate game exists and get details
            const gameDetails = await this.contract.getGame(gameId);
            if (!gameDetails || gameDetails.player1 === ethers.constants.AddressZero) {
                throw new GameError('Game not found', 'GAME_NOT_FOUND');
            }
            
            if (gameDetails.player2 !== ethers.constants.AddressZero) {
                throw new GameError('Game already has two players', 'GAME_FULL');
            }
            
            // Estimate gas
            const gasLimit = await this.estimateGas({
                method: 'joinGame',
                params: [gameId],
                value: stakeWei
            });
            
            console.log('🎯 Joining game on blockchain...', {
                gameId,
                stake: stakeAmount,
                gasLimit: gasLimit.toString()
            });
            
            // Create transaction
            const tx = await this.contract.joinGame(gameId, {
                value: stakeWei,
                gasLimit: gasLimit,
                gasPrice: this.gasPrice
            });
            
            console.log('📤 Join transaction submitted:', tx.hash);
            
            TransactionManager.showTransaction(
                'Joining game...',
                tx.hash,
                `Joining game #${gameId}`
            );
            
            // Wait for confirmation
            const receipt = await tx.wait();
            console.log('✅ Join transaction confirmed:', receipt);
            
            TransactionManager.showTransaction(
                'Successfully joined game!',
                tx.hash,
                `Joined game #${gameId}`
            );
            
            return {
                gameId: gameId,
                transactionHash: tx.hash,
                blockNumber: receipt.blockNumber,
                gasUsed: receipt.gasUsed.toString()
            };
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain game join');
            
            if (error.code === 'INSUFFICIENT_FUNDS') {
                throw new GameError('Insufficient CORE balance', 'INSUFFICIENT_FUNDS');
            } else if (error.code === 'USER_REJECTED' || error.code === 4001) {
                throw new GameError('Transaction rejected by user', 'USER_REJECTED');
            }
            
            throw error;
        }
    }
    
    async getPlayerBalance(address) {
        try {
            if (!this.provider) {
                return 0;
            }
            
            const balance = await this.provider.getBalance(address);
            return parseFloat(ethers.utils.formatEther(balance));
            
        } catch (error) {
            ErrorManager.logError(error, 'Get player balance');
            return 0;
        }
    }
    
    async getGameDetails(gameId) {
        try {
            if (!this.contract) {
                return null;
            }
            
            const gameDetails = await this.contract.getGame(gameId);
            
            return {
                player1: gameDetails.player1,
                player2: gameDetails.player2,
                stake: parseFloat(ethers.utils.formatEther(gameDetails.stake)),
                status: gameDetails.status.toString(),
                gameType: gameDetails.gameType
            };
            
        } catch (error) {
            ErrorManager.logError(error, 'Get game details');
            return null;
        }
    }
    
    validateGameCreation(gameType, stakeAmount) {
        // Validate game type
        const gameTypeValidation = SecurityManager.validateInput(gameType, 'game_type');
        if (!gameTypeValidation.valid) {
            NotificationManager.show('Invalid Game Type', gameTypeValidation.error, 'error');
            return false;
        }
        
        // Validate stake amount
        const stakeValidation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
        if (!stakeValidation.valid) {
            NotificationManager.show('Invalid Stake Amount', stakeValidation.error, 'error');
            return false;
        }
        
        return true;
    }
    
    updateContractStatus(status, message) {
        const contractStatus = document.getElementById('contractStatus');
        const contractAddress = document.getElementById('contractAddress');
        
        if (contractStatus) {
            const statusClasses = {
                'connected': 'online',
                'demo': 'pending',
                'disconnected': 'offline'
            };
            
            contractStatus.innerHTML = `
                <span class="status-indicator ${statusClasses[status]}"></span>
                <span>${message}</span>
            `;
        }
        
        if (contractAddress) {
            const addressText = contractAddress.querySelector('.address-text');
            if (addressText) {
                addressText.textContent = Config.get('CONTRACT_ADDRESS');
            }
        }
    }
    
    cleanup() {
        if (this.contract) {
            this.contract.removeAllListeners();
        }
    }
}

// ===========================
// WALLET MANAGER
// ===========================

class WalletManager {
    constructor() {
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3;
        this.accountChangeHandlers = new Set();
        this.networkChangeHandlers = new Set();
    }
    
    async connect() {
        if (this.isConnecting) {
            console.log('⏳ Wallet connection already in progress');
            return false;
        }
        
        try {
            this.isConnecting = true;
            
            PerformanceMonitor.startMeasure('wallet_connect');
            
            // Check if Web3 provider is available
            if (typeof window.ethereum === 'undefined') {
                // Demo mode for users without MetaMask
                return await this.connectDemoMode();
            }
            
            console.log('🔌 Connecting to wallet...');
            
            // Request account access
            const accounts = await window.ethereum.request({
                method: 'eth_requestAccounts'
            });
            
            if (!accounts || accounts.length === 0) {
                throw new GameError('No accounts found', 'NO_ACCOUNTS');
            }
            
            const userAccount = accounts[0];
            console.log('👤 Wallet connected:', userAccount);
            
            // Validate wallet address
            const addressValidation = SecurityManager.validateInput(userAccount, 'wallet_address');
            if (!addressValidation.valid) {
                throw new GameError('Invalid wallet address', 'INVALID_ADDRESS');
            }
            
            // Initialize blockchain manager
            await BlockchainManager.initialize();
            
            // Set up signer
            BlockchainManager.signer = BlockchainManager.provider.getSigner();
            
            // Connect contract to signer
            if (BlockchainManager.contract) {
                BlockchainManager.contract = BlockchainManager.contract.connect(BlockchainManager.signer);
            }
            
            // Get user balance
            const balance = await BlockchainManager.getPlayerBalance(userAccount);
            
            // Update state
            StateManager.set('userAccount', userAccount);
            StateManager.set('userBalance', balance);
            StateManager.set('isWalletConnected', true);
            StateManager.set('walletProvider', 'metamask');
            
            // Load user data
            await this.loadUserData(userAccount);
            
            // Update UI
            this.updateWalletUI(true, userAccount, balance);
            
            // Setup event listeners
            this.setupWalletEventListeners();
            
            // Save connection state
            try {
                sessionStorage.setItem('walletConnected', 'true');
                sessionStorage.setItem('walletAccount', userAccount);
            } catch (error) {
                console.warn('Failed to save wallet state:', error);
            }
            
            NotificationManager.show(
                'Wallet Connected',
                `Connected to ${userAccount.substring(0, 10)}... with ${balance.toFixed(4)} CORE`,
                'success'
            );
            
            PerformanceMonitor.endMeasure('wallet_connect');
            
            return true;
            
        } catch (error) {
            ErrorManager.logError(error, 'Wallet connection');
            
            if (error.code === 4001) {
                NotificationManager.show(
                    'Connection Rejected',
                    'Wallet connection was rejected by user',
                    'warning'
                );
            } else if (error.code === -32002) {
                NotificationManager.show(
                    'Connection Pending',
                    'Please check your wallet for pending connection request',
                    'info'
                );
            } else {
                NotificationManager.show(
                    'Connection Failed',
                    `Failed to connect wallet: ${error.message}`,
                    'error'
                );
            }
            
            return false;
            
        } finally {
            this.isConnecting = false;
        }
    }
    
    async connectDemoMode() {
        console.log('🎮 Connecting in demo mode...');
        
        // Generate demo account
        const demoAccount = '0x' + '1'.repeat(40);
        const demoBalance = 10.0;
        
        // Update state
        StateManager.set('userAccount', demoAccount);
        StateManager.set('userBalance', demoBalance);
        StateManager.set('isWalletConnected', true);
        StateManager.set('walletProvider', 'demo');
        
        // Update UI
        this.updateWalletUI(true, demoAccount, demoBalance);
        
        NotificationManager.show(
            'Demo Mode Connected',
            `Demo wallet connected with ${demoBalance} CORE`,
            'info'
        );
        
        return true;
    }
    
    async disconnect() {
        try {
            console.log('🔌 Disconnecting wallet...');
            
            // Clean up blockchain connections
            BlockchainManager.cleanup();
            
            // Clear state
            StateManager.set('userAccount', null);
            StateManager.set('userBalance', 0);
            StateManager.set('isWalletConnected', false);
            StateManager.set('walletProvider', null);
            
            // Update UI
            this.updateWalletUI(false, null, 0);
            
            // Clear session storage
            try {
                sessionStorage.removeItem('walletConnected');
                sessionStorage.removeItem('walletAccount');
            } catch (error) {
                console.warn('Failed to clear wallet state:', error);
            }
            
            // Remove event listeners
            this.removeWalletEventListeners();
            
            NotificationManager.show(
                'Wallet Disconnected',
                'Wallet has been disconnected',
                'info'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Wallet disconnection');
        }
    }
    
    async loadUserData(userAccount) {
        try {
            const userData = StateManager.loadFromStorage('userData');
            if (userData) {
                StateManager.set('playerStats', userData.playerStats || StateManager.get('playerStats'));
                StateManager.set('skillRatings', userData.skillRatings || StateManager.get('skillRatings'));
                StateManager.set('platformSettings', { ...StateManager.get('platformSettings'), ...userData.platformSettings });
            }
        } catch (error) {
            ErrorManager.logError(error, 'Loading user data');
        }
    }
    
    async saveUserData() {
        try {
            const userAccount = StateManager.get('userAccount');
            if (userAccount) {
                const userData = {
                    playerStats: StateManager.get('playerStats'),
                    skillRatings: StateManager.get('skillRatings'),
                    platformSettings: StateManager.get('platformSettings'),
                    lastSaved: Date.now()
                };
                
                StateManager.saveToStorage('userData', userData);
            }
        } catch (error) {
            ErrorManager.logError(error, 'Saving user data');
        }
    }
    
    setupWalletEventListeners() {
        if (!window.ethereum) return;
        
        // Account changes
        const handleAccountsChanged = (accounts) => {
            console.log('👤 Accounts changed:', accounts);
            
            if (accounts.length === 0) {
                this.disconnect();
            } else if (accounts[0] !== StateManager.get('userAccount')) {
                // Account switched
                this.handleAccountSwitch(accounts[0]);
            }
        };
        
        // Network changes
        const handleChainChanged = (chainId) => {
            console.log('🌐 Network changed:', chainId);
            
            if (chainId !== Config.get('CORE_CHAIN_ID')) {
                NotificationManager.show(
                    'Wrong Network',
                    'Please switch to Core Network',
                    'warning',
                    0
                );
                
                StateManager.set('contractStatus', 'wrong_network');
            } else {
                StateManager.set('contractStatus', 'connected');
                NotificationManager.show(
                    'Network Correct',
                    'Connected to Core Network',
                    'success'
                );
            }
        };
        
        // Add event listeners
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);
        
        // Store handlers for cleanup
        this.accountChangeHandlers.add(handleAccountsChanged);
        this.networkChangeHandlers.add(handleChainChanged);
    }
    
    removeWalletEventListeners() {
        if (!window.ethereum) return;
        
        // Remove all stored handlers
        this.accountChangeHandlers.forEach(handler => {
            window.ethereum.removeListener('accountsChanged', handler);
        });
        
        this.networkChangeHandlers.forEach(handler => {
            window.ethereum.removeListener('chainChanged', handler);
        });
        
        this.accountChangeHandlers.clear();
        this.networkChangeHandlers.clear();
    }
    
    async handleAccountSwitch(newAccount) {
        try {
            console.log('🔄 Switching account to:', newAccount);
            
            // Save current user data
            await this.saveUserData();
            
            // Validate new account
            const addressValidation = SecurityManager.validateInput(newAccount, 'wallet_address');
            if (!addressValidation.valid) {
                throw new GameError('Invalid wallet address', 'INVALID_ADDRESS');
            }
            
            // Get new balance
            const balance = await BlockchainManager.getPlayerBalance(newAccount);
            
            // Update state
            StateManager.set('userAccount', newAccount);
            StateManager.set('userBalance', balance);
            
            // Load data for new account
            await this.loadUserData(newAccount);
            
            // Update UI
            this.updateWalletUI(true, newAccount, balance);
            
            NotificationManager.show(
                'Account Switched',
                `Switched to ${newAccount.substring(0, 10)}...`,
                'info'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Account switch');
            this.disconnect();
        }
    }
    
    updateWalletUI(connected, account, balance) {
        const connectionStatus = document.getElementById('connectionStatus');
        const balanceDisplay = document.getElementById('balanceDisplay');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        
        if (connectionStatus) {
            const statusIndicator = connectionStatus.querySelector('.status-indicator');
            const statusText = connectionStatus.querySelector('.status-text');
            
            if (statusIndicator && statusText) {
                if (connected) {
                    statusIndicator.className = 'status-indicator online';
                    statusText.textContent = 'Connected';
                } else {
                    statusIndicator.className = 'status-indicator offline';
                    statusText.textContent = 'Not Connected';
                }
            }
        }
        
        if (balanceDisplay) {
            const hideBalance = StateManager.get('platformSettings')?.hideBalance;
            if (hideBalance && connected) {
                balanceDisplay.textContent = '••••• CORE';
            } else {
                balanceDisplay.textContent = `${balance.toFixed(4)} CORE`;
            }
        }
        
        if (connectBtn && disconnectBtn) {
            if (connected) {
                connectBtn.classList.add('hidden');
                disconnectBtn.classList.remove('hidden');
            } else {
                connectBtn.classList.remove('hidden');
                disconnectBtn.classList.add('hidden');
            }
        }
    }
    
    async autoConnect() {
        try {
            // Check if wallet was previously connected
            const wasConnected = sessionStorage.getItem('walletConnected') === 'true';
            const previousAccount = sessionStorage.getItem('walletAccount');
            
            if (!wasConnected || !previousAccount) {
                return false;
            }
            
            // Check if accounts are still available
            if (window.ethereum) {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.includes(previousAccount)) {
                    console.log('🔄 Auto-connecting to wallet...');
                    return await this.connect();
                }
            }
            
            return false;
            
        } catch (error) {
            console.warn('Auto-connect failed:', error);
            // Clear stale session data
            sessionStorage.removeItem('walletConnected');
            sessionStorage.removeItem('walletAccount');
            return false;
        }
    }
}

// ===========================
// TRANSACTION MANAGER
// ===========================

class TransactionManager {
    constructor() {
        this.activeTransactions = new Map();
        this.container = null;
        
        // Initialize after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initialize());
        } else {
            this.initialize();
        }
    }
    
    initialize() {
        this.container = document.getElementById('transactionStatus');
        if (!this.container) {
            console.warn('Transaction status container not found');
        }
        
        // Setup close button
        const closeBtn = document.getElementById('txClose');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.hide());
        }
    }
    
    showTransaction(message, hash = null, description = null) {
        if (!this.container) {
            console.warn('Cannot show transaction: container not initialized');
            return;
        }
        
        const messageEl = document.getElementById('txMessage');
        const hashEl = document.getElementById('txHash');
        
        if (messageEl) {
            messageEl.textContent = message;
        }
        
        if (hashEl && hash) {
            hashEl.innerHTML = `
                <strong>Hash:</strong> 
                <a href="${Config.get('CORE_EXPLORER_URL')}/tx/${hash}" 
                   target="_blank" 
                   rel="noopener noreferrer"
                   title="View on Core Explorer">
                    ${hash.substring(0, 10)}...${hash.substring(hash.length - 8)}
                </a>
            `;
            hashEl.style.display = 'block';
        } else if (hashEl) {
            hashEl.style.display = 'none';
        }
        
        this.container.classList.add('show');
        
        // Auto-hide after 10 seconds for success messages
        if (message.includes('success') || message.includes('confirmed')) {
            setTimeout(() => {
                this.hide();
            }, 10000);
        }
    }
    
    hide() {
        if (this.container) {
            this.container.classList.remove('show');
        }
    }
    
    showStatus(status, hash = null) {
        const statusMessages = {
            'pending': 'Transaction pending...',
            'confirmed': 'Transaction confirmed!',
            'failed': 'Transaction failed!',
            'rejected': 'Transaction rejected by user'
        };
        
        this.showTransaction(statusMessages[status] || status, hash);
    }
}

// ===========================
// API MANAGER (SECURE PROXY-BASED)
// ===========================

class APIManager {
    constructor() {
        this.baseURL = Config.get('API_BASE_URL');
        this.retryAttempts = 3;
        this.retryDelay = 1000;
        this.requestQueue = new Map();
    }
    
    async request(endpoint, options = {}) {
        // Rate limiting check
        if (!SecurityManager.checkRateLimit('api_request')) {
            throw new GameError('API rate limit exceeded', 'RATE_LIMIT_ERROR');
        }
        
        const url = `${this.baseURL}${endpoint}`;
        const requestId = Utils.generateId();
        
        const defaultOptions = {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
            ...options
        };
        
        try {
            console.log(`📡 API Request [${requestId}]:`, url);
            
            PerformanceMonitor.startMeasure(`api_request_${requestId}`);
            
            const response = await this.fetchWithRetry(url, defaultOptions);
            
            if (!response.ok) {
                throw new GameError(
                    `API request failed: ${response.status} ${response.statusText}`,
                    'API_ERROR',
                    { status: response.status, url }
                );
            }
            
            const data = await response.json();
            
            PerformanceMonitor.endMeasure(`api_request_${requestId}`);
            
            console.log(`✅ API Response [${requestId}]:`, data);
            
            return data;
            
        } catch (error) {
            PerformanceMonitor.endMeasure(`api_request_${requestId}`);
            ErrorManager.logError(error, `API Request: ${endpoint}`);
            throw error;
        }
    }
    
    async fetchWithRetry(url, options, attempt = 1) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            return response;
            
        } catch (error) {
            if (attempt < this.retryAttempts && error.name !== 'AbortError') {
                console.warn(`⚠️ Request failed, retrying (${attempt}/${this.retryAttempts}):`, error.message);
                await Utils.sleep(this.retryDelay * attempt);
                return this.fetchWithRetry(url, options, attempt + 1);
            }
            throw error;
        }
    }
    
    // Secure game data operations using proxy endpoints
    async getGames() {
        return this.request('/games');
    }
    
    async createGame(gameData) {
        return this.request('/games', {
            method: 'POST',
            body: JSON.stringify(gameData)
        });
    }
    
    async updateGame(gameId, gameData) {
        return this.request(`/games/${gameId}`, {
            method: 'PUT',
            body: JSON.stringify(gameData)
        });
    }
    
    async deleteGame(gameId) {
        return this.request(`/games/${gameId}`, {
            method: 'DELETE'
        });
    }
    
    async getServerStats() {
        return this.request('/stats');
    }
    
    async validateMove(gameId, moveData) {
        return this.request(`/games/${gameId}/validate-move`, {
            method: 'POST',
            body: JSON.stringify(moveData)
        });
    }
}

// ===========================
// GLOBAL INSTANCES
// ===========================

const BlockchainManager = new BlockchainManager();
const WalletManager = new WalletManager();
const TransactionManager = new TransactionManager();
const APIManager = new APIManager();

// Export to global scope
window.BlockchainManager = BlockchainManager;
window.WalletManager = WalletManager;
window.TransactionManager = TransactionManager;
window.APIManager = APIManager;

// ===========================
// INITIALIZATION
// ===========================

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('🚀 Initializing Blockchain & Wallet Integration...');
        
        // Initialize blockchain manager
        await BlockchainManager.initialize();
        
        // Try auto-connect wallet
        setTimeout(async () => {
            try {
                await WalletManager.autoConnect();
            } catch (error) {
                console.warn('Auto-connect failed:', error);
            }
        }, 1000);
        
        console.log('✅ Blockchain & Wallet Integration Initialized');
        
    } catch (error) {
        ErrorManager.logError(error, 'Blockchain & Wallet Integration Initialization');
    }
});

// Cleanup on page unload
LifecycleManager.addCleanupTask(() => {
    BlockchainManager.cleanup();
    WalletManager.removeWalletEventListeners();
    WalletManager.saveUserData();
});

console.log('✅ Blockchain & Wallet Integration Loaded');
</script>
  <script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   GAME LOGIC & UI MANAGEMENT WITH COMPLETE VALIDATION
   =========================== */

'use strict';

// ===========================
// ENHANCED GAME STATE MANAGEMENT
// ===========================

class GameStateManager {
    constructor() {
        this.gameStates = new Map();
        this.gameValidators = new Map();
        this.gameRenderers = new Map();
        
        this.initializeGameTypes();
    }
    
    initializeGameTypes() {
        // Register chess game
        this.registerGame('chess', new ChessGame(), new ChessValidator(), new ChessRenderer());
        
        // Register checkers game  
        this.registerGame('checkers', new CheckersGame(), new CheckersValidator(), new CheckersRenderer());
        
        // Register word game
        this.registerGame('words', new WordGame(), new WordValidator(), new WordRenderer());
    }
    
    registerGame(gameType, gameLogic, validator, renderer) {
        this.gameStates.set(gameType, gameLogic);
        this.gameValidators.set(gameType, validator);
        this.gameRenderers.set(gameType, renderer);
    }
    
    createGame(gameType, gameId, players) {
        const gameLogic = this.gameStates.get(gameType);
        if (!gameLogic) {
            throw new GameError(`Unknown game type: ${gameType}`, 'INVALID_GAME_TYPE');
        }
        
        return gameLogic.createNewGame(gameId, players);
    }
    
    validateMove(gameType, gameState, move, playerId) {
        const validator = this.gameValidators.get(gameType);
        if (!validator) {
            throw new GameError(`No validator for game type: ${gameType}`, 'VALIDATOR_NOT_FOUND');
        }
        
        return validator.validateMove(gameState, move, playerId);
    }
    
    makeMove(gameType, gameState, move, playerId) {
        const validator = this.gameValidators.get(gameType);
        const gameLogic = this.gameStates.get(gameType);
        
        // Validate move first
        const validation = validator.validateMove(gameState, move, playerId);
        if (!validation.valid) {
            throw new GameError(`Invalid move: ${validation.reason}`, 'INVALID_MOVE');
        }
        
        // Apply move
        return gameLogic.applyMove(gameState, move, playerId);
    }
    
    renderGame(gameType, gameState, containerId) {
        const renderer = this.gameRenderers.get(gameType);
        if (!renderer) {
            throw new GameError(`No renderer for game type: ${gameType}`, 'RENDERER_NOT_FOUND');
        }
        
        return renderer.render(gameState, containerId);
    }
}

// ===========================
// ENHANCED CHESS GAME IMPLEMENTATION
// ===========================

class ChessGame {
    constructor() {
        this.initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];
        
        this.pieceValues = {
            'P': 1, 'p': 1,
            'N': 3, 'n': 3, 
            'B': 3, 'b': 3,
            'R': 5, 'r': 5,
            'Q': 9, 'q': 9,
            'K': 0, 'k': 0
        };
    }
    
    createNewGame(gameId, players) {
        return {
            gameId: gameId,
            gameType: 'chess',
            players: players,
            board: JSON.parse(JSON.stringify(this.initialBoard)),
            currentPlayer: 0, // 0 = white, 1 = black
            moveHistory: [],
            gameStatus: 'active',
            castlingRights: {
                whiteKingside: true,
                whiteQueenside: true,
                blackKingside: true,
                blackQueenside: true
            },
            enPassantTarget: null,
            halfMoveClock: 0,
            fullMoveNumber: 1,
            checkStatus: {
                inCheck: false,
                checkedPlayer: null,
                checkingPieces: []
            },
            lastMove: null,
            capturedPieces: { white: [], black: [] },
            gameStartTime: Date.now(),
            timeControls: {
                white: 600000, // 10 minutes in milliseconds
                black: 600000
            }
        };
    }
    
    applyMove(gameState, move, playerId) {
        const newState = JSON.parse(JSON.stringify(gameState));
        const { from, to, promotion } = move;
        
        // Get piece being moved
        const piece = newState.board[from.row][from.col];
        const targetPiece = newState.board[to.row][to.col];
        
        // Handle captures
        if (targetPiece) {
            const isWhitePiece = targetPiece === targetPiece.toUpperCase();
            const captureColor = isWhitePiece ? 'white' : 'black';
            newState.capturedPieces[captureColor].push(targetPiece);
        }
        
        // Make the move
        newState.board[to.row][to.col] = piece;
        newState.board[from.row][from.col] = null;
        
        // Handle special moves
        this.handleSpecialMoves(newState, move, piece);
        
        // Handle pawn promotion
        if (promotion && (piece === 'P' || piece === 'p')) {
            newState.board[to.row][to.col] = promotion;
        }
        
        // Update castling rights
        this.updateCastlingRights(newState, move, piece);
        
        // Update en passant target
        this.updateEnPassantTarget(newState, move, piece);
        
        // Record move
        newState.moveHistory.push({
            move: move,
            piece: piece,
            captured: targetPiece,
            timestamp: Date.now(),
            playerId: playerId
        });
        
        newState.lastMove = move;
        
        // Update move counters
        this.updateMoveCounters(newState, piece, targetPiece);
        
        // Switch players
        newState.currentPlayer = 1 - newState.currentPlayer;
        
        // Check for game end conditions
        this.updateGameStatus(newState);
        
        return newState;
    }
    
    handleSpecialMoves(gameState, move, piece) {
        const { from, to } = move;
        
        // Handle castling
        if (piece === 'K' || piece === 'k') {
            const colDiff = to.col - from.col;
            
            if (Math.abs(colDiff) === 2) {
                // Castling detected
                const row = from.row;
                const isKingside = colDiff > 0;
                
                if (isKingside) {
                    // Move rook for kingside castling
                    gameState.board[row][5] = gameState.board[row][7];
                    gameState.board[row][7] = null;
                } else {
                    // Move rook for queenside castling
                    gameState.board[row][3] = gameState.board[row][0];
                    gameState.board[row][0] = null;
                }
            }
        }
        
        // Handle en passant capture
        if ((piece === 'P' || piece === 'p') && 
            gameState.enPassantTarget &&
            to.row === gameState.enPassantTarget.row &&
            to.col === gameState.enPassantTarget.col) {
            
            // Remove the captured pawn
            const capturedRow = piece === 'P' ? to.row + 1 : to.row - 1;
            const capturedPiece = gameState.board[capturedRow][to.col];
            gameState.board[capturedRow][to.col] = null;
            
            // Add to captured pieces
            const captureColor = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';
            gameState.capturedPieces[captureColor].push(capturedPiece);
        }
    }
    
    updateCastlingRights(gameState, move, piece) {
        const { from } = move;
        
        // King moves lose all castling rights
        if (piece === 'K') {
            gameState.castlingRights.whiteKingside = false;
            gameState.castlingRights.whiteQueenside = false;
        } else if (piece === 'k') {
            gameState.castlingRights.blackKingside = false;
            gameState.castlingRights.blackQueenside = false;
        }
        
        // Rook moves lose corresponding castling rights
        if (piece === 'R') {
            if (from.row === 7 && from.col === 0) {
                gameState.castlingRights.whiteQueenside = false;
            } else if (from.row === 7 && from.col === 7) {
                gameState.castlingRights.whiteKingside = false;
            }
        } else if (piece === 'r') {
            if (from.row === 0 && from.col === 0) {
                gameState.castlingRights.blackQueenside = false;
            } else if (from.row === 0 && from.col === 7) {
                gameState.castlingRights.blackKingside = false;
            }
        }
    }
    
    updateEnPassantTarget(gameState, move, piece) {
        const { from, to } = move;
        
        gameState.enPassantTarget = null;
        
        // Set en passant target for pawn double moves
        if ((piece === 'P' || piece === 'p') && Math.abs(to.row - from.row) === 2) {
            gameState.enPassantTarget = {
                row: (from.row + to.row) / 2,
                col: from.col
            };
        }
    }
    
    updateMoveCounters(gameState, piece, captured) {
        // Update half-move clock (50-move rule)
        if (piece === 'P' || piece === 'p' || captured) {
            gameState.halfMoveClock = 0;
        } else {
            gameState.halfMoveClock++;
        }
        
        // Update full move number
        if (gameState.currentPlayer === 1) {
            gameState.fullMoveNumber++;
        }
    }
    
    updateGameStatus(gameState) {
        // Check for check
        const checkResult = this.isInCheck(gameState, gameState.currentPlayer);
        gameState.checkStatus = checkResult;
        
        // Check for checkmate or stalemate
        const legalMoves = this.getAllLegalMoves(gameState, gameState.currentPlayer);
        
        if (legalMoves.length === 0) {
            if (checkResult.inCheck) {
                gameState.gameStatus = 'checkmate';
                gameState.winner = 1 - gameState.currentPlayer;
            } else {
                gameState.gameStatus = 'stalemate';
            }
        } else if (gameState.halfMoveClock >= 100) {
            gameState.gameStatus = 'draw_50_move';
        } else if (this.isInsufficientMaterial(gameState)) {
            gameState.gameStatus = 'draw_insufficient_material';
        } else if (this.isThreefoldRepetition(gameState)) {
            gameState.gameStatus = 'draw_repetition';
        }
    }
    
    isInCheck(gameState, playerIndex) {
        const isWhite = playerIndex === 0;
        const kingSymbol = isWhite ? 'K' : 'k';
        
        // Find king position
        let kingPos = null;
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                if (gameState.board[row][col] === kingSymbol) {
                    kingPos = { row, col };
                    break;
                }
            }
            if (kingPos) break;
        }
        
        if (!kingPos) {
            return { inCheck: false, checkedPlayer: null, checkingPieces: [] };
        }
        
        // Check if any opponent piece can attack the king
        const checkingPieces = [];
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece && this.isOpponentPiece(piece, isWhite)) {
                    if (this.canPieceAttackSquare(gameState, { row, col }, kingPos, piece)) {
                        checkingPieces.push({ row, col, piece });
                    }
                }
            }
        }
        
        return {
            inCheck: checkingPieces.length > 0,
            checkedPlayer: checkingPieces.length > 0 ? playerIndex : null,
            checkingPieces: checkingPieces
        };
    }
    
    getAllLegalMoves(gameState, playerIndex) {
        const legalMoves = [];
        const isWhite = playerIndex === 0;
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece && !this.isOpponentPiece(piece, isWhite)) {
                    const pieceMoves = this.getPossibleMoves(gameState, { row, col }, piece);
                    
                    for (const move of pieceMoves) {
                        if (this.isMoveLegal(gameState, { from: { row, col }, to: move }, playerIndex)) {
                            legalMoves.push({ from: { row, col }, to: move, piece });
                        }
                    }
                }
            }
        }
        
        return legalMoves;
    }
    
    isMoveLegal(gameState, move, playerIndex) {
        // Create temporary state
        const tempState = JSON.parse(JSON.stringify(gameState));
        
        // Apply move temporarily
        const piece = tempState.board[move.from.row][move.from.col];
        tempState.board[move.to.row][move.to.col] = piece;
        tempState.board[move.from.row][move.from.col] = null;
        
        // Check if move leaves king in check
        const checkResult = this.isInCheck(tempState, playerIndex);
        return !checkResult.inCheck;
    }
    
    getPossibleMoves(gameState, position, piece) {
        const moves = [];
        const { row, col } = position;
        
        switch (piece.toLowerCase()) {
            case 'p':
                moves.push(...this.getPawnMoves(gameState, position, piece));
                break;
            case 'r':
                moves.push(...this.getRookMoves(gameState, position));
                break;
            case 'n':
                moves.push(...this.getKnightMoves(gameState, position));
                break;
            case 'b':
                moves.push(...this.getBishopMoves(gameState, position));
                break;
            case 'q':
                moves.push(...this.getQueenMoves(gameState, position));
                break;
            case 'k':
                moves.push(...this.getKingMoves(gameState, position));
                break;
        }
        
        return moves;
    }
    
    getPawnMoves(gameState, position, piece) {
        const moves = [];
        const { row, col } = position;
        const isWhite = piece === 'P';
        const direction = isWhite ? -1 : 1;
        const startRow = isWhite ? 6 : 1;
        
        // Forward move
        if (this.isValidSquare(row + direction, col) && !gameState.board[row + direction][col]) {
            moves.push({ row: row + direction, col });
            
            // Double move from starting position
            if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                moves.push({ row: row + 2 * direction, col });
            }
        }
        
        // Captures
        for (const deltaCol of [-1, 1]) {
            const newRow = row + direction;
            const newCol = col + deltaCol;
            
            if (this.isValidSquare(newRow, newCol)) {
                const targetPiece = gameState.board[newRow][newCol];
                
                // Regular capture
                if (targetPiece && this.isOpponentPiece(targetPiece, isWhite)) {
                    moves.push({ row: newRow, col: newCol });
                }
                
                // En passant capture
                if (gameState.enPassantTarget &&
                    newRow === gameState.enPassantTarget.row &&
                    newCol === gameState.enPassantTarget.col) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        }
        
        return moves;
    }
    
    getRookMoves(gameState, position) {
        return this.getSlidingMoves(gameState, position, [
            [-1, 0], [1, 0], [0, -1], [0, 1]
        ]);
    }
    
    getBishopMoves(gameState, position) {
        return this.getSlidingMoves(gameState, position, [
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ]);
    }
    
    getQueenMoves(gameState, position) {
        return this.getSlidingMoves(gameState, position, [
            [-1, 0], [1, 0], [0, -1], [0, 1],
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ]);
    }
    
    getSlidingMoves(gameState, position, directions) {
        const moves = [];
        const { row, col } = position;
        const piece = gameState.board[row][col];
        const isWhite = piece === piece.toUpperCase();
        
        for (const [deltaRow, deltaCol] of directions) {
            let newRow = row + deltaRow;
            let newCol = col + deltaCol;
            
            while (this.isValidSquare(newRow, newCol)) {
                const targetPiece = gameState.board[newRow][newCol];
                
                if (!targetPiece) {
                    moves.push({ row: newRow, col: newCol });
                } else if (this.isOpponentPiece(targetPiece, isWhite)) {
                    moves.push({ row: newRow, col: newCol });
                    break;
                } else {
                    break;
                }
                
                newRow += deltaRow;
                newCol += deltaCol;
            }
        }
        
        return moves;
    }
    
    getKnightMoves(gameState, position) {
        const moves = [];
        const { row, col } = position;
        const piece = gameState.board[row][col];
        const isWhite = piece === piece.toUpperCase();
        
        const knightMoves = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1]
        ];
        
        for (const [deltaRow, deltaCol] of knightMoves) {
            const newRow = row + deltaRow;
            const newCol = col + deltaCol;
            
            if (this.isValidSquare(newRow, newCol)) {
                const targetPiece = gameState.board[newRow][newCol];
                
                if (!targetPiece || this.isOpponentPiece(targetPiece, isWhite)) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        }
        
        return moves;
    }
    
    getKingMoves(gameState, position) {
        const moves = [];
        const { row, col } = position;
        const piece = gameState.board[row][col];
        const isWhite = piece === piece.toUpperCase();
        
        // Regular king moves
        for (let deltaRow = -1; deltaRow <= 1; deltaRow++) {
            for (let deltaCol = -1; deltaCol <= 1; deltaCol++) {
                if (deltaRow === 0 && deltaCol === 0) continue;
                
                const newRow = row + deltaRow;
                const newCol = col + deltaCol;
                
                if (this.isValidSquare(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    
                    if (!targetPiece || this.isOpponentPiece(targetPiece, isWhite)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
        }
        
        // Castling moves
        if (this.canCastle(gameState, position, 'kingside')) {
            moves.push({ row, col: col + 2 });
        }
        
        if (this.canCastle(gameState, position, 'queenside')) {
            moves.push({ row, col: col - 2 });
        }
        
        return moves;
    }
    
    canCastle(gameState, kingPosition, side) {
        const { row, col } = kingPosition;
        const piece = gameState.board[row][col];
        const isWhite = piece === 'K';
        
        // Check castling rights
        const castlingKey = `${isWhite ? 'white' : 'black'}${side === 'kingside' ? 'Kingside' : 'Queenside'}`;
        if (!gameState.castlingRights[castlingKey]) {
            return false;
        }
        
        // Check if king is in check
        if (gameState.checkStatus.inCheck && gameState.checkStatus.checkedPlayer === (isWhite ? 0 : 1)) {
            return false;
        }
        
        // Check if squares between king and rook are empty
        const direction = side === 'kingside' ? 1 : -1;
        const squares = side === 'kingside' ? [col + 1, col + 2] : [col - 1, col - 2, col - 3];
        
        for (const checkCol of squares) {
            if (gameState.board[row][checkCol]) {
                return false;
            }
        }
        
        // Check if king passes through attacked squares
        for (let i = 1; i <= 2; i++) {
            const checkCol = col + i * direction;
            if (this.isSquareAttacked(gameState, { row, col: checkCol }, isWhite ? 1 : 0)) {
                return false;
            }
        }
        
        return true;
    }
    
    isSquareAttacked(gameState, square, byPlayer) {
        const isWhite = byPlayer === 0;
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece && !this.isOpponentPiece(piece, !isWhite)) {
                    if (this.canPieceAttackSquare(gameState, { row, col }, square, piece)) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    canPieceAttackSquare(gameState, piecePos, targetPos, piece) {
        const possibleMoves = this.getPossibleMoves(gameState, piecePos, piece);
        return possibleMoves.some(move => move.row === targetPos.row && move.col === targetPos.col);
    }
    
    isValidSquare(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }
    
    isOpponentPiece(piece, isCurrentPlayerWhite) {
        const pieceIsWhite = piece === piece.toUpperCase();
        return pieceIsWhite !== isCurrentPlayerWhite;
    }
    
    isInsufficientMaterial(gameState) {
        const pieces = { white: [], black: [] };
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece) {
                    const color = piece === piece.toUpperCase() ? 'white' : 'black';
                    pieces[color].push(piece.toLowerCase());
                }
            }
        }
        
        // King vs King
        if (pieces.white.length === 1 && pieces.black.length === 1) {
            return true;
        }
        
        // King and Bishop vs King or King and Knight vs King
        if ((pieces.white.length === 2 && pieces.black.length === 1) ||
            (pieces.white.length === 1 && pieces.black.length === 2)) {
            const allPieces = [...pieces.white, ...pieces.black];
            return allPieces.includes('b') || allPieces.includes('n');
        }
        
        return false;
    }
    
    isThreefoldRepetition(gameState) {
        // Simplified implementation - in practice would need to track board positions
        return false;
    }
}

// ===========================
// CHESS VALIDATOR
// ===========================

class ChessValidator {
    constructor() {
        this.chessGame = new ChessGame();
    }
    
    validateMove(gameState, move, playerId) {
        try {
            // Check if it's the player's turn
            if (gameState.currentPlayer !== playerId) {
                return { valid: false, reason: 'Not your turn' };
            }
            
            // Check if game is active
            if (gameState.gameStatus !== 'active') {
                return { valid: false, reason: 'Game is not active' };
            }
            
            // Validate move format
            if (!this.isValidMoveFormat(move)) {
                return { valid: false, reason: 'Invalid move format' };
            }
            
            const { from, to } = move;
            
            // Check if source square has a piece
            const piece = gameState.board[from.row][from.col];
            if (!piece) {
                return { valid: false, reason: 'No piece at source square' };
            }
            
            // Check if piece belongs to current player
            const isWhite = gameState.currentPlayer === 0;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (isWhite !== pieceIsWhite) {
                return { valid: false, reason: 'Not your piece' };
            }
            
            // Check if the move is possible for this piece
            const possibleMoves = this.chessGame.getPossibleMoves(gameState, from, piece);
            const moveExists = possibleMoves.some(m => m.row === to.row && m.col === to.col);
            
            if (!moveExists) {
                return { valid: false, reason: 'Invalid move for this piece' };
            }
            
            // Check if move leaves king in check
            if (!this.chessGame.isMoveLegal(gameState, move, playerId)) {
                return { valid: false, reason: 'Move leaves king in check' };
            }
            
            return { valid: true };
            
        } catch (error) {
            ErrorManager.logError(error, 'Chess move validation');
            return { valid: false, reason: 'Validation error' };
        }
    }
    
    isValidMoveFormat(move) {
        return move &&
               typeof move.from === 'object' &&
               typeof move.to === 'object' &&
               Number.isInteger(move.from.row) &&
               Number.isInteger(move.from.col) &&
               Number.isInteger(move.to.row) &&
               Number.isInteger(move.to.col) &&
               move.from.row >= 0 && move.from.row < 8 &&
               move.from.col >= 0 && move.from.col < 8 &&
               move.to.row >= 0 && move.to.row < 8 &&
               move.to.col >= 0 && move.to.col < 8;
    }
}

// ===========================
// CHESS RENDERER
// ===========================

class ChessRenderer {
    constructor() {
        this.pieceSymbols = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };
        
        this.selectedSquare = null;
        this.highlightedSquares = new Set();
    }
    
    render(gameState, containerId) {
        const container = document.getElementById(containerId);
        if (!container) {
            throw new GameError(`Container not found: ${containerId}`, 'CONTAINER_NOT_FOUND');
        }
        
        container.innerHTML = this.generateChessHTML(gameState);
        this.attachEventListeners(container, gameState);
        this.updateGameInfo(gameState);
    }
    
    generateChessHTML(gameState) {
        return `
            <div class="chess-game-container">
                <div class="chess-players">
                    <div class="player-info">
                        <span class="player-name">${this.getPlayerName(gameState, 1)} (Black)</span>
                        <div class="player-timer" id="blackTimer">${this.formatTime(gameState.timeControls.black)}</div>
                    </div>
                    <div class="player-info">
                        <span class="player-name">${this.getPlayerName(gameState, 0)} (White)</span>
                        <div class="player-timer" id="whiteTimer">${this.formatTime(gameState.timeControls.white)}</div>
                    </div>
                </div>
                
                <div class="chess-board-container">
                    <div class="chess-board" id="chessBoard">
                        ${this.generateBoardHTML(gameState)}
                    </div>
                </div>
                
                <div class="chess-controls">
                    <div class="game-status" id="chessGameStatus">
                        ${this.getStatusMessage(gameState)}
                    </div>
                    
                    <div class="chess-actions">
                        <button class="btn btn-sm btn-danger" onclick="GameUIManager.resignGame('chess')">
                            <i class="fas fa-flag"></i> Resign
                        </button>
                        <button class="btn btn-sm btn-secondary" onclick="GameUIManager.offerDraw('chess')">
                            <i class="fas fa-handshake"></i> Draw
                        </button>
                        <button class="btn btn-sm btn-warning" onclick="GameUIManager.requestUndo('chess')">
                            <i class="fas fa-undo"></i> Undo
                        </button>
                    </div>
                    
                    <div class="move-history" id="chessMoveHistory">
                        <h4>Move History</h4>
                        <div class="moves-list">
                            ${this.generateMoveHistoryHTML(gameState)}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    generateBoardHTML(gameState) {
        let html = '';
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const isLight = (row + col) % 2 === 0;
                const piece = gameState.board[row][col];
                const squareId = `chess-square-${row}-${col}`;
                
                let cssClasses = `chess-square ${isLight ? 'light' : 'dark'}`;
                
                // Highlight last move
                if (gameState.lastMove) {
                    const { from, to } = gameState.lastMove;
                    if ((row === from.row && col === from.col) || (row === to.row && col === to.col)) {
                        cssClasses += ' last-move';
                    }
                }
                
                // Highlight check
                if (gameState.checkStatus.inCheck) {
                    const piece = gameState.board[row][col];
                    if (piece === 'K' || piece === 'k') {
                        const pieceOwner = piece === 'K' ? 0 : 1;
                        if (pieceOwner === gameState.checkStatus.checkedPlayer) {
                            cssClasses += ' in-check';
                        }
                    }
                }
                
                html += `
                    <div class="${cssClasses}" 
                         id="${squareId}"
                         data-row="${row}" 
                         data-col="${col}">
                        ${piece ? this.pieceSymbols[piece] : ''}
                    </div>
                `;
            }
        }
        
        return html;
    }
    
    generateMoveHistoryHTML(gameState) {
        let html = '';
        const moves = gameState.moveHistory;
        
        for (let i = 0; i < moves.length; i += 2) {
            const moveNumber = Math.floor(i / 2) + 1;
            const whiteMove = moves[i];
            const blackMove = moves[i + 1];
            
            html += `
                <div class="move-pair">
                    <span class="move-number">${moveNumber}.</span>
                    <span class="white-move">${this.formatMove(whiteMove)}</span>
                    ${blackMove ? `<span class="black-move">${this.formatMove(blackMove)}</span>` : ''}
                </div>
            `;
        }
        
        return html || '<div class="no-moves">No moves yet</div>';
    }
    
    formatMove(moveEntry) {
        if (!moveEntry) return '';
        
        const { move, piece } = moveEntry;
        const { from, to } = move;
        
        return `${this.squareToNotation(from)}${this.squareToNotation(to)}`;
    }
    
    squareToNotation(square) {
        return String.fromCharCode(97 + square.col) + (8 - square.row);
    }
    
    getPlayerName(gameState, playerIndex) {
        if (gameState.players && gameState.players[playerIndex]) {
            const address = gameState.players[playerIndex];
            return address.substring(0, 8) + '...';
        }
        return `Player ${playerIndex + 1}`;
    }
    
    getStatusMessage(gameState) {
        if (gameState.gameStatus === 'checkmate') {
            const winner = gameState.winner === 0 ? 'White' : 'Black';
            return `Checkmate! ${winner} wins!`;
        } else if (gameState.gameStatus === 'stalemate') {
            return 'Stalemate! Game is a draw.';
        } else if (gameState.gameStatus.startsWith('draw_')) {
            return 'Game is a draw.';
        } else if (gameState.checkStatus.inCheck) {
            const checkedPlayer = gameState.checkStatus.checkedPlayer === 0 ? 'White' : 'Black';
            return `${checkedPlayer} is in check!`;
        } else {
            const currentPlayer = gameState.currentPlayer === 0 ? 'White' : 'Black';
            return `${currentPlayer} to move`;
        }
    }
    
    formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    attachEventListeners(container, gameState) {
        const squares = container.querySelectorAll('.chess-square');
        
        squares.forEach(square => {
            square.addEventListener('click', (event) => {
                this.handleSquareClick(event, gameState);
            });
        });
    }
    
    handleSquareClick(event, gameState) {
        const square = event.currentTarget;
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        
        if (this.selectedSquare) {
            // Attempt to make a move
            const move = {
                from: this.selectedSquare,
                to: { row, col }
            };
            
            GameManager.makeMove('chess', move);
            this.clearSelection();
        } else {
            // Select a piece
            const piece = gameState.board[row][col];
            if (piece) {
                const userAccount = StateManager.get('userAccount');
                const playerIndex = gameState.players.indexOf(userAccount);
                
                if (playerIndex === gameState.currentPlayer) {
                    this.selectSquare({ row, col });
                }
            }
        }
    }
    
    selectSquare(square) {
        this.clearSelection();
        this.selectedSquare = square;
        
        const squareElement = document.getElementById(`chess-square-${square.row}-${square.col}`);
        if (squareElement) {
            squareElement.classList.add('selected');
        }
    }
    
    clearSelection() {
        if (this.selectedSquare) {
            const squareElement = document.getElementById(`chess-square-${this.selectedSquare.row}-${this.selectedSquare.col}`);
            if (squareElement) {
                squareElement.classList.remove('selected');
            }
        }
        
        this.selectedSquare = null;
        this.clearHighlights();
    }
    
    clearHighlights() {
        this.highlightedSquares.forEach(square => {
            const squareElement = document.getElementById(`chess-square-${square.row}-${square.col}`);
            if (squareElement) {
                squareElement.classList.remove('possible-move');
            }
        });
        
        this.highlightedSquares.clear();
    }
    
    updateGameInfo(gameState) {
        // Update any additional game information displays
        const statusElement = document.getElementById('chessGameStatus');
        if (statusElement) {
            statusElement.textContent = this.getStatusMessage(gameState);
            
            // Add appropriate CSS classes
            statusElement.className = 'game-status';
            if (gameState.checkStatus.inCheck) {
                statusElement.classList.add('check');
            }
            if (gameState.gameStatus === 'checkmate') {
                statusElement.classList.add('checkmate');
            }
        }
    }
}

// ===========================
// SIMPLIFIED CHECKERS IMPLEMENTATION
// ===========================

class CheckersGame {
    createNewGame(gameId, players) {
        return {
            gameId: gameId,
            gameType: 'checkers',
            players: players,
            board: this.createInitialBoard(),
            currentPlayer: 0, // 0 = red, 1 = black
            gameStatus: 'active',
            moveHistory: [],
            capturedPieces: { red: 0, black: 0 },
            mustCapture: false,
            gameStartTime: Date.now()
        };
    }
    
    createInitialBoard() {
        const board = Array(8).fill(null).map(() => Array(8).fill(null));
        
        // Place black pieces (top)
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 8; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'black', king: false };
                }
            }
        }
        
        // Place red pieces (bottom)
        for (let row = 5; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'red', king: false };
                }
            }
        }
        
        return board;
    }
    
    applyMove(gameState, move, playerId) {
        const newState = JSON.parse(JSON.stringify(gameState));
        // Simplified checkers implementation
        // Full implementation would include jump validation, king promotion, etc.
        
        return newState;
    }
}

class CheckersValidator {
    validateMove(gameState, move, playerId) {
        // Simplified validation
        return { valid: true };
    }
}

class CheckersRenderer {
    render(gameState, containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div class="checkers-game-container">
                <div class="checkers-board">
                    <!-- Simplified checkers board -->
                    <div class="game-placeholder">
                        <h3>Checkers Game</h3>
                        <p>Game ID: ${gameState.gameId}</p>
                        <p>Current Player: ${gameState.currentPlayer === 0 ? 'Red' : 'Black'}</p>
                    </div>
                </div>
            </div>
        `;
    }
}

// ===========================
// SIMPLIFIED WORD GAME IMPLEMENTATION
// ===========================

class WordGame {
    createNewGame(gameId, players) {
        return {
            gameId: gameId,
            gameType: 'words',
            players: players,
            currentRound: 1,
            totalRounds: 3,
            timeLeft: 60000,
            availableLetters: this.generateLetters(),
            scores: { 0: 0, 1: 0 },
            foundWords: { 0: [], 1: [] },
            gameStatus: 'active',
            gameStartTime: Date.now()
        };
    }
    
    generateLetters() {
        const letterSets = ['BLOCKCHAIN', 'ETHEREUM', 'BITCOIN', 'GAMING', 'TOKENS'];
        return letterSets[Math.floor(Math.random() * letterSets.length)];
    }
    
    applyMove(gameState, move, playerId) {
        const newState = JSON.parse(JSON.stringify(gameState));
        // Simplified word game implementation
        
        return newState;
    }
}

class WordValidator {
    validateMove(gameState, move, playerId) {
        // Simplified validation
        return { valid: true };
    }
}

class WordRenderer {
    render(gameState, containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div class="word-game-container">
                <div class="word-game-board">
                    <h3>Word Battle</h3>
                    <p>Game ID: ${gameState.gameId}</p>
                    <p>Round: ${gameState.currentRound}/${gameState.totalRounds}</p>
                    <p>Letters: ${gameState.availableLetters}</p>
                </div>
            </div>
        `;
    }
}

// ===========================
// GAME MANAGER
// ===========================

class GameManager {
    constructor() {
        this.gameStateManager = new GameStateManager();
        this.activeGames = new Map();
        this.gameWindows = new Map();
    }
    
    async createGame(gameType, stakeAmount, players) {
        try {
            // Validate inputs
            const gameTypeValidation = SecurityManager.validateInput(gameType, 'game_type');
            if (!gameTypeValidation.valid) {
                throw new GameError(gameTypeValidation.error, 'INVALID_GAME_TYPE');
            }
            
            const stakeValidation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
            if (!stakeValidation.valid) {
                throw new GameError(stakeValidation.error, 'INVALID_STAKE');
            }
            
            // Create game on blockchain if connected
            let blockchainResult = null;
            if (StateManager.get('isWalletConnected') && StateManager.get('walletProvider') !== 'demo') {
                try {
                    blockchainResult = await BlockchainManager.createGameOnChain(gameType, stakeAmount);
                } catch (error) {
                    console.warn('Blockchain game creation failed, continuing in demo mode:', error);
                }
            }
            
            // Create game state
            const gameId = blockchainResult?.gameId || Utils.generateId();
            const gameState = this.gameStateManager.createGame(gameType, gameId, players);
            
            // Store game
            this.activeGames.set(gameId, gameState);
            
            // Update state manager
            StateManager.update('myActiveGames', games => {
                games.set(gameId, gameState);
                return games;
            });
            
            // Show success notification
            NotificationManager.show(
                'Game Created',
                `${gameType.charAt(0).toUpperCase() + gameType.slice(1)} game created successfully!`,
                'success'
            );
            
            return { gameId, gameState, blockchainResult };
            
        } catch (error) {
            ErrorManager.logError(error, 'Game creation');
            throw error;
        }
    }
    
    openGameWindow(gameType, gameId) {
        try {
            const gameState = this.activeGames.get(gameId);
            if (!gameState) {
                throw new GameError('Game not found', 'GAME_NOT_FOUND');
            }
            
            // Create game window
            const windowId = `game-window-${gameId}`;
            const gameWindow = this.createGameWindow(windowId, gameType, gameState);
            
            // Render game
            this.gameStateManager.renderGame(gameType, gameState, `${windowId}-content`);
            
            // Store window reference
            this.gameWindows.set(gameId, gameWindow);
            
            return gameWindow;
            
        } catch (error) {
            ErrorManager.logError(error, 'Opening game window');
            throw error;
        }
    }
    
    createGameWindow(windowId, gameType, gameState) {
        const gameWindow = document.createElement('div');
        gameWindow.id = windowId;
        gameWindow.className = 'game-window';
        
        gameWindow.innerHTML = `
            <div class="game-window-header">
                <h3><i class="fas fa-gamepad"></i> ${gameType.charAt(0).toUpperCase() + gameType.slice(1)} Game</h3>
                <div class="game-window-controls">
                    <button class="btn btn-sm" onclick="GameManager.minimizeGame('${gameState.gameId}')">
                        <i class="fas fa-minus"></i>
                    </button>
                    <button class="btn btn-sm btn-danger" onclick="GameManager.closeGame('${gameState.gameId}')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div class="game-window-content" id="${windowId}-content">
                <!-- Game content will be rendered here -->
            </div>
        `;
        
        // Add to page
        const container = document.getElementById('gamesSection') || document.body;
        container.appendChild(gameWindow);
        
        return gameWindow;
    }
    
    makeMove(gameType, move) {
        try {
            const userAccount = StateManager.get('userAccount');
            if (!userAccount) {
                throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
            }
            
            // Find active game for this user and game type
            const activeGame = Array.from(this.activeGames.values()).find(game => 
                game.gameType === gameType && 
                game.players.includes(userAccount) &&
                game.gameStatus === 'active'
            );
            
            if (!activeGame) {
                throw new GameError('No active game found', 'NO_ACTIVE_GAME');
            }
            
            const playerId = activeGame.players.indexOf(userAccount);
            
            // Validate and apply move
            const newGameState = this.gameStateManager.makeMove(gameType, activeGame, move, playerId);
            
            // Update stored game state
            this.activeGames.set(activeGame.gameId, newGameState);
            
            // Re-render game
            this.gameStateManager.renderGame(gameType, newGameState, `game-window-${activeGame.gameId}-content`);
            
            // Check for game end
            if (newGameState.gameStatus !== 'active') {
                this.handleGameEnd(newGameState);
            }
            
            return newGameState;
            
        } catch (error) {
            ErrorManager.logError(error, 'Making move');
            NotificationManager.show(
                'Invalid Move',
                error.message,
                'error'
            );
            throw error;
        }
    }
    
    handleGameEnd(gameState) {
        try {
            console.log('🏁 Game ended:', gameState);
            
            // Update player stats
            const userAccount = StateManager.get('userAccount');
            const playerIndex = gameState.players.indexOf(userAccount);
            
            if (playerIndex !== -1) {
                StateManager.update('playerStats', stats => {
                    stats.gamesPlayed++;
                    
                    if (gameState.winner === playerIndex) {
                        stats.gamesWon++;
                        stats.totalEarned += gameState.stake * 1.94; // 97% of pot minus platform fee
                    }
                    
                    stats.winRate = stats.gamesPlayed > 0 ? (stats.gamesWon / stats.gamesPlayed) * 100 : 0;
                    
                    return stats;
                });
                
                // Save updated stats
                WalletManager.saveUserData();
            }
            
            // Show game result
            const isWinner = gameState.winner === playerIndex;
            const resultType = gameState.gameStatus === 'stalemate' || gameState.gameStatus.startsWith('draw_') ? 'draw' : 
                              isWinner ? 'win' : 'lose';
            
            this.showGameResult(gameState, resultType);
            
        } catch (error) {
            ErrorManager.logError(error, 'Handling game end');
        }
    }
    
    showGameResult(gameState, resultType) {
        const messages = {
            win: '🏆 Congratulations! You won!',
            lose: '😞 You lost this game.',
            draw: '🤝 Game ended in a draw.'
        };
        
        const resultActions = `
            <button class="notification-btn" onclick="GameManager.closeGame('${gameState.gameId}')">
                Close Game
            </button>
            <button class="notification-btn secondary" onclick="NavigationManager.showSection('lobby')">
                Back to Lobby
            </button>
        `;
        
        NotificationManager.show(
            'Game Finished',
            messages[resultType],
            resultType === 'win' ? 'success' : resultType === 'lose' ? 'error' : 'info',
            0,
            resultActions
        );
    }
    
    minimizeGame(gameId) {
        const gameWindow = this.gameWindows.get(gameId);
        if (gameWindow) {
            gameWindow.style.display = 'none';
        }
    }
    
    closeGame(gameId) {
        try {
            // Remove from active games
            this.activeGames.delete(gameId);
            
            // Remove game window
            const gameWindow = this.gameWindows.get(gameId);
            if (gameWindow && gameWindow.parentNode) {
                gameWindow.parentNode.removeChild(gameWindow);
            }
            this.gameWindows.delete(gameId);
            
            // Update state
            StateManager.update('myActiveGames', games => {
                games.delete(gameId);
                return games;
            });
            
            NotificationManager.show('Game Closed', 'Game window closed', 'info');
            
        } catch (error) {
            ErrorManager.logError(error, 'Closing game');
        }
    }
}

// ===========================
// NAVIGATION MANAGER
// ===========================

class NavigationManager {
    constructor() {
        this.currentSection = 'lobby';
        this.sectionLoaders = new Map();
        this.initializeSectionLoaders();
    }
    
    initializeSectionLoaders() {
        this.sectionLoaders.set('lobby', () => this.loadLobbySection());
        this.sectionLoaders.set('create', () => this.loadCreateSection());
        this.sectionLoaders.set('games', () => this.loadGamesSection());
        this.sectionLoaders.set('tournaments', () => this.loadTournamentsSection());
        this.sectionLoaders.set('profile', () => this.loadProfileSection());
        this.sectionLoaders.set('settings', () => this.loadSettingsSection());
    }
    
    showSection(sectionName) {
        try {
            if (sectionName === this.currentSection) {
                return; // Already showing this section
            }
            
            // Validate section name
            const validation = SecurityManager.validateInput(sectionName, 'string', {
                maxLength: 20,
                allowSpecialChars: false
            });
            
            if (!validation.valid) {
                throw new GameError('Invalid section name', 'INVALID_SECTION');
            }
            
            // Hide all sections
            document.querySelectorAll('.section-content').forEach(section => {
                section.classList.remove('active');
            });
            
            // Update navigation
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show target section
            const targetSection = document.getElementById(`${sectionName}Section`);
            if (targetSection) {
                targetSection.classList.add('active');
                
                // Load section content
                const loader = this.sectionLoaders.get(sectionName);
                if (loader) {
                    loader();
                }
            }
            
            // Update active nav item
            const navItem = document.querySelector(`[data-section="${sectionName}"]`);
            if (navItem) {
                navItem.classList.add('active');
            }
            
            // Update state
            this.currentSection = sectionName;
            StateManager.set('currentSection', sectionName);
            
            console.log(`📍 Navigated to: ${sectionName}`);
            
        } catch (error) {
            ErrorManager.logError(error, 'Section navigation');
        }
    }
    
    loadLobbySection() {
        const section = document.getElementById('lobbySection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-home"></i> Game Lobby</h2>
                <div class="section-controls">
                    <button class="btn btn-sm btn-primary" onclick="LobbyManager.refreshLobby()">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
            </div>
            
            <div class="lobby-content">
                <div class="lobby-filters">
                    <h3>Filter Games</h3>
                    <div class="filter-controls">
                        <select id="gameTypeFilter" class="form-control">
                            <option value="all">All Games</option>
                            <option value="chess">Chess</option>
                            <option value="checkers">Checkers</option>
                            <option value="words">Word Battle</option>
                        </select>
                        <select id="skillFilter" class="form-control">
                            <option value="all">All Skill Levels</option>
                            <option value="bronze">Bronze</option>
                            <option value="silver">Silver</option>
                            <option value="gold">Gold</option>
                            <option value="diamond">Diamond</option>
                        </select>
                        <button class="btn btn-secondary" onclick="LobbyManager.applyFilters()">
                            Apply Filters
                        </button>
                    </div>
                </div>
                
                <div class="games-grid" id="lobbyGamesList">
                    <div class="loading-placeholder">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Loading games...</p>
                    </div>
                </div>
            </div>
        `;
        
        // Load games after rendering
        setTimeout(() => {
            if (window.LobbyManager) {
                LobbyManager.loadGames();
            }
        }, 100);
    }
    
    loadCreateSection() {
        const section = document.getElementById('createSection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-plus"></i> Create New Game</h2>
            </div>
            
            <div class="create-game-form">
                <div class="form-group">
                    <label>Game Type</label>
                    <div class="game-type-selector">
                        <button class="game-type-btn" data-game-type="chess">
                            <i class="fas fa-chess"></i>
                            <span>Chess</span>
                        </button>
                        <button class="game-type-btn" data-game-type="checkers">
                            <i class="fas fa-circle"></i>
                            <span>Checkers</span>
                        </button>
                        <button class="game-type-btn" data-game-type="words">
                            <i class="fas fa-font"></i>
                            <span>Words</span>
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="gameStake">Stake Amount (CORE)</label>
                    <input type="number" id="gameStake" class="form-control" 
                           min="0.01" max="100" step="0.01" value="0.1">
                    <small>Minimum: 0.01 CORE, Maximum: 100 CORE</small>
                </div>
                
                <div class="form-group">
                    <label for="gameTimeControl">Time Control</label>
                    <select id="gameTimeControl" class="form-control">
                        <option value="blitz">Blitz (5 min)</option>
                        <option value="rapid" selected>Rapid (10 min)</option>
                        <option value="standard">Standard (30 min)</option>
                    </select>
                </div>
                
                <button class="btn btn-lg btn-primary" id="createGameBtn" onclick="GameCreator.createGame()" disabled>
                    <i class="fas fa-plus"></i> Create Game
                </button>
            </div>
            
            <div class="player-stats-preview">
                <h3>Your Stats</h3>
                <div class="stats-grid" id="playerStatsDisplay">
                    <!-- Stats will be loaded by JavaScript -->
                </div>
            </div>
        `;
        
        // Load player stats
        setTimeout(() => {
            if (window.StatsManager) {
                StatsManager.updatePlayerStatsDisplay();
            }
        }, 100);
    }
    
    loadGamesSection() {
        const section = document.getElementById('gamesSection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-gamepad"></i> Active Games</h2>
            </div>
            
            <div class="games-content">
                <div class="game-windows-container" id="gameWindowsContainer">
                    <!-- Game windows will be created here -->
                </div>
                
                <div class="no-active-games" id="noActiveGames">
                    <i class="fas fa-ghost"></i>
                    <h3>No Active Games</h3>
                    <p>You don't have any active games. Create or join a game to start playing!</p>
                    <button class="btn btn-primary" onclick="NavigationManager.showSection('create')">
                        <i class="fas fa-plus"></i> Create Game
                    </button>
                </div>
            </div>
        `;
    }
    
    loadTournamentsSection() {
        const section = document.getElementById('tournamentsSection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-trophy"></i> Tournaments</h2>
            </div>
            
            <div class="tournaments-content">
                <div class="tournaments-placeholder">
                    <i class="fas fa-trophy"></i>
                    <h3>Tournaments Coming Soon!</h3>
                    <p>Tournament functionality will be available in the next update.</p>
                </div>
            </div>
        `;
    }
    
    loadProfileSection() {
        const section = document.getElementById('profileSection');
        if (!section) return;
        
        const userAccount = StateManager.get('userAccount');
        const playerStats = StateManager.get('playerStats');
        const skillRatings = StateManager.get('skillRatings');
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-user"></i> Player Profile</h2>
            </div>
            
            <div class="profile-content">
                <div class="player-identity">
                    <div class="player-avatar">
                        <div class="avatar-circle">
                            ${userAccount ? userAccount.substring(0, 2).toUpperCase() : '??'}
                        </div>
                    </div>
                    <div class="player-info">
                        <h3>${userAccount || 'Not Connected'}</h3>
                        <div class="player-badges">
                            ${userAccount ? '<span class="badge verified">✅ Verified</span>' : ''}
                            ${StateManager.get('isWalletConnected') ? '<span class="badge blockchain">⛓️ On-Chain</span>' : ''}
                        </div>
                    </div>
                </div>
                
                <div class="stats-section">
                    <h3>Gaming Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.gamesPlayed}</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.gamesWon}</div>
                            <div class="stat-label">Games Won</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.winRate.toFixed(1)}%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.totalEarned.toFixed(4)}</div>
                            <div class="stat-label">CORE Earned</div>
                        </div>
                    </div>
                </div>
                
                <div class="skills-section">
                    <h3>Skill Ratings</h3>
                    <div class="skills-list">
                        <div class="skill-item">
                            <span class="skill-name">♟️ Chess</span>
                            <span class="skill-rating">${skillRatings.chess}</span>
                        </div>
                        <div class="skill-item">
                            <span class="skill-name">⚫ Checkers</span>
                            <span class="skill-rating">${skillRatings.checkers}</span>
                        </div>
                        <div class="skill-item">
                            <span class="skill-name">📝 Words</span>
                            <span class="skill-rating">${skillRatings.words}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    loadSettingsSection() {
        const section = document.getElementById('settingsSection');
        if (!section) return;
        
        const settings = StateManager.get('platformSettings');
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-cog"></i> Settings</h2>
            </div>
            
            <div class="settings-content">
                <div class="settings-category">
                    <h3>Game Settings</h3>
                    <div class="settings-list">
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.soundEnabled ? 'checked' : ''} 
                                       onchange="SettingsManager.updateSetting('soundEnabled', this.checked)">
                                Enable Sound Effects
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.animationsEnabled ? 'checked' : ''} 
                                       onchange="SettingsManager.updateSetting('animationsEnabled', this.checked)">
                                Enable Animations
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.gameInvites ? 'checked' : ''} 
                                       onchange="SettingsManager.updateSetting('gameInvites', this.checked)">
                                Allow Game Invitations
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-category">
                    <h3>Privacy Settings</h3>
                    <div class="settings-list">
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.hideBalance ? 'checked' : ''} 
                                       onchange="SettingsManager.updateSetting('hideBalance', this.checked)">
                                Hide Balance Display
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.chatNotifications ? 'checked' : ''} 
                                       onchange="SettingsManager.updateSetting('chatNotifications', this.checked)">
                                Chat Notifications
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-category">
                    <h3>Advanced Settings</h3>
                    <div class="settings-list">
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.developerMode ? 'checked' : ''} 
                                       onchange="SettingsManager.updateSetting('developerMode', this.checked)">
                                Developer Mode
                            </label>
                            <small>Enables advanced debugging features</small>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.realTimeSync ? 'checked' : ''} 
                                       onchange="SettingsManager.updateSetting('realTimeSync', this.checked)">
                                Real-time Synchronization
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-actions">
                    <button class="btn btn-primary" onclick="SettingsManager.saveSettings()">
                        <i class="fas fa-save"></i> Save Settings
                    </button>
                    <button class="btn btn-secondary" onclick="SettingsManager.resetSettings()">
                        <i class="fas fa-undo"></i> Reset to Defaults
                    </button>
                </div>
            </div>
        `;
    }
}

// ===========================
// GLOBAL INSTANCES & EXPORTS
// ===========================

const GameManager = new GameManager();
const NavigationManager = new NavigationManager();

// Export to global scope
window.GameManager = GameManager;
window.NavigationManager = NavigationManager;
window.GameStateManager = new GameStateManager();

console.log('✅ Game Logic & UI Management Loaded');
</script>
  <script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 6: PLATFORM INTEGRATION & INITIALIZATION
   =========================== */

'use strict';

// ===========================
// LOBBY MANAGER
// ===========================

class LobbyManager {
    constructor() {
        this.availableGames = new Map();
        this.refreshInterval = null;
        this.lastRefreshTime = 0;
        this.isLoading = false;
    }
    
    async loadGames() {
        if (this.isLoading) {
            console.log('⏳ Games already loading...');
            return;
        }
        
        try {
            this.isLoading = true;
            this.showLoadingState();
            
            // Simulate API call for demo purposes
            const games = await this.fetchAvailableGames();
            
            this.availableGames.clear();
            games.forEach(game => {
                this.availableGames.set(game.id, game);
            });
            
            this.renderGamesList();
            this.lastRefreshTime = Date.now();
            
            console.log(`📋 Loaded ${games.length} games in lobby`);
            
        } catch (error) {
            ErrorManager.logError(error, 'Loading lobby games');
            this.showErrorState();
        } finally {
            this.isLoading = false;
        }
    }
    
    async fetchAvailableGames() {
        // In a real implementation, this would call the API
        // For demo purposes, we'll generate some sample games
        return new Promise((resolve) => {
            setTimeout(() => {
                const sampleGames = this.generateSampleGames();
                resolve(sampleGames);
            }, 1000);
        });
    }
    
    generateSampleGames() {
        const gameTypes = ['chess', 'checkers', 'words'];
        const stakes = [0.1, 0.25, 0.5, 1.0, 2.5];
        const players = [
            '0x1234567890123456789012345678901234567890',
            '0x9876543210987654321098765432109876543210',
            '0xabcdef1234567890abcdef1234567890abcdef12'
        ];
        
        const games = [];
        
        for (let i = 0; i < Utils.getRandomInt(3, 8); i++) {
            const gameType = gameTypes[Math.floor(Math.random() * gameTypes.length)];
            const stake = stakes[Math.floor(Math.random() * stakes.length)];
            const creator = players[Math.floor(Math.random() * players.length)];
            
            games.push({
                id: `demo-${Utils.generateId()}`,
                gameType: gameType,
                stake: stake,
                creator: creator,
                createdAt: Date.now() - Utils.getRandomInt(60000, 3600000),
                timeControl: Utils.getRandomInt(5, 30),
                skillLevel: ['bronze', 'silver', 'gold', 'diamond'][Math.floor(Math.random() * 4)],
                status: 'waiting'
            });
        }
        
        return games;
    }
    
    renderGamesList() {
        const container = document.getElementById('lobbyGamesList');
        if (!container) return;
        
        if (this.availableGames.size === 0) {
            container.innerHTML = `
                <div class="no-games-available">
                    <i class="fas fa-search"></i>
                    <h3>No Games Available</h3>
                    <p>Be the first to create a game!</p>
                    <button class="btn btn-primary" onclick="NavigationManager.showSection('create')">
                        <i class="fas fa-plus"></i> Create Game
                    </button>
                </div>
            `;
            return;
        }
        
        let html = '';
        this.availableGames.forEach(game => {
            html += this.generateGameCardHTML(game);
        });
        
        container.innerHTML = html;
    }
    
    generateGameCardHTML(game) {
        const timeAgo = Utils.formatTimeAgo(game.createdAt);
        const creatorName = game.creator.substring(0, 8) + '...';
        
        const gameIcons = {
            chess: 'fas fa-chess',
            checkers: 'fas fa-circle',
            words: 'fas fa-font'
        };
        
        const skillColors = {
            bronze: '#cd7f32',
            silver: '#c0c0c0',
            gold: '#ffd700',
            diamond: '#b9f2ff'
        };
        
        return `
            <div class="game-card" data-game-id="${game.id}">
                <div class="game-card-header">
                    <div class="game-type">
                        <i class="${gameIcons[game.gameType]}"></i>
                        <span>${game.gameType.charAt(0).toUpperCase() + game.gameType.slice(1)}</span>
                    </div>
                    <div class="game-skill" style="color: ${skillColors[game.skillLevel]}">
                        <i class="fas fa-star"></i>
                        ${game.skillLevel.charAt(0).toUpperCase() + game.skillLevel.slice(1)}
                    </div>
                </div>
                
                <div class="game-card-body">
                    <div class="game-stake">
                        <span class="stake-amount">${game.stake} CORE</span>
                        <span class="stake-label">Stake</span>
                    </div>
                    
                    <div class="game-info">
                        <div class="info-row">
                            <span class="info-label">Creator:</span>
                            <span class="info-value">${creatorName}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Time Control:</span>
                            <span class="info-value">${game.timeControl} min</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Created:</span>
                            <span class="info-value">${timeAgo}</span>
                        </div>
                    </div>
                </div>
                
                <div class="game-card-footer">
                    <button class="btn btn-primary btn-block" 
                            onclick="LobbyManager.joinGame('${game.id}')"
                            ${!StateManager.get('isWalletConnected') ? 'disabled' : ''}>
                        <i class="fas fa-play"></i> Join Game
                    </button>
                </div>
            </div>
        `;
    }
    
    async joinGame(gameId) {
        try {
            if (!StateManager.get('isWalletConnected')) {
                NotificationManager.show(
                    'Wallet Required',
                    'Please connect your wallet to join games',
                    'warning'
                );
                return;
            }
            
            const game = this.availableGames.get(gameId);
            if (!game) {
                throw new GameError('Game not found', 'GAME_NOT_FOUND');
            }
            
            // Check balance
            const userBalance = StateManager.get('userBalance');
            if (userBalance < game.stake) {
                NotificationManager.show(
                    'Insufficient Balance',
                    `You need at least ${game.stake} CORE to join this game`,
                    'error'
                );
                return;
            }
            
            // Join game on blockchain if connected
            if (StateManager.get('walletProvider') !== 'demo') {
                await BlockchainManager.joinGameOnChain(gameId, game.stake);
            }
            
            // Create local game session
            const players = [game.creator, StateManager.get('userAccount')];
            const gameSession = await GameManager.createGame(game.gameType, game.stake, players);
            
            // Open game window
            GameManager.openGameWindow(game.gameType, gameSession.gameId);
            
            // Navigate to games section
            NavigationManager.showSection('games');
            
            // Remove from lobby
            this.availableGames.delete(gameId);
            this.renderGamesList();
            
            NotificationManager.show(
                'Game Joined',
                `Successfully joined ${game.gameType} game!`,
                'success'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Joining game');
            NotificationManager.show(
                'Join Failed',
                error.message,
                'error'
            );
        }
    }
    
    refreshLobby() {
        if (Date.now() - this.lastRefreshTime < 5000) {
            NotificationManager.show(
                'Refresh Cooldown',
                'Please wait before refreshing again',
                'info'
            );
            return;
        }
        
        this.loadGames();
    }
    
    applyFilters() {
        const gameTypeFilter = document.getElementById('gameTypeFilter')?.value || 'all';
        const skillFilter = document.getElementById('skillFilter')?.value || 'all';
        
        const filteredGames = new Map();
        
        this.availableGames.forEach((game, id) => {
            let include = true;
            
            if (gameTypeFilter !== 'all' && game.gameType !== gameTypeFilter) {
                include = false;
            }
            
            if (skillFilter !== 'all' && game.skillLevel !== skillFilter) {
                include = false;
            }
            
            if (include) {
                filteredGames.set(id, game);
            }
        });
        
        // Temporarily replace games for rendering
        const originalGames = this.availableGames;
        this.availableGames = filteredGames;
        this.renderGamesList();
        this.availableGames = originalGames;
        
        NotificationManager.show(
            'Filters Applied',
            `Showing ${filteredGames.size} games`,
            'info'
        );
    }
    
    showLoadingState() {
        const container = document.getElementById('lobbyGamesList');
        if (container) {
            container.innerHTML = `
                <div class="loading-placeholder">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading games...</p>
                </div>
            `;
        }
    }
    
    showErrorState() {
        const container = document.getElementById('lobbyGamesList');
        if (container) {
            container.innerHTML = `
                <div class="error-placeholder">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3>Failed to Load Games</h3>
                    <p>Unable to fetch available games. Please try again.</p>
                    <button class="btn btn-primary" onclick="LobbyManager.loadGames()">
                        <i class="fas fa-retry"></i> Retry
                    </button>
                </div>
            `;
        }
    }
    
    startAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
        }
        
        this.refreshInterval = setInterval(() => {
            if (StateManager.get('currentSection') === 'lobby') {
                this.loadGames();
            }
        }, 30000); // Refresh every 30 seconds
    }
    
    stopAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    }
}

// ===========================
// GAME CREATOR
// ===========================

class GameCreator {
    constructor() {
        this.selectedGameType = null;
        this.isCreating = false;
    }
    
    initialize() {
        this.setupGameTypeSelector();
        this.setupFormValidation();
    }
    
    setupGameTypeSelector() {
        const gameTypeButtons = document.querySelectorAll('.game-type-btn');
        
        gameTypeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                this.selectGameType(button.dataset.gameType);
            });
        });
    }
    
    selectGameType(gameType) {
        // Validate game type
        const validation = SecurityManager.validateInput(gameType, 'game_type');
        if (!validation.valid) {
            NotificationManager.show('Invalid Game Type', validation.error, 'error');
            return;
        }
        
        this.selectedGameType = gameType;
        
        // Update UI
        document.querySelectorAll('.game-type-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        
        const selectedBtn = document.querySelector(`[data-game-type="${gameType}"]`);
        if (selectedBtn) {
            selectedBtn.classList.add('selected');
        }
        
        // Enable create button
        const createBtn = document.getElementById('createGameBtn');
        if (createBtn) {
            createBtn.disabled = false;
        }
        
        StateManager.set('selectedGameType', gameType);
        
        console.log(`🎮 Selected game type: ${gameType}`);
    }
    
    setupFormValidation() {
        const stakeInput = document.getElementById('gameStake');
        if (stakeInput) {
            stakeInput.addEventListener('input', (e) => {
                this.validateStakeAmount(e.target.value);
            });
        }
    }
    
    validateStakeAmount(amount) {
        const validation = SecurityManager.validateInput(amount, 'stake_amount');
        const stakeInput = document.getElementById('gameStake');
        
        if (stakeInput) {
            if (validation.valid) {
                stakeInput.classList.remove('invalid');
                stakeInput.classList.add('valid');
            } else {
                stakeInput.classList.remove('valid');
                stakeInput.classList.add('invalid');
            }
        }
        
        return validation;
    }
    
    async createGame() {
        if (this.isCreating) {
            console.log('⏳ Game creation already in progress');
            return;
        }
        
        try {
            this.isCreating = true;
            this.setLoadingState(true);
            
            // Validate inputs
            if (!this.selectedGameType) {
                throw new GameError('Please select a game type', 'NO_GAME_TYPE');
            }
            
            if (!StateManager.get('isWalletConnected')) {
                throw new GameError('Please connect your wallet first', 'WALLET_NOT_CONNECTED');
            }
            
            const stakeAmount = parseFloat(document.getElementById('gameStake')?.value || '0');
            const stakeValidation = this.validateStakeAmount(stakeAmount);
            
            if (!stakeValidation.valid) {
                throw new GameError(stakeValidation.error, 'INVALID_STAKE');
            }
            
            // Check balance
            const userBalance = StateManager.get('userBalance');
            if (userBalance < stakeAmount) {
                throw new GameError('Insufficient balance', 'INSUFFICIENT_BALANCE');
            }
            
            // Get time control
            const timeControl = document.getElementById('gameTimeControl')?.value || 'rapid';
            const timeMinutes = this.getTimeControlMinutes(timeControl);
            
            console.log('🎮 Creating game...', {
                gameType: this.selectedGameType,
                stake: stakeAmount,
                timeControl: timeMinutes
            });
            
            // Create game
            const players = [StateManager.get('userAccount')];
            const result = await GameManager.createGame(this.selectedGameType, stakeAmount, players);
            
            // Open game window
            GameManager.openGameWindow(this.selectedGameType, result.gameId);
            
            // Navigate to games section
            NavigationManager.showSection('games');
            
            // Reset form
            this.resetForm();
            
            NotificationManager.show(
                'Game Created',
                `${this.selectedGameType.charAt(0).toUpperCase() + this.selectedGameType.slice(1)} game created successfully!`,
                'success'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Game creation');
            NotificationManager.show(
                'Creation Failed',
                error.message,
                'error'
            );
        } finally {
            this.isCreating = false;
            this.setLoadingState(false);
        }
    }
    
    getTimeControlMinutes(timeControl) {
        const timeControls = {
            'blitz': 5,
            'rapid': 10,
            'standard': 30
        };
        
        return timeControls[timeControl] || 10;
    }
    
    setLoadingState(loading) {
        const createBtn = document.getElementById('createGameBtn');
        if (createBtn) {
            if (loading) {
                createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating...';
                createBtn.disabled = true;
            } else {
                createBtn.innerHTML = '<i class="fas fa-plus"></i> Create Game';
                createBtn.disabled = !this.selectedGameType;
            }
        }
    }
    
    resetForm() {
        this.selectedGameType = null;
        
        // Reset game type selection
        document.querySelectorAll('.game-type-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        
        // Reset stake input
        const stakeInput = document.getElementById('gameStake');
        if (stakeInput) {
            stakeInput.value = '0.1';
            stakeInput.classList.remove('valid', 'invalid');
        }
        
        // Reset time control
        const timeControl = document.getElementById('gameTimeControl');
        if (timeControl) {
            timeControl.value = 'rapid';
        }
        
        // Disable create button
        const createBtn = document.getElementById('createGameBtn');
        if (createBtn) {
            createBtn.disabled = true;
        }
    }
}

// ===========================
// STATS MANAGER
// ===========================

class StatsManager {
    constructor() {
        this.updateInterval = null;
        this.lastUpdate = 0;
    }
    
    updatePlayerStatsDisplay() {
        const playerStats = StateManager.get('playerStats');
        const skillRatings = StateManager.get('skillRatings');
        const userAccount = StateManager.get('userAccount');
        
        const container = document.getElementById('playerStatsDisplay');
        if (!container) return;
        
        container.innerHTML = `
            <div class="stat-card">
                <div class="stat-icon"><i class="fas fa-gamepad"></i></div>
                <div class="stat-info">
                    <div class="stat-value">${playerStats.gamesPlayed}</div>
                    <div class="stat-label">Games Played</div>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-icon"><i class="fas fa-trophy"></i></div>
                <div class="stat-info">
                    <div class="stat-value">${playerStats.gamesWon}</div>
                    <div class="stat-label">Games Won</div>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-icon"><i class="fas fa-percentage"></i></div>
                <div class="stat-info">
                    <div class="stat-value">${playerStats.winRate.toFixed(1)}%</div>
                    <div class="stat-label">Win Rate</div>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-icon"><i class="fas fa-coins"></i></div>
                <div class="stat-info">
                    <div class="stat-value">${playerStats.totalEarned.toFixed(4)}</div>
                    <div class="stat-label">CORE Earned</div>
                </div>
            </div>
            
            <div class="skill-ratings-preview">
                <h4>Skill Ratings</h4>
                <div class="skills-preview">
                    <div class="skill-preview-item">
                        <span class="skill-name">♟️ Chess</span>
                        <span class="skill-rating">${skillRatings.chess}</span>
                    </div>
                    <div class="skill-preview-item">
                        <span class="skill-name">⚫ Checkers</span>
                        <span class="skill-rating">${skillRatings.checkers}</span>
                    </div>
                    <div class="skill-preview-item">
                        <span class="skill-name">📝 Words</span>
                        <span class="skill-rating">${skillRatings.words}</span>
                    </div>
                </div>
            </div>
        `;
    }
    
    async updateLiveStats() {
        try {
            // Update online players count
            const onlineCount = Utils.getRandomInt(15, 45);
            this.updateStatElement('onlinePlayersCount', onlineCount);
            
            // Update active games count
            const activeGamesCount = Utils.getRandomInt(3, 12);
            this.updateStatElement('activeGamesCount', activeGamesCount);
            
            // Update total volume
            const totalVolume = (Math.random() * 1000 + 500).toFixed(2);
            this.updateStatElement('totalVolumeCount', totalVolume);
            
            this.lastUpdate = Date.now();
            
        } catch (error) {
            ErrorManager.logError(error, 'Updating live stats');
        }
    }
    
    updateStatElement(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = value;
        }
    }
    
    startLiveUpdates() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        
        // Initial update
        this.updateLiveStats();
        
        // Update every 10 seconds
        this.updateInterval = setInterval(() => {
            this.updateLiveStats();
        }, 10000);
    }
    
    stopLiveUpdates() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }
}

// ===========================
// SETTINGS MANAGER
// ===========================

class SettingsManager {
    constructor() {
        this.pendingChanges = new Map();
    }
    
    updateSetting(key, value) {
        try {
            // Validate setting key and value
            if (!this.isValidSetting(key, value)) {
                throw new GameError(`Invalid setting: ${key}`, 'INVALID_SETTING');
            }
            
            // Store pending change
            this.pendingChanges.set(key, value);
            
            // Apply immediately for some settings
            const immediateSettings = ['hideBalance', 'soundEnabled', 'animationsEnabled'];
            if (immediateSettings.includes(key)) {
                this.applySetting(key, value);
            }
            
            console.log(`⚙️ Setting updated: ${key} = ${value}`);
            
        } catch (error) {
            ErrorManager.logError(error, 'Updating setting');
            NotificationManager.show('Settings Error', error.message, 'error');
        }
    }
    
    isValidSetting(key, value) {
        const validSettings = {
            'soundEnabled': 'boolean',
            'animationsEnabled': 'boolean',
            'gameInvites': 'boolean',
            'hideBalance': 'boolean',
            'chatNotifications': 'boolean',
            'developerMode': 'boolean',
            'realTimeSync': 'boolean',
            'defaultStake': 'number',
            'autoJoin': 'boolean',
            'txNotifications': 'boolean'
        };
        
        const expectedType = validSettings[key];
        if (!expectedType) {
            return false;
        }
        
        return typeof value === expectedType;
    }
    
    applySetting(key, value) {
        const currentSettings = StateManager.get('platformSettings');
        const newSettings = { ...currentSettings, [key]: value };
        
        StateManager.set('platformSettings', newSettings);
        
        // Apply specific setting effects
        switch (key) {
            case 'hideBalance':
                WalletManager.updateWalletUI(
                    StateManager.get('isWalletConnected'),
                    StateManager.get('userAccount'),
                    StateManager.get('userBalance')
                );
                break;
                
            case 'soundEnabled':
                this.toggleSoundSystem(value);
                break;
                
            case 'animationsEnabled':
                this.toggleAnimations(value);
                break;
                
            case 'realTimeSync':
                if (value) {
                    this.startRealTimeSync();
                } else {
                    this.stopRealTimeSync();
                }
                break;
        }
    }
    
    saveSettings() {
        try {
            // Apply all pending changes
            this.pendingChanges.forEach((value, key) => {
                this.applySetting(key, value);
            });
            
            // Clear pending changes
            this.pendingChanges.clear();
            
            // Save to storage
            WalletManager.saveUserData();
            
            NotificationManager.show(
                'Settings Saved',
                'Your settings have been saved successfully',
                'success'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Saving settings');
            NotificationManager.show(
                'Save Failed',
                'Failed to save settings',
                'error'
            );
        }
    }
    
    resetSettings() {
        try {
            // Reset to default settings
            const defaultSettings = {
                autoJoin: false,
                soundEnabled: true,
                animationsEnabled: true,
                defaultStake: 0.1,
                gameInvites: true,
                txNotifications: true,
                chatNotifications: false,
                hideBalance: false,
                developerMode: false,
                realTimeSync: true
            };
            
            StateManager.set('platformSettings', defaultSettings);
            
            // Clear pending changes
            this.pendingChanges.clear();
            
            // Reload settings section
            NavigationManager.loadSettingsSection();
            
            NotificationManager.show(
                'Settings Reset',
                'Settings have been reset to defaults',
                'info'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Resetting settings');
        }
    }
    
    toggleSoundSystem(enabled) {
        if (enabled) {
            console.log('🔊 Sound system enabled');
        } else {
            console.log('🔇 Sound system disabled');
        }
    }
    
    toggleAnimations(enabled) {
        const body = document.body;
        if (enabled) {
            body.classList.remove('no-animations');
        } else {
            body.classList.add('no-animations');
        }
    }
    
    startRealTimeSync() {
        console.log('⚡ Real-time sync enabled');
        StatsManager.startLiveUpdates();
        LobbyManager.startAutoRefresh();
    }
    
    stopRealTimeSync() {
        console.log('⏸️ Real-time sync disabled');
        StatsManager.stopLiveUpdates();
        LobbyManager.stopAutoRefresh();
    }
}

// ===========================
// ACTIVITY MANAGER
// ===========================

class ActivityManager {
    constructor() {
        this.activities = [];
        this.maxActivities = Config.get('MAX_ACTIVITY_ITEMS') || 20;
    }
    
    addActivity(type, message, data = {}) {
        const activity = {
            id: Utils.generateId(),
            type: type,
            message: message,
            data: data,
            timestamp: Date.now(),
            user: StateManager.get('userAccount')
        };
        
        this.activities.unshift(activity);
        
        // Keep only recent activities
        if (this.activities.length > this.maxActivities) {
            this.activities = this.activities.slice(0, this.maxActivities);
        }
        
        this.updateActivityFeed();
        
        console.log(`📝 Activity logged: ${type} - ${message}`);
    }
    
    updateActivityFeed() {
        const container = document.getElementById('activityFeed');
        if (!container) return;
        
        if (this.activities.length === 0) {
            container.innerHTML = `
                <div class="activity-item">
                    <i class="fas fa-rocket"></i>
                    <span>Platform initialized</span>
                </div>
            `;
            return;
        }
        
        const html = this.activities
            .slice(0, 10) // Show only last 10 activities
            .map(activity => this.generateActivityHTML(activity))
            .join('');
        
        container.innerHTML = html;
    }
    
    generateActivityHTML(activity) {
        const timeAgo = Utils.formatTimeAgo(activity.timestamp);
        const icons = {
            'game_created': 'fas fa-plus-circle',
            'game_joined': 'fas fa-play',
            'game_won': 'fas fa-trophy',
            'game_lost': 'fas fa-times-circle',
            'wallet_connected': 'fas fa-plug',
            'wallet_disconnected': 'fas fa-unplug',
            'transaction': 'fas fa-exchange-alt',
            'system': 'fas fa-cog'
        };
        
        return `
            <div class="activity-item" title="${new Date(activity.timestamp).toLocaleString()}">
                <i class="${icons[activity.type] || 'fas fa-info'}"></i>
                <span>${activity.message}</span>
                <small>${timeAgo}</small>
            </div>
        `;
    }
    
    logGameActivity(type, gameType, data = {}) {
        const messages = {
            'created': `Created ${gameType} game`,
            'joined': `Joined ${gameType} game`,
            'won': `Won ${gameType} game`,
            'lost': `Lost ${gameType} game`,
            'draw': `Drew ${gameType} game`
        };
        
        this.addActivity(`game_${type}`, messages[type], { gameType, ...data });
    }
    
    logWalletActivity(type, data = {}) {
        const messages = {
            'connected': 'Wallet connected',
            'disconnected': 'Wallet disconnected',
            'transaction': 'Transaction processed'
        };
        
        this.addActivity(`wallet_${type}`, messages[type], data);
    }
    
    logSystemActivity(message, data = {}) {
        this.addActivity('system', message, data);
    }
}

// ===========================
// AGE VERIFICATION MANAGER
// ===========================

class AgeVerificationManager {
    constructor() {
        this.isVerified = false;
        this.verificationAttempts = 0;
        this.maxAttempts = 3;
    }
    
    initialize() {
        // Check if already verified in this session
        const verified = sessionStorage.getItem('ageVerified');
        if (verified === 'true') {
            this.isVerified = true;
            return;
        }
        
        // Show age verification modal
        this.showAgeVerificationModal();
    }
    
    showAgeVerificationModal() {
        const modal = document.getElementById('ageVerificationModal');
        if (modal) {
            modal.classList.remove('hidden');
            
            // Add event listeners
            const verifyButtons = modal.querySelectorAll('[data-action="verify-age"]');
            verifyButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const isAdult = e.target.dataset.value === 'true';
                    this.handleAgeVerification(isAdult);
                });
            });
        }
    }
    
    handleAgeVerification(isAdult) {
        this.verificationAttempts++;
        
        if (isAdult) {
            this.isVerified = true;
            sessionStorage.setItem('ageVerified', 'true');
            this.hideAgeVerificationModal();
            
            console.log('✅ Age verification passed');
            
            // Initialize anti-bot challenge
            AntiBotManager.initialize();
            
        } else {
            this.handleUnderageAccess();
        }
    }
    
    handleUnderageAccess() {
        NotificationManager.show(
            'Access Denied',
            'This platform is only available to users 18 years and older.',
            'error',
            0
        );
        
        // Redirect after delay
        setTimeout(() => {
            window.location.href = 'https://google.com';
        }, 3000);
    }
    
    hideAgeVerificationModal() {
        const modal = document.getElementById('ageVerificationModal');
        if (modal) {
            modal.classList.add('hidden');
        }
    }
    
    isUserVerified() {
        return this.isVerified;
    }
}

// ===========================
// ANTI-BOT MANAGER
// ===========================

class AntiBotManager {
    constructor() {
        this.isVerified = false;
        this.challengeAttempts = 0;
        this.maxAttempts = 3;
        this.currentChallenge = null;
    }
    
    initialize() {
        if (!Config.get('ENABLE_ANTI_BOT')) {
            this.isVerified = true;
            return;
        }
        
        // Check if already verified in this session
        const verified = sessionStorage.getItem('antiBotVerified');
        if (verified === 'true') {
            this.isVerified = true;
            return;
        }
        
        // Show anti-bot challenge
        this.showAntiBotChallenge();
    }
    
    showAntiBotChallenge() {
        const modal = document.getElementById('antiBotModal');
        if (modal) {
            modal.classList.remove('hidden');
            this.generateChallenge();
            this.setupChallengeEventListeners();
        }
    }
    
    generateChallenge() {
        const challenges = [
            {
                instruction: 'Select all squares containing chess pieces',
                correctAnswers: new Set([0, 2, 4, 6]),
                grid: ['♔', '🌳', '♕', '🌸', '♖', '⭐', '♗', '🌊', '♘']
            },
            {
                instruction: 'Select all squares containing game controllers',
                correctAnswers: new Set([1, 3, 7]),
                grid: ['🎯', '🎮', '🌟', '🎮', '🎲', '🎪', '🎨', '🎮', '🎭']
            },
            {
                instruction: 'Select all squares containing coins',
                correctAnswers: new Set([0, 4, 8]),
                grid: ['🪙', '🎈', '🎊', '🎁', '🪙', '🎉', '🎀', '🎇', '🪙']
            }
        ];
        
        this.currentChallenge = challenges[Math.floor(Math.random() * challenges.length)];
        this.renderChallenge();
    }
    
    renderChallenge() {
        const instructionsEl = document.getElementById('captchaInstructions');
        const gridEl = document.getElementById('captchaGrid');
        
        if (instructionsEl) {
            instructionsEl.textContent = this.currentChallenge.instruction;
        }
        
        if (gridEl) {
            gridEl.innerHTML = '';
            
            this.currentChallenge.grid.forEach((symbol, index) => {
                const tile = document.createElement('div');
                tile.className = 'captcha-tile';
                tile.textContent = symbol;
                tile.dataset.index = index;
                
                tile.addEventListener('click', () => {
                    tile.classList.toggle('selected');
                    this.updateVerifyButton();
                });
                
                gridEl.appendChild(tile);
            });
        }
    }
    
    setupChallengeEventListeners() {
        const verifyBtn = document.getElementById('verifyCaptchaBtn');
        const refreshBtn = document.getElementById('refreshCaptchaBtn');
        
        if (verifyBtn) {
            verifyBtn.addEventListener('click', () => {
                this.verifyChallengeResponse();
            });
        }
        
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                this.generateChallenge();
            });
        }
    }
    
    updateVerifyButton() {
        const selectedTiles = document.querySelectorAll('.captcha-tile.selected');
        const verifyBtn = document.getElementById('verifyCaptchaBtn');
        
        if (verifyBtn) {
            verifyBtn.disabled = selectedTiles.length === 0;
        }
    }
    
    verifyChallengeResponse() {
        const selectedTiles = document.querySelectorAll('.captcha-tile.selected');
        const selectedIndices = new Set();
        
        selectedTiles.forEach(tile => {
            selectedIndices.add(parseInt(tile.dataset.index));
        });
        
        this.challengeAttempts++;
        
        // Check if selection matches correct answer
        const isCorrect = this.setsEqual(selectedIndices, this.currentChallenge.correctAnswers);
        
        if (isCorrect) {
            this.handleChallengeSuccess();
        } else {
            this.handleChallengeFailure();
        }
    }
    
    setsEqual(setA, setB) {
        return setA.size === setB.size && [...setA].every(x => setB.has(x));
    }
    
    handleChallengeSuccess() {
        this.isVerified = true;
        sessionStorage.setItem('antiBotVerified', 'true');
        this.hideAntiBotModal();
        
        console.log('🤖 Anti-bot verification passed');
        
        NotificationManager.show(
            'Verification Complete',
            'Human verification successful!',
            'success'
        );
        
        // Initialize platform
        PlatformManager.initializePlatform();
    }
    
    handleChallengeFailure() {
        if (this.challengeAttempts >= this.maxAttempts) {
            NotificationManager.show(
                'Verification Failed',
                'Too many failed attempts. Please try again later.',
                'error',
                0
            );
            
            // Block access temporarily
            setTimeout(() => {
                window.location.reload();
            }, 5000);
            
        } else {
            NotificationManager.show(
                'Incorrect Selection',
                `Please try again. ${this.maxAttempts - this.challengeAttempts} attempts remaining.`,
                'warning'
            );
            
            // Generate new challenge
            this.generateChallenge();
        }
    }
    
    hideAntiBotModal() {
        const modal = document.getElementById('antiBotModal');
        if (modal) {
            modal.classList.add('hidden');
        }
    }
    
    isUserVerified() {
        return this.isVerified;
    }
}

// ===========================
// PLATFORM MANAGER (MAIN COORDINATOR)
// ===========================

class PlatformManager {
    constructor() {
        this.isInitialized = false;
        this.loadingProgress = 0;
        this.loadingSteps = [
            'Initializing security...',
            'Loading user interface...',
            'Connecting to blockchain...',
            'Loading game engines...',
            'Starting live systems...',
            'Platform ready!'
        ];
    }
    
    async initializePlatform() {
        if (this.isInitialized) {
            console.log('✅ Platform already initialized');
            return;
        }
        
        try {
            console.log('🚀 Initializing CrossRealm Gaming Platform...');
            
            // Step 1: Initialize security
            this.updateLoadingProgress(0, 'Initializing security...');
            await this.initializeSecurity();
            
            // Step 2: Setup UI
            this.updateLoadingProgress(1, 'Loading user interface...');
            await this.initializeUI();
            
            // Step 3: Initialize blockchain
            this.updateLoadingProgress(2, 'Connecting to blockchain...');
            await this.initializeBlockchain();
            
            // Step 4: Initialize game systems
            this.updateLoadingProgress(3, 'Loading game engines...');
            await this.initializeGameSystems();
            
            // Step 5: Start live systems
            this.updateLoadingProgress(4, 'Starting live systems...');
            await this.initializeLiveSystems();
            
            // Step 6: Complete
            this.updateLoadingProgress(5, 'Platform ready!');
            
            // Hide loading screen
            await Utils.sleep(1000);
            this.hideLoadingScreen();
            
            this.isInitialized = true;
            
            // Log success
            ActivityManager.logSystemActivity('Platform initialized successfully');
            
            console.log('✅ CrossRealm Gaming Platform initialized successfully!');
            
        } catch (error) {
            ErrorManager.logError(error, 'Platform initialization');
            this.handleInitializationError(error);
        }
    }
    
    async initializeSecurity() {
        // Security is already initialized in previous sections
        await Utils.sleep(500);
    }
    
    async initializeUI() {
        // Setup event listeners
        this.setupEventListeners();
        
        // Initialize managers
        GameCreator.initialize();
        
        await Utils.sleep(500);
    }
    
    async initializeBlockchain() {
        // Blockchain is already initialized in previous sections
        await Utils.sleep(500);
    }
    
    async initializeGameSystems() {
        // Game systems are already initialized in previous sections
        await Utils.sleep(500);
    }
    
    async initializeLiveSystems() {
        // Start live updates
        StatsManager.startLiveUpdates();
        
        // Initialize lobby
        if (StateManager.get('currentSection') === 'lobby') {
            LobbyManager.loadGames();
        }
        
        await Utils.sleep(500);
    }
    
    setupEventListeners() {
        // Navigation
        document.querySelectorAll('[data-section]').forEach(element => {
            element.addEventListener('click', (e) => {
                e.preventDefault();
                const section = e.currentTarget.dataset.section;
                NavigationManager.showSection(section);
            });
        });
        
        // Wallet connection
        const connectBtn = document.getElementById('connectBtn');
        if (connectBtn) {
            connectBtn.addEventListener('click', () => {
                WalletManager.connect();
            });
        }
        
        const disconnectBtn = document.getElementById('disconnectBtn');
        if (disconnectBtn) {
            disconnectBtn.addEventListener('click', () => {
                WalletManager.disconnect();
            });
        }
        
        // Copy contract address
        document.querySelectorAll('[data-copy-target]').forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.currentTarget.dataset.copyTarget;
                this.handleCopyAction(target);
            });
        });
        
        // Test connection
        const testConnectionBtn = document.getElementById('testConnectionBtn');
        if (testConnectionBtn) {
            testConnectionBtn.addEventListener('click', () => {
                this.testServerConnection();
            });
        }
        
        // Footer actions
        document.querySelectorAll('[data-action]').forEach(element => {
            element.addEventListener('click', (e) => {
                e.preventDefault();
                const action = e.currentTarget.dataset.action;
                this.handleFooterAction(action);
            });
        });
    }
    
    async handleCopyAction(target) {
        try {
            let textToCopy = '';
            
            switch (target) {
                case 'contract-address':
                    textToCopy = Config.get('CONTRACT_ADDRESS');
                    break;
                default:
                    throw new Error('Unknown copy target');
            }
            
            await Utils.copyToClipboard(textToCopy);
            
            NotificationManager.show(
                'Copied',
                'Address copied to clipboard',
                'success',
                2000
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Copy action');
            NotificationManager.show(
                'Copy Failed',
                'Failed to copy to clipboard',
                'error'
            );
        }
    }
    
    async testServerConnection() {
        try {
            const startTime = Date.now();
            
            // Simulate server test
            await Utils.sleep(Utils.getRandomInt(100, 500));
            
            const latency = Date.now() - startTime;
            
            // Update server status
            this.updateServerStatus('online', `Connected (${latency}ms)`, latency);
            
            NotificationManager.show(
                'Connection Test',
                `Server responding in ${latency}ms`,
                'success'
            );
            
        } catch (error) {
            this.updateServerStatus('offline', 'Connection failed', 0);
            ErrorManager.logError(error, 'Server connection test');
        }
    }
    
    updateServerStatus(status, message, latency = 0) {
        const serverStatus = document.getElementById('serverStatus');
        const serverLatency = document.getElementById('serverLatency');
        const lastSync = document.getElementById('lastSync');
        const serverStatusText = document.getElementById('serverStatusText');
        
        if (serverStatus) {
            const statusClasses = {
                'online': 'online',
                'offline': 'offline',
                'pending': 'pending'
            };
            
            serverStatus.innerHTML = `
                <span class="status-indicator ${statusClasses[status]}"></span>
                <span>${message}</span>
            `;
        }
        
        if (serverLatency) {
            serverLatency.textContent = latency > 0 ? `${latency}ms` : '--ms';
        }
        
        if (lastSync) {
            lastSync.textContent = new Date().toLocaleTimeString();
        }
        
        if (serverStatusText) {
            serverStatusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }
    }
    
    handleFooterAction(action) {
        switch (action) {
            case 'show-help':
                this.showHelpModal();
                break;
            case 'show-terms':
                this.showTermsModal();
                break;
            case 'show-privacy':
                this.showPrivacyModal();
                break;
            case 'show-fairplay':
                this.showFairPlayModal();
                break;
            case 'show-contract':
                this.showContractInfo();
                break;
            default:
                console.warn('Unknown footer action:', action);
        }
    }
    
    showHelpModal() {
        NotificationManager.show(
            'Help Center',
            'Help documentation is available at our website. Visit the support section for guides and tutorials.',
            'info',
            0
        );
    }
    
    showTermsModal() {
        NotificationManager.show(
            'Terms of Service',
            'By using this platform, you agree to our terms of service. Please play responsibly.',
            'info',
            0
        );
    }
    
    showPrivacyModal() {
        NotificationManager.show(
            'Privacy Policy',
            'We respect your privacy. Your wallet data is never stored on our servers.',
            'info',
            0
        );
    }
    
    showFairPlayModal() {
        NotificationManager.show(
            'Fair Play Guarantee',
            'All games use provably fair algorithms powered by blockchain technology.',
            'info',
            0
        );
    }
    
    showContractInfo() {
        const contractAddress = Config.get('CONTRACT_ADDRESS');
        const explorerUrl = `${Config.get('CORE_EXPLORER_URL')}/address/${contractAddress}`;
        
        NotificationManager.show(
            'Smart Contract',
            `Contract: ${contractAddress.substring(0, 10)}... \nView on Core Explorer`,
            'info',
            0,
            `<button class="notification-btn" onclick="window.open('${explorerUrl}', '_blank')">
                View Contract
            </button>`
        );
    }
    
    updateLoadingProgress(step, message) {
        const progressBar = document.getElementById('loadingProgress');
        const statusText = document.getElementById('loadingStatus');
        
        const progress = ((step + 1) / this.loadingSteps.length) * 100;
        
        if (progressBar) {
            progressBar.style.width = `${progress}%`;
        }
        
        if (statusText) {
            statusText.textContent = message;
        }
        
        console.log(`📊 Loading: ${progress.toFixed(0)}% - ${message}`);
    }
    
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
    }
    
    handleInitializationError(error) {
        console.error('❌ Platform initialization failed:', error);
        
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.innerHTML = `
                <div class="loading-content">
                    <div class="error-state">
                        <i class="fas fa-exclamation-triangle" style="color: #e74c3c; font-size: 3rem;"></i>
                        <h2>Initialization Failed</h2>
                        <p>Failed to initialize the platform. Please refresh the page to try again.</p>
                        <button class="btn btn-primary" onclick="window.location.reload()">
                            <i class="fas fa-refresh"></i> Reload Platform
                        </button>
                    </div>
                </div>
            `;
        }
    }
}

// ===========================
// GLOBAL INSTANCES
// ===========================

const LobbyManager = new LobbyManager();
const GameCreator = new GameCreator();
const StatsManager = new StatsManager();
const SettingsManager = new SettingsManager();
const ActivityManager = new ActivityManager();
const AgeVerificationManager = new AgeVerificationManager();
const AntiBotManager = new AntiBotManager();
const PlatformManager = new PlatformManager();

// Export to global scope
window.LobbyManager = LobbyManager;
window.GameCreator = GameCreator;
window.StatsManager = StatsManager;
window.SettingsManager = SettingsManager;
window.ActivityManager = ActivityManager;
window.AgeVerificationManager = AgeVerificationManager;
window.AntiBotManager = AntiBotManager;
window.PlatformManager = PlatformManager;

// ===========================
// PLATFORM STARTUP
// ===========================

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    console.log('🎮 CrossRealm Gaming Platform - Starting Up...');
    
    // Start age verification process
    AgeVerificationManager.initialize();
});

// Setup cleanup
LifecycleManager.addCleanupTask(() => {
    StatsManager.stopLiveUpdates();
    LobbyManager.stopAutoRefresh();
    SettingsManager.saveSettings();
    ActivityManager.addActivity('system', 'Platform shutdown');
});

// Add state change listeners
StateManager.subscribe('isWalletConnected', (connected) => {
    if (connected) {
        ActivityManager.logWalletActivity('connected');
    } else {
        ActivityManager.logWalletActivity('disconnected');
    }
});

StateManager.subscribe('currentSection', (section) => {
    console.log(`📍 Section changed to: ${section}`);
    
    // Section-specific initialization
    switch (section) {
        case 'lobby':
            LobbyManager.loadGames();
            break;
        case 'create':
            StatsManager.updatePlayerStatsDisplay();
            break;
        case 'profile':
            StatsManager.updatePlayerStatsDisplay();
            break;
    }
});

// Global error boundary
window.addEventListener('error', (event) => {
    console.error('💥 Unhandled error:', event.error);
    
    NotificationManager.show(
        'System Error',
        'An unexpected error occurred. The development team has been notified.',
        'error'
    );
});

// Log successful load
console.log('✅ Section 6: Platform Integration & Initialization Loaded');
console.log('🚀 CrossRealm Gaming Platform - Ready for Launch!');
</script>
</body>
</html>
