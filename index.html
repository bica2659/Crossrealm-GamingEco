<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrossRealm Gaming Ecosystem - Live Blockchain Gaming Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
</head>
<body>
    <div class="background"></div>

    <!-- Age Verification Modal -->
    <div class="age-verification" id="ageVerificationModal">
        <div class="verification-content">
            <h1><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h1>
            <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
            <div class="warning">
                <p><i class="fas fa-exclamation-circle"></i> Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
            </div>
            <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            <div class="verification-buttons">
                <button class="verify-btn accept" onclick="verifyAge(true)">I am 18+</button>
                <button class="verify-btn decline" onclick="verifyAge(false)">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Anti-Bot Protection Modal -->
    <div class="anti-bot-challenge hidden" id="antiBotChallenge">
        <div class="modal-content">
            <h3 style="color: #4ecdc4; margin-bottom: 1rem;">🛡️ Human Verification</h3>
            <p style="margin-bottom: 1rem;">Please complete this challenge to continue playing:</p>
            <p id="captchaInstructions" style="margin-bottom: 1rem; font-weight: bold; color: #f39c12;">
                Select all squares containing chess pieces
            </p>
            
            <div class="captcha-grid" id="captchaGrid"></div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
                <button class="verify-btn accept" onclick="verifyCaptcha()" id="verifyCaptchaBtn" disabled>
                    Verify
                </button>
                <button class="verify-btn" onclick="refreshCaptcha()" style="background: #666;">
                    <i class="fas fa-refresh"></i> New Challenge
                </button>
            </div>
            
            <p style="margin-top: 1rem; font-size: 0.8rem; color: #aaa;">
                This helps us prevent automated bots and ensures fair play for all users.
            </p>
        </div>
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="logo">
            <i class="fas fa-dice-d20 logo-icon"></i>
            <h1>CROSSREALM</h1>
        </div>
        
        <nav class="nav-menu" id="navMenu">
            <div class="nav-item active" onclick="showSection('lobby')">🎯 Game Lobby</div>
            <div class="nav-item" onclick="showSection('create')">🎮 Create Game</div>
            <div class="nav-item" onclick="showSection('games')">♟️ Games</div>
            <div class="nav-item" onclick="showSection('tournaments')">🏆 Tournaments</div>
            <div class="nav-item" onclick="showSection('profile')">👤 Profile</div>
            <div class="nav-item" onclick="showSection('chat')">💬 Chat</div>
            <div class="nav-item" onclick="showSection('settings')">⚙️ Settings</div>
        </nav>
        
        <div class="live-badge">🔴 LIVE ON CORE</div>
        
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">
                    <span class="connection-indicator disconnected"></span>Not Connected
                </div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn">
                <i class="fas fa-plug"></i> Connect Wallet
            </button>
            <button class="disconnect-btn hidden" id="disconnectBtn">Disconnect</button>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Smart Contract Status -->
            <div class="contract-status">
                <h3>🔐 Smart Contract Status</h3>
                <div class="contract-address" id="contractAddress">
                    0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A
                    <button class="copy-btn" onclick="copyContractAddress()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <div id="contractStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to Core Blockchain...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="connectionProgress" style="width: 0%"></div>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="live-lobby">
                <h3>📊 Live Platform Stats</h3>
                <div class="lobby-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Online Players</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalGames">0</div>
                        <div class="stat-label">Active Games</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalVolume">0</div>
                        <div class="stat-label">CORE Volume</div>
                    </div>
                </div>
            </div>

            <!-- Recent Activity Feed -->
            <div class="live-lobby">
                <h3>🔥 Recent Activity</h3>
                <div id="activityFeed"></div>
            </div>

            <!-- Tournament Leaderboard -->
            <div class="live-lobby">
                <h3>🏆 Tournament Leaders</h3>
                <div id="tournamentLeaderboard">
                    <div class="leaderboard-item gold">
                        <span>🥇 CryptoKing</span>
                        <span>127 pts</span>
                    </div>
                    <div class="leaderboard-item silver">
                        <span>🥈 GameMaster</span>
                        <span>89 pts</span>
                    </div>
                    <div class="leaderboard-item bronze">
                        <span>🥉 ChessGM</span>
                        <span>76 pts</span>
                    </div>
                </div>
            </div>

            <!-- Server Status -->
            <div class="live-lobby">
                <h3>⚡ Server Status</h3>
                <div class="server-status-grid">
                    <div class="status-item online">
                        <div class="status-value">Online</div>
                        <div class="status-label">Game Server</div>
                    </div>
                    <div class="status-item online">
                        <div class="status-value">12ms</div>
                        <div class="status-label">Latency</div>
                    </div>
                    <div class="status-item online">
                        <div class="status-value">Active</div>
                        <div class="status-label">Validation</div>
                    </div>
                    <div class="status-item online">
                        <div class="status-value">99.9%</div>
                        <div class="status-label">Uptime</div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Content Area -->
        <main class="content-area">
            <!-- Game Lobby Section -->
            <section id="lobbySection" class="section-content">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2>🎯 Live Game Lobby</h2>
                        <button onclick="refreshLobby()" class="game-btn" style="width: auto; padding: 0.5rem 1rem;">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                    
                    <!-- Skill-Based Matchmaking Filter -->
                    <div class="matchmaking-filter">
                        <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">🎯 Skill-Based Matchmaking</h4>
                        <div class="filter-controls">
                            <label>Skill Level:</label>
                            <select id="skillFilter" class="filter-select">
                                <option value="any">Any Skill Level</option>
                                <option value="bronze">Bronze (0-100)</option>
                                <option value="silver">Silver (101-300)</option>
                                <option value="gold">Gold (301-600)</option>
                                <option value="diamond">Diamond (601+)</option>
                            </select>
                            <button onclick="applySkillFilter()" class="game-btn">Apply Filter</button>
                        </div>
                    </div>
                    
                    <div id="gamesList" class="games-list"></div>
                    
                    <div id="noGames" class="hidden no-games">
                        <i class="fas fa-gamepad" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3>No Active Games</h3>
                        <p>Be the first to create a game and start earning CORE!</p>
                        <button onclick="showSection('create')" class="game-btn" style="margin-top: 1rem;">
                            Create First Game
                        </button>
                    </div>
                </div>
            </section>

            <!-- Other sections will be loaded dynamically -->
            <section id="createSection" class="section-content hidden"></section>
            <section id="gamesSection" class="section-content hidden"></section>
            <section id="tournamentsSection" class="section-content hidden"></section>
            <section id="profileSection" class="section-content hidden"></section>
            <section id="chatSection" class="section-content hidden"></section>
            <section id="settingsSection" class="section-content hidden"></section>
        </main>
    </div>

    <!-- Enhanced Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h3>🎮 CrossRealm</h3>
                <p>The premier blockchain gaming platform built on Core Network. Play, compete, and earn with provably fair games.</p>
                <div class="social-links">
                    <a href="#" title="Twitter"><i class="fab fa-twitter"></i></a>
                    <a href="#" title="Discord"><i class="fab fa-discord"></i></a>
                    <a href="#" title="Telegram"><i class="fab fa-telegram"></i></a>
                    <a href="#" title="GitHub"><i class="fab fa-github"></i></a>
                </div>
            </div>
            
            <div class="footer-section">
                <h3>🎯 Games</h3>
                <p><a href="#" onclick="showSection('games')">Chess Masters</a></p>
                <p><a href="#" onclick="showSection('games')">Checkers Pro</a></p>
                <p><a href="#" onclick="showSection('games')">Word Battle</a></p>
                <p><a href="#" onclick="showSection('tournaments')">Tournaments</a></p>
            </div>
            
            <div class="footer-section">
                <h3>🔗 Blockchain</h3>
                <p><a href="https://scan.coredao.org" target="_blank">Core Blockchain Explorer</a></p>
                <p><a href="#" onclick="copyContractAddress()">Smart Contract</a></p>
                <p><a href="https://coredao.org" target="_blank">Core Network</a></p>
                <p><a href="#" onclick="showSection('settings')">Network Settings</a></p>
            </div>
            
            <div class="footer-section">
                <h3>ℹ️ Support</h3>
                <p><a href="#" onclick="showHelp()">Help Center</a></p>
                <p><a href="#" onclick="showTerms()">Terms of Service</a></p>
                <p><a href="#" onclick="showPrivacy()">Privacy Policy</a></p>
                <p><a href="#" onclick="showFairPlay()">Fair Play</a></p>
            </div>
        </div>
        
        <div class="footer-bottom">
            <p>&copy; 2025 CrossRealm Gaming Platform. All rights reserved.</p>
            <p>Built on <strong>Core Blockchain</strong> • Licensed Gaming Platform • Age 18+ Only</p>
            <p>Contract: 0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A (Verified ✅)</p>
        </div>
    </footer>
  <style>
/* ===========================
   CROSSREALM GAMING PLATFORM
   CSS STYLES & ANIMATIONS
   =========================== */

/* Base Variables & Reset */
:root {
    --primary: #4e54c8;
    --primary-dark: #363a9e;
    --secondary: #f39c12;
    --dark: #1a1c2c;
    --light: #f5f7fa;
    --danger: #e74c3c;
    --success: #2ecc71;
    --warning: #f1c40f;
    --gray: #95a5a6;
    --accent: #4ecdc4;
    --accent-dark: #44a08d;
    --glass: rgba(255, 255, 255, 0.1);
    --glass-border: rgba(255, 255, 255, 0.2);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html, body {
    height: 100%;
    overflow-x: hidden;
}

body {
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    color: var(--light);
    position: relative;
    line-height: 1.6;
}

.background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('https://images.unsplash.com/photo-1620336655052-b57986f5a26a?q=80&w=1920') no-repeat center center;
    background-size: cover;
    opacity: 0.1;
    z-index: -1;
}

.hidden {
    display: none !important;
}

/* ========================
   ANIMATIONS & KEYFRAMES
   ======================== */

@keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
}

@keyframes glow {
    0%, 100% { box-shadow: 0 0 20px rgba(78, 205, 196, 0.3); }
    50% { box-shadow: 0 0 30px rgba(78, 205, 196, 0.6); }
}

.pulse { animation: pulse 2s infinite; }
.shake { animation: shake 0.5s; }
.fade-in { animation: fadeIn 0.5s ease-out; }
.slide-in { animation: slideIn 0.5s ease-out; }
.glow { animation: glow 2s infinite; }

/* ========================
   CONNECTION INDICATORS
   ======================== */

.connection-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 0.5rem;
}

.connected {
    background: #00ff88;
    animation: pulse 2s infinite;
}

.disconnected {
    background: #ff6b6b;
}

.pending {
    background: #f1c40f;
    animation: blink 1s infinite;
}

.loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255,255,255,.3);
    border-radius: 50%;
    border-top-color: var(--accent);
    animation: spin 1s ease-in-out infinite;
}

/* ========================
   HEADER STYLES
   ======================== */

.header {
    position: relative;
    z-index: 100;
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    padding: 1rem;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    border-bottom: 1px solid var(--glass-border);
    backdrop-filter: blur(10px);
    min-height: 80px;
}

.logo {
    display: flex;
    align-items: center;
    gap: 10px;
}

.logo h1 {
    font-size: 1.8rem;
    background: linear-gradient(to right, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.logo-icon {
    font-size: 2.5rem;
    color: var(--secondary);
}

.nav-menu {
    display: flex;
    gap: 2rem;
    align-items: center;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.nav-menu::-webkit-scrollbar {
    display: none;
}

.nav-item {
    padding: 0.5rem 1rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid transparent;
    white-space: nowrap;
    flex-shrink: 0;
}

.nav-item:hover {
    background: var(--glass);
    border-color: rgba(78, 205, 196, 0.5);
    transform: translateY(-2px);
}

.nav-item.active {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    color: white;
}

.nav-item.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}

.nav-item.game-minimized {
    opacity: 0.8;
    cursor: pointer;
    pointer-events: auto;
    border: 1px dashed rgba(78, 205, 196, 0.5);
}

.live-badge {
    background: linear-gradient(45deg, #00ff88, #00cc6a);
    color: #000;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-weight: bold;
    font-size: 0.8rem;
    animation: pulse 2s infinite;
}

.wallet-section {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.wallet-info {
    text-align: right;
}

.connection-status {
    font-size: 0.9rem;
    color: #ff6b6b;
}

.balance {
    font-size: 1.2rem;
    font-weight: bold;
}

.connect-btn, .disconnect-btn {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 25px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.disconnect-btn {
    background: linear-gradient(45deg, #ff6b6b, #ee5a52);
    margin-left: 0.5rem;
}

.connect-btn:hover, .disconnect-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
}

/* ========================
   MAIN LAYOUT
   ======================== */

.main-container {
    display: flex;
    min-height: calc(100vh - 80px);
    overflow: hidden;
}

.sidebar {
    width: 350px;
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
    border-right: 1px solid var(--glass-border);
    padding: 2rem;
    overflow-y: auto;
    overflow-x: hidden;
    max-height: calc(100vh - 80px);
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.5) transparent;
}

.sidebar::-webkit-scrollbar {
    width: 8px;
}

.sidebar::-webkit-scrollbar-track {
    background: var(--glass);
    border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.5);
    border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.8);
}

.content-area {
    flex: 1;
    padding: 2rem;
    overflow-y: auto;
    overflow-x: hidden;
    max-height: calc(100vh - 80px);
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.5) transparent;
}

.content-area::-webkit-scrollbar {
    width: 8px;
}

.content-area::-webkit-scrollbar-track {
    background: var(--glass);
    border-radius: 4px;
}

.content-area::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.5);
    border-radius: 4px;
}

.content-area::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.8);
}

.section-content {
    animation: fadeIn 0.5s ease-out;
}

/* ========================
   MODALS & OVERLAYS
   ======================== */

.age-verification {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.verification-content, .modal-content {
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    border: 2px solid var(--accent);
    border-radius: 20px;
    padding: 3rem;
    max-width: 500px;
    width: 90%;
    text-align: center;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
    animation: fadeIn 0.5s ease-out;
}

.verification-content h1 {
    color: var(--warning);
    margin-bottom: 1.5rem;
    font-size: 2rem;
}

.warning {
    background: rgba(241, 196, 15, 0.1);
    border: 1px solid rgba(241, 196, 15, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin: 1.5rem 0;
}

.verification-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 2rem;
}

.verify-btn {
    padding: 1rem 2rem;
    border: none;
    border-radius: 10px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
}

.verify-btn.accept {
    background: linear-gradient(45deg, var(--success), #27ae60);
    color: white;
}

.verify-btn.decline {
    background: linear-gradient(45deg, var(--danger), #c0392b);
    color: white;
}

.verify-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.anti-bot-challenge {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.captcha-grid {
    display: grid;
    grid-template-columns: repeat(3, 80px);
    grid-template-rows: repeat(3, 80px);
    gap: 5px;
    margin: 1rem auto;
    justify-content: center;
}

.captcha-tile {
    background: var(--glass);
    border: 2px solid var(--glass-border);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.captcha-tile:hover {
    background: rgba(78, 205, 196, 0.2);
    border-color: var(--accent);
}

.captcha-tile.selected {
    background: rgba(78, 205, 196, 0.3);
    border-color: var(--accent);
    box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
}

.transaction-status {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
    border: 1px solid var(--accent);
    border-radius: 10px;
    padding: 1rem;
    min-width: 300px;
    max-width: 400px;
    z-index: 1001;
    transform: translateX(120%);
    transition: transform 0.3s ease;
}

.transaction-status.show {
    transform: translateX(0);
}

.tx-hash {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--accent);
    margin-top: 0.5rem;
    word-break: break-all;
}

/* ========================
   LOBBY & GAME COMPONENTS
   ======================== */

.live-lobby {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    border: 2px solid var(--accent);
    box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
    animation: fadeIn 0.5s ease-out;
}

.lobby-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--glass-border);
}

.lobby-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 2rem;
    margin-bottom: 1rem;
}

.stat-item {
    text-align: center;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--accent);
    display: block;
}

.stat-label {
    font-size: 0.8rem;
    color: #aaa;
    display: block;
    margin-top: 0.25rem;
}

.contract-status {
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 2rem;
    text-align: center;
}

.contract-address {
    font-family: monospace;
    background: rgba(0, 0, 0, 0.3);
    padding: 0.5rem;
    border-radius: 5px;
    margin: 0.5rem 0;
    word-break: break-all;
    font-size: 0.9rem;
}

.copy-btn {
    background: rgba(78, 205, 196, 0.2);
    border: 1px solid var(--accent);
    border-radius: 5px;
    padding: 0.3rem 0.6rem;
    color: var(--accent);
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.3s ease;
    margin-left: 0.5rem;
}

.copy-btn:hover {
    background: rgba(78, 205, 196, 0.3);
    transform: translateY(-1px);
}

.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--glass);
    border-radius: 2px;
    overflow: hidden;
    margin: 1rem 0;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), #00ff88);
    border-radius: 2px;
    transition: width 0.3s ease;
}

.leaderboard-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem;
    margin: 0.25rem 0;
    border-radius: 5px;
    transition: all 0.3s ease;
}

.leaderboard-item:hover {
    transform: translateX(5px);
}

.leaderboard-item.gold {
    background: rgba(255, 215, 0, 0.1);
    border-left: 3px solid #ffd700;
}

.leaderboard-item.silver {
    background: rgba(192, 192, 192, 0.1);
    border-left: 3px solid #c0c0c0;
}

.leaderboard-item.bronze {
    background: rgba(205, 127, 50, 0.1);
    border-left: 3px solid #cd7f32;
}

.server-status-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem;
}

.status-item {
    text-align: center;
    padding: 0.5rem;
    border-radius: 5px;
    transition: all 0.3s ease;
}

.status-item.online {
    background: rgba(0, 255, 136, 0.1);
    border: 1px solid rgba(0, 255, 136, 0.3);
}

.status-value {
    font-weight: bold;
    color: #00ff88;
}

.status-label {
    font-size: 0.8rem;
    color: #aaa;
}

/* ========================
   BUTTONS & INTERACTIVE ELEMENTS
   ======================== */

.game-btn {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 10px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
}

.game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
}

.game-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.create-btn {
    width: 100%;
    background: linear-gradient(45deg, var(--primary), var(--secondary));
    border: none;
    padding: 1rem 2rem;
    border-radius: 15px;
    color: white;
    font-weight: bold;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 2rem;
}

.create-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 15px 30px rgba(78, 84, 200, 0.4);
}

.create-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.join-btn {
    background: linear-gradient(45deg, var(--success), #27ae60);
    border: none;
    padding: 0.6rem 1.2rem;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
    width: 100%;
    margin-top: 1rem;
}

.join-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(46, 204, 113, 0.3);
}

.join-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* ========================
   FOOTER STYLES
   ======================== */

.footer {
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    border-top: 1px solid var(--glass-border);
    padding: 3rem 2rem 2rem;
    margin-top: 2rem;
    color: var(--light);
}

.footer-content {
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 2rem;
}

.footer-section h3 {
    color: var(--accent);
    margin-bottom: 1rem;
    font-size: 1.2rem;
}

.footer-section p, .footer-section a {
    color: #ccc;
    text-decoration: none;
    line-height: 1.6;
    margin-bottom: 0.5rem;
    transition: color 0.3s ease;
}

.footer-section a:hover {
    color: var(--accent);
}

.footer-bottom {
    text-align: center;
    padding-top: 2rem;
    margin-top: 2rem;
    border-top: 1px solid var(--glass-border);
    color: #aaa;
}

.social-links {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
    justify-content: center;
}

.social-links a {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    background: rgba(78, 205, 196, 0.2);
    border-radius: 50%;
    color: var(--accent);
    font-size: 1.2rem;
    transition: all 0.3s ease;
}

.social-links a:hover {
    background: var(--accent);
    color: white;
    transform: translateY(-2px);
}

/* ========================
   RESPONSIVE DESIGN
   ======================== */

@media (max-width: 768px) {
    .main-container {
        flex-direction: column;
    }

    .sidebar {
        width: 100%;
        order: 2;
        padding: 1rem;
        max-height: none;
    }

    .content-area {
        order: 1;
        padding: 1rem;
        max-height: none;
    }

    .nav-menu {
        overflow-x: auto;
        white-space: nowrap;
        gap: 1rem;
        padding: 0.5rem 0;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }

    .nav-menu::-webkit-scrollbar {
        display: none;
    }

    .nav-item {
        flex-shrink: 0;
        padding: 0.4rem 0.8rem;
        font-size: 0.9rem;
    }

    .wallet-section {
        flex-direction: column;
        gap: 0.5rem;
        width: 100%;
    }

    .lobby-stats {
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
    }

    .verification-content, .modal-content {
        margin: 1rem;
        padding: 2rem 1rem;
    }

    .verification-content h1 {
        font-size: 1.8rem;
    }

    .verification-content p {
        font-size: 1rem;
    }

    .verify-btn {
        min-width: 100px;
        padding: 0.8rem 1.5rem;
    }

    .transaction-status {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
    }

    .footer-content {
        grid-template-columns: 1fr;
        text-align: center;
    }

    .social-links {
        justify-content: center;
    }
}

@media (max-width: 480px) {
    .header {
        padding: 0.5rem;
    }

    .logo h1 {
        font-size: 1.4rem;
    }

    .logo-icon {
        font-size: 2rem;
    }

    .verification-buttons {
        flex-direction: column;
        gap: 0.5rem;
    }

    .captcha-grid {
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(3, 60px);
    }

    .captcha-tile {
        font-size: 1.2rem;
    }
}

/* ========================
   UTILITY CLASSES
   ======================== */

.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

.mb-1 { margin-bottom: 0.25rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-3 { margin-bottom: 1rem; }
.mb-4 { margin-bottom: 1.5rem; }

.mt-1 { margin-top: 0.25rem; }
.mt-2 { margin-top: 0.5rem; }
.mt-3 { margin-top: 1rem; }
.mt-4 { margin-top: 1.5rem; }

.p-1 { padding: 0.25rem; }
.p-2 { padding: 0.5rem; }
.p-3 { padding: 1rem; }
.p-4 { padding: 1.5rem; }

.flex { display: flex; }
.flex-col { flex-direction: column; }
.items-center { align-items: center; }
.justify-center { justify-content: center; }
.gap-1 { gap: 0.25rem; }
.gap-2 { gap: 0.5rem; }
.gap-3 { gap: 1rem; }

.opacity-50 { opacity: 0.5; }
.opacity-75 { opacity: 0.75; }

.cursor-pointer { cursor: pointer; }
.cursor-not-allowed { cursor: not-allowed; }

.overflow-hidden { overflow: hidden; }
.overflow-auto { overflow: auto; }

.transition { transition: all 0.3s ease; }

/* ========================
   COMPONENT-SPECIFIC STYLES
   ======================== */

.matchmaking-filter {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 1rem;
}

.filter-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
}

.filter-select {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 5px;
    padding: 0.5rem;
    color: white;
    min-width: 150px;
}

.games-list {
    max-height: 60vh;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.5) transparent;
}

.games-list::-webkit-scrollbar {
    width: 6px;
}

.games-list::-webkit-scrollbar-track {
    background: var(--glass);
    border-radius: 3px;
}

.games-list::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.5);
    border-radius: 3px;
}

.no-games {
    text-align: center;
    padding: 3rem;
    color: #aaa;
}

.no-games i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

/* Performance optimizations */
* {
    will-change: auto;
}

.pulse, .glow, .loading {
    will-change: transform, opacity, box-shadow;
}

.nav-item, .game-btn, .join-btn, .create-btn {
    will-change: transform, box-shadow;
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
    :root {
        --accent: #00ffff;
        --glass: rgba(255, 255, 255, 0.2);
        --glass-border: rgba(255, 255, 255, 0.4);
    }
}

/* Dark mode enhancements */
@media (prefers-color-scheme: dark) {
    body {
        background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
    }
}
</style>
  <!-- ===========================
     CROSSREALM GAMING PLATFORM
     GAME BOARD COMPONENTS & WINDOWS
     =========================== -->

<!-- Game Overlay -->
<div class="game-overlay hidden" id="gameOverlay"></div>

<!-- Chess Game Window -->
<div class="game-window hidden" id="chessGameWindow">
    <div class="game-window-header">
        <div class="game-window-title">
            ♟️ Chess Masters 
            <span class="skill-badge skill-gold" id="chessSkillBadge">Gold</span>
            <span class="validation-status validated" title="Server Validated">✓</span>
        </div>
        <div class="game-window-controls">
            <button class="window-btn minimize-btn" onclick="minimizeGame('chess')" title="Minimize">−</button>
            <button class="window-btn close-btn" onclick="closeGame('chess')" title="Close">×</button>
        </div>
    </div>
    <div class="game-window-content">
        <div class="game-info-bar">
            <div class="player-info">
                <div class="player-avatar">👤</div>
                <div class="player-details">
                    <div class="player-name">You (White)</div>
                    <div class="player-rating">Rating: 456</div>
                </div>
            </div>
            <div class="game-timer">
                <div class="timer white-timer" id="whiteTimer">10:00</div>
                <div class="timer black-timer" id="blackTimer">10:00</div>
            </div>
            <div class="player-info opponent">
                <div class="player-details">
                    <div class="player-name">Opponent (Black)</div>
                    <div class="player-rating">Rating: 432</div>
                </div>
                <div class="player-avatar">🤖</div>
            </div>
        </div>
        
        <div class="game-status" id="chessStatus">Waiting for opponent...</div>
        <div class="chess-board" id="chessBoard"></div>
        
        <div class="game-controls">
            <button class="game-btn" onclick="resignChess()">
                <i class="fas fa-flag"></i> Resign
            </button>
            <button class="game-btn" onclick="drawChess()">
                <i class="fas fa-handshake"></i> Offer Draw
            </button>
            <button class="game-btn" onclick="requestUndo()">
                <i class="fas fa-undo"></i> Request Undo
            </button>
        </div>
        
        <div class="game-chat">
            <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">
                <i class="fas fa-comments"></i> Game Chat
            </h4>
            <div class="game-chat-messages" id="chessGameChat">
                <div class="game-chat-message system">
                    <strong>System:</strong> Game started! Good luck!
                </div>
            </div>
            <div class="game-chat-input">
                <input type="text" placeholder="Type a message..." id="chessChatInput" 
                       onkeypress="handleGameChatKeyPress(event, 'chess')" maxlength="100">
                <button onclick="sendGameChatMessage('chess')">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Checkers Game Window -->
<div class="game-window hidden" id="checkersGameWindow">
    <div class="game-window-header">
        <div class="game-window-title">
            ⚫ Checkers Pro 
            <span class="skill-badge skill-silver" id="checkersSkillBadge">Silver</span>
            <span class="validation-status validated" title="Server Validated">✓</span>
        </div>
        <div class="game-window-controls">
            <button class="window-btn minimize-btn" onclick="minimizeGame('checkers')" title="Minimize">−</button>
            <button class="window-btn close-btn" onclick="closeGame('checkers')" title="Close">×</button>
        </div>
    </div>
    <div class="game-window-content">
        <div class="game-info-bar">
            <div class="player-info">
                <div class="player-avatar">🔴</div>
                <div class="player-details">
                    <div class="player-name">You (Red)</div>
                    <div class="player-rating">Rating: 234</div>
                </div>
            </div>
            <div class="move-counter">
                <div class="move-count">Move: <span id="moveCount">1</span></div>
                <div class="captured-pieces">
                    <div>Red captured: <span id="redCaptured">0</span></div>
                    <div>Black captured: <span id="blackCaptured">0</span></div>
                </div>
            </div>
            <div class="player-info opponent">
                <div class="player-details">
                    <div class="player-name">Opponent (Black)</div>
                    <div class="player-rating">Rating: 267</div>
                </div>
                <div class="player-avatar">⚫</div>
            </div>
        </div>
        
        <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
        <div class="checkers-board" id="checkersBoard"></div>
        
        <div class="game-controls">
            <button class="game-btn" onclick="resignCheckers()">
                <i class="fas fa-flag"></i> Resign
            </button>
            <button class="game-btn" onclick="requestUndo()">
                <i class="fas fa-undo"></i> Request Undo
            </button>
            <button class="game-btn" onclick="showMoveHistory()">
                <i class="fas fa-history"></i> Moves
            </button>
        </div>
        
        <div class="game-chat">
            <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">
                <i class="fas fa-comments"></i> Game Chat
            </h4>
            <div class="game-chat-messages" id="checkersGameChat">
                <div class="game-chat-message system">
                    <strong>System:</strong> Game started! Make your move!
                </div>
            </div>
            <div class="game-chat-input">
                <input type="text" placeholder="Type a message..." id="checkersChatInput" 
                       onkeypress="handleGameChatKeyPress(event, 'checkers')" maxlength="100">
                <button onclick="sendGameChatMessage('checkers')">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Word Game Window -->
<div class="game-window hidden" id="wordGameWindow">
    <div class="game-window-header">
        <div class="game-window-title">
            📝 Word Battle 
            <span class="skill-badge skill-bronze" id="wordSkillBadge">Bronze</span>
            <span class="validation-status validated" title="Server Validated">✓</span>
        </div>
        <div class="game-window-controls">
            <button class="window-btn minimize-btn" onclick="minimizeGame('word')" title="Minimize">−</button>
            <button class="window-btn close-btn" onclick="closeGame('word')" title="Close">×</button>
        </div>
    </div>
    <div class="game-window-content">
        <div class="game-info-bar">
            <div class="round-info">
                <div class="round-counter">Round <span id="currentRound">1</span> of 3</div>
                <div class="round-timer">Time: <span id="roundTimer">60</span>s</div>
            </div>
        </div>
        
        <div class="game-status" id="wordStatus">Round 1 of 3 - Your turn!</div>
        
        <div class="word-game">
            <h4 id="wordPrompt" class="word-prompt">Make a word with these letters:</h4>
            <div id="wordLetters" class="word-letters">BLOCKCHAIN</div>
            
            <div class="word-input-container">
                <input type="text" class="word-input" id="wordInput" 
                       placeholder="Enter your word..." maxlength="20" 
                       onkeypress="handleWordInputKeyPress(event)">
                <button class="submit-word-btn" onclick="submitWord()">
                    <i class="fas fa-check"></i> Submit
                </button>
            </div>
            
            <div class="word-validation" id="wordValidation">
                <div class="valid-words">
                    <h5>Valid words found:</h5>
                    <div id="validWordsDisplay"></div>
                </div>
            </div>
            
            <div class="word-score">
                <div class="score-item">
                    <div class="score-label">Your Score</div>
                    <div class="score-value" id="playerScore">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Opponent</div>
                    <div class="score-value" id="opponentScore">0</div>
                </div>
            </div>
            
            <div class="game-controls">
                <button class="game-btn" onclick="submitWord()">
                    <i class="fas fa-paper-plane"></i> Submit Word
                </button>
                <button class="game-btn secondary" onclick="skipRound()">
                    <i class="fas fa-forward"></i> Skip Round
                </button>
            </div>
        </div>
        
        <div class="game-chat">
            <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">
                <i class="fas fa-comments"></i> Game Chat
            </h4>
            <div class="game-chat-messages" id="wordGameChat">
                <div class="game-chat-message system">
                    <strong>System:</strong> Word battle begins! Show your vocabulary skills!
                </div>
            </div>
            <div class="game-chat-input">
                <input type="text" placeholder="Type a message..." id="wordChatInput" 
                       onkeypress="handleGameChatKeyPress(event, 'word')" maxlength="100">
                <button onclick="sendGameChatMessage('word')">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Move History Modal -->
<div class="modal hidden" id="moveHistoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h3><i class="fas fa-history"></i> Move History</h3>
            <button class="close-modal" onclick="closeMoveHistory()">×</button>
        </div>
        <div class="modal-body">
            <div id="moveHistoryList" class="move-history-list"></div>
        </div>
    </div>
</div>

<!-- Game Results Modal -->
<div class="modal hidden" id="gameResultsModal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="gameResultTitle">🏆 Game Complete!</h3>
        </div>
        <div class="modal-body">
            <div class="game-result-content">
                <div class="result-stats">
                    <div class="stat-item">
                        <div class="stat-label">Winner</div>
                        <div class="stat-value" id="gameWinner">You!</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Game Duration</div>
                        <div class="stat-value" id="gameDuration">5:32</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Moves Played</div>
                        <div class="stat-value" id="totalMoves">23</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Winnings</div>
                        <div class="stat-value" id="gameWinnings">0.97 CORE</div>
                    </div>
                </div>
                
                <div class="rating-change">
                    <div class="rating-item">
                        <div class="rating-label">Your Rating Change</div>
                        <div class="rating-value positive" id="ratingChange">+12</div>
                    </div>
                </div>
                
                <div class="result-actions">
                    <button class="game-btn" onclick="playAgain()">
                        <i class="fas fa-redo"></i> Play Again
                    </button>
                    <button class="game-btn secondary" onclick="closeGameResults()">
                        <i class="fas fa-home"></i> Back to Lobby
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* ===========================
   GAME WINDOW STYLES
   =========================== */

.game-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    z-index: 999;
    backdrop-filter: blur(2px);
}

.game-overlay.minimized {
    display: none;
}

.game-window {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 28, 44, 0.95));
    backdrop-filter: blur(15px);
    border: 2px solid var(--accent);
    border-radius: 15px;
    padding: 1.5rem;
    z-index: 1000;
    max-width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
    min-width: 600px;
    animation: slideInScale 0.3s ease-out;
}

@keyframes slideInScale {
    from {
        opacity: 0;
        transform: translate(-50%, -60%) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

.game-window.minimized {
    top: auto;
    bottom: 20px;
    right: 20px;
    left: auto;
    transform: none;
    width: 300px;
    height: 60px;
    overflow: hidden;
    cursor: pointer;
    z-index: 500;
    min-width: 280px;
    border-radius: 10px;
    animation: slideInRight 0.3s ease-out;
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
    }
    to {
        transform: translateX(0);
    }
}

.game-window-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--glass-border);
}

.game-window-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--accent);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.skill-badge {
    padding: 0.2rem 0.5rem;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: bold;
    text-transform: uppercase;
}

.skill-bronze { background: rgba(205, 127, 50, 0.3); color: #cd7f32; }
.skill-silver { background: rgba(192, 192, 192, 0.3); color: #c0c0c0; }
.skill-gold { background: rgba(255, 215, 0, 0.3); color: #ffd700; }
.skill-diamond { background: rgba(185, 242, 255, 0.3); color: #b9f2ff; }

.validation-status {
    display: inline-block;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    text-align: center;
    line-height: 20px;
    font-size: 0.7rem;
    font-weight: bold;
}

.validation-status.validated {
    background: rgba(46, 204, 113, 0.3);
    color: #2ecc71;
}

.validation-status.pending-validation {
    background: rgba(241, 196, 15, 0.3);
    color: #f1c40f;
}

.game-window-controls {
    display: flex;
    gap: 0.5rem;
}

.window-btn {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 6px;
    color: white;
    cursor: pointer;
    padding: 0.3rem 0.6rem;
    font-size: 0.9rem;
    font-weight: bold;
    transition: all 0.2s ease;
    min-width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.window-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
}

.minimize-btn {
    background: rgba(255, 193, 7, 0.3);
    border-color: rgba(255, 193, 7, 0.5);
}

.close-btn {
    background: rgba(220, 53, 69, 0.3);
    border-color: rgba(220, 53, 69, 0.5);
}

.game-window-content {
    display: block;
}

.game-window.minimized .game-window-content {
    display: none;
}

/* ===========================
   GAME INFO BAR
   =========================== */

.game-info-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--glass);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 1rem;
    border: 1px solid var(--glass-border);
}

.player-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.player-info.opponent {
    flex-direction: row-reverse;
}

.player-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    color: white;
}

.player-details {
    text-align: left;
}

.player-info.opponent .player-details {
    text-align: right;
}

.player-name {
    font-weight: bold;
    color: var(--accent);
    font-size: 0.9rem;
}

.player-rating {
    font-size: 0.8rem;
    color: #aaa;
}

.game-timer {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    align-items: center;
}

.timer {
    background: var(--dark);
    border: 2px solid var(--accent);
    border-radius: 8px;
    padding: 0.5rem 1rem;
    font-family: monospace;
    font-weight: bold;
    font-size: 1.1rem;
    color: var(--accent);
    min-width: 80px;
    text-align: center;
}

.timer.active {
    background: var(--accent);
    color: var(--dark);
    animation: pulse 1s infinite;
}

.timer.low-time {
    border-color: var(--danger);
    color: var(--danger);
    animation: blink 0.5s infinite;
}

.move-counter {
    text-align: center;
}

.move-count {
    font-weight: bold;
    color: var(--accent);
    margin-bottom: 0.5rem;
}

.captured-pieces {
    font-size: 0.8rem;
    color: #aaa;
}

.round-info {
    display: flex;
    gap: 2rem;
    align-items: center;
    justify-content: center;
    width: 100%;
}

.round-counter, .round-timer {
    text-align: center;
    font-weight: bold;
}

.round-counter {
    color: var(--accent);
    font-size: 1.1rem;
}

.round-timer {
    color: var(--warning);
}

/* ===========================
   GAME BOARDS
   =========================== */

.chess-board, .checkers-board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 3px solid var(--accent);
    border-radius: 10px;
    margin: 1rem auto;
    background: #f4f4f4;
    gap: 0;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
}

.chess-square, .checkers-square {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    border: none;
    user-select: none;
}

.chess-square.white, .checkers-square.light {
    background: #f0d9b5;
}

.chess-square.black, .checkers-square.dark {
    background: #b58863;
}

.chess-square:hover, .checkers-square:hover {
    box-shadow: inset 0 0 10px rgba(78, 205, 196, 0.3);
    z-index: 1;
}

.chess-square.selected {
    background: #ff6b6b !important;
    box-shadow: inset 0 0 15px rgba(255, 107, 107, 0.8);
    z-index: 2;
}

.chess-square.possible-move {
    background: rgba(78, 205, 196, 0.4) !important;
    position: relative;
}

.chess-square.possible-move::after {
    content: '●';
    color: var(--accent);
    position: absolute;
    font-size: 1rem;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}

.chess-square.last-move {
    background: rgba(255, 193, 7, 0.3) !important;
    box-shadow: inset 0 0 10px rgba(255, 193, 7, 0.5);
}

/* ===========================
   CHECKER PIECES
   =========================== */

.checker-piece {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    border: 2px solid #000;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    position: relative;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 1;
}

.checker-piece:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    z-index: 2;
}

.red-piece {
    background: radial-gradient(circle at 30% 30%, #ff6666, #cc0000);
    border-color: #aa0000;
}

.black-piece {
    background: radial-gradient(circle at 30% 30%, #666666, #000000);
    border-color: #333;
}

.checker-piece.king::after {
    content: '♔';
    position: absolute;
    font-size: 1.3rem;
    color: rgba(255, 215, 0, 0.9);
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

.checker-piece.selected {
    box-shadow: 0 0 15px rgba(78, 205, 196, 0.8);
    border-color: var(--accent);
    z-index: 3;
}

.checker-piece.can-move {
    animation: pulse 1s infinite;
}

/* ===========================
   WORD GAME COMPONENTS
   =========================== */

.word-game {
    text-align: center;
    padding: 1rem;
}

.word-prompt {
    color: var(--accent);
    margin-bottom: 1rem;
    font-size: 1.1rem;
}

.word-letters {
    font-size: 2.5rem;
    color: var(--secondary);
    font-weight: bold;
    margin: 1rem 0;
    letter-spacing: 0.2rem;
    text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
    animation: glow 2s infinite;
}

.word-input-container {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
    align-items: center;
    margin: 1.5rem 0;
}

.word-input {
    flex: 1;
    max-width: 300px;
    background: var(--glass);
    border: 2px solid var(--glass-border);
    border-radius: 10px;
    padding: 1rem;
    color: white;
    font-size: 1.2rem;
    text-align: center;
    font-weight: bold;
    transition: all 0.3s ease;
}

.word-input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 15px rgba(78, 205, 196, 0.3);
}

.submit-word-btn {
    background: linear-gradient(45deg, var(--success), #27ae60);
    border: none;
    padding: 1rem 1.5rem;
    border-radius: 10px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.submit-word-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
}

.word-validation {
    margin: 1rem 0;
    padding: 1rem;
    background: var(--glass);
    border-radius: 10px;
    border: 1px solid var(--glass-border);
}

.valid-words h5 {
    color: var(--accent);
    margin-bottom: 0.5rem;
}

.valid-words-display {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
}

.valid-word-tag {
    background: rgba(46, 204, 113, 0.2);
    border: 1px solid rgba(46, 204, 113, 0.4);
    color: #2ecc71;
    padding: 0.2rem 0.5rem;
    border-radius: 5px;
    font-size: 0.8rem;
    font-weight: bold;
}

.word-score {
    display: flex;
    justify-content: space-around;
    margin: 1.5rem 0;
    padding: 1rem;
    background: var(--glass);
    border-radius: 10px;
    border: 1px solid var(--glass-border);
}

.score-item {
    text-align: center;
}

.score-label {
    font-size: 0.9rem;
    color: #aaa;
    margin-bottom: 0.5rem;
}

.score-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--accent);
}

/* ===========================
   GAME STATUS & CONTROLS
   =========================== */

.game-status {
    text-align: center;
    font-size: 1.1rem;
    margin-bottom: 1rem;
    color: var(--accent);
    padding: 0.5rem;
    background: var(--glass);
    border-radius: 8px;
    border: 1px solid var(--glass-border);
    font-weight: bold;
}

.game-status.warning {
    color: var(--warning);
    border-color: rgba(241, 196, 15, 0.5);
}

.game-status.danger {
    color: var(--danger);
    border-color: rgba(231, 76, 60, 0.5);
    animation: pulse 1s infinite;
}

.game-controls {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin: 1.5rem 0;
    flex-wrap: wrap;
}

.game-btn.secondary {
    background: linear-gradient(45deg, var(--gray), #7f8c8d);
}

.game-btn.secondary:hover {
    box-shadow: 0 5px 15px rgba(149, 165, 166, 0.3);
}

.game-over-message {
    color: #00ff88;
    font-weight: bold;
    font-size: 1.2rem;
    animation: pulse 1.5s infinite;
    text-align: center;
    margin: 1rem 0;
}

/* ===========================
   GAME CHAT
   =========================== */

.game-chat {
    background: var(--glass);
    border-radius: 10px;
    padding: 1rem;
    margin-top: 1.5rem;
    border: 1px solid var(--glass-border);
    max-height: 200px;
    display: flex;
    flex-direction: column;
}

.game-chat h4 {
    margin-bottom: 0.5rem;
    color: var(--accent);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.game-chat-messages {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 0.5rem;
    max-height: 120px;
    background: rgba(0, 0, 0, 0.3);
    padding: 0.5rem;
    border-radius: 5px;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.5) transparent;
}

.game-chat-messages::-webkit-scrollbar {
    width: 4px;
}

.game-chat-messages::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
}

.game-chat-messages::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.5);
    border-radius: 2px;
}

.game-chat-message {
    margin-bottom: 0.3rem;
    font-size: 0.9rem;
    line-height: 1.4;
    animation: slideIn 0.3s ease-out;
}

.game-chat-message.system {
    color: var(--accent);
    font-style: italic;
}

.game-chat-message strong {
    color: var(--secondary);
}

.game-chat-input {
    display: flex;
    gap: 0.5rem;
}

.game-chat-input input {
    flex: 1;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 5px;
    padding: 0.5rem;
    color: white;
    font-size: 0.9rem;
}

.game-chat-input input:focus {
    outline: none;
    border-color: var(--accent);
}

.game-chat-input button {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
}

.game-chat-input button:hover {
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(78, 205, 196, 0.3);
}

/* ===========================
   MODALS
   =========================== */

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    backdrop-filter: blur(5px);
}

.modal .modal-content {
    background: linear-gradient(135deg, var(--dark), #2c3e50);
    border: 2px solid var(--accent);
    border-radius: 15px;
    padding: 2rem;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    animation: slideInScale 0.3s ease-out;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--glass-border);
}

.modal-header h3 {
    color: var(--accent);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.close-modal {
    background: none;
    border: none;
    color: #aaa;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.close-modal:hover {
    background: rgba(255, 255, 255, 0.1);
    color: white;
}

.move-history-list {
    max-height: 300px;
    overflow-y: auto;
}

.move-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem;
    margin: 0.25rem 0;
    background: var(--glass);
    border-radius: 5px;
    border: 1px solid var(--glass-border);
}

.move-number {
    font-weight: bold;
    color: var(--accent);
}

.move-notation {
    font-family: monospace;
    color: white;
}

.game-result-content {
    text-align: center;
}

.result-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 1.5rem 0;
}

.result-stats .stat-item {
    background: var(--glass);
    padding: 1rem;
    border-radius: 10px;
    border: 1px solid var(--glass-border);
}

.result-stats .stat-label {
    font-size: 0.9rem;
    color: #aaa;
    margin-bottom: 0.5rem;
}

.result-stats .stat-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--accent);
}

.rating-change {
    margin: 1.5rem 0;
    padding: 1rem;
    background: var(--glass);
    border-radius: 10px;
    border: 1px solid var(--glass-border);
}

.rating-label {
    font-size: 0.9rem;
    color: #aaa;
    margin-bottom: 0.5rem;
}

.rating-value {
    font-size: 1.5rem;
    font-weight: bold;
}

.rating-value.positive {
    color: var(--success);
}

.rating-value.negative {
    color: var(--danger);
}

.result-actions {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 2rem;
}

/* ===========================
   RESPONSIVE DESIGN
   =========================== */

@media (max-width: 768px) {
    .game-window {
        min-width: 95vw;
        max-width: 95vw;
        padding: 1rem;
        margin: 1rem;
    }

    .game-window.minimized {
        min-width: 250px;
        width: 250px;
    }

    .chess-board, .checkers-board {
        grid-template-columns: repeat(8, 35px);
        grid-template-rows: repeat(8, 35px);
        margin: 0.5rem auto;
    }

    .chess-square, .checkers-square {
        font-size: 1.2rem;
    }

    .checker-piece {
        width: 30px;
        height: 30px;
        font-size: 0.8rem;
    }

    .checker-piece.king::after {
        font-size: 1rem;
    }

    .game-info-bar {
        flex-direction: column;
        gap: 1rem;
    }

    .game-timer {
        flex-direction: row;
        gap: 1rem;
    }

    .word-letters {
        font-size: 1.8rem;
        letter-spacing: 0.1rem;
    }

    .word-input-container {
        flex-direction: column;
        gap: 1rem;
    }

    .word-input {
        max-width: 100%;
    }

    .game-controls {
        gap: 0.5rem;
    }

    .game-btn {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
    }

    .result-stats {
        grid-template-columns: 1fr;
        gap: 0.5rem;
    }

    .result-actions {
        flex-direction: column;
        gap: 0.5rem;
    }
}

@media (max-width: 480px) {
    .game-window {
        padding: 0.5rem;
    }

    .chess-board, .checkers-board {
        grid-template-columns: repeat(8, 30px);
        grid-template-rows: repeat(8, 30px);
    }

    .chess-square, .checkers-square {
        font-size: 1rem;
    }

    .checker-piece {
        width: 25px;
        height: 25px;
        font-size: 0.7rem;
    }

    .word-letters {
        font-size: 1.5rem;
    }

    .word-input {
        font-size: 1rem;
        padding: 0.8rem;
    }
}
</style>

<script>
/* ===========================
   GAME BOARD COMPONENT FUNCTIONS
   =========================== */

// Handle word input key press
function handleWordInputKeyPress(event) {
    if (event.key === 'Enter') {
        submitWord();
    }
}

// Show move history modal
function showMoveHistory() {
    const modal = document.getElementById('moveHistoryModal');
    const historyList = document.getElementById('moveHistoryList');
    
    if (modal && historyList) {
        // Clear previous history
        historyList.innerHTML = '';
        
        // Add move history (example)
        const moves = ['e2-e4', 'e7-e5', 'Ng1-f3', 'Nb8-c6', 'Bf1-c4'];
        moves.forEach((move, index) => {
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            moveItem.innerHTML = `
                <span class="move-number">${Math.floor(index / 2) + 1}${index % 2 === 0 ? '.' : '...'}</span>
                <span class="move-notation">${move}</span>
            `;
            historyList.appendChild(moveItem);
        });
        
        modal.classList.remove('hidden');
    }
}

// Close move history modal
function closeMoveHistory() {
    const modal = document.getElementById('moveHistoryModal');
    if (modal) {
        modal.classList.add('hidden');
    }
}

// Show game results modal
function showGameResults(winner, duration, moves, winnings, ratingChange) {
    const modal = document.getElementById('gameResultsModal');
    if (modal) {
        // Update content
        document.getElementById('gameWinner').textContent = winner;
        document.getElementById('gameDuration').textContent = duration;
        document.getElementById('totalMoves').textContent = moves;
        document.getElementById('gameWinnings').textContent = winnings;
        
        const ratingEl = document.getElementById('ratingChange');
        if (ratingEl) {
            ratingEl.textContent = ratingChange > 0 ? `+${ratingChange}` : ratingChange;
            ratingEl.className = `rating-value ${ratingChange > 0 ? 'positive' : 'negative'}`;
        }
        
        modal.classList.remove('hidden');
    }
}

// Close game results modal
function closeGameResults() {
    const modal = document.getElementById('gameResultsModal');
    if (modal) {
        modal.classList.add('hidden');
    }
}

// Play again function
function playAgain() {
    closeGameResults();
    // Logic to start a new game
    showTransactionStatus('🎮 Starting new game...', '');
}

// Update game timers
function updateGameTimer(gameType, whiteTime, blackTime, activePlayer) {
    if (gameType === 'chess') {
        const whiteTimer = document.getElementById('whiteTimer');
        const blackTimer = document.getElementById('blackTimer');
        
        if (whiteTimer && blackTimer) {
            whiteTimer.textContent = formatTime(whiteTime);
            blackTimer.textContent = formatTime(blackTime);
            
            // Update active timer styling
            whiteTimer.classList.toggle('active', activePlayer === 'white');
            blackTimer.classList.toggle('active', activePlayer === 'black');
            
            // Low time warning
            whiteTimer.classList.toggle('low-time', whiteTime < 60);
            blackTimer.classList.toggle('low-time', blackTime < 60);
        }
    }
}

// Format time in MM:SS format
function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// Update move counter for checkers
function updateMoveCounter(moveNumber) {
    const moveCountEl = document.getElementById('moveCount');
    if (moveCountEl) {
        moveCountEl.textContent = moveNumber;
    }
}

// Update captured pieces count
function updateCapturedPieces(redCaptured, blackCaptured) {
    const redEl = document.getElementById('redCaptured');
    const blackEl = document.getElementById('blackCaptured');
    
    if (redEl) redEl.textContent = redCaptured;
    if (blackEl) blackEl.textContent = blackCaptured;
}

// Update word game round
function updateWordGameRound(currentRound, timeLeft) {
    const roundEl = document.getElementById('currentRound');
    const timerEl = document.getElementById('roundTimer');
    
    if (roundEl) roundEl.textContent = currentRound;
    if (timerEl) {
        timerEl.textContent = timeLeft;
        timerEl.style.color = timeLeft <= 10 ? '#e74c3c' : '#f39c12';
    }
}

// Add valid word to display
function addValidWord(word, points) {
    const display = document.getElementById('validWordsDisplay');
    if (display) {
        const wordTag = document.createElement('span');
        wordTag.className = 'valid-word-tag';
        wordTag.textContent = `${word} (${points}pts)`;
        display.appendChild(wordTag);
    }
}

// Update word game scores
function updateWordScores(playerScore, opponentScore) {
    const playerEl = document.getElementById('playerScore');
    const opponentEl = document.getElementById('opponentScore');
    
    if (playerEl) playerEl.textContent = playerScore;
    if (opponentEl) opponentEl.textContent = opponentScore;
}

// Animate piece movement (for visual feedback)
function animatePieceMove(fromSquare, toSquare, piece) {
    // Create a temporary piece for animation
    const animPiece = document.createElement('div');
    animPiece.textContent = piece;
    animPiece.style.cssText = `
        position: absolute;
        font-size: 2rem;
        pointer-events: none;
        z-index: 1000;
        transition: all 0.3s ease;
    `;
    
    // Position at start
    const fromRect = fromSquare.getBoundingClientRect();
    animPiece.style.left = fromRect.left + 'px';
    animPiece.style.top = fromRect.top + 'px';
    
    document.body.appendChild(animPiece);
    
    // Animate to end position
    setTimeout(() => {
        const toRect = toSquare.getBoundingClientRect();
        animPiece.style.left = toRect.left + 'px';
        animPiece.style.top = toRect.top + 'px';
    }, 10);
    
    // Remove after animation
    setTimeout(() => {
        if (animPiece.parentNode) {
            animPiece.parentNode.removeChild(animPiece);
        }
    }, 300);
}

// Highlight possible moves
function highlightPossibleMoves(squares) {
    // Clear previous highlights
    document.querySelectorAll('.chess-square, .checkers-square').forEach(square => {
        square.classList.remove('possible-move');
    });
    
    // Add highlights to possible moves
    squares.forEach(square => {
        square.classList.add('possible-move');
    });
}

// Add game result notification
function addGameResultNotification(result, winnings) {
    const notification = document.createElement('div');
    notification.className = 'game-result-notification';
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(45deg, #2ecc71, #27ae60);
        color: white;
        padding: 2rem;
        border-radius: 15px;
        text-align: center;
        z-index: 3000;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        animation: slideInScale 0.5s ease-out;
    `;
    
    notification.innerHTML = `
        <h2>${result === 'win' ? '🎉 You Won!' : result === 'draw' ? '🤝 Draw!' : '😔 You Lost'}</h2>
        ${winnings > 0 ? `<p>Winnings: ${winnings.toFixed(4)} CORE</p>` : ''}
        <p>Click anywhere to continue</p>
    `;
    
    document.body.appendChild(notification);
    
    // Remove on click
    notification.onclick = () => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    };
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 5000);
}

// Validate game window positioning (ensure it's visible)
function validateGameWindowPosition(gameWindow) {
    if (!gameWindow || gameWindow.classList.contains('minimized')) return;
    
    const rect = gameWindow.getBoundingClientRect();
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    // Ensure window is within viewport
    if (rect.left < 0 || rect.top < 0 || rect.right > windowWidth || rect.bottom > windowHeight) {
        gameWindow.style.transform = 'translate(-50%, -50%)';
        gameWindow.style.top = '50%';
        gameWindow.style.left = '50%';
    }
}

// Handle window resize for game components
window.addEventListener('resize', () => {
    document.querySelectorAll('.game-window').forEach(validateGameWindowPosition);
});

console.log('✅ Game Board Components & Windows Loaded Successfully');
</script>
  <script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   CORE JAVASCRIPT - BLOCKCHAIN INTEGRATION & STATE MANAGEMENT
   =========================== */

// ===========================
// CONSTANTS & CONFIGURATION
// ===========================

const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = "0x45c"; // Core Blockchain Chain ID
const JSONBIN_API_KEY = '$2a$10$Ppx.2Z91xbnEF57ad1FmZOIkkmy.0QJbB8b1.IP561Z.px8smIRBe';
const JSONBIN_BIN_ID = '686ea4c0c264cf03d2e83902';
const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

// Smart Contract ABI
const GAME_CONTRACT_ABI = [
    "function createGame(string memory gameType, uint256 timeLimit) external payable returns (uint256)",
    "function joinGame(uint256 gameId) external payable",
    "function submitMove(uint256 gameId, bytes memory moveData) external",
    "function finalizeGame(uint256 gameId, address winner) external",
    "function claimWinnings(uint256 gameId) external",
    "function refundStake(uint256 gameId) external",
    "function createTournament(string memory name, uint256 entryFee, uint256 maxPlayers) external payable returns (uint256)",
    "function joinTournament(uint256 tournamentId) external payable",
    "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint256 status, string memory gameType)",
    "function getTotalGames() external view returns (uint256)",
    "function getPlayerGames(address player) external view returns (uint256[] memory)",
    "function owner() external view returns (address)",
    "function paused() external view returns (bool)",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint256 stake, string gameType)",
    "event GameJoined(uint256 indexed gameId, address indexed player)",
    "event GameFinalized(uint256 indexed gameId, address indexed winner, uint256 payout)",
    "event TournamentCreated(uint256 indexed tournamentId, address indexed creator, uint256 entryFee)",
    "event TournamentJoined(uint256 indexed tournamentId, address indexed player)"
];

// ===========================
// GLOBAL STATE VARIABLES
// ===========================

let web3Provider = null;
let userAccount = null;
let gameContract = null;
let currentBalance = 0;
let activeGames = [];
let globalGamesList = [];
let selectedGameType = null;
let gameUpdateInterval = null;
let multiplayerSession = null;
let gameRoomConnections = new Map();
let pendingMatches = new Map();

// Real-time sync variables
let lastSyncTimestamp = 0;
let syncInterval = null;
let isConnectedToLobby = false;

// Player stats and game state
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    winRate: 0
};

// Player skill ratings
let playerSkillRatings = {
    chess: 456,    // Gold level
    checkers: 234, // Silver level
    words: 89      // Bronze level
};

// Current settings
let currentSkillFilter = 'any';
let antiBotChallengeActive = false;
let captchaSelection = [];
let verifiableRandomness = {
    source: 'chainlink',
    lastSeed: null,
    commitHash: null
};

// Game state tracking
let isGameActive = false;
let activeGameType = null;
let gameIsMinimized = false;

// Platform settings with secure defaults
let platformSettings = {
    autoJoin: false,
    sound: true,
    animations: true,
    defaultStake: 0.1,
    gameInvites: true,
    txNotifications: true,
    chatNotifications: false,
    autoLock: true,
    sessionTimeout: 30,
    hideBalance: false,
    gasPriority: 'standard',
    rpcEndpoint: 'https://rpc.coredao.org',
    developerMode: false,
    serverValidation: true,
    antiBot: true,
    randomnessSource: 'chainlink'
};

// Current section tracking
let currentSection = 'lobby';

// ===========================
// ERROR HANDLING & LOGGING
// ===========================

class GameError extends Error {
    constructor(message, code = 'GAME_ERROR', details = {}) {
        super(message);
        this.name = 'GameError';
        this.code = code;
        this.details = details;
        this.timestamp = new Date().toISOString();
    }
}

function logError(error, context = '') {
    console.error(`[CrossRealm Error] ${context}:`, error);
    
    // In production, send to error tracking service
    if (platformSettings.developerMode) {
        console.trace();
    }
}

function handleAsyncError(promise, context = '') {
    return promise.catch(error => {
        logError(error, context);
        throw error;
    });
}

// ===========================
// BLOCKCHAIN INTEGRATION
// ===========================

async function initializeBlockchain() {
    try {
        updateConnectionProgress(20);
        
        if (typeof window.ethereum === 'undefined') {
            console.log('MetaMask not detected - continuing in demo mode');
            updateConnectionProgress(100);
            updateContractStatus('demo');
            await initializeMultiplayerSystem();
            return true;
        }

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        updateConnectionProgress(40);

        // Check network
        const network = await web3Provider.getNetwork();
        console.log('Current network:', network);
        
        updateConnectionProgress(60);
        
        if (network.chainId !== parseInt(CORE_CHAIN_ID, 16)) {
            console.log('Network mismatch - continuing in demo mode');
        }
        
        updateConnectionProgress(80);
        
        // Initialize contract (read-only for now)
        gameContract = new ethers.Contract(
            GAME_CONTRACT_ADDRESS, 
            GAME_CONTRACT_ABI, 
            web3Provider
        );
        
        updateConnectionProgress(100);
        updateContractStatus('connected');
        
        await initializeMultiplayerSystem();
        
        return true;
    } catch (error) {
        logError(error, 'Blockchain initialization');
        updateContractStatus('demo', 'Running in demo mode');
        await initializeMultiplayerSystem();
        return true; // Continue in demo mode
    }
}

async function switchToCore() {
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: CORE_CHAIN_ID }],
        });
    } catch (switchError) {
        if (switchError.code === 4902) {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: CORE_CHAIN_ID,
                        chainName: 'Core Blockchain',
                        nativeCurrency: {
                            name: 'CORE',
                            symbol: 'CORE',
                            decimals: 18
                        },
                        rpcUrls: ['https://rpc.coredao.org'],
                        blockExplorerUrls: ['https://scan.coredao.org']
                    }],
                });
            } catch (addError) {
                throw new GameError('Failed to add Core network', 'NETWORK_ADD_FAILED', { addError });
            }
        } else {
            throw switchError;
        }
    }
}

async function connectWallet() {
    try {
        showTransactionStatus('🔄 Connecting wallet...', '');
        
        if (typeof window.ethereum === 'undefined') {
            // Demo mode for users without MetaMask
            userAccount = '0x' + Math.random().toString(16).slice(2, 42);
            currentBalance = 10.0; // Demo balance
            
            updateConnectionStatus('connected');
            updateBalanceDisplay();
            updateWalletButtons(true);
            
            showTransactionStatus('✅ Demo wallet connected!', '');
            await loadUserData();
            await refreshLobby();
            startRealTimeUpdates();
            return;
        }

        if (!await initializeBlockchain()) {
            throw new GameError('Failed to initialize blockchain', 'BLOCKCHAIN_INIT_FAILED');
        }

        const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
        });
        
        if (accounts.length === 0) {
            throw new GameError('No accounts found', 'NO_ACCOUNTS');
        }

        userAccount = accounts[0];
        
        // Get signer for contract interactions
        const signer = web3Provider.getSigner();
        if (gameContract) {
            gameContract = gameContract.connect(signer);
        }
        
        // Get balance
        const balance = await web3Provider.getBalance(userAccount);
        currentBalance = parseFloat(ethers.utils.formatEther(balance));
        
        // Update UI
        updateConnectionStatus('connected');
        updateBalanceDisplay();
        updateWalletButtons(true);
        
        showTransactionStatus('✅ Wallet connected successfully!', '');
        
        // Load user data and start updates
        await loadUserData();
        await refreshLobby();
        startRealTimeUpdates();
        
        // Listen for account changes
        if (window.ethereum.on) {
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
        }
        
        // Save connection state
        try {
            sessionStorage.setItem('walletConnected', 'true');
        } catch (e) {
            console.log('Session storage not available');
        }
        
    } catch (error) {
        logError(error, 'Wallet connection');
        showTransactionStatus('❌ Failed to connect wallet: ' + error.message, '');
        updateConnectionStatus('disconnected');
        throw error;
    }
}

function disconnectWallet() {
    try {
        userAccount = null;
        currentBalance = 0;
        gameContract = null;
        
        updateConnectionStatus('disconnected');
        updateBalanceDisplay();
        updateWalletButtons(false);
        
        // Clear intervals
        if (gameUpdateInterval) {
            clearInterval(gameUpdateInterval);
            gameUpdateInterval = null;
        }
        
        if (syncInterval) {
            clearInterval(syncInterval);
            syncInterval = null;
        }
        
        // Clear session
        try {
            sessionStorage.removeItem('walletConnected');
        } catch (e) {
            console.log('Session storage not available');
        }
        
        showTransactionStatus('👋 Wallet disconnected', '');
    } catch (error) {
        logError(error, 'Wallet disconnection');
    }
}

function handleAccountsChanged(accounts) {
    if (accounts.length === 0) {
        disconnectWallet();
    } else if (accounts[0] !== userAccount) {
        userAccount = accounts[0];
        connectWallet();
    }
}

function handleChainChanged(chainId) {
    if (chainId !== CORE_CHAIN_ID) {
        showTransactionStatus('⚠️ Please switch to Core network', '');
        updateConnectionStatus('disconnected');
    } else {
        updateConnectionStatus('connected');
    }
}

// ===========================
// REAL-TIME MULTIPLAYER SYSTEM
// ===========================

async function initializeMultiplayerSystem() {
    console.log('🚀 Initializing Real-Time Multiplayer System...');
    
    try {
        // Start real-time sync
        await syncGlobalGamesList();
        
        // Set up periodic sync every 5 seconds
        if (syncInterval) clearInterval(syncInterval);
        syncInterval = setInterval(async () => {
            try {
                await syncGlobalGamesList();
            } catch (error) {
                logError(error, 'Periodic sync');
            }
        }, 5000);
        
        // Initialize with demo games if none exist
        if (globalGamesList.length === 0) {
            globalGamesList = [
                {
                    id: Date.now() - 300000,
                    type: 'chess',
                    creator: 'DemoPlayer1',
                    stake: 0.05,
                    status: 'waiting',
                    createdAt: Date.now() - 300000,
                    skillLevel: 'gold',
                    timeControl: 'rapid',
                    serverValidated: true,
                    isDemo: true
                }
            ];
        }
        
        console.log('✅ Real-Time Multiplayer System Initialized');
        
    } catch (error) {
        logError(error, 'Multiplayer system initialization');
        
        // Fallback to offline mode
        globalGamesList = [
            {
                id: Date.now(),
                type: 'chess',
                creator: 'OfflineDemo',
                stake: 0.01,
                status: 'waiting',
                createdAt: Date.now(),
                skillLevel: 'bronze',
                timeControl: 'rapid',
                serverValidated: false,
                isDemo: true
            }
        ];
    }
}

async function syncGlobalGamesList() {
    try {
        const response = await fetch(JSONBIN_URL, {
            method: 'GET',
            headers: {
                'X-Master-Key': JSONBIN_API_KEY,
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (data.record && data.record.games) {
                const serverGames = data.record.games;
                
                // Merge server games with local games intelligently
                const mergedGames = [...serverGames];
                
                // Add local games that aren't on server yet
                globalGamesList.forEach(localGame => {
                    if (!serverGames.find(serverGame => serverGame.id === localGame.id)) {
                        mergedGames.push(localGame);
                    }
                });
                
                globalGamesList = mergedGames;
                lastSyncTimestamp = Date.now();
                isConnectedToLobby = true;
                
                // Update display if on lobby
                if (currentSection === 'lobby') {
                    updateGamesDisplay();
                }
                
                console.log('✅ Games synced:', globalGamesList.length);
            }
        }
    } catch (error) {
        logError(error, 'Games list sync');
        isConnectedToLobby = false;
    }
}

async function pushGameToServer(game) {
    try {
        // First, get current games
        await syncGlobalGamesList();
        
        // Add new game if it doesn't exist
        if (!globalGamesList.find(g => g.id === game.id)) {
            globalGamesList.push(game);
        }
        
        // Push to server
        const response = await fetch(JSONBIN_URL, {
            method: 'PUT',
            headers: {
                'X-Master-Key': JSONBIN_API_KEY,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                games: globalGamesList,
                lastUpdated: Date.now()
            })
        });
        
        if (response.ok) {
            console.log('✅ Game pushed to server successfully');
            broadcastGameUpdate();
        } else {
            throw new GameError('Failed to push game to server', 'SERVER_PUSH_FAILED');
        }
    } catch (error) {
        logError(error, 'Game server push');
        throw error;
    }
}

async function removeGameFromServer(gameId) {
    try {
        await syncGlobalGamesList();
        globalGamesList = globalGamesList.filter(game => game.id !== gameId);
        
        const response = await fetch(JSONBIN_URL, {
            method: 'PUT',
            headers: {
                'X-Master-Key': JSONBIN_API_KEY,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                games: globalGamesList,
                lastUpdated: Date.now()
            })
        });
        
        if (response.ok) {
            console.log('✅ Game removed from server successfully');
            broadcastGameUpdate();
        } else {
            throw new GameError('Failed to remove game from server', 'SERVER_REMOVE_FAILED');
        }
    } catch (error) {
        logError(error, 'Game server removal');
        throw error;
    }
}

function broadcastGameUpdate() {
    // In a real implementation, this would use WebSockets or Server-Sent Events
    setTimeout(() => {
        if (currentSection === 'lobby') {
            updateGamesDisplay();
        }
    }, 1000);
}

// ===========================
// GAME STATE MANAGEMENT
// ===========================

function setGameActive(gameType, active) {
    isGameActive = active;
    activeGameType = active ? gameType : null;
    
    // Update navigation state
    const navItems = document.querySelectorAll('.nav-item');
    navItems.forEach(item => {
        if (active && !gameIsMinimized) {
            item.classList.add('disabled');
        } else if (active && gameIsMinimized) {
            item.classList.remove('disabled');
            item.classList.add('game-minimized');
        } else {
            item.classList.remove('disabled', 'game-minimized');
        }
    });
    
    // Update status message
    if (active && !gameIsMinimized) {
        showTransactionStatus(`🎮 Game active: ${gameType}. Navigation locked.`, '');
    } else if (active && gameIsMinimized) {
        showTransactionStatus(`🎮 Game minimized: ${gameType}. Navigation available.`, '');
    } else {
        showTransactionStatus('✅ Navigation unlocked', '');
    }
}

function getPlayerSkillLevel(gameType) {
    const rating = playerSkillRatings[gameType] || 0;
    
    if (rating < 100) return 'bronze';
    if (rating < 300) return 'silver';
    if (rating < 600) return 'gold';
    return 'diamond';
}

function shouldShowGame(game) {
    if (currentSkillFilter === 'any') return true;
    return game.skillLevel === currentSkillFilter;
}

// ===========================
// UI UPDATE FUNCTIONS
// ===========================

function updateConnectionProgress(progress) {
    const progressBar = document.getElementById('connectionProgress');
    if (progressBar) {
        progressBar.style.width = progress + '%';
    }
}

function updateContractStatus(status, message = '') {
    const statusElement = document.getElementById('contractStatus');
    if (statusElement) {
        if (status === 'connected') {
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected to Core Blockchain';
        } else if (status === 'demo') {
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>' + (message || 'Demo Mode');
        } else {
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Disconnected';
        }
    }
}

function updateConnectionStatus(status) {
    const statusElement = document.getElementById('connectionStatus');
    if (statusElement) {
        if (status === 'connected') {
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected';
        } else {
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Not Connected';
        }
    }
}

function updateBalanceDisplay() {
    const balanceEl = document.getElementById('balanceDisplay');
    if (balanceEl) {
        if (platformSettings.hideBalance && userAccount) {
            balanceEl.textContent = '••••• CORE';
        } else {
            balanceEl.textContent = currentBalance.toFixed(4) + ' CORE';
        }
    }
}

function updateWalletButtons(connected) {
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    if (connectBtn && disconnectBtn) {
        if (connected) {
            connectBtn.classList.add('hidden');
            disconnectBtn.classList.remove('hidden');
        } else {
            connectBtn.classList.remove('hidden');
            disconnectBtn.classList.add('hidden');
        }
    }
}

function showTransactionStatus(message, txHash = '') {
    const statusElement = document.getElementById('transactionStatus');
    const messageElement = document.getElementById('txStatusMessage');
    const hashElement = document.getElementById('txHash');
    
    if (statusElement && messageElement) {
        messageElement.textContent = message;
        
        if (hashElement && txHash) {
            hashElement.textContent = txHash;
            hashElement.style.display = 'block';
        } else if (hashElement) {
            hashElement.style.display = 'none';
        }
        
        statusElement.classList.add('show');
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            statusElement.classList.remove('show');
        }, 5000);
    }
}

function updateLiveStats() {
    try {
        const totalGames = globalGamesList.length;
        const totalVolume = globalGamesList.reduce((sum, game) => sum + (game.stake || 0), 0);
        const onlinePlayers = totalGames > 0 ? 
            totalGames + Math.floor(Math.random() * 20) + 10 : 
            Math.floor(Math.random() * 50) + 5;
        
        const totalPlayersEl = document.getElementById('totalPlayers');
        const totalGamesEl = document.getElementById('totalGames');
        const totalVolumeEl = document.getElementById('totalVolume');
        
        if (totalPlayersEl) totalPlayersEl.textContent = onlinePlayers;
        if (totalGamesEl) totalGamesEl.textContent = totalGames;
        if (totalVolumeEl) totalVolumeEl.textContent = totalVolume.toFixed(2);
    } catch (error) {
        logError(error, 'Live stats update');
    }
}

function updatePlayerStats() {
    try {
        const gamesPlayedEl = document.getElementById('profileGamesPlayed');
        const gamesWonEl = document.getElementById('profileGamesWon');
        const totalEarnedEl = document.getElementById('profileTotalEarned');
        const winRateEl = document.getElementById('profileWinRate');
        
        if (gamesPlayedEl) gamesPlayedEl.textContent = playerStats.gamesPlayed;
        if (gamesWonEl) gamesWonEl.textContent = playerStats.gamesWon;
        if (totalEarnedEl) totalEarnedEl.textContent = playerStats.totalEarned.toFixed(4);
        if (winRateEl) {
            const winRate = playerStats.gamesPlayed > 0 
                ? ((playerStats.gamesWon / playerStats.gamesPlayed) * 100).toFixed(1) 
                : 0;
            winRateEl.textContent = winRate + '%';
        }
    } catch (error) {
        logError(error, 'Player stats update');
    }
}

function addActivityFeedItem(message) {
    try {
        const feed = document.getElementById('activityFeed');
        if (feed) {
            const item = document.createElement('div');
            item.style.cssText = 'padding: 0.5rem; margin: 0.25rem 0; background: rgba(78, 205, 196, 0.1); border-radius: 5px; font-size: 0.9rem; animation: slideIn 0.3s ease-out;';
            item.textContent = message;
            feed.insertBefore(item, feed.firstChild);
            
            // Keep only last 5 items
            while (feed.children.length > 5) {
                feed.removeChild(feed.lastChild);
            }
        }
    } catch (error) {
        logError(error, 'Activity feed update');
    }
}

// ===========================
// DATA PERSISTENCE
// ===========================

async function loadUserData() {
    try {
        if (userAccount) {
            const savedData = localStorage.getItem('crossrealm_user_' + userAccount);
            if (savedData) {
                const data = JSON.parse(savedData);
                playerStats = { ...playerStats, ...(data.playerStats || {}) };
                playerSkillRatings = { ...playerSkillRatings, ...(data.playerSkillRatings || {}) };
            }
        }
    } catch (error) {
        logError(error, 'Loading user data');
    }
}

function saveUserData() {
    try {
        if (userAccount) {
            const data = {
                playerStats,
                playerSkillRatings,
                lastSaved: Date.now()
            };
            localStorage.setItem('crossrealm_user_' + userAccount, JSON.stringify(data));
        }
    } catch (error) {
        logError(error, 'Saving user data');
    }
}

function loadSettings() {
    try {
        const savedSettings = localStorage.getItem('crossrealm_settings');
        if (savedSettings) {
            platformSettings = { ...platformSettings, ...JSON.parse(savedSettings) };
        }
        
        // Apply loaded settings
        Object.keys(platformSettings).forEach(key => {
            applySetting(key, platformSettings[key]);
        });
        
    } catch (error) {
        logError(error, 'Loading settings');
    }
}

function saveSettings() {
    try {
        localStorage.setItem('crossrealm_settings', JSON.stringify(platformSettings));
        showTransactionStatus('✅ Settings saved successfully', '');
    } catch (error) {
        logError(error, 'Saving settings');
        showTransactionStatus('⚠️ Settings could not be saved', '');
    }
}

function applySetting(setting, value) {
    try {
        switch(setting) {
            case 'hideBalance':
                updateBalanceDisplay();
                break;
            case 'serverValidation':
                showTransactionStatus(
                    value ? '✅ Server validation enabled' : '⚠️ Client-only validation', 
                    ''
                );
                break;
            case 'antiBot':
                showTransactionStatus(
                    value ? '🛡️ Anti-bot protection enabled' : '⚠️ Anti-bot protection disabled', 
                    ''
                );
                break;
            case 'animations':
                if (!value) {
                    // Disable animations
                    document.documentElement.style.setProperty('--animation-duration', '0ms');
                } else {
                    document.documentElement.style.removeProperty('--animation-duration');
                }
                break;
        }
    } catch (error) {
        logError(error, `Applying setting: ${setting}`);
    }
}

// ===========================
// UTILITY FUNCTIONS
// ===========================

function startRealTimeUpdates() {
    try {
        if (gameUpdateInterval) {
            clearInterval(gameUpdateInterval);
        }
        
        gameUpdateInterval = setInterval(() => {
            try {
                updateLiveStats();
                if (currentSection === 'lobby') {
                    updateGamesDisplay();
                }
            } catch (error) {
                logError(error, 'Real-time updates');
            }
        }, 5000);
    } catch (error) {
        logError(error, 'Starting real-time updates');
    }
}

function validateStakeAndWallet(stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return false;
    }
    
    if (!stakeAmount || stakeAmount < 0.01) {
        showTransactionStatus('❌ Please enter a valid stake amount (minimum 0.01 CORE)', '');
        return false;
    }
    
    if (stakeAmount > currentBalance) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return false;
    }
    
    return true;
}

async function refreshLobby() {
    try {
        console.log('Refreshing lobby...');
        
        // Sync with server first
        await syncGlobalGamesList();
        
        // Update UI components
        updateGamesDisplay();
        updateLiveStats();
        
        console.log('Lobby refreshed successfully');
        
    } catch (error) {
        logError(error, 'Lobby refresh');
        // Don't show error to user since lobby can still work offline
    }
}

function copyContractAddress() {
    const address = GAME_CONTRACT_ADDRESS;
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(address).then(() => {
            showTransactionStatus('✅ Contract address copied to clipboard!', '');
        }).catch(err => {
            logError(err, 'Clipboard copy');
            fallbackCopyText(address);
        });
    } else {
        fallbackCopyText(address);
    }
}

function fallbackCopyText(text) {
    try {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        textArea.style.top = '-9999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                showTransactionStatus('✅ Contract address copied to clipboard!', '');
            } else {
                showTransactionStatus('❌ Failed to copy address', '');
            }
        } catch (err) {
            logError(err, 'Fallback copy');
            showTransactionStatus('❌ Failed to copy address', '');
        }
        
        document.body.removeChild(textArea);
    } catch (error) {
        logError(error, 'Fallback copy text');
        showTransactionStatus('❌ Failed to copy address', '');
    }
}

// ===========================
// AGE VERIFICATION SYSTEM
// ===========================

function verifyAge(isAdult) {
    try {
        if (isAdult) {
            const modal = document.getElementById('ageVerificationModal');
            if (modal) modal.style.display = 'none';
            
            try {
                sessionStorage.setItem('ageVerified', 'true');
            } catch (error) {
                console.log('Failed to save age verification:', error);
            }
            
            showTransactionStatus('✅ Age verified. Welcome to CrossRealm!', '');
            initializeBlockchain();
        } else {
            alert('Sorry, you must be 18 or older to use this platform.');
            window.location.href = 'https://www.google.com';
        }
    } catch (error) {
        logError(error, 'Age verification');
    }
}

function checkAgeVerification() {
    try {
        if (!sessionStorage.getItem('ageVerified')) {
            const modal = document.getElementById('ageVerificationModal');
            if (modal) modal.style.display = 'flex';
            return false;
        }
    } catch (error) {
        console.log('Failed to check age verification:', error);
    }
    return true;
}

// ===========================
// PERFORMANCE MONITORING
// ===========================

function measurePerformance(name, fn) {
    const start = performance.now();
    try {
        const result = fn();
        const end = performance.now();
        console.log(`[Performance] ${name}: ${(end - start).toFixed(2)}ms`);
        return result;
    } catch (error) {
        const end = performance.now();
        console.log(`[Performance] ${name} (error): ${(end - start).toFixed(2)}ms`);
        throw error;
    }
}

async function measureAsyncPerformance(name, fn) {
    const start = performance.now();
    try {
        const result = await fn();
        const end = performance.now();
        console.log(`[Performance] ${name}: ${(end - start).toFixed(2)}ms`);
        return result;
    } catch (error) {
        const end = performance.now();
        console.log(`[Performance] ${name} (error): ${(end - start).toFixed(2)}ms`);
        throw error;
    }
}

// ===========================
// INITIALIZATION
// ===========================

async function initializePlatform() {
    console.log('🚀 Initializing Enhanced CrossRealm Gaming Platform...');
    
    try {
        // Check age verification first
        if (!checkAgeVerification()) {
            return;
        }
        
        // Load settings
        loadSettings();
        
        // Initialize blockchain
        await measureAsyncPerformance('Blockchain Init', () => initializeBlockchain());
        
        // Auto-connect if previously connected
        try {
            if (sessionStorage.getItem('walletConnected') === 'true') {
                setTimeout(async () => {
                    try {
                        await connectWallet();
                    } catch (error) {
                        logError(error, 'Auto-connect');
                        try {
                            sessionStorage.removeItem('walletConnected');
                        } catch (e) {
                            console.log('Failed to clear session:', e);
                        }
                    }
                }, 1000);
            }
        } catch (error) {
            console.log('Session storage not available:', error);
        }
        
        // Initial data load
        await refreshLobby();
        
        // Add initial activity items
        addActivityFeedItem('🚀 Platform initialized successfully');
        addActivityFeedItem('🔗 Connected to Real-Time Multiplayer');
        addActivityFeedItem('🎮 Ready for gaming!');
        addActivityFeedItem('🛡️ Anti-bot protection active');
        addActivityFeedItem('⚡ Server validation enabled');
        
        console.log('✅ Enhanced platform initialization complete!');
        
    } catch (error) {
        logError(error, 'Platform initialization');
        showTransactionStatus('❌ Platform initialization failed: ' + error.message, '');
    }
}

// ===========================
// EVENT LISTENERS
// ===========================

// Window events
window.addEventListener('beforeunload', () => {
    try {
        saveUserData();
        saveSettings();
        
        if (userAccount) {
            try {
                sessionStorage.setItem('walletConnected', 'true');
            } catch (error) {
                console.log('Session storage not available:', error);
            }
        } else {
            try {
                sessionStorage.removeItem('walletConnected');
            } catch (error) {
                console.log('Session storage not available:', error);
            }
        }
    } catch (error) {
        logError(error, 'Window beforeunload');
    }
});

// Handle visibility change for performance optimization
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Page is hidden, reduce update frequency
        if (syncInterval) {
            clearInterval(syncInterval);
        }
    } else {
        // Page is visible, resume normal updates
        if (isConnectedToLobby) {
            syncInterval = setInterval(async () => {
                try {
                    await syncGlobalGamesList();
                } catch (error) {
                    logError(error, 'Visibility change sync');
                }
            }, 5000);
        }
    }
});

// Performance monitoring
if (typeof PerformanceObserver !== 'undefined') {
    try {
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.duration > 100) { // Log slow operations
                    console.log(`[Performance Warning] ${entry.name}: ${entry.duration.toFixed(2)}ms`);
                }
            }
        });
        observer.observe({ entryTypes: ['measure'] });
    } catch (error) {
        console.log('Performance observer not available');
    }
}

console.log('✅ Core JavaScript - Blockchain Integration & State Management Loaded Successfully');
</script>
  <script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   GAME LOGIC & REAL-TIME MULTIPLAYER SYSTEM
   =========================== */

// ===========================
// GAME STATE OBJECTS
// ===========================

// Enhanced Chess Game State
let chessGameState = {
    board: null,
    currentPlayer: 'white',
    selectedSquare: null,
    gameActive: false,
    moveHistory: [],
    lastMove: null,
    isCheck: false,
    isCheckmate: false,
    castlingRights: {
        whiteKingside: true,
        whiteQueenside: true,
        blackKingside: true,
        blackQueenside: true
    },
    enPassantTarget: null,
    halfMoveClock: 0,
    fullMoveNumber: 1
};

// Enhanced Checkers Game State  
let checkersGameState = {
    board: null,
    currentPlayer: 'red',
    selectedSquare: null,
    gameActive: false,
    moveHistory: [],
    mandatoryJumps: [],
    capturedPieces: { red: 0, black: 0 },
    moveCount: 1,
    isMultiJump: false,
    multiJumpPiece: null
};

// Word Game State
let wordGameState = {
    currentRound: 1,
    totalRounds: 3,
    timeLeft: 60,
    availableLetters: 'BLOCKCHAIN',
    validWords: [],
    playerScore: 0,
    opponentScore: 0,
    gameActive: false,
    timer: null
};

// Tournament System
let activeTournaments = [
    {
        id: 'chess_weekly',
        name: 'Weekly Chess Championship',
        gameType: 'chess',
        entryFee: 2.0,
        prizePool: 50,
        maxPlayers: 32,
        currentPlayers: 16,
        format: 'Single Elimination',
        status: 'registering',
        startTime: Date.now() + (2 * 60 * 60 * 1000),
        participants: []
    },
    {
        id: 'checkers_blitz',
        name: 'Speed Checkers Blitz',
        gameType: 'checkers',
        entryFee: 1.0,
        prizePool: 25,
        maxPlayers: 16,
        currentPlayers: 8,
        format: 'Swiss System',
        status: 'registering',
        startTime: Date.now() + (1 * 60 * 60 * 1000),
        participants: []
    },
    {
        id: 'word_masters',
        name: 'Word Masters Cup',
        gameType: 'words',
        entryFee: 0.5,
        prizePool: 15,
        maxPlayers: 24,
        currentPlayers: 12,
        format: '5 Rounds',
        status: 'registering',
        startTime: Date.now() + (45 * 60 * 1000),
        participants: []
    }
];

// ===========================
// GAME CREATION & JOINING
// ===========================

async function createGameOnChain(gameType, stakeAmount) {
    if (!userAccount) {
        throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
    }

    // Show anti-bot challenge before creating game
    if (platformSettings.antiBot) {
        const antiBotPassed = await showAntiBotChallenge();
        if (!antiBotPassed) {
            throw new GameError('Anti-bot verification failed', 'ANTIBOT_FAILED');
        }
    }
    
    try {
        showTransactionStatus('🔄 Creating game...', '');
        
        const gameId = Date.now();
        
        // Simulate blockchain transaction
        await new Promise(resolve => setTimeout(resolve, 1500));
        showTransactionStatus('✅ Game created successfully!', '');
        
        // Get player skill and settings
        const playerSkill = getPlayerSkillLevel(gameType);
        const timeControlEl = document.getElementById('timeControl');
        const serverValidationEl = document.getElementById('serverValidation');
        const timeControl = timeControlEl ? timeControlEl.value : 'rapid';
        const serverValidation = serverValidationEl ? serverValidationEl.value !== 'off' : true;
        
        const newGlobalGame = {
            id: gameId,
            type: gameType,
            creator: userAccount,
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now(),
            skillLevel: playerSkill,
            timeControl: timeControl,
            serverValidated: serverValidation,
            isDemo: false
        };
        
        // Push to server for real-time sharing
        await pushGameToServer(newGlobalGame);
        
        return gameId;
        
    } catch (error) {
        logError(error, 'Game creation');
        throw new GameError('Failed to create game: ' + error.message, 'GAME_CREATION_FAILED');
    }
}

async function joinGame(gameId, stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stakeAmount) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }
    
    try {
        showTransactionStatus('🔄 Joining game...', '');
        
        // Find game in global list
        const gameData = globalGamesList.find(game => game.id === gameId);
        if (!gameData) {
            showTransactionStatus('❌ Game not found', '');
            return;
        }
        
        if (gameData.status !== 'waiting') {
            showTransactionStatus('❌ Game is not available for joining', '');
            return;
        }
        
        if (gameData.creator === userAccount) {
            showTransactionStatus('❌ Cannot join your own game', '');
            return;
        }
        
        // Update balance
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        // Update game status and sync to server
        gameData.status = 'playing';
        gameData.player2 = userAccount;
        await pushGameToServer(gameData);
        
        // Start the game
        await startMultiplayerGame(gameData);
        
        // Refresh lobby
        await refreshLobby();
        
        addActivityFeedItem(`⚔️ You joined game #${gameId} with ${stakeAmount} CORE stake`);
        showTransactionStatus('🎮 Game joined! Good luck!', '');
        
    } catch (error) {
        logError(error, 'Game joining');
        showTransactionStatus('❌ Failed to join game: ' + error.message, '');
    }
}

async function startMultiplayerGame(gameData) {
    try {
        // Open the appropriate game window
        openGameWindow(gameData.type);
        
        // Initialize game state based on type
        switch(gameData.type) {
            case 'chess':
                initializeChessGame();
                break;
            case 'checkers':
                initializeCheckersGame();
                break;
            case 'words':
                initializeWordGame();
                break;
        }
        
        // Start game simulation (in real implementation, this would be multiplayer)
        setTimeout(() => {
            simulateGameCompletion(gameData);
        }, 10000); // 10 seconds for demo
        
    } catch (error) {
        logError(error, 'Starting multiplayer game');
        throw error;
    }
}

function simulateGameCompletion(gameData) {
    try {
        const winner = Math.random() > 0.5 ? userAccount : 'AI_OPPONENT';
        const totalPot = gameData.stake * 2;
        
        showTransactionStatus(`🎮 Game completed!`, '');
        
        setTimeout(() => {
            settleGame(gameData.id, winner, totalPot);
        }, 2000);
    } catch (error) {
        logError(error, 'Game simulation');
    }
}

// ===========================
// CHESS GAME LOGIC
// ===========================

function initializeChessGame() {
    try {
        const board = document.getElementById('chessBoard');
        if (!board) return;
        
        board.innerHTML = '';
        
        // Initial chess position
        const initialPosition = [
            ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
            ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
            ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
        ];
        
        chessGameState = {
            board: JSON.parse(JSON.stringify(initialPosition)),
            currentPlayer: 'white',
            selectedSquare: null,
            gameActive: true,
            moveHistory: [],
            lastMove: null,
            isCheck: false,
            isCheckmate: false,
            castlingRights: {
                whiteKingside: true,
                whiteQueenside: true,
                blackKingside: true,
                blackQueenside: true
            },
            enPassantTarget: null,
            halfMoveClock: 0,
            fullMoveNumber: 1
        };
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                square.dataset.row = row;
                square.dataset.col = col;
                square.textContent = initialPosition[row][col];
                square.onclick = () => handleChessSquareClick(row, col);
                
                square.onmouseenter = () => {
                    if (chessGameState.gameActive) {
                        square.style.boxShadow = 'inset 0 0 10px rgba(78, 205, 196, 0.3)';
                    }
                };
                square.onmouseleave = () => {
                    if (!square.classList.contains('selected')) {
                        square.style.boxShadow = '';
                    }
                };
                
                board.appendChild(square);
            }
        }
        
        updateChessStatus();
        console.log('✅ Chess game initialized');
    } catch (error) {
        logError(error, 'Chess initialization');
    }
}

function handleChessSquareClick(row, col) {
    if (!chessGameState.gameActive) return;
    
    try {
        const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (!square) return;
        
        const piece = chessGameState.board[row][col];
        
        // Clear previous selections and highlights
        document.querySelectorAll('.chess-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
            s.style.boxShadow = '';
        });
        
        if (chessGameState.selectedSquare) {
            const selectedRow = chessGameState.selectedSquare.row;
            const selectedCol = chessGameState.selectedSquare.col;
            const selectedPiece = chessGameState.board[selectedRow][selectedCol];
            
            // Check if this is a valid move
            if (isValidChessMove(selectedRow, selectedCol, row, col)) {
                makeChessMove(selectedRow, selectedCol, row, col, selectedPiece);
            }
            
            chessGameState.selectedSquare = null;
        } else if (piece && isPieceOwnedByCurrentPlayer(piece, chessGameState.currentPlayer)) {
            // Select piece if it belongs to current player
            square.classList.add('selected');
            chessGameState.selectedSquare = { row, col };
            showPossibleChessMoves(row, col);
            
            addGameChatMessage('chess', 'System', `Selected ${piece} at ${String.fromCharCode(97 + col)}${8 - row}`);
        }
    } catch (error) {
        logError(error, 'Chess square click');
    }
}

function makeChessMove(fromRow, fromCol, toRow, toCol, piece) {
    try {
        // Check for capture
        const capturedPiece = chessGameState.board[toRow][toCol];
        
        // Make the move
        chessGameState.board[toRow][toCol] = piece;
        chessGameState.board[fromRow][fromCol] = '';
        
        // Update display
        const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
        const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
        
        if (fromSquare) fromSquare.textContent = '';
        if (toSquare) toSquare.textContent = piece;
        
        // Animate the move
        if (fromSquare && toSquare) {
            animatePieceMove(fromSquare, toSquare, piece);
        }
        
        // Record move
        const moveNotation = generateMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece);
        chessGameState.moveHistory.push(moveNotation);
        chessGameState.lastMove = { from: [fromRow, fromCol], to: [toRow, toCol] };
        
        // Highlight last move
        document.querySelectorAll('.chess-square').forEach(s => s.classList.remove('last-move'));
        if (fromSquare) fromSquare.classList.add('last-move');
        if (toSquare) toSquare.classList.add('last-move');
        
        // Switch players
        chessGameState.currentPlayer = chessGameState.currentPlayer === 'white' ? 'black' : 'white';
        chessGameState.fullMoveNumber++;
        
        addGameChatMessage('chess', 'System', `Move: ${moveNotation}`);
        updateChessStatus();
        
        // Server validation if enabled
        if (platformSettings.serverValidation) {
            validateMoveOnServer('chess', moveNotation);
        }
        
        // Check for game end conditions
        checkChessGameEnd();
        
    } catch (error) {
        logError(error, 'Making chess move');
    }
}

function generateMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece) {
    const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
    const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
    const capture = capturedPiece ? 'x' : '-';
    return `${fromSquare}${capture}${toSquare}`;
}

function isValidChessMove(fromRow, fromCol, toRow, toCol) {
    try {
        const piece = chessGameState.board[fromRow][fromCol];
        const targetPiece = chessGameState.board[toRow][toCol];
        
        // Can't move to same square
        if (fromRow === toRow && fromCol === toCol) return false;
        
        // Can't capture own piece
        if (targetPiece && isPieceOwnedByCurrentPlayer(targetPiece, chessGameState.currentPlayer)) return false;
        
        // Basic move validation
        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);
        
        const pieceType = piece.toLowerCase();
        
        switch (pieceType) {
            case '♙': case '♟': // Pawn
                return isValidPawnMove(fromRow, fromCol, toRow, toCol, piece);
            case '♖': case '♜': // Rook
                return (rowDiff === 0 || colDiff === 0) && isPathClear(fromRow, fromCol, toRow, toCol);
            case '♗': case '♝': // Bishop
                return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);
            case '♕': case '♛': // Queen
                return (rowDiff === 0 || colDiff === 0 || rowDiff === colDiff) && isPathClear(fromRow, fromCol, toRow, toCol);
            case '♔': case '♚': // King
                return rowDiff <= 1 && colDiff <= 1;
            case '♘': case '♞': // Knight
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            default:
                return false;
        }
    } catch (error) {
        logError(error, 'Chess move validation');
        return false;
    }
}

function isPieceOwnedByCurrentPlayer(piece, currentPlayer) {
    const whitePieces = ['♙', '♖', '♘', '♗', '♕', '♔'];
    const blackPieces = ['♟', '♜', '♞', '♝', '♛', '♚'];
    
    if (currentPlayer === 'white') {
        return whitePieces.includes(piece);
    } else {
        return blackPieces.includes(piece);
    }
}

function isValidPawnMove(fromRow, fromCol, toRow, toCol, piece) {
    const direction = piece === '♙' ? -1 : 1;
    const rowDiff = toRow - fromRow;
    const colDiff = Math.abs(toCol - fromCol);
    
    // Forward move
    if (colDiff === 0) {
        if (rowDiff === direction && !chessGameState.board[toRow][toCol]) {
            return true;
        }
        // Initial two-square move
        if ((fromRow === 6 && piece === '♙') || (fromRow === 1 && piece === '♟')) {
            return rowDiff === 2 * direction && !chessGameState.board[toRow][toCol];
        }
    }
    // Capture move
    else if (colDiff === 1 && rowDiff === direction) {
        return chessGameState.board[toRow][toCol] !== '';
    }
    
    return false;
}

function isPathClear(fromRow, fromCol, toRow, toCol) {
    const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
    const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
    
    let currentRow = fromRow + rowStep;
    let currentCol = fromCol + colStep;
    
    while (currentRow !== toRow || currentCol !== toCol) {
        if (chessGameState.board[currentRow][currentCol] !== '') {
            return false;
        }
        currentRow += rowStep;
        currentCol += colStep;
    }
    
    return true;
}

function showPossibleChessMoves(row, col) {
    try {
        for (let dr = -2; dr <= 2; dr++) {
            for (let dc = -2; dc <= 2; dc++) {
                if (dr === 0 && dc === 0) continue;
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    if (isValidChessMove(row, col, newRow, newCol)) {
                        const targetSquare = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                        if (targetSquare) {
                            targetSquare.classList.add('possible-move');
                        }
                    }
                }
            }
        }
    } catch (error) {
        logError(error, 'Showing possible chess moves');
    }
}

function updateChessStatus() {
    try {
        const statusEl = document.getElementById('chessStatus');
        if (statusEl) {
            const currentPlayerName = chessGameState.currentPlayer === 'white' ? 'White' : 'Black';
            statusEl.textContent = `${currentPlayerName} to move`;
            
            if (chessGameState.isCheck) {
                statusEl.textContent += ' - Check!';
                statusEl.classList.add('warning');
            } else {
                statusEl.classList.remove('warning');
            }
        }
    } catch (error) {
        logError(error, 'Chess status update');
    }
}

function checkChessGameEnd() {
    // Simplified game end detection
    // In a real implementation, this would check for checkmate, stalemate, etc.
    if (chessGameState.moveHistory.length >= 50) {
        chessGameState.gameActive = false;
        addGameChatMessage('chess', 'System', 'Game ended by move limit');
        showGameResults('Draw', '25:30', chessGameState.moveHistory.length, 0, 0);
    }
}

// ===========================
// CHECKERS GAME LOGIC
// ===========================

function initializeCheckersGame() {
    try {
        const board = document.getElementById('checkersBoard');
        if (!board) return;
        
        board.innerHTML = '';
        
        // Initialize checkers board state
        checkersGameState = {
            board: Array(8).fill().map(() => Array(8).fill(null)),
            currentPlayer: 'red',
            selectedSquare: null,
            gameActive: true,
            moveHistory: [],
            mandatoryJumps: [],
            capturedPieces: { red: 0, black: 0 },
            moveCount: 1,
            isMultiJump: false,
            multiJumpPiece: null
        };
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                square.dataset.row = row;
                square.dataset.col = col;
                
                // Add checker pieces on dark squares only
                if ((row + col) % 2 === 1) {
                    if (row < 3) {
                        // Red pieces (top)
                        const piece = createCheckerPiece('red', row, col);
                        square.appendChild(piece);
                        checkersGameState.board[row][col] = 'red';
                    } else if (row > 4) {
                        // Black pieces (bottom)
                        const piece = createCheckerPiece('black', row, col);
                        square.appendChild(piece);
                        checkersGameState.board[row][col] = 'black';
                    }
                }
                
                square.onclick = () => handleCheckersSquareClick(row, col);
                board.appendChild(square);
            }
        }
        
        updateCheckersStatus();
        console.log('✅ Checkers game initialized');
    } catch (error) {
        logError(error, 'Checkers initialization');
    }
}

function createCheckerPiece(color, row, col) {
    const piece = document.createElement('div');
    piece.className = `checker-piece ${color}-piece`;
    piece.onclick = (e) => {
        e.stopPropagation();
        handleCheckerPieceClick(row, col);
    };
    return piece;
}

function handleCheckersSquareClick(row, col) {
    if (!checkersGameState.gameActive) return;
    
    try {
        if (checkersGameState.selectedSquare) {
            const selectedRow = checkersGameState.selectedSquare.row;
            const selectedCol = checkersGameState.selectedSquare.col;
            
            if (isValidCheckersMove(selectedRow, selectedCol, row, col)) {
                makeCheckersMove(selectedRow, selectedCol, row, col);
            }
            
            // Clear selection
            document.querySelectorAll('.checker-piece').forEach(p => p.classList.remove('selected'));
            checkersGameState.selectedSquare = null;
        }
    } catch (error) {
        logError(error, 'Checkers square click');
    }
}

function handleCheckerPieceClick(row, col) {
    if (!checkersGameState.gameActive) return;
    
    try {
        const piece = checkersGameState.board[row][col];
        if (!piece || piece !== checkersGameState.currentPlayer) return;
        
        // Clear previous selections
        document.querySelectorAll('.checker-piece').forEach(p => p.classList.remove('selected'));
        
        // Select this piece
        const pieceElement = document.querySelector(`[data-row="${row}"][data-col="${col}"] .checker-piece`);
        if (pieceElement) {
            pieceElement.classList.add('selected');
            checkersGameState.selectedSquare = { row, col };
        }
        
        addGameChatMessage('checkers', 'System', `Selected ${piece} piece at (${row}, ${col})`);
    } catch (error) {
        logError(error, 'Checker piece click');
    }
}

function isValidCheckersMove(fromRow, fromCol, toRow, toCol) {
    try {
        const piece = checkersGameState.board[fromRow][fromCol];
        
        // Must be on dark square
        if ((toRow + toCol) % 2 === 0) return false;
        
        // Must be empty
        if (checkersGameState.board[toRow][toCol]) return false;
        
        const rowDiff = toRow - fromRow;
        const colDiff = Math.abs(toCol - fromCol);
        
        // Regular pieces can only move diagonally forward
        if (piece === 'red') {
            return rowDiff === 1 && colDiff === 1;
        } else if (piece === 'black') {
            return rowDiff === -1 && colDiff === 1;
        }
        
        return false;
    } catch (error) {
        logError(error, 'Checkers move validation');
        return false;
    }
}

function makeCheckersMove(fromRow, fromCol, toRow, toCol) {
    try {
        const piece = checkersGameState.board[fromRow][fromCol];
        
        // Move piece
        checkersGameState.board[toRow][toCol] = piece;
        checkersGameState.board[fromRow][fromCol] = null;
        
        // Update display
        const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
        const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
        
        if (fromSquare && toSquare) {
            const pieceElement = fromSquare.querySelector('.checker-piece');
            if (pieceElement) {
                fromSquare.removeChild(pieceElement);
                const newPiece = createCheckerPiece(piece, toRow, toCol);
                toSquare.appendChild(newPiece);
                newPiece.classList.remove('selected');
            }
        }
        
        // Check for king promotion
        if ((piece === 'red' && toRow === 7) || (piece === 'black' && toRow === 0)) {
            const pieceElement = toSquare.querySelector('.checker-piece');
            if (pieceElement) {
                pieceElement.classList.add('king');
                addGameChatMessage('checkers', 'System', `${piece} piece crowned as king!`);
            }
        }
        
        // Record move
        const moveNotation = `(${fromRow},${fromCol}) → (${toRow},${toCol})`;
        checkersGameState.moveHistory.push(moveNotation);
        
        // Switch players
        checkersGameState.currentPlayer = checkersGameState.currentPlayer === 'red' ? 'black' : 'red';
        checkersGameState.moveCount++;
        
        updateMoveCounter(checkersGameState.moveCount);
        addGameChatMessage('checkers', 'System', `${piece} moved ${moveNotation}`);
        updateCheckersStatus();
        
        // Check for game end
        checkCheckersGameEnd();
        
    } catch (error) {
        logError(error, 'Making checkers move');
    }
}

function updateCheckersStatus() {
    try {
        const statusEl = document.getElementById('checkersStatus');
        if (statusEl) {
            const currentPlayerName = checkersGameState.currentPlayer === 'red' ? 'Red' : 'Black';
            statusEl.textContent = `${currentPlayerName} to move`;
        }
    } catch (error) {
        logError(error, 'Checkers status update');
    }
}

function checkCheckersGameEnd() {
    // Simplified game end detection
    if (checkersGameState.moveCount >= 100) {
        checkersGameState.gameActive = false;
        addGameChatMessage('checkers', 'System', 'Game ended by move limit');
        showGameResults('Draw', '15:45', checkersGameState.moveCount, 0, 0);
    }
}

// ===========================
// WORD GAME LOGIC
// ===========================

function initializeWordGame() {
    try {
        wordGameState = {
            currentRound: 1,
            totalRounds: 3,
            timeLeft: 60,
            availableLetters: 'BLOCKCHAIN',
            validWords: [],
            playerScore: 0,
            opponentScore: 0,
            gameActive: true,
            timer: null
        };
        
        updateWordGameUI();
        startWordGameTimer();
        
        console.log('✅ Word game initialized');
    } catch (error) {
        logError(error, 'Word game initialization');
    }
}

function updateWordGameUI() {
    try {
        const lettersEl = document.getElementById('wordLetters');
        const promptEl = document.getElementById('wordPrompt');
        const roundEl = document.getElementById('currentRound');
        const timerEl = document.getElementById('roundTimer');
        
        if (lettersEl) lettersEl.textContent = wordGameState.availableLetters;
        if (promptEl) promptEl.textContent = `Round ${wordGameState.currentRound}: Make words with these letters:`;
        if (roundEl) roundEl.textContent = wordGameState.currentRound;
        if (timerEl) timerEl.textContent = wordGameState.timeLeft;
        
        updateWordScores(wordGameState.playerScore, wordGameState.opponentScore);
    } catch (error) {
        logError(error, 'Word game UI update');
    }
}

function startWordGameTimer() {
    try {
        if (wordGameState.timer) {
            clearInterval(wordGameState.timer);
        }
        
        wordGameState.timer = setInterval(() => {
            wordGameState.timeLeft--;
            updateWordGameRound(wordGameState.currentRound, wordGameState.timeLeft);
            
            if (wordGameState.timeLeft <= 0) {
                endWordGameRound();
            }
        }, 1000);
    } catch (error) {
        logError(error, 'Word game timer');
    }
}

function submitWord() {
    try {
        const input = document.getElementById('wordInput');
        if (!input || !input.value) return;
        
        const word = input.value.trim().toUpperCase();
        if (!word) return;
        
        // Validate word
        if (isValidWord(word)) {
            const score = calculateWordScore(word);
            wordGameState.playerScore += score;
            wordGameState.validWords.push(word);
            
            addValidWord(word, score);
            updateWordScores(wordGameState.playerScore, wordGameState.opponentScore);
            
            showTransactionStatus(`✅ Scored ${score} points for "${word}"!`, '');
            addGameChatMessage('word', 'You', `Played: ${word} (${score} pts)`);
        } else {
            showTransactionStatus(`❌ "${word}" is not valid!`, '');
        }
        
        input.value = '';
    } catch (error) {
        logError(error, 'Word submission');
    }
}

function isValidWord(word) {
    // Check if word can be made from available letters
    const letters = wordGameState.availableLetters.split('');
    const wordLetters = word.split('');
    
    for (const letter of wordLetters) {
        const index = letters.indexOf(letter);
        if (index === -1) return false;
        letters.splice(index, 1);
    }
    
    // Check minimum length
    return word.length >= 3;
}

function calculateWordScore(word) {
    // Simple scoring: 1 point per letter + bonus for longer words
    let score = word.length;
    if (word.length >= 6) score += 5;
    if (word.length >= 8) score += 10;
    return score;
}

function skipRound() {
    try {
        addGameChatMessage('word', 'System', 'Round skipped');
        endWordGameRound();
    } catch (error) {
        logError(error, 'Skip round');
    }
}

function endWordGameRound() {
    try {
        if (wordGameState.timer) {
            clearInterval(wordGameState.timer);
        }
        
        // Simulate opponent score
        const opponentScore = Math.floor(Math.random() * 20) + 10;
        wordGameState.opponentScore += opponentScore;
        updateWordScores(wordGameState.playerScore, wordGameState.opponentScore);
        
        addGameChatMessage('word', 'System', `Round ${wordGameState.currentRound} ended!`);
        
        if (wordGameState.currentRound >= wordGameState.totalRounds) {
            endWordGame();
        } else {
            // Start next round
            wordGameState.currentRound++;
            wordGameState.timeLeft = 60;
            wordGameState.availableLetters = generateRandomLetters();
            updateWordGameUI();
            startWordGameTimer();
        }
    } catch (error) {
        logError(error, 'End word round');
    }
}

function endWordGame() {
    try {
        wordGameState.gameActive = false;
        
        const winner = wordGameState.playerScore > wordGameState.opponentScore ? 'You' : 'Opponent';
        const finalScore = `${wordGameState.playerScore} - ${wordGameState.opponentScore}`;
        
        addGameChatMessage('word', 'System', `Game Over! Final Score: ${finalScore}`);
        showGameResults(winner === 'You' ? 'win' : 'lose', '3:00', wordGameState.totalRounds, 
                       winner === 'You' ? 0.97 : 0, winner === 'You' ? 15 : -8);
    } catch (error) {
        logError(error, 'End word game');
    }
}

function generateRandomLetters() {
    const letterSets = ['BLOCKCHAIN', 'ETHEREUM', 'BITCOIN', 'GAMEFLY', 'VICTORY'];
    return letterSets[Math.floor(Math.random() * letterSets.length)];
}

// ===========================
// ANTI-BOT PROTECTION SYSTEM
// ===========================

function showAntiBotChallenge() {
    return new Promise((resolve) => {
        try {
            if (!platformSettings.antiBot) {
                resolve(true);
                return;
            }
            
            const challenge = document.getElementById('antiBotChallenge');
            if (challenge) {
                challenge.classList.remove('hidden');
                antiBotChallengeActive = true;
                captchaSelection = [];
                
                generateCaptchaGrid();
                
                window.antiBotResolve = resolve;
            } else {
                resolve(true);
            }
        } catch (error) {
            logError(error, 'Anti-bot challenge');
            resolve(true);
        }
    });
}

function generateCaptchaGrid() {
    try {
        const grid = document.getElementById('captchaGrid');
        const instructions = document.getElementById('captchaInstructions');
        
        if (!grid || !instructions) return;
        
        const challenges = [
            {
                type: 'chess',
                instruction: 'Select all squares containing chess pieces',
                items: ['♔', '♕', '♖', '♗', '♘', '♙', '♚', '♛', '♜'],
                decoys: ['🎯', '🎮', '🎲', '🃏', '🎪', '🎨', '🎭', '🎬', '🎤']
            },
            {
                type: 'numbers',
                instruction: 'Select all squares containing prime numbers',
                items: ['2', '3', '5', '7', '11', '13', '17', '19', '23'],
                decoys: ['4', '6', '8', '9', '10', '12', '14', '15', '16']
            },
            {
                type: 'symbols',
                instruction: 'Select all squares containing blockchain symbols',
                items: ['₿', '⚡', '🔗', '💎', '🚀', '⛏️', '🏦', '💰', '🔐'],
                decoys: ['🌟', '🎨', '🎪', '🎭', '🎬', '🎤', '🎵', '🎸', '🎹']
            }
        ];
        
        const challenge = challenges[Math.floor(Math.random() * challenges.length)];
        instructions.textContent = challenge.instruction;
        
        const selectedItems = [];
        const correctItems = [];
        
        for (let i = 0; i < 9; i++) {
            const isCorrect = Math.random() < 0.4;
            if (isCorrect && challenge.items.length > 0) {
                const item = challenge.items.splice(Math.floor(Math.random() * challenge.items.length), 1)[0];
                selectedItems.push(item);
                correctItems.push(i);
            } else if (challenge.decoys.length > 0) {
                const item = challenge.decoys.splice(Math.floor(Math.random() * challenge.decoys.length), 1)[0];
                selectedItems.push(item);
            } else {
                selectedItems.push('');
            }
        }
        
        grid.innerHTML = '';
        for (let i = 0; i < 9; i++) {
            const tile = document.createElement('div');
            tile.className = 'captcha-tile';
            tile.textContent = selectedItems[i];
            tile.dataset.index = i;
            tile.onclick = () => toggleCaptchaTile(i);
            grid.appendChild(tile);
        }
        
        window.captchaCorrectAnswers = correctItems;
        updateCaptchaVerifyButton();
    } catch (error) {
        logError(error, 'Captcha generation');
    }
}

function toggleCaptchaTile(index) {
    try {
        const tile = document.querySelector(`[data-index="${index}"]`);
        if (!tile) return;
        
        const isSelected = captchaSelection.includes(index);
        
        if (isSelected) {
            captchaSelection = captchaSelection.filter(i => i !== index);
            tile.classList.remove('selected');
        } else {
            captchaSelection.push(index);
            tile.classList.add('selected');
        }
        
        updateCaptchaVerifyButton();
    } catch (error) {
        logError(error, 'Captcha tile toggle');
    }
}

function updateCaptchaVerifyButton() {
    try {
        const btn = document.getElementById('verifyCaptchaBtn');
        if (btn) {
            btn.disabled = captchaSelection.length === 0;
        }
    } catch (error) {
        logError(error, 'Captcha button update');
    }
}

function verifyCaptcha() {
    try {
        const correctAnswers = window.captchaCorrectAnswers || [];
        const isCorrect = captchaSelection.length === correctAnswers.length && 
                         captchaSelection.every(answer => correctAnswers.includes(answer));
        
        const challenge = document.getElementById('antiBotChallenge');
        if (challenge) {
            if (isCorrect) {
                challenge.classList.add('hidden');
                antiBotChallengeActive = false;
                showTransactionStatus('✅ Human verification successful!', '');
                
                if (window.antiBotResolve) {
                    window.antiBotResolve(true);
                }
            } else {
                showTransactionStatus('❌ Verification failed. Please try again.', '');
                refreshCaptcha();
            }
        }
    } catch (error) {
        logError(error, 'Captcha verification');
        if (window.antiBotResolve) {
            window.antiBotResolve(false);
        }
    }
}

function refreshCaptcha() {
    try {
        captchaSelection = [];
        generateCaptchaGrid();
    } catch (error) {
        logError(error, 'Captcha refresh');
    }
}

// ===========================
// TOURNAMENT SYSTEM
// ===========================

async function joinTournament(tournamentId) {
    try {
        const tournament = activeTournaments.find(t => t.id === tournamentId);
        if (!tournament) {
            showTransactionStatus('❌ Tournament not found', '');
            return;
        }
        
        if (!userAccount) {
            showTransactionStatus('❌ Please connect your wallet first', '');
            return;
        }
        
        if (currentBalance < tournament.entryFee) {
            showTransactionStatus('❌ Insufficient CORE balance', '');
            return;
        }
        
        if (tournament.participants.includes(userAccount)) {
            showTransactionStatus('❌ Already registered for this tournament', '');
            return;
        }
        
        if (tournament.currentPlayers >= tournament.maxPlayers) {
            showTransactionStatus('❌ Tournament is full', '');
            return;
        }

        // Show anti-bot challenge
        if (platformSettings.antiBot) {
            const antiBotPassed = await showAntiBotChallenge();
            if (!antiBotPassed) {
                showTransactionStatus('❌ Anti-bot verification failed', '');
                return;
            }
        }
        
        showTransactionStatus('🔄 Joining tournament...', '');
        
        // Simulate tournament registration
        tournament.participants.push(userAccount);
        tournament.currentPlayers++;
        
        // Update balance
        currentBalance -= tournament.entryFee;
        updateBalanceDisplay();
        
        showTransactionStatus(`✅ Joined ${tournament.name}!`, '');
        addActivityFeedItem(`🏆 You joined ${tournament.name} tournament`);
        
        // Update player stats
        playerStats.gamesPlayed++;
        updatePlayerStats();
        saveUserData();
        
    } catch (error) {
        logError(error, 'Tournament joining');
        showTransactionStatus('❌ Failed to join tournament: ' + error.message, '');
    }
}

function updateTournamentTimers() {
    try {
        activeTournaments.forEach((tournament, index) => {
            const timeLeft = tournament.startTime - Date.now();
            const timerElement = document.getElementById(`tournament${index + 1}Timer`);
            
            if (timerElement && timeLeft > 0) {
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                
                if (hours > 0) {
                    timerElement.textContent = `${hours}h ${minutes}m`;
                } else {
                    timerElement.textContent = `${minutes}m`;
                }
            } else if (timerElement && timeLeft <= 0) {
                timerElement.textContent = 'Starting...';
                tournament.status = 'active';
            }
        });
    } catch (error) {
        logError(error, 'Tournament timer update');
    }
}

// ===========================
// GAME SETTLEMENT SYSTEM
// ===========================

async function settleGame(gameId, winnerAddress, totalPot) {
    try {
        showTransactionStatus('🏆 Processing game settlement...', '');
        
        // Calculate winnings (97% to winner, 3% platform fee)
        const platformFee = totalPot * 0.03;
        const winnings = totalPot - platformFee;
        
        const isWinner = winnerAddress.toLowerCase() === userAccount.toLowerCase();
        
        if (isWinner) {
            currentBalance += winnings;
            updateBalanceDisplay();
            
            showTransactionStatus(`🎉 You won ${winnings.toFixed(4)} CORE!`, '');
            addActivityFeedItem(`🏆 You won ${winnings.toFixed(4)} CORE!`);
            
            // Update stats
            playerStats.gamesWon++;
            playerStats.totalEarned += winnings;
        } else {
            showTransactionStatus('😔 Game lost. Better luck next time!', '');
        }
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        saveUserData();
        
        // Remove game from server
        await removeGameFromServer(gameId);
        
        // Remove game from local lists
        activeGames = activeGames.filter(game => game.id !== gameId);
        updateGamesDisplay();
        
        // Show game results
        setTimeout(() => {
            showGameResults(
                isWinner ? 'win' : 'lose',
                '12:34',
                25,
                isWinner ? winnings : 0,
                isWinner ? 12 : -8
            );
        }, 2000);
        
    } catch (error) {
        logError(error, 'Game settlement');
        showTransactionStatus('❌ Settlement failed: ' + error.message, '');
    }
}

// ===========================
// SERVER VALIDATION
// ===========================

async function validateMoveOnServer(gameType, moveData) {
    try {
        if (!platformSettings.serverValidation) return true;
        
        console.log(`Validating ${gameType} move on server:`, moveData);
        
        // Simulate server validation
        await new Promise(resolve => setTimeout(resolve, 200));
        
        const isValid = Math.random() > 0.1; // 90% chance of valid move
        
        if (!isValid) {
            showTransactionStatus('❌ Invalid move detected by server', '');
            return false;
        }
        
        return true;
    } catch (error) {
        logError(error, 'Server validation');
        return true; // Allow move if server is unavailable
    }
}

// ===========================
// GAME ACTION FUNCTIONS
// ===========================

function resignChess() {
    try {
        if (confirm('Are you sure you want to resign?')) {
            chessGameState.gameActive = false;
            showTransactionStatus('🏳️ You resigned the game', '');
            addGameChatMessage('chess', 'System', 'Game ended by resignation');
            setTimeout(() => closeGame('chess'), 2000);
        }
    } catch (error) {
        logError(error, 'Chess resignation');
    }
}

function drawChess() {
    try {
        showTransactionStatus('🤝 Draw offer sent', '');
        addGameChatMessage('chess', 'System', 'Draw offer sent to opponent');
    } catch (error) {
        logError(error, 'Chess draw offer');
    }
}

function resignCheckers() {
    try {
        if (confirm('Are you sure you want to resign?')) {
            checkersGameState.gameActive = false;
            showTransactionStatus('🏳️ You resigned the game', '');
            addGameChatMessage('checkers', 'System', 'Game ended by resignation');
            setTimeout(() => closeGame('checkers'), 2000);
        }
    } catch (error) {
        logError(error, 'Checkers resignation');
    }
}

function requestUndo() {
    try {
        showTransactionStatus('🔄 Undo request sent', '');
        addGameChatMessage('chess', 'System', 'Undo request sent to opponent');
    } catch (error) {
        logError(error, 'Undo request');
    }
}

// Start tournament timer updates
setInterval(updateTournamentTimers, 1000);

console.log('✅ Game Logic & Real-time Multiplayer System Loaded Successfully');
</script>
  <script>
/* ===========================
   CROSSREALM GAMING PLATFORM
   UI COMPONENTS & SECTION MANAGEMENT
   =========================== */

// ===========================
// NAVIGATION & SECTION MANAGEMENT
// ===========================

function showSection(section) {
    try {
        // Check if navigation is allowed
        if (isGameActive && !gameIsMinimized && section !== currentSection) {
            showTransactionStatus('⚠️ Please finish or close your current game before navigating', '');
            return;
        }
        
        // Hide all sections
        document.querySelectorAll('[id$="Section"]').forEach(el => {
            if (el && el.id !== section + 'Section') {
                el.classList.add('hidden');
            }
        });
        
        // Show target section
        const targetSection = document.getElementById(section + 'Section');
        if (targetSection) {
            targetSection.classList.remove('hidden');
            
            // Load section content dynamically
            loadSectionContent(section);
        }
        
        // Update navigation
        document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
        
        // Find and activate the clicked nav item
        const clickedItem = Array.from(document.querySelectorAll('.nav-item')).find(item => 
            item.textContent.toLowerCase().includes(section.toLowerCase())
        );
        if (clickedItem) {
            clickedItem.classList.add('active');
        }
        
        currentSection = section;
        
        // Section-specific initialization
        switch(section) {
            case 'lobby':
                refreshLobby();
                break;
            case 'profile':
                updatePlayerStats();
                loadGameHistory();
                break;
            case 'settings':
                loadSettingsUI();
                break;
            case 'chat':
                initializeGlobalChat();
                break;
            case 'tournaments':
                loadTournamentsUI();
                break;
            case 'create':
                loadCreateGameUI();
                break;
            case 'games':
                loadGamesUI();
                break;
        }
        
    } catch (error) {
        logError(error, 'Section navigation');
    }
}

function loadSectionContent(section) {
    try {
        const targetSection = document.getElementById(section + 'Section');
        if (!targetSection) return;
        
        // Only load content if section is empty
        if (targetSection.innerHTML.trim() === '') {
            targetSection.innerHTML = getSectionHTML(section);
        }
    } catch (error) {
        logError(error, 'Loading section content');
    }
}

function getSectionHTML(section) {
    switch(section) {
        case 'create':
            return getCreateGameHTML();
        case 'games':
            return getGamesHTML();
        case 'tournaments':
            return getTournamentsHTML();
        case 'profile':
            return getProfileHTML();
        case 'chat':
            return getChatHTML();
        case 'settings':
            return getSettingsHTML();
        default:
            return '';
    }
}

// ===========================
// SECTION HTML GENERATORS
// ===========================

function getCreateGameHTML() {
    return `
        <div class="create-game-section">
            <h2>🎮 Create New Game</h2>
            
            <div class="game-type-selector">
                <div class="game-type-card" data-type="chess" onclick="selectGameType('chess')">
                    <div class="game-icon">♟️</div>
                    <h3>Chess Masters</h3>
                    <p>Strategic blockchain chess with real stakes</p>
                    <small>5-30 minutes per game</small>
                </div>
                <div class="game-type-card" data-type="checkers" onclick="selectGameType('checkers')">
                    <div class="game-icon">⚫</div>
                    <h3>Checkers Pro</h3>
                    <p>Fast-paced checkers battles</p>
                    <small>3-15 minutes per game</small>
                </div>
                <div class="game-type-card" data-type="words" onclick="selectGameType('words')">
                    <div class="game-icon">📝</div>
                    <h3>Word Battle</h3>
                    <p>Vocabulary competition game</p>
                    <small>1-3 minutes per round</small>
                </div>
            </div>
            
            <div style="margin: 2rem 0;">
                <label for="gameStake" style="display: block; margin-bottom: 0.5rem; color: #4ecdc4; font-weight: bold;">
                    Stake Amount (CORE)
                </label>
                <input type="number" class="stake-input" id="gameStake" 
                       placeholder="Enter stake amount (min 0.01 CORE)" 
                       min="0.01" step="0.01" 
                       oninput="updateCreateButton()">
                <small style="color: #aaa; display: block; margin-top: 0.5rem;">
                    Winner takes 97% of total pool (3% platform fee)
                </small>
            </div>

            <div class="advanced-settings">
                <h4 style="margin-bottom: 1rem; color: #4ecdc4;">⚙️ Advanced Settings</h4>
                <div class="settings-grid">
                    <div>
                        <label>Time Control</label>
                        <select id="timeControl" class="setting-select">
                            <option value="blitz">Blitz (5+3)</option>
                            <option value="rapid" selected>Rapid (10+5)</option>
                            <option value="classical">Classical (30+0)</option>
                        </select>
                    </div>
                    <div>
                        <label>Skill Range</label>
                        <select id="skillRange" class="setting-select">
                            <option value="any">Any Skill Level</option>
                            <option value="similar" selected>Similar Skill (±100)</option>
                            <option value="strict">Exact Skill (±50)</option>
                        </select>
                    </div>
                    <div>
                        <label>Server Validation</label>
                        <select id="serverValidation" class="setting-select">
                            <option value="full" selected>Full Validation</option>
                            <option value="light">Light Validation</option>
                            <option value="off">Client Only</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <button class="create-btn" id="createGameBtn" onclick="createGame()" disabled>
                <i class="fas fa-plus"></i> Select Game Type & Enter Stake
            </button>
        </div>
    `;
}

function getGamesHTML() {
    return `
        <div class="games-showcase">
            <div class="games-header">
                <h2>♟️ Featured Games</h2>
                <div class="info-banner">
                    <p><strong>🏆 Smart Contract Gaming - 97% of every stake goes directly to the winner!</strong></p>
                    <p>Powered by Core Blockchain • Instant payouts • Provably fair</p>
                </div>
            </div>

            <div class="legal-notice">
                <h4>⚖️ Legal Notice</h4>
                <ul>
                    <li>Educational gaming platform for skill development</li>
                    <li>Minimum age: 18+ required worldwide</li>
                    <li>Tax obligations: Players responsible for local tax compliance</li>
                    <li>Not available in restricted jurisdictions</li>
                    <li>Contract: 0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A (Verified ✅)</li>
                </ul>
            </div>

            <div class="games-grid">
                <div class="game-showcase-card">
                    <div class="game-card-header">
                        <h3><i class="fas fa-chess" style="font-size: 2rem; margin-bottom: 0.5rem;"></i> Chess Masters</h3>
                        <div class="game-stats">
                            <span class="stat">Active Players: <strong>234</strong></span>
                            <span class="stat">Games Today: <strong>1,847</strong></span>
                        </div>
                    </div>
                    <p>Strategic blockchain chess with real CORE stakes. Smart contract ensures fair play and instant payouts.</p>
                    <div class="features-list">
                        <span class="feature">🔒 Smart Contract Protected</span>
                        <span class="feature">⚡ Instant Settlement</span>
                        <span class="feature">🏆 Skill-Based Matching</span>
                        <span class="feature">📊 Rating System</span>
                    </div>
                    <input type="number" class="stake-input" id="chessStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                    <button class="game-action-btn" onclick="createChessGame()">
                        <i class="fas fa-chess-board"></i> Create Chess Game
                    </button>
                </div>

                <div class="game-showcase-card">
                    <div class="game-card-header">
                        <h3><i class="fas fa-th" style="font-size: 2rem; margin-bottom: 0.5rem;"></i> Checkers Pro</h3>
                        <div class="game-stats">
                            <span class="stat">Active Players: <strong>156</strong></span>
                            <span class="stat">Games Today: <strong>923</strong></span>
                        </div>
                    </div>
                    <p>Fast checkers with blockchain stakes! Quick games with instant rewards and competitive rankings.</p>
                    <div class="features-list">
                        <span class="feature">⚡ Quick Matches</span>
                        <span class="feature">🎯 Jump Mechanics</span>
                        <span class="feature">👑 King Promotions</span>
                        <span class="feature">📈 Live Leaderboards</span>
                    </div>
                    <input type="number" class="stake-input" id="checkersStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                    <button class="game-action-btn" onclick="createCheckersGame()">
                        <i class="fas fa-th"></i> Create Checkers Game
                    </button>
                </div>

                <div class="game-showcase-card">
                    <div class="game-card-header">
                        <h3>📝 Word Battle</h3>
                        <div class="game-stats">
                            <span class="stat">Active Players: <strong>89</strong></span>
                            <span class="stat">Games Today: <strong>445</strong></span>
                        </div>
                    </div>
                    <p>Compete in word games with crypto stakes! Test your vocabulary against other players worldwide.</p>
                    <div class="features-list">
                        <span class="feature">📚 Dictionary Verified</span>
                        <span class="feature">⏱️ Timed Rounds</span>
                        <span class="feature">🎲 Random Letters</span>
                        <span class="feature">🏆 Vocabulary Rankings</span>
                    </div>
                    <input type="number" class="stake-input" id="wordStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                    <button class="game-action-btn" onclick="createWordGame()">📝 Create Word Game</button>
                </div>
            </div>

            <div class="coming-soon">
                <h3>🚀 Coming Soon</h3>
                <div class="upcoming-games">
                    <div class="upcoming-game">🃏 Poker Texas Hold'em</div>
                    <div class="upcoming-game">🎲 Dice Battles</div>
                    <div class="upcoming-game">🎯 Darts Competition</div>
                    <div class="upcoming-game">🧩 Puzzle Challenges</div>
                </div>
            </div>
        </div>
    `;
}

function getTournamentsHTML() {
    return `
        <div class="tournament-section">
            <h2 style="color: #4ecdc4; margin-bottom: 2rem;">🏆 Live Tournaments</h2>
            
            <div class="tournament-cards">
                <div class="tournament-card">
                    <div class="tournament-header">
                        <div class="tournament-title">🏆 Weekly Chess Championship</div>
                        <div class="tournament-prize">💰 50 CORE Prize Pool</div>
                    </div>
                    
                    <div class="tournament-info">
                        <div class="tournament-detail">
                            <div class="detail-label">Players</div>
                            <div class="detail-value" style="color: #4ecdc4; font-weight: bold;">16/32</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Entry Fee</div>
                            <div class="detail-value" style="color: #f39c12; font-weight: bold;">2.0 CORE</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Format</div>
                            <div class="detail-value">Single Elimination</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Starts In</div>
                            <div class="detail-value" id="tournament1Timer">2h 15m</div>
                        </div>
                    </div>
                    
                    <div class="tournament-bracket">
                        <h4>Tournament Bracket</h4>
                        <div class="bracket-rounds">
                            <div class="bracket-round">
                                <div class="bracket-match">CryptoKing vs Player2</div>
                                <div class="bracket-match">GameMaster vs Player4</div>
                            </div>
                            <div class="bracket-round">
                                <div class="bracket-match">Semi-Final 1</div>
                                <div class="bracket-match">Semi-Final 2</div>
                            </div>
                            <div class="bracket-round">
                                <div class="bracket-match">🏆 FINAL 🏆</div>
                            </div>
                        </div>
                    </div>
                    
                    <button class="join-btn" onclick="joinTournament('chess_weekly')" id="joinChessTournament">
                        <i class="fas fa-trophy"></i> Join Tournament (2.0 CORE)
                    </button>
                </div>
                
                <div class="tournament-card">
                    <div class="tournament-header">
                        <div class="tournament-title">⚡ Speed Checkers Blitz</div>
                        <div class="tournament-prize">💰 25 CORE Prize Pool</div>
                    </div>
                    
                    <div class="tournament-info">
                        <div class="tournament-detail">
                            <div class="detail-label">Players</div>
                            <div class="detail-value" style="color: #4ecdc4; font-weight: bold;">8/16</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Entry Fee</div>
                            <div class="detail-value" style="color: #f39c12; font-weight: bold;">1.0 CORE</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Format</div>
                            <div class="detail-value">Swiss System</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Time Control</div>
                            <div class="detail-value">3+2 mins</div>
                        </div>
                    </div>
                    
                    <button class="join-btn" onclick="joinTournament('checkers_blitz')" id="joinCheckersBlitz">
                        <i class="fas fa-bolt"></i> Join Blitz (1.0 CORE)
                    </button>
                </div>

                <div class="tournament-card">
                    <div class="tournament-header">
                        <div class="tournament-title">📝 Word Masters Cup</div>
                        <div class="tournament-prize">💰 15 CORE Prize Pool</div>
                    </div>
                    
                    <div class="tournament-info">
                        <div class="tournament-detail">
                            <div class="detail-label">Players</div>
                            <div class="detail-value" style="color: #4ecdc4; font-weight: bold;">12/24</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Entry Fee</div>
                            <div class="detail-value" style="color: #f39c12; font-weight: bold;">0.5 CORE</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Rounds</div>
                            <div class="detail-value">5 Rounds</div>
                        </div>
                        <div class="tournament-detail">
                            <div class="detail-label">Starts In</div>
                            <div class="detail-value" id="tournament3Timer">45m</div>
                        </div>
                    </div>
                    
                    <button class="join-btn" onclick="joinTournament('word_masters')" id="joinWordMasters">
                        <i class="fas fa-pen"></i> Join Tournament (0.5 CORE)
                    </button>
                </div>
            </div>
            
            <div class="create-tournament">
                <h3 style="color: #ffd700; margin-bottom: 1rem;">🎯 Create Your Own Tournament</h3>
                <p style="margin-bottom: 1.5rem;">Host your own tournament and earn hosting fees from participants!</p>
                
                <div class="tournament-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Tournament Name</label>
                            <input type="text" class="form-input" id="tournamentName" placeholder="My Tournament">
                        </div>
                        <div class="form-group">
                            <label>Game Type</label>
                            <select class="form-input" id="tournamentGameType">
                                <option value="chess">Chess</option>
                                <option value="checkers">Checkers</option>
                                <option value="words">Word Game</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Entry Fee (CORE)</label>
                            <input type="number" class="form-input" id="tournamentFee" placeholder="1.0" min="0.1" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Max Players</label>
                            <select class="form-input" id="tournamentSize">
                                <option value="8">8 Players</option>
                                <option value="16">16 Players</option>
                                <option value="32">32 Players</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <button class="create-btn" onclick="createTournament()" id="createTournamentBtn">
                    <i class="fas fa-plus"></i> Create Tournament (Host Fee: 0.1 CORE)
                </button>
            </div>
        </div>
    `;
}

function getProfileHTML() {
    return `
        <div class="profile-section">
            <div class="profile-header">
                <div class="profile-avatar">
                    <i class="fas fa-user-circle"></i>
                </div>
                <div class="profile-info">
                    <h2>Player Profile</h2>
                    <p class="wallet-address" id="profileWalletAddress">Connect wallet to view profile</p>
                </div>
            </div>

            <div class="profile-stats">
                <h3 style="color: #4ecdc4; margin-bottom: 1rem;">📊 Player Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="profileGamesPlayed">0</div>
                        <div class="stat-label">Games Played</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileGamesWon">0</div>
                        <div class="stat-label">Games Won</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileTotalEarned">0</div>
                        <div class="stat-label">CORE Earned</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="profileWinRate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                </div>
            </div>
            
            <div class="skill-ratings">
                <h3 style="margin-bottom: 1rem; color: #4ecdc4;">🎯 Skill Ratings</h3>
                <div class="ratings-grid">
                    <div class="rating-card">
                        <div class="rating-icon">♟️</div>
                        <div class="rating-info">
                            <div class="rating-level gold">Gold</div>
                            <div class="rating-points">Chess: 456</div>
                        </div>
                    </div>
                    <div class="rating-card">
                        <div class="rating-icon">⚫</div>
                        <div class="rating-info">
                            <div class="rating-level silver">Silver</div>
                            <div class="rating-points">Checkers: 234</div>
                        </div>
                    </div>
                    <div class="rating-card">
                        <div class="rating-icon">📝</div>
                        <div class="rating-info">
                            <div class="rating-level bronze">Bronze</div>
                            <div class="rating-points">Words: 89</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="game-history">
                <h3 style="margin-bottom: 1rem; color: #4ecdc4;">📜 Recent Games</h3>
                <div id="gameHistory" class="history-list">
                    <div class="history-placeholder">
                        <p>No game history yet. Play some games to see your history!</p>
                    </div>
                </div>
            </div>

            <div class="achievements">
                <h3 style="margin-bottom: 1rem; color: #4ecdc4;">🏆 Achievements</h3>
                <div class="achievements-grid">
                    <div class="achievement-card earned">
                        <div class="achievement-icon">🥇</div>
                        <div class="achievement-info">
                            <div class="achievement-name">First Victory</div>
                            <div class="achievement-desc">Win your first game</div>
                        </div>
                    </div>
                    <div class="achievement-card earned">
                        <div class="achievement-icon">💎</div>
                        <div class="achievement-info">
                            <div class="achievement-name">High Roller</div>
                            <div class="achievement-desc">Stake 10+ CORE in a game</div>
                        </div>
                    </div>
                    <div class="achievement-card locked">
                        <div class="achievement-icon">🏆</div>
                        <div class="achievement-info">
                            <div class="achievement-name">Tournament Winner</div>
                            <div class="achievement-desc">Win a tournament</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function getChatHTML() {
    return `
        <div class="chat-section">
            <div class="chat-container">
                <h3 style="margin-bottom: 1rem;">💬 Global Chat</h3>
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input-container">
                    <input type="text" placeholder="Type your message..." id="chatInput" 
                           class="chat-input" onkeypress="handleChatKeyPress(event)" maxlength="200">
                    <button onclick="sendChatMessage()" class="chat-send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
                
                <div class="chat-rules">
                    <h5 style="color: #f39c12; margin-bottom: 0.5rem;">Chat Rules</h5>
                    <ul>
                        <li>Be respectful to all players</li>
                        <li>No spam or excessive messages</li>
                        <li>No sharing personal information</li>
                        <li>English language only</li>
                        <li>Violations may result in chat restrictions</li>
                    </ul>
                </div>
            </div>
        </div>
    `;
}

function getSettingsHTML() {
    return `
        <div class="settings-section">
            <h2 style="color: #4ecdc4; margin-bottom: 2rem;">⚙️ Platform Settings</h2>
            
            <div class="settings-groups">
                <div class="settings-group">
                    <h3>🎮 Game Settings</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Auto-join Games</h4>
                                <p>Automatically join games when available</p>
                            </div>
                            <div class="settings-toggle" id="autoJoinToggle" onclick="toggleSetting('autoJoin')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Sound Effects</h4>
                                <p>Enable game sound effects</p>
                            </div>
                            <div class="settings-toggle active" id="soundToggle" onclick="toggleSetting('sound')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Show Animations</h4>
                                <p>Enable board animations</p>
                            </div>
                            <div class="settings-toggle active" id="animationsToggle" onclick="toggleSetting('animations')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Default Stake Amount</h4>
                                <p>Set your preferred stake amount</p>
                            </div>
                            <input type="number" class="settings-input" id="defaultStake" placeholder="0.01" min="0.01" step="0.01" value="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>🔔 Notifications</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Game Invitations</h4>
                                <p>Notify when invited to games</p>
                            </div>
                            <div class="settings-toggle active" id="gameInvitesToggle" onclick="toggleSetting('gameInvites')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Transaction Updates</h4>
                                <p>Notify on blockchain transactions</p>
                            </div>
                            <div class="settings-toggle active" id="txNotificationsToggle" onclick="toggleSetting('txNotifications')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Chat Messages</h4>
                                <p>Notify on new chat messages</p>
                            </div>
                            <div class="settings-toggle" id="chatNotificationsToggle" onclick="toggleSetting('chatNotifications')"></div>
                        </div>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>🔒 Security & Privacy</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Auto-lock Wallet</h4>
                                <p>Automatically disconnect after inactivity</p>
                            </div>
                            <div class="settings-toggle active" id="autoLockToggle" onclick="toggleSetting('autoLock')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Session Timeout (minutes)</h4>
                                <p>Auto-disconnect time</p>
                            </div>
                            <input type="number" class="settings-input" id="sessionTimeout" placeholder="30" min="5" max="120" value="30">
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Hide Balance</h4>
                                <p>Hide wallet balance from others</p>
                            </div>
                            <div class="settings-toggle" id="hideBalanceToggle" onclick="toggleSetting('hideBalance')"></div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>⚡ Advanced</h3>
                    <div class="settings-items">
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Gas Price Priority</h4>
                                <p>Transaction speed preference</p>
                            </div>
                            <select class="settings-input" id="gasPriority">
                                <option value="slow">Slow (Low Fee)</option>
                                <option value="standard" selected>Standard</option>
                                <option value="fast">Fast (High Fee)</option>
                            </select>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Server-Side Validation</h4>
                                <p>Enable move validation on server</p>
                            </div>
                            <div class="settings-toggle active" id="serverValidationToggle" onclick="toggleSetting('serverValidation')"></div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="setting-info">
                                <h4>Anti-Bot Challenges</h4>
                                <p>Show verification challenges before games</p>
                            </div>
                            <div class="settings-toggle active" id="antiBotToggle" onclick="toggleSetting('antiBot')"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="settings-actions">
                <button class="settings-button" onclick="saveSettings()">
                    <i class="fas fa-save"></i> Save Settings
                </button>
                <button class="settings-button" onclick="resetSettings()">
                    <i class="fas fa-undo"></i> Reset to Default
                </button>
                <button class="settings-button" onclick="exportSettings()">
                    <i class="fas fa-download"></i> Export Settings
                </button>
                <button class="settings-button danger-button" onclick="clearAllData()">
                    <i class="fas fa-trash"></i> Clear All Data
                </button>
            </div>
        </div>
    `;
}

// ===========================
// GAMES DISPLAY & FILTERING
// ===========================

function updateGamesDisplay() {
    try {
        const gamesList = document.getElementById('gamesList');
        const noGames = document.getElementById('noGames');
        
        if (!gamesList || !noGames) return;
        
        // Separate real games from demo games
        const realGames = globalGamesList.filter(game => !game.isDemo && shouldShowGame(game));
        const demoGames = globalGamesList.filter(game => game.isDemo && shouldShowGame(game));
        
        if (realGames.length === 0 && demoGames.length === 0) {
            gamesList.innerHTML = '';
            noGames.classList.remove('hidden');
            return;
        }
        
        noGames.classList.add('hidden');
        
        let gamesHTML = '';
        
        // Connection status indicator
        gamesHTML += `
            <div class="connection-indicator-banner ${isConnectedToLobby ? 'connected' : 'disconnected'}">
                <i class="fas fa-wifi"></i> 
                ${isConnectedToLobby ? 'Connected to Real-Time Lobby' : 'Offline Mode - Games will sync when reconnected'}
            </div>
        `;
        
        // Show real games first
        if (realGames.length > 0) {
            gamesHTML += '<h4 class="games-section-title">🎮 Live Player Games</h4>';
            gamesHTML += realGames.map(game => createGameHTML(game)).join('');
        }
        
        // Show demo games separately
        if (demoGames.length > 0) {
            gamesHTML += '<h4 class="games-section-title demo">🤖 Demo Games (For Testing)</h4>';
            gamesHTML += demoGames.map(game => createGameHTML(game, true)).join('');
        }
        
        gamesList.innerHTML = gamesHTML;
    } catch (error) {
        logError(error, 'Games display update');
    }
}

function createGameHTML(game, isDemo = false) {
    try {
        const gameIcons = { chess: '♟️', checkers: '⚫', words: '📝' };
        const gameNames = { chess: 'Chess Masters', checkers: 'Checkers Pro', words: 'Word Battle' };
        
        const timeAgo = Math.floor((Date.now() - game.createdAt) / 60000);
        const creator = game.creator === userAccount ? 'You' : 
                       typeof game.creator === 'string' && game.creator.startsWith('0x') ? 
                       game.creator.substring(0, 6) + '...' + game.creator.substring(38) :
                       game.creator;
        
        const canJoin = userAccount && 
                       game.creator !== userAccount && 
                       game.status === 'waiting' && 
                       currentBalance >= game.stake;

        const skillBadgeClass = `skill-${game.skillLevel}`;
        const validationIcon = game.serverValidated ? 'validated' : 'pending-validation';
        const validationTitle = game.serverValidated ? 'Server Validated' : 'Client Validation Only';
        
        const demoTag = isDemo ? '<span class="demo-tag">DEMO</span>' : '';
        
        return `
            <div class="game-entry fade-in ${isDemo ? 'demo-game' : ''}">
                <div class="game-header">
                    <div class="game-title">
                        ${gameIcons[game.type]} ${gameNames[game.type]} #${game.id}
                        <span class="skill-badge ${skillBadgeClass}">${game.skillLevel.toUpperCase()}</span>
                        <span class="validation-status ${validationIcon}" title="${validationTitle}">
                            ${game.serverValidated ? '✓' : '⏳'}
                        </span>
                        ${demoTag}
                    </div>
                    <div class="game-status ${game.status === 'waiting' ? 'status-waiting' : 'status-playing'}">
                        ${game.status.toUpperCase()}
                    </div>
                </div>
                
                <div class="game-details">
                    <div class="detail-item">
                        <div class="detail-label">Creator</div>
                        <div class="detail-value">${creator}</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Stake</div>
                        <div class="detail-value">${game.stake} CORE</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Time Control</div>
                        <div class="detail-value">${game.timeControl || 'Standard'}</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Created</div>
                        <div class="detail-value">${timeAgo}m ago</div>
                    </div>
                </div>
                
                ${getGameActionButton(game, canJoin, isDemo)}
            </div>
        `;
    } catch (error) {
        logError(error, 'Creating game HTML');
        return '';
    }
}

function getGameActionButton(game, canJoin, isDemo) {
    if (canJoin) {
        return `
            <button class="join-btn" onclick="joinGame(${game.id}, ${game.stake})">
                <i class="fas fa-sword"></i> Join Game (${game.stake} CORE)
            </button>
        `;
    } else if (game.creator === userAccount) {
        return `
            <button class="join-btn waiting" disabled>
                <i class="fas fa-clock"></i> Waiting for Opponent
            </button>
        `;
    } else if (!userAccount) {
        return `
            <button class="join-btn disabled" disabled>
                <i class="fas fa-wallet"></i> Connect Wallet to Join
            </button>
        `;
    } else if (currentBalance < game.stake) {
        return `
            <button class="join-btn disabled" disabled>
                <i class="fas fa-coins"></i> Insufficient Balance
            </button>
        `;
    } else if (isDemo) {
        return `
            <button class="join-btn demo" onclick="joinGame(${game.id}, ${game.stake})">
                <i class="fas fa-play"></i> Try Demo Game
            </button>
        `;
    } else {
        return `
            <button class="join-btn disabled" disabled>
                <i class="fas fa-users"></i> Game Full
            </button>
        `;
    }
}

function applySkillFilter() {
    try {
        const skillFilterEl = document.getElementById('skillFilter');
        if (skillFilterEl) {
            currentSkillFilter = skillFilterEl.value;
            updateGamesDisplay();
            showTransactionStatus(`🎯 Filter applied: ${currentSkillFilter} skill level`, '');
        }
    } catch (error) {
        logError(error, 'Skill filter application');
    }
}

// ===========================
// GAME CREATION FUNCTIONS
// ===========================

function selectGameType(type) {
    try {
        selectedGameType = type;
        
        // Update UI
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        const selectedCard = document.querySelector(`[data-type="${type}"]`);
        if (selectedCard) {
            selectedCard.classList.add('selected');
        }
        
        updateCreateButton();
    } catch (error) {
        logError(error, 'Game type selection');
    }
}

function updateCreateButton() {
    try {
        const btn = document.getElementById('createGameBtn');
        const stakeInput = document.getElementById('gameStake');
        
        if (!btn || !stakeInput) return;
        
        const stake = parseFloat(stakeInput.value);
        
        if (selectedGameType && stake >= 0.01) {
            btn.disabled = false;
            btn.innerHTML = `<i class="fas fa-plus"></i> Create ${selectedGameType.toUpperCase()} Game (${stake} CORE)`;
        } else if (selectedGameType && !stake) {
            btn.disabled = true;
            btn.innerHTML = `<i class="fas fa-plus"></i> Enter Stake Amount`;
        } else if (!selectedGameType && stake >= 0.01) {
            btn.disabled = true;
            btn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type`;
        } else {
            btn.disabled = true;
            btn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type & Enter Stake`;
        }
    } catch (error) {
        logError(error, 'Create button update');
    }
}

async function createGame() {
    try {
        const stakeInput = document.getElementById('gameStake');
        if (!stakeInput) {
            showTransactionStatus('❌ Stake input not found', '');
            return;
        }
        
        const stakeAmount = parseFloat(stakeInput.value);
        
        if (!validateStakeAndWallet(stakeAmount) || !selectedGameType) {
            return;
        }
        
        const gameId = await createGameOnChain(selectedGameType, stakeAmount);
        
        // Add to local games list
        const newGame = {
            id: gameId,
            type: selectedGameType,
            creator: userAccount,
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now()
        };
        
        activeGames.push(newGame);
        
        addActivityFeedItem(`🎮 You created a ${selectedGameType} game with ${stakeAmount} CORE stake`);
        
        // Clear form
        stakeInput.value = '';
        selectedGameType = null;
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        updateCreateButton();
        
        // Switch to lobby to see the created game
        showSection('lobby');
        
        // Update balance
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
    } catch (error) {
        logError(error, 'Game creation');
        showTransactionStatus('❌ Failed to create game: ' + error.message, '');
    }
}

// Individual game creation functions
async function createChessGame() {
    try {
        const stakeInput = document.getElementById('chessStake');
        if (!stakeInput) return;
        
        const stakeAmount = parseFloat(stakeInput.value);
        if (!validateStakeAndWallet(stakeAmount)) return;
        
        showTransactionStatus('🔄 Creating Chess game...', '');
        
        const gameId = await createGameOnChain('chess', stakeAmount);
        
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        updateGamesDisplay();
        
        stakeInput.value = '';
        
    } catch (error) {
        logError(error, 'Chess game creation');
        showTransactionStatus('❌ Failed to create Chess game: ' + error.message, '');
    }
}

async function createCheckersGame() {
    try {
        const stakeInput = document.getElementById('checkersStake');
        if (!stakeInput) return;
        
        const stakeAmount = parseFloat(stakeInput.value);
        if (!validateStakeAndWallet(stakeAmount)) return;
        
        showTransactionStatus('🔄 Creating Checkers game...', '');
        
        const gameId = await createGameOnChain('checkers', stakeAmount);
        
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        updateGamesDisplay();
        
        stakeInput.value = '';
        
    } catch (error) {
        logError(error, 'Checkers game creation');
        showTransactionStatus('❌ Failed to create Checkers game: ' + error.message, '');
    }
}

async function createWordGame() {
    try {
        const stakeInput = document.getElementById('wordStake');
        if (!stakeInput) return;
        
        const stakeAmount = parseFloat(stakeInput.value);
        if (!validateStakeAndWallet(stakeAmount)) return;
        
        showTransactionStatus('🔄 Creating Word game...', '');
        
        const gameId = await createGameOnChain('words', stakeAmount);
        
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        updateGamesDisplay();
        
        stakeInput.value = '';
        
    } catch (error) {
        logError(error, 'Word game creation');
        showTransactionStatus('❌ Failed to create Word game: ' + error.message, '');
    }
}

// ===========================
// CHAT SYSTEM
// ===========================

function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendChatMessage();
    }
}

function sendChatMessage() {
    try {
        const input = document.getElementById('chatInput');
        if (!input || !input.value.trim()) return;
        
        const message = input.value.trim();
        const sender = userAccount ? 
            userAccount.substring(0, 6) + '...' + userAccount.substring(38) : 
            'Anonymous';
        
        addChatMessage(sender, message);
        input.value = '';
    } catch (error) {
        logError(error, 'Sending chat message');
    }
}

function addChatMessage(sender, message) {
    try {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message fade-in';
            messageDiv.innerHTML = `
                <span class="chat-sender">${sender}:</span>
                <span class="chat-text">${message}</span>
                <span class="chat-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            `;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Keep only last 50 messages
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }
    } catch (error) {
        logError(error, 'Adding chat message');
    }
}

function initializeGlobalChat() {
    try {
        // Add initial chat messages if empty
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages && chatMessages.children.length === 0) {
            addChatMessage('System', 'Welcome to CrossRealm! Connect your wallet to start playing.');
            addChatMessage('CryptoKing', 'Just won 2.5 CORE in Chess! 🎉');
            addChatMessage('GameMaster', 'New high stakes games available!');
            addChatMessage('WordWizard', 'Word battles are intense here! 📝');
            addChatMessage('AntiBotGuard', 'All games are protected against bots! 🛡️');
        }
    } catch (error) {
        logError(error, 'Chat initialization');
    }
}

// ===========================
// GAME WINDOW MANAGEMENT
// ===========================

function openGameWindow(gameType) {
    try {
        console.log('Opening game window for:', gameType);
        
        setGameActive(gameType, true);
        gameIsMinimized = false;
        
        // Hide other game windows
        document.querySelectorAll('.game-window').forEach(w => w.classList.add('hidden'));
        const overlay = document.getElementById('gameOverlay');
        if (overlay) {
            overlay.classList.remove('hidden', 'minimized');
        }
        
        const windowId = gameType + 'GameWindow';
        const gameWindow = document.getElementById(windowId);
        if (gameWindow) {
            gameWindow.classList.remove('hidden', 'minimized');
            
            // Initialize the appropriate game
            setTimeout(() => {
                switch(gameType) {
                    case 'chess':
                        initializeChessGame();
                        break;
                    case 'checkers':
                        initializeCheckersGame();
                        break;
                    case 'word':
                        initializeWordGame();
                        break;
                }
            }, 100);
        }
    } catch (error) {
        logError(error, 'Opening game window');
    }
}

function closeGame(gameType) {
    try {
        const windowId = gameType + 'GameWindow';
        const gameWindow = document.getElementById(windowId);
        if (gameWindow) {
            gameWindow.classList.add('hidden');
        }
        const overlay = document.getElementById('gameOverlay');
        if (overlay) {
            overlay.classList.add('hidden');
        }
        
        setGameActive(gameType, false);
        gameIsMinimized = false;
        
        // Reset game states
        if (gameType === 'chess') {
            chessGameState.gameActive = false;
        } else if (gameType === 'checkers') {
            checkersGameState.gameActive = false;
        } else if (gameType === 'word') {
            wordGameState.gameActive = false;
            if (wordGameState.timer) {
                clearInterval(wordGameState.timer);
            }
        }
        
        // Clear multiplayer session
        if (multiplayerSession && multiplayerSession.gameType === gameType) {
            multiplayerSession = null;
        }
    } catch (error) {
        logError(error, 'Closing game');
    }
}

function minimizeGame(gameType) {
    try {
        const windowId = gameType + 'GameWindow';
        const gameWindow = document.getElementById(windowId);
        const overlay = document.getElementById('gameOverlay');
        
        if (gameWindow) {
            const isMinimized = gameWindow.classList.contains('minimized');
            
            if (isMinimized) {
                // Restore game
                gameWindow.classList.remove('minimized');
                if (overlay) {
                    overlay.classList.remove('hidden', 'minimized');
                }
                gameIsMinimized = false;
                setGameActive(gameType, true);
            } else {
                // Minimize game
                gameWindow.classList.add('minimized');
                if (overlay) {
                    overlay.classList.add('hidden', 'minimized');
                }
                gameIsMinimized = true;
                setGameActive(gameType, true);
            }
        }
    } catch (error) {
        logError(error, 'Minimizing game');
    }
}

// ===========================
// GAME CHAT FUNCTIONS
// ===========================

function handleGameChatKeyPress(event, gameType) {
    if (event.key === 'Enter') {
        sendGameChatMessage(gameType);
    }
}

function sendGameChatMessage(gameType) {
    try {
        const input = document.getElementById(gameType + 'ChatInput');
        if (!input || !input.value.trim()) return;
        
        const message = input.value.trim();
        addGameChatMessage(gameType, 'You', message);
        input.value = '';
    } catch (error) {
        logError(error, 'Sending game chat message');
    }
}

function addGameChatMessage(gameType, sender, message) {
    try {
        const chatContainer = document.getElementById(gameType + 'GameChat');
        if (chatContainer) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'game-chat-message slide-in';
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Keep only last 20 messages
            while (chatContainer.children.length > 20) {
                chatContainer.removeChild(chatContainer.firstChild);
            }
        }
    } catch (error) {
        logError(error, 'Adding game chat message');
    }
}

// ===========================
// SETTINGS MANAGEMENT
// ===========================

function loadSettingsUI() {
    try {
        // Update UI toggles to match current settings
        Object.keys(platformSettings).forEach(key => {
            const toggle = document.getElementById(key + 'Toggle');
            if (toggle) {
                if (platformSettings[key]) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
            
            // Update inputs
            const input = document.getElementById(key);
            if (input && typeof platformSettings[key] !== 'boolean') {
                input.value = platformSettings[key];
            }
        });
    } catch (error) {
        logError(error, 'Loading settings UI');
    }
}

function toggleSetting(setting) {
    try {
        platformSettings[setting] = !platformSettings[setting];
        
        const toggle = document.getElementById(setting + 'Toggle');
        if (toggle) {
            if (platformSettings[setting]) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
        }
        
        // Apply setting immediately
        applySetting(setting, platformSettings[setting]);
    } catch (error) {
        logError(error, 'Toggling setting');
    }
}

function resetSettings() {
    try {
        if (confirm('Are you sure you want to reset all settings to default?')) {
            platformSettings = {
                autoJoin: false,
                sound: true,
                animations: true,
                defaultStake: 0.1,
                gameInvites: true,
                txNotifications: true,
                chatNotifications: false,
                autoLock: true,
                sessionTimeout: 30,
                hideBalance: false,
                gasPriority: 'standard',
                rpcEndpoint: 'https://rpc.coredao.org',
                developerMode: false,
                serverValidation: true,
                antiBot: true,
                randomnessSource: 'chainlink'
            };
            
            try {
                localStorage.removeItem('crossrealm_settings');
            } catch (error) {
                console.log('Failed to clear settings:', error);
            }
            
            loadSettingsUI();
            showTransactionStatus('✅ Settings reset to default', '');
        }
    } catch (error) {
        logError(error, 'Resetting settings');
    }
}

function exportSettings() {
    try {
        const dataStr = JSON.stringify(platformSettings, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'crossrealm_settings.json';
        link.click();
        URL.revokeObjectURL(url);
        showTransactionStatus('✅ Settings exported', '');
    } catch (error) {
        logError(error, 'Exporting settings');
        showTransactionStatus('❌ Failed to export settings', '');
    }
}

function clearAllData() {
    try {
        if (confirm('⚠️ This will delete ALL your data including settings, game history, and cached information. This action cannot be undone. Are you sure?')) {
            try {
                localStorage.clear();
                sessionStorage.clear();
            } catch (error) {
                console.log('Failed to clear data:', error);
            }
            
            // Reset variables
            playerStats = { gamesPlayed: 0, gamesWon: 0, totalEarned: 0, winRate: 0 };
            resetSettings();
            
            showTransactionStatus('✅ All data cleared', '');
            
            // Refresh the page
            setTimeout(() => location.reload(), 2000);
        }
    } catch (error) {
        logError(error, 'Clearing all data');
    }
}

// ===========================
// HELPER FUNCTIONS
// ===========================

function loadGameHistory() {
    try {
        const historyContainer = document.getElementById('gameHistory');
        if (!historyContainer) return;
        
        // Show placeholder for now
        historyContainer.innerHTML = `
            <div class="history-placeholder">
                <i class="fas fa-history" style="font-size: 2rem; opacity: 0.5; margin-bottom: 1rem;"></i>
                <p>No game history yet. Play some games to see your history!</p>
            </div>
        `;
    } catch (error) {
        logError(error, 'Loading game history');
    }
}

function loadCreateGameUI() {
    // Reset form state
    selectedGameType = null;
    document.querySelectorAll('.game-type-card').forEach(card => {
        card.classList.remove('selected');
    });
    updateCreateButton();
}

function loadGamesUI() {
    // No specific initialization needed
}

function loadTournamentsUI() {
    // Update tournament timers
    updateTournamentTimers();
}

// Footer helper functions
function showHelp() {
    showTransactionStatus('📖 Opening help center...', '');
}

function showTerms() {
    showTransactionStatus('📋 Opening terms of service...', '');
}

function showPrivacy() {
    showTransactionStatus('🔒 Opening privacy policy...', '');
}

function showFairPlay() {
    showTransactionStatus('⚖️ Opening fair play policy...', '');
}

// ===========================
// INITIALIZATION & EVENT HANDLING
// ===========================

// Initialize platform when page loads
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('🎮 Enhanced CrossRealm Multiplayer Platform Loading...');
        
        await measureAsyncPerformance('Platform Initialization', initializePlatform);
        
        // Attach event listeners safely
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const transactionStatus = document.getElementById('transactionStatus');
        
        if (connectBtn) {
            connectBtn.addEventListener('click', connectWallet);
        }
        
        if (disconnectBtn) {
            disconnectBtn.addEventListener('click', disconnectWallet);
        }
        
        if (transactionStatus) {
            transactionStatus.addEventListener('click', () => {
                transactionStatus.classList.remove('show');
            });
        }
        
        console.log('🚀 Enhanced CrossRealm Platform Ready with ALL Features!');
        
    } catch (error) {
        logError(error, 'Platform initialization');
        showTransactionStatus('❌ Platform initialization failed. Retrying...', '');
        
        // Retry initialization once
        setTimeout(() => {
            try {
                initializePlatform();
            } catch (retryError) {
                logError(retryError, 'Platform initialization retry');
            }
        }, 3000);
    }
});

console.log('✅ UI Components & Section Management Loaded Successfully');
</script>

<style>
/* ===========================
   UI COMPONENTS & SECTION STYLES
   =========================== */

/* Section Content Styles */
.section-content {
    min-height: 400px;
}

/* Create Game Styles */
.create-game-section {
    max-width: 800px;
    margin: 0 auto;
}

.game-type-selector {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.game-type-card {
    background: var(--glass);
    border: 2px solid var(--glass-border);
    border-radius: 15px;
    padding: 1.5rem;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
}

.game-type-card:hover {
    border-color: var(--accent);
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
}

.game-type-card.selected {
    border-color: var(--accent);
    background: rgba(78, 205, 196, 0.1);
    box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
}

.game-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
}

.stake-input, .setting-select, .form-input {
    width: 100%;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 8px;
    padding: 0.8rem;
    color: white;
    font-size: 1rem;
    margin: 0.5rem 0;
    transition: all 0.3s ease;
}

.stake-input:focus, .setting-select:focus, .form-input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
}

.advanced-settings {
    background: var(--glass);
    border-radius: 10px;
    padding: 1.5rem;
    margin: 1rem 0;
    border: 1px solid var(--glass-border);
}

.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
}

/* Games Showcase Styles */
.games-showcase {
    max-width: 1000px;
    margin: 0 auto;
}

.games-header {
    text-align: center;
    margin-bottom: 2rem;
}

.info-banner {
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin: 1rem 0;
}

.legal-notice {
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    border-radius: 10px;
    padding: 1.5rem;
    margin: 2rem 0;
}

.legal-notice ul {
    list-style: none;
    padding: 0;
}

.legal-notice li {
    margin: 0.5rem 0;
    padding-left: 1rem;
}

.legal-notice li::before {
    content: '•';
    color: var(--accent);
    margin-right: 0.5rem;
}

.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 2rem;
    margin: 2rem 0;
}

.game-showcase-card {
    background: var(--glass);
    border: 2px solid var(--glass-border);
    border-radius: 15px;
    padding: 1.5rem;
    transition: all 0.3s ease;
}

.game-showcase-card:hover {
    border-color: var(--accent);
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
}

.game-card-header {
    margin-bottom: 1rem;
}

.game-stats {
    display: flex;
    gap: 1rem;
    margin: 0.5rem 0;
    font-size: 0.9rem;
}

.stat {
    color: var(--accent);
}

.features-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin: 1rem 0;
}

.feature {
    background: rgba(78, 205, 196, 0.2);
    border: 1px solid rgba(78, 205, 196, 0.4);
    border-radius: 15px;
    padding: 0.3rem 0.8rem;
    font-size: 0.8rem;
    color: var(--accent);
}

.game-action-btn {
    width: 100%;
    background: linear-gradient(45deg, var(--primary), var(--secondary));
    border: none;
    padding: 1rem;
    border-radius: 10px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    margin-top: 1rem;
}

.game-action-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(78, 84, 200, 0.4);
}

.coming-soon {
    background: var(--glass);
    border-radius: 15px;
    padding: 2rem;
    text-align: center;
    margin-top: 3rem;
    border: 1px solid var(--glass-border);
}

.upcoming-games {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.upcoming-game {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--glass-border);
    border-radius: 8px;
    padding: 1rem;
    color: #aaa;
}

/* Tournament Styles */
.tournament-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin: 2rem 0;
}

.tournament-card {
    background: var(--glass);
    border: 2px solid var(--accent);
    border-radius: 15px;
    padding: 1.5rem;
    transition: all 0.3s ease;
}

.tournament-card:hover {
    box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
    transform: translateY(-2px);
}

.tournament-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--glass-border);
    flex-wrap: wrap;
    gap: 1rem;
}

.tournament-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--accent);
}

.tournament-prize {
    font-size: 1.1rem;
    font-weight: bold;
    color: var(--secondary);
}

.tournament-info {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 1rem 0;
}

.tournament-detail {
    text-align: center;
}

.detail-label {
    font-size: 0.8rem;
    color: #aaa;
    margin-bottom: 0.25rem;
}

.detail-value {
    font-size: 1rem;
    font-weight: bold;
    color: white;
}

.tournament-bracket {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin: 1rem 0;
}

.tournament-bracket h4 {
    color: var(--accent);
    margin-bottom: 1rem;
    text-align: center;
}

.bracket-rounds {
    display: flex;
    gap: 1rem;
    overflow-x: auto;
}

.bracket-round {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    min-width: 150px;
}

.bracket-match {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 5px;
    padding: 0.5rem;
    text-align: center;
    font-size: 0.8rem;
    white-space: nowrap;
}

.create-tournament {
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 15px;
    padding: 2rem;
    margin-top: 2rem;
}

.tournament-form {
    margin: 1.5rem 0;
}

.form-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
}

.form-group {
    display: flex;
    flex-direction: column;
}

.form-group label {
    color: var(--accent);
    margin-bottom: 0.5rem;
    font-weight: bold;
}

/* Profile Styles */
.profile-section {
    max-width: 800px;
    margin: 0 auto;
}

.profile-header {
    display: flex;
    align-items: center;
    gap: 2rem;
    background: var(--glass);
    border-radius: 15px;
    padding: 2rem;
    margin-bottom: 2rem;
    border: 1px solid var(--glass-border);
}

.profile-avatar {
    font-size: 4rem;
    color: var(--accent);
}

.profile-info h2 {
    color: var(--accent);
    margin-bottom: 0.5rem;
}

.wallet-address {
    font-family: monospace;
    color: #aaa;
    font-size: 0.9rem;
}

.profile-stats, .skill-ratings, .game-history, .achievements {
    background: var(--glass);
    border-radius: 15px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    border: 1px solid var(--glass-border);
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
}

.stat-card {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    text-align: center;
    border: 1px solid var(--glass-border);
}

.stat-card .stat-value {
    font-size: 2rem;
    font-weight: bold;
    color: var(--accent);
    display: block;
}

.stat-card .stat-label {
    font-size: 0.9rem;
    color: #aaa;
    margin-top: 0.5rem;
}

.ratings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
}

.rating-card {
    display: flex;
    align-items: center;
    gap: 1rem;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    border: 1px solid var(--glass-border);
}

.rating-icon {
    font-size: 2rem;
}

.rating-level {
    font-weight: bold;
    margin-bottom: 0.25rem;
}

.rating-level.gold { color: #ffd700; }
.rating-level.silver { color: #c0c0c0; }
.rating-level.bronze { color: #cd7f32; }

.rating-points {
    color: #aaa;
    font-size: 0.9rem;
}

.history-list {
    min-height: 200px;
}

.history-placeholder {
    text-align: center;
    padding: 3rem;
    color: #aaa;
}

.achievements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
}

.achievement-card {
    display: flex;
    align-items: center;
    gap: 1rem;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    border: 1px solid var(--glass-border);
    transition: all 0.3s ease;
}

.achievement-card.earned {
    border-color: var(--accent);
    background: rgba(78, 205, 196, 0.1);
}

.achievement-card.locked {
    opacity: 0.5;
}

.achievement-icon {
    font-size: 2rem;
}

.achievement-name {
    font-weight: bold;
    color: var(--accent);
    margin-bottom: 0.25rem;
}

.achievement-desc {
    color: #aaa;
    font-size: 0.9rem;
}

/* Chat Styles */
.chat-section {
    max-width: 600px;
    margin: 0 auto;
}

.chat-container {
    background: var(--glass);
    border-radius: 15px;
    padding: 1.5rem;
    border: 1px solid var(--glass-border);
    height: 500px;
    display: flex;
    flex-direction: column;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 1rem;
    border: 1px solid var(--glass-border);
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.5) transparent;
}

.chat-messages::-webkit-scrollbar {
    width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
}

.chat-messages::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.5);
    border-radius: 3px;
}

.chat-message {
    margin-bottom: 0.5rem;
    padding: 0.5rem;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    border-left: 3px solid var(--accent);
    animation: slideIn 0.3s ease-out;
}

.chat-sender {
    color: var(--secondary);
    font-weight: bold;
}

.chat-text {
    color: white;
    margin-left: 0.5rem;
}

.chat-time {
    color: #aaa;
    font-size: 0.7rem;
    float: right;
}

.chat-input-container {
    display: flex;
    gap: 0.5rem;
}

.chat-input {
    flex: 1;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 25px;
    padding: 0.8rem 1rem;
    color: white;
    font-size: 1rem;
}

.chat-input:focus {
    outline: none;
    border-color: var(--accent);
}

.chat-send-btn {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    border-radius: 50%;
    width: 45px;
    height: 45px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chat-send-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
}

.chat-rules {
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1rem;
}

.chat-rules ul {
    list-style: none;
    padding: 0;
    margin: 0.5rem 0 0;
}

.chat-rules li {
    margin: 0.25rem 0;
    font-size: 0.8rem;
    color: #aaa;
}

.chat-rules li::before {
    content: '•';
    color: var(--accent);
    margin-right: 0.5rem;
}

/* Settings Styles */
.settings-section {
    max-width: 800px;
    margin: 0 auto;
}

.settings-groups {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.settings-group {
    background: var(--glass);
    border-radius: 15px;
    padding: 1.5rem;
    border: 1px solid var(--glass-border);
}

.settings-group h3 {
    color: var(--secondary);
    margin-bottom: 1rem;
    font-size: 1.2rem;
    border-bottom: 1px solid var(--glass-border);
    padding-bottom: 0.5rem;
}

.settings-items {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.settings-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    border: 1px solid var(--glass-border);
    gap: 1rem;
}

.setting-info {
    flex: 1;
}

.setting-info h4 {
    color: var(--accent);
    margin-bottom: 0.25rem;
}

.setting-info p {
    color: #aaa;
    font-size: 0.9rem;
    margin: 0;
}

.settings-toggle {
    width: 50px;
    height: 25px;
    background: #666;
    border-radius: 25px;
    position: relative;
    cursor: pointer;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.settings-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 21px;
    height: 21px;
    background: white;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.settings-toggle.active {
    background: var(--accent);
}

.settings-toggle.active::after {
    transform: translateX(25px);
}

.settings-input {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 5px;
    padding: 0.5rem;
    color: white;
    min-width: 150px;
    flex-shrink: 0;
}

.settings-input:focus {
    outline: none;
    border-color: var(--accent);
}

.settings-actions {
    display: flex;
    gap: 1rem;
    margin-top: 2rem;
    flex-wrap: wrap;
    justify-content: center;
}

.settings-button {
    background: linear-gradient(45deg, var(--accent), var(--accent-dark));
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 10px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.settings-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
}

.settings-button.danger-button {
    background: linear-gradient(45deg, var(--danger), #c0392b);
}

.settings-button.danger-button:hover {
    box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
}

/* Game Display Styles */
.connection-indicator-banner {
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    border-radius: 5px;
    padding: 0.5rem;
    margin-bottom: 1rem;
    text-align: center;
    color: #f1c40f;
    transition: all 0.3s ease;
}

.connection-indicator-banner.connected {
    background: rgba(0, 255, 136, 0.1);
    border-color: rgba(0, 255, 136, 0.3);
    color: #00ff88;
}

.games-section-title {
    color: var(--accent);
    margin: 1rem 0;
    font-size: 1.1rem;
    border-bottom: 1px solid var(--glass-border);
    padding-bottom: 0.5rem;
}

.games-section-title.demo {
    color: #aaa;
    font-size: 0.9rem;
}

.game-entry {
    background: var(--glass);
    border: 2px solid var(--glass-border);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 1rem;
    transition: all 0.3s ease;
}

.game-entry:hover {
    border-color: var(--accent);
    box-shadow: 0 5px 15px rgba(78, 205, 196, 0.2);
}

.game-entry.demo-game {
    opacity: 0.7;
    border-color: #666;
}

.game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.game-title {
    font-weight: bold;
    color: var(--accent);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.game-status {
    padding: 0.3rem 0.8rem;
    border-radius: 15px;
    font-size: 0.8rem;
    font-weight: bold;
}

.status-waiting {
    background: rgba(255, 193, 7, 0.3);
    color: #f1c40f;
}

.status-playing {
    background: rgba(46, 204, 113, 0.3);
    color: #2ecc71;
}

.demo-tag {
    background: #666;
    color: #ccc;
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    font-size: 0.7rem;
}

.game-details {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
}

.detail-item {
    text-align: center;
}

.join-btn.waiting {
    background: #666;
    color: #999;
}

.join-btn.disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
}

.join-btn.demo {
    background: linear-gradient(45deg, #666, #777);
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
    .tournament-cards,
    .games-grid {
        grid-template-columns: 1fr;
    }
    
    .tournament-header {
        flex-direction: column;
        text-align: center;
    }
    
    .tournament-info {
        grid-template-columns: 1fr;
        gap: 0.5rem;
    }
    
    .bracket-rounds {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .bracket-match {
        min-width: 100%;
    }
    
    .form-row {
        grid-template-columns: 1fr;
    }
    
    .profile-header {
        flex-direction: column;
        text-align: center;
    }
    
    .stats-grid,
    .ratings-grid,
    .achievements-grid {
        grid-template-columns: 1fr;
    }
    
    .settings-item {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
    }
    
    .settings-actions {
        flex-direction: column;
    }
    
    .game-details {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
    }
    
    .detail-item {
        font-size: 0.9rem;
    }
}

@media (max-width: 480px) {
    .game-type-selector {
        grid-template-columns: 1fr;
    }
    
    .advanced-settings .settings-grid {
        grid-template-columns: 1fr;
    }
    
    .chat-container {
        height: 400px;
        padding: 1rem;
    }
    
    .profile-avatar {
        font-size: 3rem;
    }
    
    .game-details {
        grid-template-columns: 1fr;
    }
}

/* Performance optimizations */
.game-entry,
.tournament-card,
.game-showcase-card,
.achievement-card,
.settings-item {
    will-change: transform, box-shadow;
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
    .game-entry,
    .tournament-card,
    .game-showcase-card,
    .chat-message {
        animation: none !important;
        transition-duration: 0.01ms !important;
    }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
    .game-entry,
    .tournament-card,
    .settings-item {
        border-width: 3px;
    }
    
    .settings-toggle {
        border: 2px solid white;
    }
}

/* Print styles */
@media print {
    .settings-section,
    .profile-section {
        background: white;
        color: black;
    }
    
    .game-entry,
    .tournament-card {
        border: 1px solid black;
        background: white;
    }
}
</body>
</html>
