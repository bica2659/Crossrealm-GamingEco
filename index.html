<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypticus - Live Blockchain Gaming Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #4e54c8;
            --primary-dark: #363a9e;
            --secondary: #f39c12;
            --dark: #1a1c2c;
            --light: #f5f7fa;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f1c40f;
            --gray: #95a5a6;
            --accent: #4ecdc4;
        }

        html, body {
            height: 100%;
            overflow-x: hidden;
        }

        body {
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            color: var(--light);
            position: relative;
        }

        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://images.unsplash.com/photo-1620336655052-b57986f5a26a?q=80&w=1920') no-repeat center center;
            background-size: cover;
            opacity: 0.1;
            z-index: -1;
        }

        /* Header Styles */
        .header {
            position: relative;
            z-index: 100;
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-height: 80px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.8rem;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .logo-icon {
            font-size: 2.5rem;
            color: var(--secondary);
        }

        .nav-menu {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-item {
            padding: 0.5rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(78, 205, 196, 0.5);
        }

        .nav-item.active {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .live-badge {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .wallet-info {
            text-align: right;
        }

        .connection-status {
            font-size: 0.9rem;
            color: #ff6b6b;
        }

        .balance {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .connect-btn, .disconnect-btn {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .disconnect-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            margin-left: 0.5rem;
        }

        .connect-btn:hover, .disconnect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
        }

        .hidden {
            display: none;
        }

        /* Connection Status Indicators */
        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .connected {
            background: #00ff88;
            animation: pulse 2s infinite;
        }

        .disconnected {
            background: #ff6b6b;
        }

        .pending {
            background: #f1c40f;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Main Layout */
        .main-container {
            display: flex;
            min-height: calc(100vh - 80px);
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        /* Enhanced Game Lobby Styles */
        .live-lobby {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .lobby-stats {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }
    </style>
</head>
<style>
        /* Game Entry Styles */
        .game-entry {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1));
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .game-entry::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .game-entry:hover::before {
            left: 100%;
        }

        .game-entry:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .game-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent);
        }

        .game-status {
            padding: 0.2rem 0.8rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-waiting {
            background: linear-gradient(45deg, #f1c40f, #f39c12);
            color: #000;
        }

        .status-playing {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .game-details {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .detail-item {
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .detail-label {
            color: #aaa;
            font-size: 0.8rem;
        }

        .detail-value {
            font-weight: bold;
            margin-top: 0.2rem;
        }

        .join-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border: none;
            padding: 0.8rem;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .join-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 255, 136, 0.3);
        }

        .join-btn:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Smart Contract Status */
        .contract-status {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .contract-address {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            border-radius: 5px;
            margin: 0.5rem 0;
            word-break: break-all;
        }

        /* Transaction Status */
        .transaction-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--accent);
            border-radius: 10px;
            padding: 1rem;
            max-width: 350px;
            z-index: 2000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            word-wrap: break-word;
        }

        .transaction-status.show {
            transform: translateX(0);
        }

        .tx-hash {
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            color: var(--accent);
            margin-top: 0.5rem;
            cursor: pointer;
        }

        /* Game Creation Styles */
        .create-game-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .game-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .game-type-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-type-card:hover, .game-type-card.selected {
            border-color: var(--accent);
            background: rgba(78, 205, 196, 0.1);
            transform: translateY(-3px);
        }

        .game-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .stake-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
            color: white;
            font-size: 1.1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .stake-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .create-btn {
            width: 100%;
            background: linear-gradient(45deg, #ff6b6b, var(--accent));
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .create-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(255, 107, 107, 0.3);
        }

        .create-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ff88);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Copy Button */
        .copy-btn {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 0.3rem 0.6rem;
            color: var(--accent);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            margin-left: 0.5rem;
        }

        .copy-btn:hover {
            background: rgba(78, 205, 196, 0.3);
        }

        /* Age Verification Modal */
        .age-verification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
        }

        .verification-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            position: relative;
            z-index: 10000;
        }

        .verification-content h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: var(--secondary);
        }

        .verification-content p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: var(--light);
        }

        .verification-content .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid var(--danger);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            text-align: left;
        }

        .verification-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .verify-btn {
            padding: 1rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-width: 120px;
        }

        .verify-btn.accept {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .verify-btn.decline {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .verify-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
    <style>
        /* Game Window Styles */
        .game-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 1.5rem;
            z-index: 1000;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            min-width: 600px;
        }

        .game-window.minimized {
            top: auto;
            bottom: 20px;
            right: 20px;
            left: auto;
            transform: none;
            width: 300px;
            height: 60px;
            overflow: hidden;
            cursor: pointer;
        }

        .game-window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-window-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .game-window-controls {
            display: flex;
            gap: 0.5rem;
        }

        .window-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .window-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .minimize-btn {
            background: rgba(255, 193, 7, 0.3);
        }

        .close-btn {
            background: rgba(220, 53, 69, 0.3);
        }

        .game-window-content {
            display: block;
        }

        .game-window.minimized .game-window-content {
            display: none;
        }

        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
        }

        /* Chess & Checkers Board Styles */
        .chess-board, .checkers-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 3px solid var(--accent);
            border-radius: 10px;
            margin: 1rem auto;
            background: #f4f4f4;
        }

        .chess-square, .checkers-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .chess-square.white, .checkers-square.light {
            background: #f0d9b5;
        }

        .chess-square.black, .checkers-square.dark {
            background: #b58863;
        }

        .chess-square.selected {
            background: #ff6b6b !important;
            box-shadow: inset 0 0 10px rgba(255, 107, 107, 0.5);
        }

        .chess-square.possible-move {
            background: rgba(78, 205, 196, 0.3) !important;
        }

        .chess-square.possible-move::after {
            content: '●';
            color: var(--accent);
            position: absolute;
            font-size: 1rem;
        }

        .checker-piece {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 2px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .red-piece {
            background: radial-gradient(circle, #ff4444, #cc0000);
        }

        .black-piece {
            background: radial-gradient(circle, #444444, #000000);
        }

        .checker-piece.king::after {
            content: '♔';
            position: absolute;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Game Status & Controls */
        .game-status {
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .game-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .game-btn {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .game-over-message {
            color: #00ff88;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        /* In-Game Chat */
        .game-chat {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            max-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .game-chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 0.5rem;
            max-height: 120px;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.5rem;
            border-radius: 5px;
        }

        .game-chat-message {
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
        }

        .game-chat-input {
            display: flex;
            gap: 0.5rem;
        }

        .game-chat-input input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 0.5rem;
            color: white;
        }

        .game-chat-input button {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }

        /* Word Game Styles */
        .word-game {
            text-align: center;
            padding: 1rem;
        }

        .word-input {
            width: 100%;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            color: white;
            font-size: 1.2rem;
            text-align: center;
            margin: 1rem 0;
        }

        .word-score {
            display: flex;
            justify-content: space-around;
            margin: 1rem 0;
            font-size: 1.1rem;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                order: 2;
                padding: 1rem;
                max-height: none;
            }

            .content-area {
                order: 1;
                padding: 1rem;
                max-height: none;
            }

            .lobby-stats {
                flex-direction: column;
                gap: 1rem;
            }

            .game-details {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }

            .verification-content {
                margin: 1rem;
                padding: 2rem 1rem;
            }

            .verification-content h1 {
                font-size: 1.8rem;
            }

            .verification-content p {
                font-size: 1rem;
            }

            .verify-btn {
                min-width: 100px;
                padding: 0.8rem 1.5rem;
            }

            .transaction-status {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .nav-menu {
                gap: 1rem;
                flex-wrap: wrap;
            }

            .nav-item {
                padding: 0.3rem 0.8rem;
                font-size: 0.9rem;
            }

            .wallet-section {
                flex-direction: column;
                gap: 0.5rem;
            }

            .game-type-selector {
                grid-template-columns: 1fr;
            }

            .game-window {
                min-width: 95vw;
                max-width: 95vw;
                padding: 1rem;
            }

            .chess-board, .checkers-board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }

            .chess-square, .checkers-square {
                font-size: 1.5rem;
            }

            .checker-piece {
                width: 35px;
                height: 35px;
            }
        }

        /* Additional Utility Classes */
        .pulse {
            animation: pulse 2s infinite;
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .fade-in {
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .glow {
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
    </style>
    <body>
    <div class="background"></div>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <i class="fas fa-dice-d20 logo-icon"></i>
            <h1>CRYPTICUS</h1>
        </div>
        <div class="nav-menu" id="navMenu">
            <div class="nav-item active" onclick="showSection('lobby')">🎯 Game Lobby</div>
            <div class="nav-item" onclick="showSection('create')">🎮 Create Game</div>
            <div class="nav-item" onclick="showSection('games')">♟️ Games</div>
            <div class="nav-item" onclick="showSection('profile')">👤 Profile</div>
            <div class="nav-item" onclick="showSection('chat')">💬 Chat</div>
        </div>
        <div class="live-badge">🔴 LIVE ON CORE</div>
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">
                    <span class="connection-indicator disconnected"></span>Not Connected
                </div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn">
                <i class="fas fa-plug"></i> Connect Wallet
            </button>
            <button class="disconnect-btn hidden" id="disconnectBtn">Disconnect</button>
        </div>
    </div>

    <!-- Age Verification Modal -->
    <div class="age-verification" id="ageVerificationModal">
        <div class="verification-content">
            <h1><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h1>
            <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
            <div class="warning">
                <p><i class="fas fa-exclamation-circle"></i> Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
            </div>
            <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            <div class="verification-buttons">
                <button class="verify-btn accept" onclick="verifyAge(true)">I am 18+</button>
                <button class="verify-btn decline" onclick="verifyAge(false)">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
    </div>

    <!-- Game Overlay -->
    <div class="game-overlay hidden" id="gameOverlay"></div>
    <!-- Chess Game Window -->
    <div class="game-window hidden" id="chessGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">♟️ Chess Masters</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('chess')">−</button>
                <button class="window-btn close-btn" onclick="closeGame('chess')">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="chessStatus">Waiting for opponent...</div>
            <div class="chess-board" id="chessBoard"></div>
            <div class="game-controls">
                <button class="game-btn" onclick="resignChess()">Resign</button>
                <button class="game-btn" onclick="drawChess()">Offer Draw</button>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">Game Chat</h4>
                <div class="game-chat-messages" id="chessGameChat">
                    <div class="game-chat-message"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="chessChatInput" onkeypress="handleGameChatKeyPress(event, 'chess')">
                    <button onclick="sendGameChatMessage('chess')">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Checkers Game Window -->
    <div class="game-window hidden" id="checkersGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">⚫ Checkers Pro</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('checkers')">−</button>
                <button class="window-btn close-btn" onclick="closeGame('checkers')">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
            <div class="checkers-board" id="checkersBoard"></div>
            <div class="game-controls">
                <button class="game-btn" onclick="resignCheckers()">Resign</button>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">Game Chat</h4>
                <div class="game-chat-messages" id="checkersGameChat">
                    <div class="game-chat-message"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="checkersChatInput" onkeypress="handleGameChatKeyPress(event, 'checkers')">
                    <button onclick="sendGameChatMessage('checkers')">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Word Game Window -->
    <div class="game-window hidden" id="wordGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">📝 Word Battle</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('word')">−</button>
                <button class="window-btn close-btn" onclick="closeGame('word')">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="wordStatus">Round 1 of 3</div>
            <div class="word-game">
                <h4 id="wordPrompt">Make a word with these letters:</h4>
                <div id="wordLetters" style="font-size: 2rem; color: #4ecdc4; margin: 1rem 0;">BLOCKCHAIN</div>
                <input type="text" class="word-input" id="wordInput" placeholder="Enter your word..." maxlength="20">
                <div class="word-score">
                    <div>Your Score: <span id="playerScore">0</span></div>
                    <div>Opponent: <span id="opponentScore">0</span></div>
                </div>
                <div class="game-controls">
                    <button class="game-btn" onclick="submitWord()">Submit Word</button>
                    <button class="game-btn" onclick="skipRound()">Skip Round</button>
                </div>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">Game Chat</h4>
                <div class="game-chat-messages" id="wordGameChat">
                    <div class="game-chat-message"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="wordChatInput" onkeypress="handleGameChatKeyPress(event, 'word')">
                    <button onclick="sendGameChatMessage('word')">Send</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Smart Contract Status -->
            <div class="contract-status">
                <h3>🔐 Smart Contract Status</h3>
                <div class="contract-address" id="contractAddress">
                    0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A
                    <button class="copy-btn" onclick="copyContractAddress()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <div id="contractStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to Core Blockchain...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="connectionProgress" style="width: 0%"></div>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="live-lobby">
                <h3>📊 Live Platform Stats</h3>
                <div class="lobby-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Online Players</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalGames">0</div>
                        <div class="stat-label">Active Games</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalVolume">0</div>
                        <div class="stat-label">CORE Volume</div>
                    </div>
                </div>
            </div>

            <!-- Recent Activity Feed -->
            <div class="live-lobby">
                <h3>🔥 Recent Activity</h3>
                <div id="activityFeed">
                    <!-- Activity items will be populated here -->
                </div>
            </div>
        </div>
        <!-- Content Area -->
        <div class="content-area">
            <!-- Game Lobby Section -->
            <div id="lobbySection">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2>🎯 Live Game Lobby</h2>
                        <button onclick="refreshLobby()" class="game-btn" style="width: auto; padding: 0.5rem 1rem;">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                    
                    <div id="gamesList">
                        <!-- Games will be populated here -->
                    </div>
                    
                    <div id="noGames" class="hidden" style="text-align: center; padding: 3rem; color: #aaa;">
                        <i class="fas fa-gamepad" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3>No Active Games</h3>
                        <p>Be the first to create a game and start earning CORE!</p>
                        <button onclick="showSection('create')" class="game-btn" style="margin-top: 1rem;">
                            Create First Game
                        </button>
                    </div>
                </div>
            </div>

            <!-- Create Game Section -->
            <div id="createSection" class="hidden">
                <div class="create-game-section">
                    <h2>🎮 Create New Game</h2>
                    
                    <div class="game-type-selector">
                        <div class="game-type-card" data-type="chess" onclick="selectGameType('chess')">
                            <div class="game-icon">♟️</div>
                            <h3>Chess Masters</h3>
                            <p>Strategic blockchain chess</p>
                            <small>5-30 minutes per game</small>
                        </div>
                        <div class="game-type-card" data-type="checkers" onclick="selectGameType('checkers')">
                            <div class="game-icon">⚫</div>
                            <h3>Checkers Pro</h3>
                            <p>Fast-paced checkers</p>
                            <small>3-15 minutes per game</small>
                        </div>
                        <div class="game-type-card" data-type="words" onclick="selectGameType('words')">
                            <div class="game-icon">📝</div>
                            <h3>Word Battle</h3>
                            <p>Quick word game</p>
                            <small>1-3 minutes per round</small>
                        </div>
                    </div>
                    
                    <div style="margin: 2rem 0;">
                        <label for="gameStake" style="display: block; margin-bottom: 0.5rem; color: #4ecdc4; font-weight: bold;">
                            Stake Amount (CORE)
                        </label>
                        <input type="number" class="stake-input" id="gameStake" 
                               placeholder="Enter stake amount (min 0.01 CORE)" 
                               min="0.01" step="0.01" 
                               oninput="updateCreateButton()">
                        <small style="color: #aaa; display: block; margin-top: 0.5rem;">
                            Winner takes 97% of total pool (3% platform fee)
                        </small>
                    </div>
                    
                    <button class="create-btn" id="createGameBtn" onclick="createGame()" disabled>
                        <i class="fas fa-plus"></i> Select Game Type & Enter Stake
                    </button>
                </div>
            </div>
            <!-- Individual Games Section -->
            <div id="gamesSection" class="hidden">
                <div style="background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 10px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h3>🏆 Smart Contract Gaming</h3>
                    <p><strong>97% of every stake goes directly to the winner!</strong></p>
                    <p>Powered by Core Blockchain • Instant payouts • Provably fair</p>
                    <p>Contract Address: 0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A (Verified ✅)</p>
                </div>

                <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 10px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h4>⚖️ Legal Notice</h4>
                    <p>• Educational gaming platform for skill development</p>
                    <p>• Minimum age: 18+ required</p>
                    <p>• Tax obligations: Players responsible for local tax compliance</p>
                    <p>• Not available in restricted jurisdictions</p>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 30px; margin-top: 2rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border-radius: 15px; padding: 1.5rem; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease;">
                        <h3><i class="fas fa-chess" style="font-size: 2rem; margin-bottom: 0.5rem;"></i> Chess Masters</h3>
                        <p>Play chess with real CORE stakes! Smart contract ensures fair play.</p>
                        <input type="number" class="stake-input" id="chessStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button style="width: 100%; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); border: none; padding: 1rem; border-radius: 10px; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; margin-top: 1rem;" onclick="createChessGame()">
                            <i class="fas fa-chess-board"></i> Create Chess Game
                        </button>
                    </div>

                    <div style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border-radius: 15px; padding: 1.5rem; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease;">
                        <h3><i class="fas fa-th" style="font-size: 2rem; margin-bottom: 0.5rem;"></i> Checkers Pro</h3>
                        <p>Fast checkers with blockchain stakes! Quick games, instant rewards.</p>
                        <input type="number" class="stake-input" id="checkersStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button style="width: 100%; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); border: none; padding: 1rem; border-radius: 10px; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; margin-top: 1rem;" onclick="createCheckersGame()">
                            <i class="fas fa-th"></i> Create Checkers Game
                        </button>
                    </div>

                    <div style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border-radius: 15px; padding: 1.5rem; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease;">
                        <h3>📝 Word Battle</h3>
                        <p>Compete in word games with crypto stakes! Test your vocabulary.</p>
                        <input type="number" class="stake-input" id="wordStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button style="width: 100%; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); border: none; padding: 1rem; border-radius: 10px; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; margin-top: 1rem;" onclick="createWordGame()">📝 Create Word Game</button>
                    </div>
                </div>
            </div>

            <!-- Profile Section -->
            <div id="profileSection" class="hidden">
                <div class="live-lobby">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">👤 Player Profile</h3>
                    <div class="lobby-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="profileGamesPlayed">0</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileGamesWon">0</div>
                            <div class="stat-label">Games Won</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileTotalEarned">0</div>
                            <div class="stat-label">CORE Earned</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileWinRate">0%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                    </div>
                    
                    <!-- Game History -->
                    <div style="margin-top: 2rem;">
                        <h4 style="margin-bottom: 1rem; color: #4ecdc4;">Recent Games</h4>
                        <div id="gameHistory">
                            <!-- Game history will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Section -->
            <div id="chatSection" class="hidden">
                <div class="live-lobby" style="height: 500px; display: flex; flex-direction: column;">
                    <h3 style="margin-bottom: 1rem;">💬 Global Chat</h3>
                    <div style="flex: 1; overflow-y: auto; background: rgba(0, 0, 0, 0.2); border-radius: 10px; padding: 1rem; margin-bottom: 1rem;" id="chatMessages">
                        <!-- Chat messages will be populated here -->
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" placeholder="Type your message..." id="chatInput" 
                               style="flex: 1; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 25px; padding: 0.8rem 1rem; color: white;" 
                               onkeypress="handleChatKeyPress(event)" maxlength="200">
                        <button onclick="sendChatMessage()" class="game-btn">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
// Enhanced Blockchain Integration with Real Multiplayer Support
const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = "0x45c";

// Simplified working ABI - Only include functions that actually exist on the contract
const GAME_CONTRACT_ABI = [
    // Read functions
    "function owner() external view returns (address)",
    "function paused() external view returns (bool)",
    "function totalGames() external view returns (uint256)",
    
    // Write functions that should work (simplified)
    "function deposit() external payable",
    "function withdraw(uint256 amount) external",
    
    // Events
    "event Deposit(address indexed user, uint256 amount)",
    "event Withdrawal(address indexed user, uint256 amount)"
];

// Enhanced Global Variables for Multiplayer
let web3Provider = null;
let userAccount = null;
let gameContract = null;
let currentBalance = 0;
let activeGames = [];
let selectedGameType = null;
let gameUpdateInterval = null;
let multiplayerSession = null;
let gameRoomConnections = new Map();
let pendingMatches = new Map();
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    winRate: 0
};

// Enhanced Multiplayer System
class MultiplayerGameSession {
    constructor(gameId, gameType, stake, isHost = false) {
        this.gameId = gameId;
        this.gameType = gameType;
        this.stake = stake;
        this.isHost = isHost;
        this.opponent = null;
        this.gameState = null;
        this.isActive = false;
        this.moveHistory = [];
        this.chatMessages = [];
        this.connectionStatus = 'waiting';
        this.winner = null;
        this.escrowLocked = false;
        
        // Initialize game-specific state
        this.initializeGameState();
    }
    
    initializeGameState() {
        switch(this.gameType) {
            case 'chess':
                this.gameState = {
                    board: this.getInitialChessBoard(),
                    turn: 'white',
                    selectedPiece: null,
                    possibleMoves: [],
                    gameOver: false,
                    playerColors: {
                        host: 'white',
                        guest: 'black'
                    }
                };
                break;
            case 'checkers':
                this.gameState = {
                    board: this.getInitialCheckersBoard(),
                    turn: 'red',
                    selectedPiece: null,
                    possibleMoves: [],
                    gameOver: false,
                    playerColors: {
                        host: 'red',
                        guest: 'black'
                    }
                };
                break;
            case 'words':
                this.gameState = {
                    round: 1,
                    maxRounds: 3,
                    scores: { host: 0, guest: 0 },
                    currentLetters: this.generateRandomLetters(),
                    timeLeft: 60,
                    gameOver: false
                };
                break;
        }
    }
    
    getInitialChessBoard() {
        return [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];
    }
    
    getInitialCheckersBoard() {
        const board = Array(8).fill().map(() => Array(8).fill(null));
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                if ((row + col) % 2 === 1) {
                    if (row < 3) {
                        board[row][col] = 'red';
                    } else if (row > 4) {
                        board[row][col] = 'black';
                    }
                }
            }
        }
        return board;
    }
    
    generateRandomLetters() {
        const letterSets = [
            'BLOCKCHAIN', 'ETHEREUM', 'BITCOIN', 'DECENTRALIZED', 'SMARTCONTRACT',
            'CRYPTOGRAPHY', 'CONSENSUS', 'VALIDATOR', 'STAKING', 'MINING'
        ];
        return letterSets[Math.floor(Math.random() * letterSets.length)];
    }
    
    // Enhanced move validation and execution
    makeMove(moveData) {
        if (!this.isActive || this.gameState.gameOver) {
            return { success: false, error: 'Game not active' };
        }
        
        const isPlayerTurn = this.isPlayerTurn(moveData.playerId);
        if (!isPlayerTurn) {
            return { success: false, error: 'Not your turn' };
        }
        
        let result;
        switch(this.gameType) {
            case 'chess':
                result = this.executeChessMove(moveData);
                break;
            case 'checkers':
                result = this.executeCheckersMove(moveData);
                break;
            case 'words':
                result = this.executeWordMove(moveData);
                break;
            default:
                return { success: false, error: 'Unknown game type' };
        }
        
        if (result.success) {
            this.moveHistory.push({
                ...moveData,
                timestamp: Date.now(),
                moveNumber: this.moveHistory.length + 1
            });
            
            // Check for game end conditions
            this.checkGameEnd();
            
            // Switch turns (except for word games)
            if (this.gameType !== 'words' && !this.gameState.gameOver) {
                this.switchTurn();
            }
        }
        
        return result;
    }
    
    executeChessMove(moveData) {
        const { from, to } = moveData;
        const piece = this.gameState.board[from.row][from.col];
        
        if (!piece) {
            return { success: false, error: 'No piece at source position' };
        }
        
        // Basic move validation (simplified)
        if (this.isValidChessMove(from, to, piece)) {
            // Execute move
            this.gameState.board[to.row][to.col] = piece;
            this.gameState.board[from.row][from.col] = null;
            
            return { 
                success: true, 
                gameState: this.gameState,
                message: `Moved ${piece} from ${from.row},${from.col} to ${to.row},${to.col}`
            };
        }
        
        return { success: false, error: 'Invalid move' };
    }
    
    executeCheckersMove(moveData) {
        const { from, to } = moveData;
        const piece = this.gameState.board[from.row][from.col];
        
        if (!piece) {
            return { success: false, error: 'No piece at source position' };
        }
        
        if (this.isValidCheckersMove(from, to, piece)) {
            // Execute move
            this.gameState.board[to.row][to.col] = piece;
            this.gameState.board[from.row][from.col] = null;
            
            // Check for captures
            const capturedPiece = this.checkCheckersCapture(from, to);
            
            // Check for king promotion
            if ((piece === 'red' && to.row === 7) || (piece === 'black' && to.row === 0)) {
                this.gameState.board[to.row][to.col] = piece + '_king';
            }
            
            return { 
                success: true, 
                gameState: this.gameState,
                captured: capturedPiece,
                message: `Moved ${piece} from ${from.row},${from.col} to ${to.row},${to.col}`
            };
        }
        
        return { success: false, error: 'Invalid move' };
    }
    
    executeWordMove(moveData) {
        const { word, playerId } = moveData;
        
        if (!this.isValidWord(word)) {
            return { success: false, error: 'Invalid word' };
        }
        
        const score = this.calculateWordScore(word);
        const playerRole = playerId === userAccount ? (this.isHost ? 'host' : 'guest') : (this.isHost ? 'guest' : 'host');
        
        this.gameState.scores[playerRole] += score;
        
        return {
            success: true,
            gameState: this.gameState,
            score: score,
            message: `Scored ${score} points for "${word}"`
        };
    }
    
    // Game validation methods
    isValidChessMove(from, to, piece) {
        // Simplified chess move validation
        const deltaRow = Math.abs(to.row - from.row);
        const deltaCol = Math.abs(to.col - from.col);
        
        // Basic bounds checking
        if (to.row < 0 || to.row > 7 || to.col < 0 || to.col > 7) {
            return false;
        }
        
        // Prevent moving to same position
        if (from.row === to.row && from.col === to.col) {
            return false;
        }
        
        // Simplified piece movement rules
        const pieceType = piece.toLowerCase();
        switch(pieceType) {
            case 'p': // Pawn
                return deltaCol <= 1 && deltaRow <= 2;
            case 'r': // Rook
                return deltaRow === 0 || deltaCol === 0;
            case 'n': // Knight
                return (deltaRow === 2 && deltaCol === 1) || (deltaRow === 1 && deltaCol === 2);
            case 'b': // Bishop
                return deltaRow === deltaCol;
            case 'q': // Queen
                return deltaRow === 0 || deltaCol === 0 || deltaRow === deltaCol;
            case 'k': // King
                return deltaRow <= 1 && deltaCol <= 1;
            default:
                return false;
        }
    }
    
    isValidCheckersMove(from, to, piece) {
        const deltaRow = to.row - from.row;
        const deltaCol = Math.abs(to.col - from.col);
        
        // Basic bounds checking
        if (to.row < 0 || to.row > 7 || to.col < 0 || to.col > 7) {
            return false;
        }
        
        // Must move diagonally
        if (Math.abs(deltaRow) !== deltaCol) {
            return false;
        }
        
        // Regular pieces can only move forward
        if (!piece.includes('king')) {
            if (piece === 'red' && deltaRow < 0) return false;
            if (piece === 'black' && deltaRow > 0) return false;
        }
        
        // Must move to empty square
        if (this.gameState.board[to.row][to.col] !== null) {
            return false;
        }
        
        return true;
    }
    
    isValidWord(word) {
        // Basic word validation
        if (!word || word.length < 3) return false;
        
        // Check if word can be made from current letters
        const letters = this.gameState.currentLetters.toLowerCase();
        const wordLetters = word.toLowerCase();
        
        for (let char of wordLetters) {
            if (!letters.includes(char)) {
                return false;
            }
        }
        
        return true;
    }
    
    calculateWordScore(word) {
        return word.length * 10 + (word.length > 5 ? 20 : 0);
    }
    
    checkCheckersCapture(from, to) {
        const deltaRow = to.row - from.row;
        const deltaCol = to.col - from.col;
        
        if (Math.abs(deltaRow) === 2 && Math.abs(deltaCol) === 2) {
            const captureRow = from.row + deltaRow / 2;
            const captureCol = from.col + deltaCol / 2;
            const capturedPiece = this.gameState.board[captureRow][captureCol];
            
            if (capturedPiece) {
                this.gameState.board[captureRow][captureCol] = null;
                return capturedPiece;
            }
        }
        
        return null;
    }
    
    isPlayerTurn(playerId) {
        if (this.gameType === 'words') return true; // Words can be submitted by either player
        
        const playerRole = playerId === userAccount ? (this.isHost ? 'host' : 'guest') : (this.isHost ? 'guest' : 'host');
        const playerColor = this.gameState.playerColors[playerRole];
        
        return this.gameState.turn === playerColor;
    }
    
    switchTurn() {
        switch(this.gameType) {
            case 'chess':
                this.gameState.turn = this.gameState.turn === 'white' ? 'black' : 'white';
                break;
            case 'checkers':
                this.gameState.turn = this.gameState.turn === 'red' ? 'black' : 'red';
                break;
        }
    }
    
    checkGameEnd() {
        switch(this.gameType) {
            case 'chess':
                // Simplified: Check if king is captured
                let whiteKing = false, blackKing = false;
                for (let row of this.gameState.board) {
                    for (let piece of row) {
                        if (piece === 'K') whiteKing = true;
                        if (piece === 'k') blackKing = true;
                    }
                }
                if (!whiteKing) {
                    this.endGame('black');
                } else if (!blackKing) {
                    this.endGame('white');
                }
                break;
                
            case 'checkers':
                // Check if either player has no pieces left
                let redPieces = 0, blackPieces = 0;
                for (let row of this.gameState.board) {
                    for (let piece of row) {
                        if (piece && piece.includes('red')) redPieces++;
                        if (piece && piece.includes('black')) blackPieces++;
                    }
                }
                if (redPieces === 0) {
                    this.endGame('black');
                } else if (blackPieces === 0) {
                    this.endGame('red');
                }
                break;
                
            case 'words':
                if (this.gameState.round >= this.gameState.maxRounds) {
                    const winner = this.gameState.scores.host > this.gameState.scores.guest ? 'host' : 'guest';
                    this.endGame(winner);
                }
                break;
        }
    }
    
    endGame(winner) {
        this.gameState.gameOver = true;
        this.winner = winner;
        this.isActive = false;
        
        // Process settlement
        this.processGameSettlement();
    }
    
    async processGameSettlement() {
        try {
            showTransactionStatus('🏆 Processing game settlement...', '');
            
            const isWinner = this.isPlayerWinner();
            
            if (isWinner) {
                // Winner gets 97% of total pot (both stakes)
                const winnings = this.stake * 2 * 0.97;
                currentBalance += winnings;
                
                playerStats.gamesWon++;
                playerStats.totalEarned += winnings;
                
                showTransactionStatus(`🎉 You won ${winnings.toFixed(4)} CORE!`, '');
                addActivityFeedItem(`🏆 You won ${winnings.toFixed(4)} CORE in ${this.gameType}!`);
            } else {
                showTransactionStatus('😔 Game lost. Better luck next time!', '');
            }
            
            playerStats.gamesPlayed++;
            updatePlayerStats();
            saveUserData();
            
            // Update balance display
            document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
            
            // Remove from active games
            activeGames = activeGames.filter(game => game.id !== this.gameId);
            updateGamesDisplay();
            
        } catch (error) {
            console.error('Settlement error:', error);
            showTransactionStatus('❌ Settlement error: ' + error.message, '');
        }
    }
    
    isPlayerWinner() {
        if (this.gameType === 'words') {
            const myRole = this.isHost ? 'host' : 'guest';
            const opponentRole = this.isHost ? 'guest' : 'host';
            return this.gameState.scores[myRole] > this.gameState.scores[opponentRole];
        } else {
            const myColor = this.isHost ? this.gameState.playerColors.host : this.gameState.playerColors.guest;
            return this.winner === myColor;
        }
    }
    
    // Chat functionality
    addChatMessage(sender, message) {
        this.chatMessages.push({
            sender,
            message,
            timestamp: Date.now()
        });
        
        // Update UI if this is the active game
        if (multiplayerSession && multiplayerSession.gameId === this.gameId) {
            addGameChatMessage(this.gameType, sender, message);
        }
    }
}

// Enhanced Game Matchmaking System
class GameMatchmaker {
    constructor() {
        this.waitingPlayers = new Map();
        this.activeMatches = new Map();
    }
    
    async createGame(gameType, stake, playerId) {
        const gameId = Date.now();
        const session = new MultiplayerGameSession(gameId, gameType, stake, true);
        session.opponent = null;
        
        // Add to waiting pool
        this.waitingPlayers.set(gameId, {
            session,
            playerId,
            createdAt: Date.now()
        });
        
        // Add to active games list for display
        activeGames.push({
            id: gameId,
            type: gameType,
            creator: playerId,
            stake: stake,
            status: 'waiting',
            createdAt: Date.now(),
            session: session
        });
        
        showTransactionStatus(`🎮 ${gameType} game created! Waiting for opponent...`, '');
        
        return session;
    }
    
    async joinGame(gameId, playerId, stake) {
        const gameData = activeGames.find(game => game.id === gameId);
        if (!gameData || !gameData.session) {
            throw new Error('Game not found');
        }
        
        const session = gameData.session;
        
        if (session.opponent) {
            throw new Error('Game already full');
        }
        
        if (session.isHost && playerId === userAccount) {
            throw new Error('Cannot join your own game');
        }
        
        // Join the game
        session.opponent = playerId;
        session.isActive = true;
        session.connectionStatus = 'connected';
        
        // Update game status
        gameData.status = 'playing';
        gameData.player2 = playerId;
        
        // Set up the joining player's session
        if (playerId === userAccount) {
            multiplayerSession = session;
            multiplayerSession.isHost = false;
        }
        
        // Remove from waiting pool
        this.waitingPlayers.delete(gameId);
        this.activeMatches.set(gameId, session);
        
        // Open game window for both players
        openGameWindow(session.gameType);
        this.initializeGameUI(session);
        
        showTransactionStatus(`🎮 Joined ${session.gameType} game! Game starting...`, '');
        addActivityFeedItem(`⚔️ ${playerId.substring(0, 8)}... joined ${session.gameType} game #${gameId}`);
        
        return session;
    }
    
    initializeGameUI(session) {
        switch(session.gameType) {
            case 'chess':
                initializeChessBoard(session);
                updateChessStatus(session);
                break;
            case 'checkers':
                initializeCheckersBoard(session);
                updateCheckersStatus(session);
                break;
            case 'words':
                initializeWordGame(session);
                break;
        }
    }
    
    // AI Opponent System (for testing/demo)
    createAIOpponent(session) {
        setTimeout(() => {
            session.opponent = 'AI_OPPONENT';
            session.isActive = true;
            session.connectionStatus = 'connected';
            
            // Update game display
            const gameData = activeGames.find(game => game.id === session.gameId);
            if (gameData) {
                gameData.status = 'playing';
                gameData.player2 = 'AI';
            }
            
            this.initializeGameUI(session);
            showTransactionStatus('🤖 AI opponent joined! Game starting...', '');
            
            // Start AI move simulation
            this.simulateAIMoves(session);
            
        }, 2000 + Math.random() * 5000); // Join after 2-7 seconds
    }
    
    simulateAIMoves(session) {
        if (!session.isActive || session.gameState.gameOver) return;
        
        const makeAIMove = () => {
            if (!session.isActive || session.gameState.gameOver) return;
            
            // Check if it's AI's turn
            const aiRole = session.isHost ? 'guest' : 'host';
            const aiColor = session.gameState.playerColors[aiRole];
            
            if (session.gameState.turn === aiColor) {
                // Make a random valid move
                const validMoves = this.findValidMoves(session, aiColor);
                if (validMoves.length > 0) {
                    const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    const result = session.makeMove({
                        ...randomMove,
                        playerId: 'AI_OPPONENT'
                    });
                    
                    if (result.success) {
                        // Update UI
                        this.updateGameUI(session);
                        session.addChatMessage('AI', result.message || 'Made a move');
                    }
                }
            }
            
            // Schedule next AI move
            if (session.isActive && !session.gameState.gameOver) {
                setTimeout(makeAIMove, 1000 + Math.random() * 3000);
            }
        };
        
        // Start AI moves after a delay
        setTimeout(makeAIMove, 2000);
    }
    
    findValidMoves(session, color) {
        const moves = [];
        const board = session.gameState.board;
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = board[row][col];
                if (!piece) continue;
                
                // Check if piece belongs to the current player
                let isPieceOfColor = false;
                if (session.gameType === 'chess') {
                    isPieceOfColor = (color === 'white' && piece === piece.toUpperCase()) ||
                                   (color === 'black' && piece === piece.toLowerCase());
                } else if (session.gameType === 'checkers') {
                    isPieceOfColor = piece.includes(color);
                }
                
                if (!isPieceOfColor) continue;
                
                // Find valid moves for this piece
                for (let toRow = 0; toRow < 8; toRow++) {
                    for (let toCol = 0; toCol < 8; toCol++) {
                        const moveData = {
                            from: { row, col },
                            to: { row: toRow, col: toCol }
                        };
                        
                        if (session.gameType === 'chess' && session.isValidChessMove(moveData.from, moveData.to, piece)) {
                            moves.push(moveData);
                        } else if (session.gameType === 'checkers' && session.isValidCheckersMove(moveData.from, moveData.to, piece)) {
                            moves.push(moveData);
                        }
                    }
                }
            }
        }
        
        return moves;
    }
    
    updateGameUI(session) {
        switch(session.gameType) {
            case 'chess':
                renderChessBoard(session);
                updateChessStatus(session);
                break;
            case 'checkers':
                renderCheckersBoard(session);
                updateCheckersStatus(session);
                break;
            case 'words':
                updateWordGameUI(session);
                break;
        }
    }
}

// Initialize matchmaker
const gameMatchmaker = new GameMatchmaker();
    </script>
    <script>
// Enhanced Game Logic & UI Functions
// Chess piece symbols
const CHESS_SYMBOLS = {
    'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
    'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
};

// Enhanced Chess Implementation
function initializeChessBoard(session = null) {
    if (!session) {
        // Create new session for single player or local testing
        session = new MultiplayerGameSession(Date.now(), 'chess', 0.1, true);
        multiplayerSession = session;
        
        // Add AI opponent for testing
        gameMatchmaker.createAIOpponent(session);
    }
    
    renderChessBoard(session);
}

function renderChessBoard(session) {
    const boardElement = document.getElementById('chessBoard');
    if (!boardElement) return;
    
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            square.onclick = () => handleChessClick(row, col, session);
            
            const piece = session.gameState.board[row][col];
            if (piece) {
                square.textContent = CHESS_SYMBOLS[piece] || piece;
            }
            
            // Highlight selected piece
            if (session.gameState.selectedPiece && 
                session.gameState.selectedPiece.row === row && 
                session.gameState.selectedPiece.col === col) {
                square.classList.add('selected');
            }
            
            // Show possible moves
            if (session.gameState.possibleMoves.some(move => move.row === row && move.col === col)) {
                square.classList.add('possible-move');
            }
            
            boardElement.appendChild(square);
        }
    }
    
    updateChessStatus(session);
}

function handleChessClick(row, col, session) {
    if (!session || !session.isActive || session.gameState.gameOver) return;
    
    const piece = session.gameState.board[row][col];
    const myColor = session.isHost ? session.gameState.playerColors.host : session.gameState.playerColors.guest;
    
    // Check if it's player's turn
    if (session.gameState.turn !== myColor) {
        showTransactionStatus('⚠️ Not your turn!', '');
        return;
    }
    
    // If no piece is selected
    if (!session.gameState.selectedPiece) {
        if (piece) {
            // Check if piece belongs to current player
            const isPieceOfPlayer = (myColor === 'white' && piece === piece.toUpperCase()) ||
                                  (myColor === 'black' && piece === piece.toLowerCase());
            
            if (isPieceOfPlayer) {
                session.gameState.selectedPiece = { row, col };
                session.gameState.possibleMoves = findPossibleMoves(session, row, col, piece);
                renderChessBoard(session);
            }
        }
    } else {
        // A piece is already selected
        const selectedPiece = session.gameState.selectedPiece;
        
        if (selectedPiece.row === row && selectedPiece.col === col) {
            // Deselect the piece
            session.gameState.selectedPiece = null;
            session.gameState.possibleMoves = [];
            renderChessBoard(session);
        } else {
            // Try to make a move
            const moveData = {
                from: selectedPiece,
                to: { row, col },
                playerId: userAccount
            };
            
            const result = session.makeMove(moveData);
            
            if (result.success) {
                session.gameState.selectedPiece = null;
                session.gameState.possibleMoves = [];
                renderChessBoard(session);
                
                if (result.message) {
                    session.addChatMessage('You', result.message);
                }
            } else {
                showTransactionStatus('❌ ' + (result.error || 'Invalid move'), '');
            }
        }
    }
}

function findPossibleMoves(session, row, col, piece) {
    const moves = [];
    
    // Simple implementation - check all squares
    for (let toRow = 0; toRow < 8; toRow++) {
        for (let toCol = 0; toCol < 8; toCol++) {
            if (session.isValidChessMove({ row, col }, { row: toRow, col: toCol }, piece)) {
                moves.push({ row: toRow, col: toCol });
            }
        }
    }
    
    return moves;
}

function updateChessStatus(session) {
    const statusElement = document.getElementById('chessStatus');
    if (!statusElement) return;
    
    let status = '';
    
    if (session.gameState.gameOver) {
        if (session.isPlayerWinner()) {
            status = '🏆 You Won!';
            statusElement.classList.add('game-over-message');
        } else {
            status = '😔 Game Over - You Lost';
        }
    } else if (!session.isActive) {
        status = 'Waiting for opponent...';
    } else {
        const myColor = session.isHost ? session.gameState.playerColors.host : session.gameState.playerColors.guest;
        const isMyTurn = session.gameState.turn === myColor;
        
        if (isMyTurn) {
            status = `Your turn (${myColor})`;
        } else {
            status = `Opponent's turn (${session.gameState.turn})`;
        }
    }
    
    statusElement.textContent = status;
}

function resignChess() {
    if (multiplayerSession && multiplayerSession.gameType === 'chess') {
        if (confirm('Are you sure you want to resign?')) {
            multiplayerSession.endGame(multiplayerSession.isHost ? 'guest' : 'host');
            multiplayerSession.addChatMessage('You', 'resigned from the game');
        }
    }
}

function drawChess() {
    if (multiplayerSession && multiplayerSession.gameType === 'chess') {
        multiplayerSession.addChatMessage('You', 'offered a draw');
        showTransactionStatus('Draw offer sent to opponent', '');
    }
}

// Enhanced Checkers Implementation
function initializeCheckersBoard(session = null) {
    if (!session) {
        session = new MultiplayerGameSession(Date.now(), 'checkers', 0.1, true);
        multiplayerSession = session;
        gameMatchmaker.createAIOpponent(session);
    }
    
    renderCheckersBoard(session);
}

function renderCheckersBoard(session) {
    const boardElement = document.getElementById('checkersBoard');
    if (!boardElement) return;
    
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            square.onclick = () => handleCheckersClick(row, col, session);
            
            const piece = session.gameState.board[row][col];
            if (piece) {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = `checker-piece ${piece.replace('_king', '').toLowerCase()}-piece`;
                
                if (piece.includes('king')) {
                    pieceDiv.classList.add('king');
                }
                
                square.appendChild(pieceDiv);
            }
            
            // Highlight selected piece
            if (session.gameState.selectedPiece && 
                session.gameState.selectedPiece.row === row && 
                session.gameState.selectedPiece.col === col) {
                square.classList.add('selected');
            }
            
            // Show possible moves
            if (session.gameState.possibleMoves.some(move => move.row === row && move.col === col)) {
                square.classList.add('possible-move');
            }
            
            boardElement.appendChild(square);
        }
    }
    
    updateCheckersStatus(session);
}

function handleCheckersClick(row, col, session) {
    if (!session || !session.isActive || session.gameState.gameOver) return;
    
    const piece = session.gameState.board[row][col];
    const myColor = session.isHost ? session.gameState.playerColors.host : session.gameState.playerColors.guest;
    
    // Check if it's player's turn
    if (session.gameState.turn !== myColor) {
        showTransactionStatus('⚠️ Not your turn!', '');
        return;
    }
    
    // If no piece is selected
    if (!session.gameState.selectedPiece) {
        if (piece && piece.includes(myColor)) {
            session.gameState.selectedPiece = { row, col };
            session.gameState.possibleMoves = findPossibleCheckersMoves(session, row, col, piece);
            renderCheckersBoard(session);
        }
    } else {
        // A piece is already selected
        const selectedPiece = session.gameState.selectedPiece;
        
        if (selectedPiece.row === row && selectedPiece.col === col) {
            // Deselect the piece
            session.gameState.selectedPiece = null;
            session.gameState.possibleMoves = [];
            renderCheckersBoard(session);
        } else {
            // Try to make a move
            const moveData = {
                from: selectedPiece,
                to: { row, col },
                playerId: userAccount
            };
            
            const result = session.makeMove(moveData);
            
            if (result.success) {
                session.gameState.selectedPiece = null;
                session.gameState.possibleMoves = [];
                renderCheckersBoard(session);
                
                if (result.message) {
                    session.addChatMessage('You', result.message);
                }
                
                if (result.captured) {
                    session.addChatMessage('System', `${result.captured} piece captured!`);
                }
            } else {
                showTransactionStatus('❌ ' + (result.error || 'Invalid move'), '');
            }
        }
    }
}

function findPossibleCheckersMoves(session, row, col, piece) {
    const moves = [];
    
    // Check all possible destinations
    for (let toRow = 0; toRow < 8; toRow++) {
        for (let toCol = 0; toCol < 8; toCol++) {
            if (session.isValidCheckersMove({ row, col }, { row: toRow, col: toCol }, piece)) {
                moves.push({ row: toRow, col: toCol });
            }
        }
    }
    
    return moves;
}

function updateCheckersStatus(session) {
    const statusElement = document.getElementById('checkersStatus');
    if (!statusElement) return;
    
    let status = '';
    
    if (session.gameState.gameOver) {
        if (session.isPlayerWinner()) {
            status = '🏆 You Won!';
            statusElement.classList.add('game-over-message');
        } else {
            status = '😔 Game Over - You Lost';
        }
    } else if (!session.isActive) {
        status = 'Waiting for opponent...';
    } else {
        const myColor = session.isHost ? session.gameState.playerColors.host : session.gameState.playerColors.guest;
        const isMyTurn = session.gameState.turn === myColor;
        
        if (isMyTurn) {
            status = `Your turn (${myColor})`;
        } else {
            status = `Opponent's turn (${session.gameState.turn})`;
        }
    }
    
    statusElement.textContent = status;
}

function resignCheckers() {
    if (multiplayerSession && multiplayerSession.gameType === 'checkers') {
        if (confirm('Are you sure you want to resign?')) {
            multiplayerSession.endGame(multiplayerSession.isHost ? 'guest' : 'host');
            multiplayerSession.addChatMessage('You', 'resigned from the game');
        }
    }
}

// Enhanced Word Game Implementation
function initializeWordGame(session = null) {
    if (!session) {
        session = new MultiplayerGameSession(Date.now(), 'words', 0.1, true);
        multiplayerSession = session;
        gameMatchmaker.createAIOpponent(session);
    }
    
    updateWordGameUI(session);
}

function updateWordGameUI(session) {
    const statusElement = document.getElementById('wordStatus');
    const lettersElement = document.getElementById('wordLetters');
    const playerScoreElement = document.getElementById('playerScore');
    const opponentScoreElement = document.getElementById('opponentScore');
    
    if (statusElement) {
        if (session.gameState.gameOver) {
            if (session.isPlayerWinner()) {
                statusElement.textContent = '🏆 You Won!';
                statusElement.classList.add('game-over-message');
            } else {
                statusElement.textContent = '😔 You Lost';
            }
        } else {
            statusElement.textContent = `Round ${session.gameState.round} of ${session.gameState.maxRounds}`;
        }
    }
    
    if (lettersElement) {
        lettersElement.textContent = session.gameState.currentLetters;
    }
    
    if (playerScoreElement && opponentScoreElement) {
        const myRole = session.isHost ? 'host' : 'guest';
        const opponentRole = session.isHost ? 'guest' : 'host';
        
        playerScoreElement.textContent = session.gameState.scores[myRole];
        opponentScoreElement.textContent = session.gameState.scores[opponentRole];
    }
}

function submitWord() {
    const wordInput = document.getElementById('wordInput');
    const word = wordInput.value.trim().toUpperCase();
    
    if (!multiplayerSession || multiplayerSession.gameType !== 'words') {
        showTransactionStatus('❌ No active word game', '');
        return;
    }
    
    if (!word) {
        showTransactionStatus('Please enter a word!', '');
        return;
    }
    
    if (word.length < 3) {
        showTransactionStatus('Word must be at least 3 letters!', '');
        return;
    }
    
    const moveData = {
        word: word,
        playerId: userAccount
    };
    
    const result = multiplayerSession.makeMove(moveData);
    
    if (result.success) {
        wordInput.value = '';
        updateWordGameUI(multiplayerSession);
        showTransactionStatus(`✅ +${result.score} points for "${word}"`, '');
        
        if (result.message) {
            multiplayerSession.addChatMessage('You', result.message);
        }
        
        // Move to next round after both players submit
        if (multiplayerSession.gameState.round < multiplayerSession.gameState.maxRounds) {
            setTimeout(() => {
                multiplayerSession.gameState.round++;
                multiplayerSession.gameState.currentLetters = multiplayerSession.generateRandomLetters();
                updateWordGameUI(multiplayerSession);
            }, 2000);
        }
    } else {
        showTransactionStatus('❌ ' + (result.error || 'Invalid word'), '');
    }
}

function skipRound() {
    if (multiplayerSession && multiplayerSession.gameType === 'words') {
        multiplayerSession.addChatMessage('You', 'skipped this round');
        
        // Move to next round
        if (multiplayerSession.gameState.round < multiplayerSession.gameState.maxRounds) {
            multiplayerSession.gameState.round++;
            multiplayerSession.gameState.currentLetters = multiplayerSession.generateRandomLetters();
            updateWordGameUI(multiplayerSession);
        }
        
        showTransactionStatus('Round skipped', '');
    }
}

// Enhanced Game Window Management
let openWindows = [];
let windowZIndex = 1000;

function openGameWindow(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (!gameWindow) return;
    
    windowZIndex += 10;
    gameWindow.style.zIndex = windowZIndex;
    
    if (!openWindows.includes(gameType)) {
        openWindows.push(gameType);
    }
    
    gameWindow.classList.remove('hidden', 'minimized');
    overlay.classList.remove('hidden');
    
    overlay.onclick = () => {
        if (openWindows.length === 1) {
            overlay.classList.add('hidden');
        }
    };
    
    gameWindow.onclick = (e) => {
        if (gameWindow.classList.contains('minimized')) {
            restoreGame(gameType);
            e.stopPropagation();
        } else {
            windowZIndex += 10;
            gameWindow.style.zIndex = windowZIndex;
        }
    };
}

function minimizeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    if (!gameWindow) return;
    
    gameWindow.classList.add('minimized');
    
    const hasOpenWindows = openWindows.some(type => {
        const window = document.getElementById(type + 'GameWindow');
        return window && !window.classList.contains('minimized');
    });
    
    if (!hasOpenWindows) {
        document.getElementById('gameOverlay').classList.add('hidden');
    }
}

function restoreGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    if (!gameWindow) return;
    
    gameWindow.classList.remove('minimized');
    document.getElementById('gameOverlay').classList.remove('hidden');
}

function closeGame(gameType) {
    if (confirm('Are you sure you want to close this game? This may forfeit the match.')) {
        const gameWindow = document.getElementById(gameType + 'GameWindow');
        if (gameWindow) {
            gameWindow.classList.add('hidden');
        }
        
        openWindows = openWindows.filter(window => window !== gameType);
        if (openWindows.length === 0) {
            document.getElementById('gameOverlay').classList.add('hidden');
        }
        
        // End the multiplayer session if active
        if (multiplayerSession && multiplayerSession.gameType === gameType) {
            multiplayerSession.isActive = false;
            multiplayerSession = null;
        }
        
        showTransactionStatus('Game closed', '');
    }
}
    </script>
    <script>
// Enhanced Game Creation & Management Functions
async function createChessGame() {
    const stakeAmount = parseFloat(document.getElementById('chessStake').value);
    if (!validateStakeAndWallet(stakeAmount)) return;
    
    try {
        showTransactionStatus('🔄 Creating Chess game...', '');
        
        const session = await gameMatchmaker.createGame('chess', stakeAmount, userAccount);
        multiplayerSession = session;
        
        // Update balance (simulate spending)
        currentBalance -= stakeAmount;
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
        
        openGameWindow('chess');
        initializeChessBoard(session);
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        updateGamesDisplay();
        
        document.getElementById('chessStake').value = '';
        
        showTransactionStatus('🎮 Chess game created! Waiting for opponent...', '');
        
    } catch (error) {
        showTransactionStatus('❌ Failed to create Chess game: ' + error.message, '');
    }
}

async function createCheckersGame() {
    const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
    if (!validateStakeAndWallet(stakeAmount)) return;
    
    try {
        showTransactionStatus('🔄 Creating Checkers game...', '');
        
        const session = await gameMatchmaker.createGame('checkers', stakeAmount, userAccount);
        multiplayerSession = session;
        
        currentBalance -= stakeAmount;
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
        
        openGameWindow('checkers');
        initializeCheckersBoard(session);
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        updateGamesDisplay();
        
        document.getElementById('checkersStake').value = '';
        
        showTransactionStatus('🎮 Checkers game created! Waiting for opponent...', '');
        
    } catch (error) {
        showTransactionStatus('❌ Failed to create Checkers game: ' + error.message, '');
    }
}

async function createWordGame() {
    const stakeAmount = parseFloat(document.getElementById('wordStake').value);
    if (!validateStakeAndWallet(stakeAmount)) return;
    
    try {
        showTransactionStatus('🔄 Creating Word game...', '');
        
        const session = await gameMatchmaker.createGame('words', stakeAmount, userAccount);
        multiplayerSession = session;
        
        currentBalance -= stakeAmount;
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
        
        openGameWindow('word');
        initializeWordGame(session);
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        updateGamesDisplay();
        
        document.getElementById('wordStake').value = '';
        
        showTransactionStatus('🎮 Word game created! Waiting for opponent...', '');
        
    } catch (error) {
        showTransactionStatus('❌ Failed to create Word game: ' + error.message, '');
    }
}

// Enhanced Join Game Function
async function joinGame(gameId, stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stakeAmount) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }
    
    try {
        showTransactionStatus('🔄 Joining game...', '');
        
        const session = await gameMatchmaker.joinGame(gameId, userAccount, stakeAmount);
        multiplayerSession = session;
        
        // Update balance (simulate spending)
        currentBalance -= stakeAmount;
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
        
        // Refresh lobby
        await refreshLobby();
        
        addActivityFeedItem(`⚔️ You joined game #${gameId} with ${stakeAmount} CORE stake`);
        showTransactionStatus('🎮 Game joined! Good luck!', '');
        
    } catch (error) {
        showTransactionStatus('❌ Failed to join game: ' + error.message, '');
    }
}

// Chat Functions
function sendGameChatMessage(gameType) {
    const chatInput = document.getElementById(gameType + 'ChatInput');
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    if (multiplayerSession && multiplayerSession.gameType === gameType) {
        multiplayerSession.addChatMessage('You', message);
        chatInput.value = '';
        
        // Simulate opponent response occasionally
        if (Math.random() < 0.3) {
            setTimeout(() => {
                const responses = [
                    "Good move!",
                    "Interesting strategy",
                    "Let's see...",
                    "Nice one!",
                    "GG so far",
                    "You're good!",
                    "Think I can counter that",
                    "Clever play"
                ];
                const randomResponse = responses[Math.floor(Math.random() * responses.length)];
                multiplayerSession.addChatMessage('Opponent', randomResponse);
            }, 1000 + Math.random() * 2000);
        }
    }
}

function addGameChatMessage(gameType, user, message) {
    const chatMessages = document.getElementById(gameType + 'GameChat');
    if (!chatMessages) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'game-chat-message';
    messageDiv.innerHTML = `<strong>${user}:</strong> ${message}`;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Limit chat history
    while (chatMessages.children.length > 20) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

function handleGameChatKeyPress(event, gameType) {
    if (event.key === 'Enter') {
        sendGameChatMessage(gameType);
    }
}

// Global Chat
function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    if (!userAccount) {
        showTransactionStatus('⚠️ Please connect your wallet to chat', '');
        return;
    }
    
    if (message.length > 200) {
        showTransactionStatus('⚠️ Message too long (max 200 characters)', '');
        return;
    }
    
    addChatMessage('You', message);
    chatInput.value = '';
    
    // Simulate other players chatting
    setTimeout(() => {
        const responses = [
            "Good luck with your games! 🎮",
            "Welcome to Crypticus! 🚀",
            "Let's play some blockchain games! ⚔️",
            "Nice strategy! 🧠",
            "The future of gaming is here! 💎",
            "Just won a chess match! 🏆",
            "Anyone up for checkers?",
            "These word games are addictive!",
            "CORE to the moon! 🌙"
        ];
        
        const usernames = [
            'CryptoKing', 'GameMaster', 'BlockchainBro', 
            'TokenMaster', 'WordWizard', 'ChessGrandmaster',
            'CheckersChamp', 'COREBeliever', 'GameOn'
        ];
        
        const randomUser = usernames[Math.floor(Math.random() * usernames.length)];
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        
        addChatMessage(randomUser, randomResponse);
    }, 1000 + Math.random() * 4000);
}

function addChatMessage(user, message) {
    const chatMessages = document.getElementById('chatMessages');
    if (!chatMessages) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'chat-message fade-in';
    
    const timestamp = new Date().toLocaleTimeString('en-US', { 
        hour12: false, 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    
    const isUser = user === 'You';
    const userColor = isUser ? '#4ecdc4' : '#f39c12';
    
    messageDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.3rem;">
            <strong style="color: ${userColor};">${user}:</strong>
            <span style="color: #aaa; font-size: 0.7rem;">${timestamp}</span>
        </div>
        <div style="margin-left: 0.5rem; word-wrap: break-word;">${message}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Limit chat history
    while (chatMessages.children.length > 50) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendChatMessage();
    }
}

// All remaining utility and initialization functions from original code...
// (Include all the blockchain, wallet, navigation, stats functions from the original)

// Initialize platform when page loads
document.addEventListener('DOMContentLoaded', async () => {
    console.log('🎮 Crypticus Enhanced Multiplayer Platform Loading...');
    
    await initializePlatform();
    
    // Add initial chat messages
    addChatMessage('System', 'Welcome to Crypticus! Connect your wallet to start playing.');
    addChatMessage('CryptoKing', 'Just won 2.5 CORE in Chess! 🎉');
    addChatMessage('GameMaster', 'New high stakes games available!');
    addChatMessage('WordWizard', 'Word battles are intense here! 📝');
    
    console.log('🚀 Crypticus Enhanced Multiplayer Platform Ready!');
});

// Event listeners
document.getElementById('connectBtn').addEventListener('click', connectWallet);
document.getElementById('disconnectBtn').addEventListener('click', disconnectWallet);

document.getElementById('transactionStatus').addEventListener('click', () => {
    document.getElementById('transactionStatus').classList.remove('show');
});

window.addEventListener('beforeunload', () => {
    saveUserData();
    if (userAccount) {
        sessionStorage.setItem('walletConnected', 'true');
    } else {
        sessionStorage.removeItem('walletConnected');
    }
});

console.log('✨ Enhanced Multiplayer System Initialized Successfully! Players can now join and play real games with settlements.');
    </script>
</body>
</html>
