<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="CrossRealm Gaming - Blockchain gaming platform on Core Network">
    <meta name="keywords" content="blockchain gaming, Core Network, cryptocurrency games, chess, checkers">
    <meta name="author" content="CrossRealm Gaming">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; img-src 'self' data: https:; connect-src 'self' https://api.jsonbin.io https://rpc.coredao.org https://scan.coredao.org; font-src 'self' https://cdnjs.cloudflare.com;">
    <title>CrossRealm Gaming - Blockchain Gaming on Core Network</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" integrity="sha512-JNGbhLCEQuKMUOdNuY3iDeApC5A3VdMGGqLfGKFqN4iIdFJX3J0sEF8HWjKgw9LhJHQ8Qj9K4i2kGY1tCXKSMQ==" crossorigin="anonymous"></script>
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎮</text></svg>">
</head>
<body>
    <div class="background-overlay"></div>
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-content">
            <div class="logo-loading">
                <i class="fas fa-dice-d20 logo-icon"></i>
                <h1>CROSSREALM</h1>
            </div>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <div class="loading-status" id="loadingStatus">Initializing platform...</div>
            <!-- FIX: Added debug info and emergency bypass -->
            <div style="margin-top: 20px; font-size: 12px; color: #888; text-align: center;">
                <div id="debugInfo">Loading...</div>
                <button id="emergencyBypass" style="margin-top: 10px; padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; display: none; font-size: 11px;">
                    Emergency Bypass (Dev)
                </button>
                <div id="loadingTimer" style="margin-top: 5px; font-size: 10px;">Time: <span id="timerCount">0</span>s</div>
            </div>
        </div>
    </div>

    <!-- FIX: Age Verification Modal - Enhanced with better event handling -->
    <div class="modal-overlay" id="ageVerificationModal" style="display: none;">
        <div class="modal-content verification-modal">
            <div class="modal-header">
                <h2><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h2>
            </div>
            <div class="modal-body">
                <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
                <div class="warning-box">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
                </div>
                <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-success" id="ageVerifyYes" data-action="verify-age" data-value="true">I am 18+</button>
                <button class="btn btn-danger" id="ageVerifyNo" data-action="verify-age" data-value="false">Under 18</button>
            </div>
        </div>
    </div>

    <!-- FIX: Anti-Bot Challenge Modal - Enhanced with better event handling -->
    <div class="modal-overlay" id="antiBotModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-shield-alt"></i> Human Verification</h3>
            </div>
            <div class="modal-body">
                <p>Please complete this challenge to continue:</p>
                <div class="captcha-container">
                    <div class="captcha-instructions" id="captchaInstructions">
                        Select all squares containing chess pieces
                    </div>
                    <div class="captcha-grid" id="captchaGrid">
                        <!-- Grid will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="verifyCaptchaBtn" disabled>Verify</button>
                <button class="btn btn-secondary" id="refreshCaptchaBtn">New Challenge</button>
            </div>
        </div>
    </div>

    <!-- Game Invitation Modal -->
    <div class="modal-overlay hidden" id="gameInvitationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-gamepad"></i> Game Invitation</h3>
            </div>
            <div class="modal-body">
                <p id="invitationMessage">Player wants to join your game!</p>
                <div class="invitation-details" id="invitationDetails"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-success" data-action="accept-invitation">Accept</button>
                <button class="btn btn-danger" data-action="decline-invitation">Decline</button>
            </div>
        </div>
    </div>

    <!-- Notification System -->
    <div class="notification-container" id="notificationContainer">
        <!-- Notifications will be populated by JavaScript -->
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div class="tx-message" id="txMessage">Processing...</div>
        <div class="tx-hash" id="txHash"></div>
        <button class="tx-close" id="txClose">&times;</button>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <i class="fas fa-dice-d20 logo-icon"></i>
                <h1>CROSSREALM</h1>
            </div>
            
            <nav class="nav-menu" id="navMenu">
                <button class="nav-item active" data-section="lobby">
                    <i class="fas fa-home"></i> Lobby
                </button>
                <button class="nav-item" data-section="create">
                    <i class="fas fa-plus"></i> Create Game
                </button>
                <button class="nav-item" data-section="games">
                    <i class="fas fa-gamepad"></i> Games
                </button>
                <button class="nav-item" data-section="tournaments">
                    <i class="fas fa-trophy"></i> Tournaments
                </button>
                <button class="nav-item" data-section="profile">
                    <i class="fas fa-user"></i> Profile
                </button>
                <button class="nav-item" data-section="settings">
                    <i class="fas fa-cog"></i> Settings
                </button>
            </nav>
            
            <div class="live-indicator">
                <div class="pulse-dot"></div>
                <span>LIVE ON CORE</span>
            </div>
            
            <div class="wallet-section">
                <div class="wallet-info">
                    <div class="connection-status" id="connectionStatus">
                        <span class="status-indicator offline"></span>
                        <span class="status-text">Not Connected</span>
                    </div>
                    <div class="balance" id="balanceDisplay">0.0000 CORE</div>
                </div>
                <button class="btn btn-primary" id="connectBtn">
                    <i class="fas fa-plug"></i> Connect Wallet
                </button>
                <button class="btn btn-secondary hidden" id="disconnectBtn">
                    <i class="fas fa-sign-out-alt"></i> Disconnect
                </button>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Smart Contract Status -->
            <div class="widget contract-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-file-contract"></i> Smart Contract</h3>
                </div>
                <div class="widget-content">
                    <div class="contract-address" id="contractAddress">
                        <span class="address-text">Loading...</span>
                        <button class="btn-copy" data-copy-target="contract-address">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                    <div class="contract-status" id="contractStatus">
                        <span class="status-indicator pending"></span>
                        <span>Connecting...</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="connectionProgress"></div>
                    </div>
                </div>
            </div>

            <!-- Server Status -->
            <div class="widget server-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-server"></i> Server Status</h3>
                </div>
                <div class="widget-content">
                    <div class="server-status" id="serverStatus">
                        <span class="status-indicator pending"></span>
                        <span>Connecting...</span>
                    </div>
                    <div class="server-details">
                        <div class="detail-row">
                            <span class="detail-label">Latency:</span>
                            <span class="detail-value" id="serverLatency">--ms</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Last Sync:</span>
                            <span class="detail-value" id="lastSync">Never</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Status:</span>
                            <span class="detail-value" id="serverStatusText">Offline</span>
                        </div>
                    </div>
                    <button class="btn btn-sm btn-primary" id="testConnectionBtn">
                        <i class="fas fa-wifi"></i> Test Connection
                    </button>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="widget stats-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-chart-line"></i> Live Stats</h3>
                </div>
                <div class="widget-content">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="onlinePlayersCount">0</div>
                            <div class="stat-label">Online Players</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="activeGamesCount">0</div>
                            <div class="stat-label">Active Games</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalVolumeCount">0</div>
                            <div class="stat-label">CORE Volume</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- My Active Games -->
            <div class="widget my-games-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-gamepad"></i> My Active Games</h3>
                </div>
                <div class="widget-content">
                    <div class="my-games-list" id="myActiveGamesList">
                        <div class="no-games">
                            <i class="fas fa-ghost"></i>
                            <p>No active games</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activity Feed -->
            <div class="widget activity-widget">
                <div class="widget-header">
                    <h3><i class="fas fa-fire"></i> Recent Activity</h3>
                </div>
                <div class="widget-content">
                    <div class="activity-feed" id="activityFeed">
                        <div class="activity-item">
                            <i class="fas fa-rocket"></i>
                            <span>Platform initialized</span>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="content-area">
            <!-- Sections will be dynamically loaded here -->
            <section id="lobbySection" class="section-content active">
                <!-- Lobby content will be loaded by JavaScript -->
            </section>
            <section id="createSection" class="section-content">
                <!-- Create game content will be loaded by JavaScript -->
            </section>
            <section id="gamesSection" class="section-content">
                <!-- Games content will be loaded by JavaScript -->
            </section>
            <section id="tournamentsSection" class="section-content">
                <!-- Tournaments content will be loaded by JavaScript -->
            </section>
            <section id="profileSection" class="section-content">
                <!-- Profile content will be loaded by JavaScript -->
            </section>
            <section id="settingsSection" class="section-content">
                <!-- Settings content will be loaded by JavaScript -->
            </section>
        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4><i class="fas fa-dice-d20"></i> CrossRealm</h4>
                <p>Premier blockchain gaming platform on Core Network. Play, compete, and earn with provably fair games.</p>
                <div class="social-links">
                    <a href="#" class="social-link" aria-label="Twitter">
                        <i class="fab fa-twitter"></i>
                    </a>
                    <a href="#" class="social-link" aria-label="Discord">
                        <i class="fab fa-discord"></i>
                    </a>
                    <a href="#" class="social-link" aria-label="GitHub">
                        <i class="fab fa-github"></i>
                    </a>
                </div>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-gamepad"></i> Games</h4>
                <ul>
                    <li><a href="#" data-section="games">Chess Masters</a></li>
                    <li><a href="#" data-section="games">Checkers Pro</a></li>
                    <li><a href="#" data-section="games">Word Battle</a></li>
                    <li><a href="#" data-section="tournaments">Tournaments</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-link"></i> Blockchain</h4>
                <ul>
                    <li><a href="https://scan.coredao.org" target="_blank" rel="noopener noreferrer">Core Explorer</a></li>
                    <li><a href="https://coredao.org" target="_blank" rel="noopener noreferrer">Core Network</a></li>
                    <li><a href="#" data-action="show-contract">Smart Contract</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4><i class="fas fa-info-circle"></i> Support</h4>
                <ul>
                    <li><a href="#" data-action="show-help">Help Center</a></li>
                    <li><a href="#" data-action="show-terms">Terms of Service</a></li>
                    <li><a href="#" data-action="show-privacy">Privacy Policy</a></li>
                    <li><a href="#" data-action="show-fairplay">Fair Play</a></li>
                </ul>
            </div>
        </div>
        
        <div class="footer-bottom">
            <p>&copy; 2025 CrossRealm Gaming Platform. All rights reserved.</p>
            <p>Built on <strong>Core Blockchain</strong> • Licensed Gaming Platform • 18+ Only</p>
        </div>
    </footer>
  <style>
    /* ===========================
   CROSSREALM GAMING PLATFORM
   COMPLETE CSS STYLING WITH PERFORMANCE & SECURITY FIXES
   =========================== */

/* CSS Custom Properties for Better Theming */
:root {
    /* Color Palette */
    --color-primary: #4e54c8;
    --color-primary-dark: #363a9e;
    --color-secondary: #f39c12;
    --color-accent: #4ecdc4;
    --color-accent-dark: #44a08d;
    --color-success: #2ecc71;
    --color-warning: #f1c40f;
    --color-danger: #e74c3c;
    --color-info: #3498db;
    
    /* Background Colors */
    --bg-primary: #1a1c2c;
    --bg-secondary: #2c3e50;
    --bg-surface: rgba(255, 255, 255, 0.05);
    --bg-glass: rgba(255, 255, 255, 0.1);
    --bg-overlay: rgba(0, 0, 0, 0.8);
    
    /* Text Colors */
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --text-muted: #888888;
    
    /* Border Colors */
    --border-primary: rgba(255, 255, 255, 0.2);
    --border-accent: rgba(78, 205, 196, 0.5);
    
    /* Spacing */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    --spacing-xxl: 3rem;
    
    /* Border Radius */
    --radius-sm: 4px;
    --radius-md: 8px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    --radius-pill: 50px;
    
    /* Shadows */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.2);
    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.3);
    --shadow-glow: 0 0 20px rgba(78, 205, 196, 0.3);
    
    /* Animation Timing */
    --transition-fast: 0.15s ease-out;
    --transition-normal: 0.3s ease-out;
    --transition-slow: 0.5s ease-out;
    
    /* Z-index Scale */
    --z-background: -1;
    --z-base: 0;
    --z-elevated: 10;
    --z-dropdown: 100;
    --z-sticky: 200;
    --z-fixed: 300;
    --z-modal-backdrop: 900;
    --z-modal: 1000;
    --z-notification: 1100;
    --z-tooltip: 1200;
}

/* CSS Reset & Base Styles */
*,
*::before,
*::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    scroll-behavior: smooth;
}

body {
    font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
    background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
    overflow-x: hidden;
    position: relative;
}

/* Performance Optimizations */
* {
    will-change: auto;
}

.loading-screen,
.modal-overlay,
.notification,
.game-window {
    will-change: transform, opacity;
}

/* Accessibility Improvements */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Focus Styles for Accessibility */
button:focus,
input:focus,
select:focus,
textarea:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
}

/* Background Overlay */
.background-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(circle at 20% 50%, rgba(78, 205, 196, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(78, 84, 200, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(243, 156, 18, 0.05) 0%, transparent 50%);
    z-index: var(--z-background);
    pointer-events: none;
}

/* ===========================
   LOADING SCREEN
   =========================== */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: var(--z-modal);
    backdrop-filter: blur(10px);
}

.loading-content {
    text-align: center;
    max-width: 400px;
    padding: var(--spacing-xl);
}

.logo-loading {
    margin-bottom: var(--spacing-xl);
}

.logo-loading .logo-icon {
    font-size: 4rem;
    color: var(--color-accent);
    margin-bottom: var(--spacing-md);
    animation: pulse 2s infinite;
}

.logo-loading h1 {
    font-size: 2.5rem;
    background: linear-gradient(45deg, var(--color-primary), var(--color-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.loading-bar {
    width: 100%;
    height: 4px;
    background: var(--bg-surface);
    border-radius: var(--radius-pill);
    overflow: hidden;
    margin-bottom: var(--spacing-md);
}

.loading-progress {
    height: 100%;
    background: linear-gradient(90deg, var(--color-accent), var(--color-primary));
    width: 0%;
    transition: width var(--transition-normal);
    border-radius: var(--radius-pill);
}

.loading-status {
    color: var(--text-secondary);
    font-size: 0.9rem;
}

/* ===========================
   UTILITY CLASSES
   =========================== */
.hidden { display: none !important; }
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* Text Utilities */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

/* Spacing Utilities */
.mt-0 { margin-top: 0; }
.mt-1 { margin-top: var(--spacing-sm); }
.mt-2 { margin-top: var(--spacing-md); }
.mt-3 { margin-top: var(--spacing-lg); }

.mb-0 { margin-bottom: 0; }
.mb-1 { margin-bottom: var(--spacing-sm); }
.mb-2 { margin-bottom: var(--spacing-md); }
.mb-3 { margin-bottom: var(--spacing-lg); }

/* ===========================
   BUTTON SYSTEM
   =========================== */
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    border: none;
    border-radius: var(--radius-md);
    font-size: 0.9rem;
    font-weight: 600;
    text-decoration: none;
    cursor: pointer;
    transition: all var(--transition-fast);
    position: relative;
    overflow: hidden;
    min-height: 44px; /* Accessibility minimum touch target */
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

.btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left var(--transition-normal);
}

.btn:hover:not(:disabled)::before {
    left: 100%;
}

.btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.btn:active:not(:disabled) {
    transform: translateY(0);
}

/* Button Variants */
.btn-primary {
    background: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark));
    color: white;
}

.btn-secondary {
    background: var(--bg-surface);
    color: var(--text-primary);
    border: 1px solid var(--border-primary);
}

.btn-success {
    background: linear-gradient(135deg, var(--color-success), #27ae60);
    color: white;
}

.btn-danger {
    background: linear-gradient(135deg, var(--color-danger), #c0392b);
    color: white;
}

.btn-warning {
    background: linear-gradient(135deg, var(--color-warning), var(--color-secondary));
    color: var(--bg-primary);
}

.btn-accent {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    color: white;
}

/* Button Sizes */
.btn-sm {
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: 0.8rem;
    min-height: 36px;
}

.btn-lg {
    padding: var(--spacing-md) var(--spacing-xl);
    font-size: 1.1rem;
    min-height: 52px;
}

.btn-copy {
    padding: var(--spacing-xs);
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    min-height: 32px;
    width: 32px;
}

.btn-block {
    width: 100%;
}

/* ===========================
   MODAL SYSTEM (FIXED)
   =========================== */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: var(--z-modal-backdrop);
    backdrop-filter: blur(5px);
    animation: fadeIn var(--transition-normal) ease-out;
}

.modal-content {
    background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
    border: 2px solid var(--color-accent);
    border-radius: var(--radius-xl);
    padding: 0;
    max-width: 90vw;
    max-height: 90vh;
    overflow: hidden;
    box-shadow: var(--shadow-lg);
    animation: slideInScale var(--transition-normal) ease-out;
    position: relative;
    z-index: var(--z-modal);
}

.modal-header {
    padding: var(--spacing-lg);
    border-bottom: 1px solid var(--border-primary);
    background: rgba(78, 205, 196, 0.1);
}

.modal-header h2,
.modal-header h3 {
    margin: 0;
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.modal-body {
    padding: var(--spacing-lg);
}

.modal-footer {
    padding: var(--spacing-lg);
    border-top: 1px solid var(--border-primary);
    display: flex;
    gap: var(--spacing-md);
    justify-content: center;
    background: var(--bg-surface);
}

.verification-modal {
    max-width: 500px;
}

.warning-box {
    background: rgba(241, 196, 15, 0.1);
    border: 1px solid rgba(241, 196, 15, 0.3);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin: var(--spacing-md) 0;
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-sm);
}

.warning-box i {
    color: var(--color-warning);
    margin-top: 2px;
    flex-shrink: 0;
}

/* ===========================
   CAPTCHA SYSTEM
   =========================== */
.captcha-container {
    text-align: center;
}

.captcha-instructions {
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-sm);
    background: var(--bg-surface);
    border-radius: var(--radius-md);
    font-weight: 600;
    color: var(--color-warning);
}

.captcha-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-sm);
    max-width: 240px;
    margin: 0 auto var(--spacing-md);
}

.captcha-tile {
    aspect-ratio: 1;
    background: var(--bg-surface);
    border: 2px solid var(--border-primary);
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all var(--transition-fast);
    user-select: none;
}

.captcha-tile:hover {
    background: rgba(78, 205, 196, 0.1);
    border-color: var(--color-accent);
}

.captcha-tile.selected {
    background: rgba(78, 205, 196, 0.2);
    border-color: var(--color-accent);
    box-shadow: var(--shadow-glow);
}

/* ===========================
   NOTIFICATION SYSTEM (ENHANCED)
   =========================== */
.notification-container {
    position: fixed;
    top: 80px;
    right: var(--spacing-md);
    z-index: var(--z-notification);
    max-width: 380px;
    pointer-events: none;
}

.notification {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 28, 44, 0.95));
    backdrop-filter: blur(15px);
    border: 2px solid var(--color-accent);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    animation: slideInRight var(--transition-normal) ease-out;
    pointer-events: auto;
    cursor: pointer;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
}

.notification::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 4px;
    height: 100%;
    background: var(--color-accent);
}

.notification.success {
    border-color: var(--color-success);
}

.notification.success::before {
    background: var(--color-success);
}

.notification.warning {
    border-color: var(--color-warning);
}

.notification.warning::before {
    background: var(--color-warning);
}

.notification.error {
    border-color: var(--color-danger);
}

.notification.error::before {
    background: var(--color-danger);
}

.notification-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: var(--spacing-sm);
}

.notification-title {
    font-weight: 600;
    color: var(--color-accent);
    font-size: 0.9rem;
}

.notification-close {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color var(--transition-fast);
}

.notification-close:hover {
    color: var(--text-primary);
}

.notification-message {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
    margin-bottom: var(--spacing-sm);
}

.notification-actions {
    display: flex;
    gap: var(--spacing-sm);
    justify-content: flex-end;
}

.notification-btn {
    padding: var(--spacing-xs) var(--spacing-sm);
    background: var(--color-accent);
    border: none;
    border-radius: var(--radius-sm);
    color: white;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all var(--transition-fast);
}

.notification-btn:hover {
    background: var(--color-accent-dark);
    transform: translateY(-1px);
}

.notification-btn.secondary {
    background: var(--bg-surface);
    color: var(--text-primary);
}

/* ===========================
   TRANSACTION STATUS
   =========================== */
.transaction-status {
    position: fixed;
    bottom: var(--spacing-md);
    right: var(--spacing-md);
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(15px);
    border: 1px solid var(--color-accent);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    min-width: 300px;
    max-width: 400px;
    z-index: var(--z-notification);
    transform: translateX(120%);
    transition: transform var(--transition-normal);
    box-shadow: var(--shadow-lg);
}

.transaction-status.show {
    transform: translateX(0);
}

.tx-message {
    color: var(--text-primary);
    margin-bottom: var(--spacing-sm);
    font-weight: 500;
}

.tx-hash {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: var(--color-accent);
    word-break: break-all;
    margin-bottom: var(--spacing-sm);
}

.tx-close {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-sm);
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* ===========================
   HEADER STYLES
   =========================== */
.header {
    position: sticky;
    top: 0;
    z-index: var(--z-sticky);
    background: rgba(26, 28, 44, 0.95);
    backdrop-filter: blur(15px);
    border-bottom: 1px solid var(--border-primary);
    padding: var(--spacing-md);
}

.header-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-md);
    max-width: 1400px;
    margin: 0 auto;
}

.logo {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    flex-shrink: 0;
}

.logo-icon {
    font-size: 2rem;
    color: var(--color-accent);
    animation: pulse 3s infinite;
}

.logo h1 {
    font-size: 1.5rem;
    background: linear-gradient(45deg, var(--color-primary), var(--color-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight: 800;
}

.nav-menu {
    display: flex;
    gap: var(--spacing-sm);
    align-items: center;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    padding: var(--spacing-xs) 0;
}

.nav-menu::-webkit-scrollbar {
    display: none;
}

.nav-item {
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-fast);
    white-space: nowrap;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
}

.nav-item:hover {
    background: rgba(78, 205, 196, 0.1);
    border-color: var(--color-accent);
    transform: translateY(-2px);
}

.nav-item.active {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
    border-color: var(--color-accent);
    color: white;
}

.nav-item.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}

.live-indicator {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    padding: var(--spacing-xs) var(--spacing-sm);
    background: linear-gradient(135deg, var(--color-success), #27ae60);
    border-radius: var(--radius-pill);
    color: white;
    font-size: 0.8rem;
    font-weight: 600;
    flex-shrink: 0;
}

.pulse-dot {
    width: 8px;
    height: 8px;
    background: white;
    border-radius: 50%;
    animation: pulse 1.5s infinite;
}

.wallet-section {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    flex-shrink: 0;
}

.wallet-info {
    text-align: right;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    font-size: 0.85rem;
    margin-bottom: var(--spacing-xs);
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.status-indicator.online {
    background: var(--color-success);
    animation: pulse 2s infinite;
}

.status-indicator.offline {
    background: var(--color-danger);
}

.status-indicator.pending {
    background: var(--color-warning);
    animation: blink 1s infinite;
}

.balance {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-accent);
    font-family: 'Courier New', monospace;
}

/* ===========================
   MAIN LAYOUT
   =========================== */
.main-container {
    display: flex;
    min-height: calc(100vh - 80px);
    max-width: 1400px;
    margin: 0 auto;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
}

.sidebar {
    width: 320px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.sidebar::-webkit-scrollbar {
    width: 6px;
}

.sidebar::-webkit-scrollbar-track {
    background: var(--bg-surface);
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.5);
}

.content-area {
    flex: 1;
    min-width: 0;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.content-area::-webkit-scrollbar {
    width: 6px;
}

.content-area::-webkit-scrollbar-track {
    background: var(--bg-surface);
    border-radius: 3px;
}

.content-area::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 3px;
}

.content-area::-webkit-scrollbar-thumb:hover {
    background: rgba(78, 205, 196, 0.5);
}

.section-content {
    display: none;
    animation: fadeIn var(--transition-normal) ease-out;
}

.section-content.active {
    display: block;
}

/* ===========================
   WIDGET SYSTEM
   =========================== */
.widget {
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    transition: all var(--transition-fast);
}

.widget:hover {
    border-color: var(--border-accent);
    box-shadow: var(--shadow-sm);
}

.widget-header {
    padding: var(--spacing-md);
    background: rgba(78, 205, 196, 0.05);
    border-bottom: 1px solid var(--border-primary);
}

.widget-header h3 {
    margin: 0;
    font-size: 1rem;
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.widget-content {
    padding: var(--spacing-md);
}

/* Contract Widget */
.contract-address {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    background: var(--bg-primary);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
}

.address-text {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: var(--text-secondary);
    flex: 1;
    word-break: break-all;
}

.contract-status,
.server-status {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    font-size: 0.9rem;
}

.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--bg-primary);
    border-radius: var(--radius-pill);
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--color-accent), var(--color-primary));
    width: 0%;
    transition: width var(--transition-normal);
    border-radius: var(--radius-pill);
}

/* Server Widget */
.server-details {
    margin: var(--spacing-sm) 0;
}

.detail-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xs) 0;
    font-size: 0.85rem;
}

.detail-label {
    color: var(--text-muted);
}

.detail-value {
    color: var(--color-accent);
    font-weight: 500;
}

/* Stats Widget */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: var(--spacing-md);
}

.stat-item {
    text-align: center;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-accent);
    display: block;
    line-height: 1;
}

.stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: var(--spacing-xs);
    line-height: 1.2;
}

/* My Games Widget */
.my-games-list {
    max-height: 200px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.my-games-list::-webkit-scrollbar {
    width: 4px;
}

.my-games-list::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

.my-games-list::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 2px;
}

.my-game-item {
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
}

.my-game-item:hover {
    background: rgba(78, 205, 196, 0.05);
    border-color: var(--color-accent);
    transform: translateX(2px);
}

.my-game-item:last-child {
    margin-bottom: 0;
}

.no-games {
    text-align: center;
    padding: var(--spacing-xl);
    color: var(--text-muted);
}

.no-games i {
    font-size: 2rem;
    margin-bottom: var(--spacing-sm);
    opacity: 0.5;
}

/* Activity Widget */
.activity-feed {
    max-height: 150px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(78, 205, 196, 0.3) transparent;
}

.activity-feed::-webkit-scrollbar {
    width: 4px;
}

.activity-feed::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

.activity-feed::-webkit-scrollbar-thumb {
    background: rgba(78, 205, 196, 0.3);
    border-radius: 2px;
}

.activity-item {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-xs) 0;
    font-size: 0.85rem;
    color: var(--text-secondary);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.activity-item:last-child {
    border-bottom: none;
}

.activity-item i {
    color: var(--color-accent);
    width: 16px;
    flex-shrink: 0;
}

/* ===========================
   CONTENT SECTIONS
   =========================== */
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-xl);
    padding-bottom: var(--spacing-md);
    border-bottom: 1px solid var(--border-primary);
}

.section-header h2 {
    color: var(--color-accent);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: var(--spacing-lg);
    padding: var(--spacing-md) 0;
}

.game-card {
    background: var(--bg-surface);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    transition: all var(--transition-fast);
    cursor: pointer;
}

.game-card:hover {
    border-color: var(--color-accent);
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
}

.game-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-md);
    background: rgba(78, 205, 196, 0.05);
    border-bottom: 1px solid var(--border-primary);
}

.game-type {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-weight: 600;
    color: var(--color-accent);
}

.game-skill {
    font-size: 0.85rem;
    font-weight: 500;
}

.game-card-body {
    padding: var(--spacing-md);
}

.game-stake {
    text-align: center;
    margin-bottom: var(--spacing-md);
}

.stake-amount {
    display: block;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-accent);
    font-family: 'Courier New', monospace;
}

.stake-label {
    font-size: 0.8rem;
    color: var(--text-muted);
}

.game-info {
    margin-bottom: var(--spacing-md);
}

.info-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xs) 0;
    font-size: 0.9rem;
}

.info-label {
    color: var(--text-muted);
}

.info-value {
    color: var(--text-primary);
    font-weight: 500;
}

.game-card-footer {
    padding: var(--spacing-md);
    padding-top: 0;
}

/* ===========================
   FOOTER STYLES
   =========================== */
.footer {
    background: var(--bg-primary);
    border-top: 1px solid var(--border-primary);
    padding: var(--spacing-xxl) var(--spacing-md) var(--spacing-xl);
    margin-top: var(--spacing-xxl);
}

.footer-content {
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: var(--spacing-xl);
}

.footer-section h4 {
    color: var(--color-accent);
    margin-bottom: var(--spacing-md);
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.footer-section p {
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: var(--spacing-md);
}

.footer-section ul {
    list-style: none;
}

.footer-section ul li {
    margin-bottom: var(--spacing-sm);
}

.footer-section a {
    color: var(--text-secondary);
    text-decoration: none;
    transition: color var(--transition-fast);
    cursor: pointer;
}

.footer-section a:hover {
    color: var(--color-accent);
}

.social-links {
    display: flex;
    gap: var(--spacing-md);
    margin-top: var(--spacing-md);
}

.social-link {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    background: var(--bg-surface);
    border-radius: 50%;
    color: var(--color-accent);
    text-decoration: none;
    transition: all var(--transition-fast);
}

.social-link:hover {
    background: var(--color-accent);
    color: white;
    transform: translateY(-2px);
}

.footer-bottom {
    text-align: center;
    padding-top: var(--spacing-xl);
    margin-top: var(--spacing-xl);
    border-top: 1px solid var(--border-primary);
    color: var(--text-muted);
    font-size: 0.9rem;
    line-height: 1.6;
}

/* ===========================
   ANIMATIONS (ENHANCED)
   =========================== */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideInRight {
    from {
        opacity: 0;
        transform: translateX(100%);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes slideInScale {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes pulse {
    0%, 100% { 
        transform: scale(1); 
        opacity: 1; 
    }
    50% { 
        transform: scale(1.05); 
        opacity: 0.8; 
    }
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ===========================
   RESPONSIVE DESIGN
   =========================== */
@media (max-width: 1024px) {
    .main-container {
        flex-direction: column;
        gap: var(--spacing-md);
    }
    
    .sidebar {
        width: 100%;
        max-height: none;
        order: 2;
    }
    
    .content-area {
        order: 1;
        max-height: none;
    }
    
    .header-content {
        flex-wrap: wrap;
        gap: var(--spacing-sm);
    }
    
    .wallet-section {
        order: -1;
        width: 100%;
        justify-content: space-between;
    }
}

@media (max-width: 768px) {
    .main-container {
        padding: var(--spacing-sm);
    }
    
    .header {
        padding: var(--spacing-sm);
    }
    
    .header-content {
        flex-direction: column;
        align-items: stretch;
        gap: var(--spacing-sm);
    }
    
    .logo {
        justify-content: center;
    }
    
    .nav-menu {
        justify-content: center;
        overflow-x: auto;
        padding: var(--spacing-sm) 0;
    }
    
    .wallet-section {
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .notification-container {
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        max-width: none;
    }
    
    .modal-content {
        margin: var(--spacing-md);
        max-width: none;
    }
    
    .footer-content {
        grid-template-columns: 1fr;
        text-align: center;
    }
}

@media (max-width: 480px) {
    .logo h1 {
        font-size: 1.2rem;
    }
    
    .logo-icon {
        font-size: 1.5rem;
    }
    
    .nav-item {
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 0.8rem;
    }
    
    .btn {
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 0.8rem;
    }
    
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .captcha-grid {
        max-width: 180px;
    }
    
    .captcha-tile {
        font-size: 1.2rem;
    }
}

/* ===========================
   PRINT STYLES
   =========================== */
@media print {
    .header,
    .sidebar,
    .footer,
    .notification-container,
    .transaction-status,
    .modal-overlay {
        display: none !important;
    }
    
    .main-container {
        flex-direction: column;
        padding: 0;
    }
    
    .content-area {
        max-height: none;
        overflow: visible;
    }
    
    body {
        background: white !important;
        color: black !important;
    }
}

/* ===========================
   HIGH CONTRAST MODE
   =========================== */
@media (prefers-contrast: high) {
    :root {
        --bg-surface: rgba(255, 255, 255, 0.15);
        --border-primary: rgba(255, 255, 255, 0.4);
        --text-secondary: #e0e0e0;
    }
    
    .btn {
        border: 2px solid currentColor;
    }
    
    .notification,
    .modal-content,
    .widget {
        border-width: 3px;
    }
}

/* ===========================
   NO ANIMATIONS CLASS (DEV MODE)
   =========================== */
.no-animations * {
    animation: none !important;
    transition: none !important;
}
  </style>
  <script>
    /* ===========================
   CROSSREALM GAMING PLATFORM
   CORE JAVASCRIPT - STATE MANAGEMENT & SECURITY LAYER (FIXED)
   =========================== */

'use strict';

// ===========================
// SECURITY & CONFIGURATION
// ===========================

// Secure Configuration Manager
class ConfigManager {
    constructor() {
        this.config = {
            // Blockchain Configuration
            CORE_CHAIN_ID: '0x45c',
            CORE_RPC_URL: 'https://rpc.coredao.org',
            CORE_EXPLORER_URL: 'https://scan.coredao.org',
            CONTRACT_ADDRESS: '0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A',
            
            // API Configuration (Proxied for security)
            API_BASE_URL: '/api', // This would proxy to your backend
            JSONBIN_PROXY_URL: '/api/jsonbin', // Secure proxy endpoint
            
            // Rate Limiting
            MAX_REQUESTS_PER_MINUTE: 30,
            MAX_GAMES_PER_HOUR: 10,
            MAX_TRANSACTIONS_PER_MINUTE: 5,
            
            // Security Settings
            ENABLE_ANTI_BOT: true,
            ENABLE_RATE_LIMITING: true,
            ENABLE_INPUT_VALIDATION: true,
            SESSION_TIMEOUT: 30 * 60 * 1000, // 30 minutes
            
            // Game Settings
            MIN_STAKE_AMOUNT: 0.01,
            MAX_STAKE_AMOUNT: 100,
            PLATFORM_FEE_PERCENTAGE: 3,
            
            // Performance Settings
            MAX_CHAT_MESSAGES: 100,
            MAX_ACTIVITY_ITEMS: 20,
            CLEANUP_INTERVAL: 5 * 60 * 1000, // 5 minutes
            
            // FIX: Development mode settings
            DEV_MODE: false,
            BYPASS_VERIFICATION: false,
            DEBUG_LOGGING: true
        };
    }
    
    get(key) {
        return this.config[key];
    }
    
    set(key, value) {
        if (this.config.hasOwnProperty(key)) {
            this.config[key] = value;
        } else {
            throw new Error(`Configuration key '${key}' does not exist`);
        }
    }
}

// Global Configuration Instance
const Config = new ConfigManager();

// ===========================
// ENHANCED ERROR HANDLING SYSTEM (FIXED)
// ===========================

class GameError extends Error {
    constructor(message, code = 'GAME_ERROR', details = {}) {
        super(message);
        this.name = 'GameError';
        this.code = code;
        this.details = details;
        this.timestamp = new Date().toISOString();
        this.stack = (new Error()).stack;
    }
}

class ErrorManager {
    constructor() {
        this.errorLog = [];
        this.maxErrors = 50;
        this.setupGlobalErrorHandlers();
    }
    
    setupGlobalErrorHandlers() {
        window.addEventListener('error', (event) => {
            this.logError(new GameError(
                event.message,
                'RUNTIME_ERROR',
                {
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    stack: event.error?.stack
                }
            ));
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            this.logError(new GameError(
                'Unhandled Promise Rejection',
                'PROMISE_ERROR',
                { reason: event.reason }
            ));
            event.preventDefault();
        });
    }
    
    logError(error, context = 'Unknown') {
        const errorEntry = {
            id: Date.now() + Math.random(),
            error: error,
            context: context,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href,
            userAccount: StateManager.get('userAccount')
        };
        
        this.errorLog.push(errorEntry);
        
        // Keep only recent errors
        if (this.errorLog.length > this.maxErrors) {
            this.errorLog = this.errorLog.slice(-this.maxErrors);
        }
        
        if (Config.get('DEBUG_LOGGING')) {
            console.error('🚨 Game Error:', errorEntry);
        }
        
        // Send to analytics if available
        if (typeof gtag !== 'undefined') {
            gtag('event', 'exception', {
                description: `${context}: ${error.message}`,
                fatal: false
            });
        }
        
        // Show user-friendly notification for critical errors
        if (error.code === 'RUNTIME_ERROR' || error.code === 'BLOCKCHAIN_ERROR') {
            if (window.NotificationManager) {
                NotificationManager.show(
                    'System Error',
                    'Something went wrong. Please try again.',
                    'error',
                    5000
                );
            }
        }
    }
    
    getRecentErrors(count = 10) {
        return this.errorLog.slice(-count);
    }
    
    clearErrors() {
        this.errorLog = [];
    }
}

// ===========================
// ENHANCED STATE MANAGEMENT SYSTEM (FIXED)
// ===========================

class StateManager {
    constructor() {
        this.state = new Map();
        this.listeners = new Map();
        this.initialized = false;
        
        // Initialize default state
        this.initializeDefaultState();
    }
    
    initializeDefaultState() {
        const defaultState = {
            // User State
            userAccount: null,
            userBalance: 0,
            isWalletConnected: false,
            walletProvider: null,
            
            // Platform State
            currentSection: 'lobby',
            isLoading: false,
            isServerConnected: false,
            serverLatency: 0,
            lastSyncTime: null,
            
            // FIX: Verification states
            isAgeVerified: false,
            isAntiBotVerified: false,
            isPlatformInitialized: false,
            initializationStartTime: Date.now(),
            
            // Game State
            activeGames: new Map(),
            myActiveGames: new Map(),
            gameInvitations: new Map(),
            currentGameSessions: new Map(),
            selectedGameType: null,
            
            // Settings
            platformSettings: {
                autoJoin: false,
                soundEnabled: true,
                animationsEnabled: true,
                defaultStake: 0.1,
                gameInvites: true,
                txNotifications: true,
                chatNotifications: false,
                hideBalance: false,
                developerMode: false,
                realTimeSync: true
            },
            
            // Player Stats
            playerStats: {
                gamesPlayed: 0,
                gamesWon: 0,
                totalEarned: 0,
                winRate: 0
            },
            
            // Skill Ratings
            skillRatings: {
                chess: 100,
                checkers: 100,
                words: 100
            }
        };
        
        // Set default state
        Object.entries(defaultState).forEach(([key, value]) => {
            this.state.set(key, value);
        });
        
        this.initialized = true;
    }
    
    get(key) {
        if (!this.state.has(key)) {
            console.warn(`State key '${key}' does not exist`);
            return null;
        }
        return this.state.get(key);
    }
    
    set(key, value) {
        const oldValue = this.state.get(key);
        this.state.set(key, value);
        
        // Notify listeners
        if (this.listeners.has(key)) {
            this.listeners.get(key).forEach(callback => {
                try {
                    callback(value, oldValue);
                } catch (error) {
                    ErrorManager.logError(error, `State listener for ${key}`);
                }
            });
        }
        
        // Auto-save certain state changes
        if (['platformSettings', 'playerStats', 'skillRatings'].includes(key)) {
            this.saveToStorage(key, value);
        }
        
        // FIX: Log important state changes
        if (Config.get('DEBUG_LOGGING')) {
            console.log(`📊 State: ${key} = ${value}`);
        }
    }
    
    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, new Set());
        }
        this.listeners.get(key).add(callback);
        
        // Return unsubscribe function
        return () => {
            if (this.listeners.has(key)) {
                this.listeners.get(key).delete(callback);
            }
        };
    }
    
    update(key, updater) {
        const currentValue = this.get(key);
        const newValue = updater(currentValue);
        this.set(key, newValue);
    }
    
    saveToStorage(key, value) {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                const storageKey = `crossrealm_${key}_${userAccount}`;
                localStorage.setItem(storageKey, JSON.stringify(value));
            }
        } catch (error) {
            console.warn('Failed to save to storage:', error);
        }
    }
    
    loadFromStorage(key) {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                const storageKey = `crossrealm_${key}_${userAccount}`;
                const stored = localStorage.getItem(storageKey);
                if (stored) {
                    return JSON.parse(stored);
                }
            }
        } catch (error) {
            console.warn('Failed to load from storage:', error);
        }
        return null;
    }
    
    clearUserData() {
        try {
            const userAccount = this.get('userAccount');
            if (userAccount) {
                ['platformSettings', 'playerStats', 'skillRatings'].forEach(key => {
                    const storageKey = `crossrealm_${key}_${userAccount}`;
                    localStorage.removeItem(storageKey);
                });
            }
        } catch (error) {
            console.warn('Failed to clear user data:', error);
        }
    }
    
    getSnapshot() {
        const snapshot = {};
        this.state.forEach((value, key) => {
            snapshot[key] = value;
        });
        return snapshot;
    }
    
    // FIX: Emergency reset for development
    emergencyReset() {
        console.warn('🚨 Emergency state reset triggered');
        sessionStorage.clear();
        this.state.clear();
        this.initializeDefaultState();
        window.location.reload();
    }
}

// Global State Manager Instance
const StateManager = new StateManager();

// ===========================
// ENHANCED SECURITY MANAGER (FIXED)
// ===========================

class SecurityManager {
    constructor() {
        this.requestCounts = new Map();
        this.suspiciousActivity = 0;
        this.blockedIPs = new Set();
        this.sessionStartTime = Date.now();
        
        this.setupSecurityMonitoring();
    }
    
    setupSecurityMonitoring() {
        // Monitor for developer tools (only if not in dev mode)
        if (!Config.get('DEV_MODE')) {
            this.monitorDevTools();
        }
        
        // Monitor for suspicious key combinations
        this.monitorKeyboardEvents();
        
        // Monitor for page visibility changes
        this.monitorPageVisibility();
        
        // Periodic security checks
        setInterval(() => {
            this.performSecurityCheck();
        }, 60000); // Every minute
    }
    
    monitorDevTools() {
        const threshold = 160;
        let devToolsOpen = false;
        
        setInterval(() => {
            const widthThreshold = window.outerWidth - window.innerWidth > threshold;
            const heightThreshold = window.outerHeight - window.innerHeight > threshold;
            
            if ((widthThreshold || heightThreshold) && !devToolsOpen) {
                devToolsOpen = true;
                this.handleDevToolsDetection();
            } else if (!widthThreshold && !heightThreshold && devToolsOpen) {
                devToolsOpen = false;
            }
        }, 500);
    }
    
    monitorKeyboardEvents() {
        document.addEventListener('keydown', (event) => {
            const isDeveloperMode = StateManager.get('platformSettings')?.developerMode || Config.get('DEV_MODE');
            
            if (!isDeveloperMode) {
                // Block common developer tools shortcuts
                if ((event.ctrlKey || event.metaKey) && 
                    ['I', 'J', 'U', 'K'].includes(event.key.toUpperCase())) {
                    event.preventDefault();
                    this.logSuspiciousActivity('Developer tools access attempt');
                }
                
                // Block F12
                if (event.key === 'F12') {
                    event.preventDefault();
                    this.logSuspiciousActivity('F12 developer tools attempt');
                }
            }
        });
        
        // Prevent right-click in production
        document.addEventListener('contextmenu', (event) => {
            const isDeveloperMode = StateManager.get('platformSettings')?.developerMode || Config.get('DEV_MODE');
            if (!isDeveloperMode) {
                event.preventDefault();
            }
        });
    }
    
    monitorPageVisibility() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden - pause sensitive operations
                this.pauseSensitiveOperations();
            } else {
                // Page is visible - resume operations
                this.resumeSensitiveOperations();
            }
        });
    }
    
    handleDevToolsDetection() {
        const isDeveloperMode = StateManager.get('platformSettings')?.developerMode || Config.get('DEV_MODE');
        
        if (!isDeveloperMode) {
            this.logSuspiciousActivity('Developer tools detected');
            
            const activeGames = StateManager.get('currentGameSessions');
            if (activeGames && activeGames.size > 0 && window.NotificationManager) {
                NotificationManager.show(
                    'Security Alert',
                    'Developer tools detected during active game. Game paused for security.',
                    'warning',
                    0
                );
                
                // Pause active games
                this.pauseActiveGames();
            }
        }
    }
    
    checkRateLimit(action, limit = null, window = 60000) {
        if (!Config.get('ENABLE_RATE_LIMITING')) {
            return true;
        }
        
        // Use default limits based on action type
        if (!limit) {
            const limits = {
                'api_request': Config.get('MAX_REQUESTS_PER_MINUTE'),
                'game_creation': Config.get('MAX_GAMES_PER_HOUR') / 60,
                'transaction': Config.get('MAX_TRANSACTIONS_PER_MINUTE'),
                'default': 10
            };
            limit = limits[action] || limits.default;
        }
        
        const now = Date.now();
        const userAccount = StateManager.get('userAccount') || 'anonymous';
        const key = `${action}_${userAccount}`;
        
        if (!this.requestCounts.has(key)) {
            this.requestCounts.set(key, []);
        }
        
        const requests = this.requestCounts.get(key);
        
        // Remove old requests outside the window
        const validRequests = requests.filter(time => now - time < window);
        
        if (validRequests.length >= limit) {
            this.logSuspiciousActivity(`Rate limit exceeded for ${action}`);
            return false;
        }
        
        validRequests.push(now);
        this.requestCounts.set(key, validRequests);
        
        return true;
    }
    
    validateInput(input, type, options = {}) {
        if (!Config.get('ENABLE_INPUT_VALIDATION')) {
            return { valid: true, sanitized: input };
        }
        
        try {
            switch (type) {
                case 'stake_amount':
                    return this.validateStakeAmount(input);
                case 'game_type':
                    return this.validateGameType(input);
                case 'wallet_address':
                    return this.validateWalletAddress(input);
                case 'string':
                    return this.validateString(input, options);
                case 'number':
                    return this.validateNumber(input, options);
                default:
                    return { valid: false, error: 'Unknown validation type' };
            }
        } catch (error) {
            ErrorManager.logError(error, 'Input validation');
            return { valid: false, error: 'Validation error' };
        }
    }
    
    validateStakeAmount(amount) {
        const numAmount = parseFloat(amount);
        
        if (isNaN(numAmount)) {
            return { valid: false, error: 'Stake amount must be a number' };
        }
        
        if (numAmount < Config.get('MIN_STAKE_AMOUNT')) {
            return { valid: false, error: `Minimum stake is ${Config.get('MIN_STAKE_AMOUNT')} CORE` };
        }
        
        if (numAmount > Config.get('MAX_STAKE_AMOUNT')) {
            return { valid: false, error: `Maximum stake is ${Config.get('MAX_STAKE_AMOUNT')} CORE` };
        }
        
        return { valid: true, sanitized: numAmount };
    }
    
    validateGameType(gameType) {
        const validTypes = ['chess', 'checkers', 'words'];
        
        if (!validTypes.includes(gameType)) {
            return { valid: false, error: 'Invalid game type' };
        }
        
        return { valid: true, sanitized: gameType };
    }
    
    validateWalletAddress(address) {
        if (typeof address !== 'string') {
            return { valid: false, error: 'Address must be a string' };
        }
        
        if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            return { valid: false, error: 'Invalid wallet address format' };
        }
        
        return { valid: true, sanitized: address.toLowerCase() };
    }
    
    validateString(input, options = {}) {
        const {
            minLength = 0,
            maxLength = 1000,
            allowHTML = false,
            allowSpecialChars = true
        } = options;
        
        if (typeof input !== 'string') {
            return { valid: false, error: 'Input must be a string' };
        }
        
        if (input.length < minLength) {
            return { valid: false, error: `Minimum length is ${minLength}` };
        }
        
        if (input.length > maxLength) {
            return { valid: false, error: `Maximum length is ${maxLength}` };
        }
        
        let sanitized = input;
        
        if (!allowHTML) {
            sanitized = sanitized.replace(/[<>]/g, '');
        }
        
        if (!allowSpecialChars) {
            sanitized = sanitized.replace(/[^\w\s]/g, '');
        }
        
        return { valid: true, sanitized: sanitized.trim() };
    }
    
    validateNumber(input, options = {}) {
        const {
            min = -Infinity,
            max = Infinity,
            integer = false
        } = options;
        
        const num = Number(input);
        
        if (isNaN(num)) {
            return { valid: false, error: 'Input must be a number' };
        }
        
        if (integer && !Number.isInteger(num)) {
            return { valid: false, error: 'Input must be an integer' };
        }
        
        if (num < min) {
            return { valid: false, error: `Minimum value is ${min}` };
        }
        
        if (num > max) {
            return { valid: false, error: `Maximum value is ${max}` };
        }
        
        return { valid: true, sanitized: num };
    }
    
    logSuspiciousActivity(activity) {
        this.suspiciousActivity++;
        
        const logEntry = {
            activity,
            timestamp: new Date().toISOString(),
            userAccount: StateManager.get('userAccount'),
            userAgent: navigator.userAgent,
            url: window.location.href,
            suspiciousCount: this.suspiciousActivity
        };
        
        if (Config.get('DEBUG_LOGGING')) {
            console.warn('🚨 Suspicious Activity:', logEntry);
        }
        
        ErrorManager.logError(
            new GameError('Suspicious activity detected', 'SECURITY_ALERT', logEntry),
            'Security'
        );
        
        if (this.suspiciousActivity >= 5 && window.NotificationManager) {
            NotificationManager.show(
                'Security Warning',
                'Multiple security alerts detected. Account may be temporarily restricted.',
                'error',
                0
            );
        }
    }
    
    pauseSensitiveOperations() {
        // Implementation for pausing sensitive operations
        if (Config.get('DEBUG_LOGGING')) {
            console.log('🛡️ Pausing sensitive operations');
        }
    }
    
    resumeSensitiveOperations() {
        // Implementation for resuming sensitive operations
        if (Config.get('DEBUG_LOGGING')) {
            console.log('🛡️ Resuming sensitive operations');
        }
    }
    
    pauseActiveGames() {
        const activeGames = StateManager.get('currentGameSessions');
        if (activeGames) {
            activeGames.forEach((session, gameId) => {
                if (session.syncInterval) {
                    clearInterval(session.syncInterval);
                    session.paused = true;
                }
            });
        }
    }
    
    performSecurityCheck() {
        // Check session timeout
        const sessionAge = Date.now() - this.sessionStartTime;
        const sessionTimeout = Config.get('SESSION_TIMEOUT');
        
        if (sessionAge > sessionTimeout) {
            this.handleSessionTimeout();
        }
        
        // Clean up old rate limit entries
        this.cleanupRateLimits();
    }
    
    handleSessionTimeout() {
        if (window.NotificationManager) {
            NotificationManager.show(
                'Session Expired',
                'Your session has expired for security. Please reconnect your wallet.',
                'warning',
                0
            );
        }
        
        // Disconnect wallet and clear sensitive data
        if (window.WalletManager) {
            WalletManager.disconnect();
        }
    }
    
    cleanupRateLimits() {
        const now = Date.now();
        const window = 3600000; // 1 hour
        
        this.requestCounts.forEach((requests, key) => {
            const validRequests = requests.filter(time => now - time < window);
            if (validRequests.length === 0) {
                this.requestCounts.delete(key);
            } else {
                this.requestCounts.set(key, validRequests);
            }
        });
    }
}

// ===========================
// ENHANCED NOTIFICATION MANAGER (FIXED)
// ===========================

class NotificationManager {
    constructor() {
        this.notifications = new Map();
        this.container = null;
        this.maxNotifications = 5;
        
        // Initialize after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initialize());
        } else {
            this.initialize();
        }
    }
    
    initialize() {
        this.container = document.getElementById('notificationContainer');
        if (!this.container) {
            console.warn('Notification container not found');
        }
    }
    
    show(title, message, type = 'info', duration = 5000, actions = null) {
        // FIX: Fallback if container not ready
        if (!this.container) {
            console.log(`Notification: ${title} - ${message}`);
            return null;
        }
        
        const id = Date.now() + Math.random();
        const notification = this.createNotificationElement(id, title, message, type, actions);
        
        // Limit number of notifications
        if (this.notifications.size >= this.maxNotifications) {
            const oldestId = this.notifications.keys().next().value;
            this.remove(oldestId);
        }
        
        this.notifications.set(id, notification);
        this.container.appendChild(notification);
        
        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(() => {
                this.remove(id);
            }, duration);
        }
        
        return id;
    }
    
    createNotificationElement(id, title, message, type, actions) {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.id = `notification-${id}`;
        notification.dataset.created = Date.now().toString();
        
        const iconMap = {
            info: 'fas fa-info-circle',
            success: 'fas fa-check-circle',
            warning: 'fas fa-exclamation-triangle',
            error: 'fas fa-times-circle'
        };
        
        notification.innerHTML = `
            <div class="notification-header">
                <div class="notification-title">
                    <i class="${iconMap[type]}"></i>
                    ${this.escapeHtml(title)}
                </div>
                <button class="notification-close" onclick="NotificationManager.remove('${id}')">
                    &times;
                </button>
            </div>
            <div class="notification-message">
                ${this.escapeHtml(message)}
            </div>
            ${actions ? `<div class="notification-actions">${actions}</div>` : ''}
        `;
        
        return notification;
    }
    
    remove(id) {
        const notification = this.notifications.get(id);
        if (notification && notification.parentNode) {
            notification.style.animation = 'slideInRight 0.3s ease-out reverse';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                this.notifications.delete(id);
            }, 300);
        }
    }
    
    clear() {
        this.notifications.forEach((notification, id) => {
            this.remove(id);
        });
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// ===========================
// PERFORMANCE MONITOR
// ===========================

class PerformanceMonitor {
    constructor() {
        this.metrics = new Map();
        this.observers = new Map();
        this.startTime = performance.now();
        
        this.setupPerformanceObservers();
    }
    
    setupPerformanceObservers() {
        try {
            // Monitor long tasks
            if ('PerformanceObserver' in window) {
                const longTaskObserver = new PerformanceObserver((list) => {
                    list.getEntries().forEach((entry) => {
                        if (entry.duration > 50) {
                            if (Config.get('DEBUG_LOGGING')) {
                                console.warn(`⚠️ Long task: ${entry.duration.toFixed(2)}ms`);
                            }
                            
                            ErrorManager.logError(
                                new GameError(
                                    `Long task detected: ${entry.duration}ms`,
                                    'PERFORMANCE_WARNING'
                                ),
                                'Performance'
                            );
                        }
                    });
                });
                
                longTaskObserver.observe({ entryTypes: ['longtask'] });
                this.observers.set('longtask', longTaskObserver);
            }
        } catch (error) {
            console.warn('Performance observers not supported:', error);
        }
    }
    
    startMeasure(name) {
        this.metrics.set(name, performance.now());
        return name;
    }
    
    endMeasure(name) {
        const startTime = this.metrics.get(name);
        if (startTime) {
            const duration = performance.now() - startTime;
            this.metrics.delete(name);
            
            if (Config.get('DEBUG_LOGGING')) {
                console.log(`📊 ${name}: ${duration.toFixed(2)}ms`);
            }
            
            // Log slow operations
            if (duration > 1000) {
                console.warn(`⚠️ Slow operation: ${name} took ${duration.toFixed(2)}ms`);
            }
            
            return duration;
        }
        return null;
    }
    
    getMemoryUsage() {
        if ('memory' in performance) {
            return {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
            };
        }
        return null;
    }
    
    cleanup() {
        this.observers.forEach(observer => observer.disconnect());
        this.observers.clear();
        this.metrics.clear();
    }
}

// ===========================
// ENHANCED UTILITY FUNCTIONS (FIXED)
// ===========================

class Utils {
    static async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    static throttle(func, limit) {
        let inThrottle;
        return function executedFunction(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    static formatCurrency(amount, decimals = 4) {
        return parseFloat(amount).toFixed(decimals);
    }
    
    static formatTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);
        
        if (seconds < 60) return `${seconds}s ago`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
        return `${Math.floor(seconds / 86400)}d ago`;
    }
    
    static generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    static copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            return navigator.clipboard.writeText(text);
        } else {
            return this.fallbackCopyToClipboard(text);
        }
    }
    
    static fallbackCopyToClipboard(text) {
        return new Promise((resolve, reject) => {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);
                if (successful) {
                    resolve();
                } else {
                    reject(new Error('Copy command failed'));
                }
            } catch (err) {
                document.body.removeChild(textArea);
                reject(err);
            }
        });
    }
    
    static validateEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }
    
    static sanitizeHtml(html) {
        const div = document.createElement('div');
        div.textContent = html;
        return div.innerHTML;
    }
    
    static isOnline() {
        return navigator.onLine;
    }
    
    static isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    
    static getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    static shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
    
    // FIX: Emergency helpers for development
    static emergencyBypass() {
        console.warn('🚨 Emergency bypass triggered');
        Config.set('DEV_MODE', true);
        Config.set('BYPASS_VERIFICATION', true);
        sessionStorage.setItem('ageVerified', 'true');
        sessionStorage.setItem('antiBotVerified', 'true');
        StateManager.set('isAgeVerified', true);
        StateManager.set('isAntiBotVerified', true);
        
        // Trigger platform initialization
        if (window.PlatformManager) {
            PlatformManager.initializePlatform();
        }
    }
    
    static getInitializationTime() {
        const startTime = StateManager.get('initializationStartTime');
        return Date.now() - startTime;
    }
}

// ===========================
// LIFECYCLE MANAGER (ENHANCED)
// ===========================

class LifecycleManager {
    constructor() {
        this.cleanupTasks = new Set();
        this.setupLifecycleHandlers();
        this.initializationTimer = null;
        this.setupEmergencyHandlers();
    }
    
    setupLifecycleHandlers() {
        window.addEventListener('beforeunload', () => {
            this.performCleanup();
        });
        
        window.addEventListener('pagehide', () => {
            this.performCleanup();
        });
        
        // Periodic cleanup
        setInterval(() => {
            this.performPeriodicCleanup();
        }, Config.get('CLEANUP_INTERVAL'));
    }
    
    // FIX: Setup emergency handlers for stuck initialization
    setupEmergencyHandlers() {
        // Start initialization timer
        this.initializationTimer = setTimeout(() => {
            this.handleStuckInitialization();
        }, 30000); // 30 seconds timeout
        
        // Show emergency bypass after 10 seconds if not initialized
        setTimeout(() => {
            this.showEmergencyBypass();
        }, 10000);
    }
    
    handleStuckInitialization() {
        if (!StateManager.get('isPlatformInitialized')) {
            console.error('🚨 Platform initialization appears to be stuck');
            
            const debugInfo = {
                ageVerified: StateManager.get('isAgeVerified'),
                antiBotVerified: StateManager.get('isAntiBotVerified'),
                platformInitialized: StateManager.get('isPlatformInitialized'),
                initTime: Utils.getInitializationTime(),
                errors: ErrorManager.getRecentErrors(5)
            };
            
            console.log('🔍 Debug info:', debugInfo);
            
            // Show emergency bypass
            this.showEmergencyBypass(true);
        }
    }
    
    showEmergencyBypass(force = false) {
        if (!StateManager.get('isPlatformInitialized') || force) {
            const bypassBtn = document.getElementById('emergencyBypass');
            if (bypassBtn) {
                bypassBtn.style.display = 'block';
                bypassBtn.onclick = () => {
                    Utils.emergencyBypass();
                };
            }
        }
    }
    
    clearInitializationTimer() {
        if (this.initializationTimer) {
            clearTimeout(this.initializationTimer);
            this.initializationTimer = null;
        }
    }
    
    addCleanupTask(task) {
        this.cleanupTasks.add(task);
    }
    
    removeCleanupTask(task) {
        this.cleanupTasks.delete(task);
    }
    
    performCleanup() {
        if (Config.get('DEBUG_LOGGING')) {
            console.log('🧹 Performing cleanup...');
        }
        
        try {
            this.cleanupTasks.forEach(task => {
                try {
                    task();
                } catch (error) {
                    console.error('Cleanup task failed:', error);
                }
            });
            
            // Clear intervals and timeouts
            this.clearAllIntervals();
            
            // Disconnect observers
            PerformanceMonitor.cleanup();
            
            this.clearInitializationTimer();
            
            if (Config.get('DEBUG_LOGGING')) {
                console.log('✅ Cleanup completed');
            }
        } catch (error) {
            console.error('❌ Cleanup failed:', error);
        }
    }
    
    performPeriodicCleanup() {
        // Clean up old notifications
        if (window.NotificationManager) {
            NotificationManager.notifications.forEach((notification, id) => {
                const age = Date.now() - parseInt(notification.dataset.created || '0');
                if (age > 300000) { // 5 minutes
                    NotificationManager.remove(id);
                }
            });
        }
        
        // Clean up old errors
        if (ErrorManager.errorLog.length > 20) {
            ErrorManager.errorLog = ErrorManager.errorLog.slice(-20);
        }
        
        // Clean up old metrics
        PerformanceMonitor.metrics.clear();
    }
    
    clearAllIntervals() {
        // Get all interval IDs and clear them
        const intervalId = setInterval(() => {}, 1000);
        for (let i = 1; i <= intervalId; i++) {
            clearInterval(i);
        }
    }
}

// ===========================
// GLOBAL INSTANCES & INITIALIZATION
// ===========================

// Initialize global managers
const ErrorManager = new ErrorManager();
const SecurityManager = new SecurityManager();
const NotificationManager = new NotificationManager();
const PerformanceMonitor = new PerformanceMonitor();
const LifecycleManager = new LifecycleManager();

// Export utilities to global scope for use in other sections
window.StateManager = StateManager;
window.ErrorManager = ErrorManager;
window.SecurityManager = SecurityManager;
window.NotificationManager = NotificationManager;
window.PerformanceMonitor = PerformanceMonitor;
window.LifecycleManager = LifecycleManager;
window.Utils = Utils;
window.Config = Config;
window.GameError = GameError;

// FIX: Initialize loading timer in DOM
document.addEventListener('DOMContentLoaded', () => {
    let timerCount = 0;
    const timerInterval = setInterval(() => {
        timerCount++;
        const timerElement = document.getElementById('timerCount');
        if (timerElement) {
            timerElement.textContent = timerCount;
        }
        
        // Auto-bypass after 60 seconds of no progress
        if (timerCount >= 60 && !StateManager.get('isPlatformInitialized')) {
            clearInterval(timerInterval);
            console.warn('🚨 Auto-triggering emergency bypass after 60 seconds');
            Utils.emergencyBypass();
        }
    }, 1000);
    
    // Clear timer when platform initializes
    StateManager.subscribe('isPlatformInitialized', (initialized) => {
        if (initialized) {
            clearInterval(timerInterval);
            LifecycleManager.clearInitializationTimer();
        }
    });
});

console.log('✅ Core JavaScript - State Management & Security (FIXED) Loaded');
  </script>
  <script>
    /* ===========================
   CROSSREALM GAMING PLATFORM
   BLOCKCHAIN & WALLET INTEGRATION WITH SECURITY FIXES (FIXED)
   =========================== */

'use strict';

// ===========================
// ENHANCED BLOCKCHAIN MANAGER (FIXED)
// ===========================

class BlockchainManager {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.contract = null;
        this.network = null;
        this.gasPrice = null;
        this.isInitialized = false;
        this.isDemoMode = false;
        
        this.contractABI = [
            "function createGame(string memory gameType, uint256 timeLimit) external payable returns (uint256)",
            "function joinGame(uint256 gameId) external payable",
            "function submitMove(uint256 gameId, bytes memory moveData) external",
            "function finalizeGame(uint256 gameId, address winner) external",
            "function claimWinnings(uint256 gameId) external",
            "function refundStake(uint256 gameId) external",
            "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint256 status, string memory gameType)",
            "function getTotalGames() external view returns (uint256)",
            "function getPlayerGames(address player) external view returns (uint256[] memory)",
            "function owner() external view returns (address)",
            "function paused() external view returns (bool)",
            "event GameCreated(uint256 indexed gameId, address indexed creator, uint256 stake, string gameType)",
            "event GameJoined(uint256 indexed gameId, address indexed player)",
            "event GameFinalized(uint256 indexed gameId, address indexed winner, uint256 payout)",
            "event MoveSubmitted(uint256 indexed gameId, address indexed player, bytes moveData)"
        ];
    }
    
    async initialize() {
        try {
            if (this.isInitialized) {
                return true;
            }
            
            PerformanceMonitor.startMeasure('blockchain_init');
            
            // FIX: Check if Web3 provider is available
            if (typeof window.ethereum === 'undefined') {
                console.log('🔍 No Web3 provider detected - running in demo mode');
                this.initializeDemoMode();
                return true;
            }
            
            // FIX: Try to initialize Web3 provider with better error handling
            try {
                this.provider = new ethers.providers.Web3Provider(window.ethereum, "any");
                
                // Get network information with timeout
                const networkPromise = this.provider.getNetwork();
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Network detection timeout')), 10000)
                );
                
                this.network = await Promise.race([networkPromise, timeoutPromise]);
                console.log('🌐 Network detected:', this.network);
                
                // Validate network
                if (this.network.chainId !== parseInt(Config.get('CORE_CHAIN_ID'), 16)) {
                    console.warn('⚠️ Wrong network detected, continuing in demo mode');
                    this.initializeDemoMode();
                    return true;
                }
                
                // Get gas price with fallback
                try {
                    this.gasPrice = await this.provider.getGasPrice();
                    console.log('⛽ Gas price:', ethers.utils.formatUnits(this.gasPrice, 'gwei'), 'gwei');
                } catch (error) {
                    console.warn('Failed to get gas price:', error);
                    this.gasPrice = ethers.utils.parseUnits('20', 'gwei'); // Fallback
                }
                
                // Initialize contract (read-only initially)
                this.contract = new ethers.Contract(
                    Config.get('CONTRACT_ADDRESS'),
                    this.contractABI,
                    this.provider
                );
                
                // Verify contract exists with timeout
                try {
                    const ownerPromise = this.contract.owner();
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Contract verification timeout')), 5000)
                    );
                    
                    await Promise.race([ownerPromise, timeoutPromise]);
                    console.log('✅ Smart contract verified');
                } catch (error) {
                    console.warn('⚠️ Contract verification failed, using demo mode:', error);
                    this.initializeDemoMode();
                    return true;
                }
                
            } catch (error) {
                console.warn('⚠️ Web3 initialization failed, using demo mode:', error);
                this.initializeDemoMode();
                return true;
            }
            
            this.isInitialized = true;
            
            // Setup event listeners
            this.setupEventListeners();
            
            PerformanceMonitor.endMeasure('blockchain_init');
            
            StateManager.set('contractStatus', 'connected');
            this.updateContractStatus('connected', 'Connected to Core Network');
            
            return true;
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain initialization');
            this.initializeDemoMode();
            return false;
        }
    }
    
    initializeDemoMode() {
        console.log('🎮 Initializing demo mode');
        this.isInitialized = true;
        this.isDemoMode = true;
        StateManager.set('contractStatus', 'demo');
        this.updateContractStatus('demo', 'Demo Mode - No Real Transactions');
        
        // FIX: Initialize demo contract data
        this.initializeDemoContract();
    }
    
    initializeDemoContract() {
        // Mock contract interactions for demo
        this.demoGames = new Map();
        this.demoGameIdCounter = 1;
        
        // Create some demo games
        this.createDemoGames();
    }
    
    createDemoGames() {
        const demoGames = [
            { gameType: 'chess', stake: 0.1, creator: '0x1234567890123456789012345678901234567890' },
            { gameType: 'checkers', stake: 0.25, creator: '0x9876543210987654321098765432109876543210' }
        ];
        
        demoGames.forEach(game => {
            const gameId = this.demoGameIdCounter++;
            this.demoGames.set(gameId, {
                ...game,
                gameId,
                player2: '0x0000000000000000000000000000000000000000',
                status: 0, // waiting
                createdAt: Date.now()
            });
        });
    }
    
    setupEventListeners() {
        if (!this.contract || this.isDemoMode) return;
        
        try {
            // Listen for game creation events
            this.contract.on('GameCreated', (gameId, creator, stake, gameType, event) => {
                console.log('🎮 Game Created:', { 
                    gameId: gameId.toString(), 
                    creator, 
                    stake: ethers.utils.formatEther(stake), 
                    gameType 
                });
                
                NotificationManager.show(
                    'Game Created',
                    `New ${gameType} game created with ${ethers.utils.formatEther(stake)} CORE stake`,
                    'success'
                );
            });
            
            // Listen for game join events
            this.contract.on('GameJoined', (gameId, player, event) => {
                console.log('👥 Game Joined:', { gameId: gameId.toString(), player });
                
                NotificationManager.show(
                    'Player Joined',
                    `Player joined game #${gameId.toString()}`,
                    'info'
                );
            });
            
            // Listen for game finalization events
            this.contract.on('GameFinalized', (gameId, winner, payout, event) => {
                console.log('🏆 Game Finalized:', { 
                    gameId: gameId.toString(), 
                    winner, 
                    payout: ethers.utils.formatEther(payout) 
                });
                
                const userAccount = StateManager.get('userAccount');
                if (userAccount && winner.toLowerCase() === userAccount.toLowerCase()) {
                    NotificationManager.show(
                        'You Won!',
                        `Congratulations! You won ${ethers.utils.formatEther(payout)} CORE`,
                        'success',
                        0
                    );
                }
            });
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain event listeners setup');
        }
    }
    
    async estimateGas(transaction) {
        try {
            if (!this.contract || !this.signer || this.isDemoMode) {
                return ethers.utils.parseUnits('21000', 'wei'); // Default gas limit
            }
            
            const gasEstimate = await this.contract.estimateGas[transaction.method](...transaction.params, {
                value: transaction.value || 0
            });
            
            // Add 20% buffer for gas estimation
            return gasEstimate.mul(120).div(100);
            
        } catch (error) {
            ErrorManager.logError(error, 'Gas estimation');
            return ethers.utils.parseUnits('500000', 'wei'); // Fallback gas limit
        }
    }
    
    async createGameOnChain(gameType, stakeAmount, timeLimit = 600) {
        try {
            if (!this.validateGameCreation(gameType, stakeAmount)) {
                throw new GameError('Invalid game parameters', 'VALIDATION_ERROR');
            }
            
            // Rate limiting check
            if (!SecurityManager.checkRateLimit('game_creation', 5, 3600000)) { // 5 games per hour
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT_ERROR');
            }
            
            // FIX: Handle demo mode
            if (this.isDemoMode) {
                return await this.createDemoGame(gameType, stakeAmount, timeLimit);
            }
            
            // Check if we have a signer (wallet connected)
            if (!this.signer) {
                throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
            }
            
            const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
            
            // Estimate gas
            const gasLimit = await this.estimateGas({
                method: 'createGame',
                params: [gameType, timeLimit],
                value: stakeWei
            });
            
            console.log('🔥 Creating game on blockchain...', {
                gameType,
                stake: stakeAmount,
                gasLimit: gasLimit.toString()
            });
            
            // Create transaction
            const tx = await this.contract.createGame(gameType, timeLimit, {
                value: stakeWei,
                gasLimit: gasLimit,
                gasPrice: this.gasPrice
            });
            
            console.log('📤 Transaction submitted:', tx.hash);
            
            // Show transaction status
            TransactionManager.showTransaction(
                'Creating game...',
                tx.hash,
                'Game creation transaction submitted'
            );
            
            // Wait for confirmation
            const receipt = await tx.wait();
            console.log('✅ Transaction confirmed:', receipt);
            
            // Extract game ID from events
            const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
            const gameId = gameCreatedEvent?.args?.gameId?.toString();
            
            if (!gameId) {
                throw new GameError('Failed to extract game ID from transaction', 'BLOCKCHAIN_ERROR');
            }
            
            TransactionManager.showTransaction(
                'Game created successfully!',
                tx.hash,
                `Game #${gameId} created on blockchain`
            );
            
            return {
                gameId: parseInt(gameId),
                transactionHash: tx.hash,
                blockNumber: receipt.blockNumber,
                gasUsed: receipt.gasUsed.toString()
            };
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain game creation');
            
            if (error.code === 'INSUFFICIENT_FUNDS') {
                throw new GameError('Insufficient CORE balance', 'INSUFFICIENT_FUNDS');
            } else if (error.code === 'USER_REJECTED' || error.code === 4001) {
                throw new GameError('Transaction rejected by user', 'USER_REJECTED');
            }
            
            throw error;
        }
    }
    
    // FIX: Demo game creation
    async createDemoGame(gameType, stakeAmount, timeLimit) {
        // Simulate blockchain delay
        await Utils.sleep(1000);
        
        const gameId = this.demoGameIdCounter++;
        const userAccount = StateManager.get('userAccount');
        
        this.demoGames.set(gameId, {
            gameId,
            gameType,
            stake: stakeAmount,
            creator: userAccount,
            player2: '0x0000000000000000000000000000000000000000',
            status: 0, // waiting
            createdAt: Date.now(),
            timeLimit
        });
        
        console.log('🎮 Demo game created:', { gameId, gameType, stake: stakeAmount });
        
        return {
            gameId: gameId,
            transactionHash: `0x${Math.random().toString(16).substr(2, 64)}`, // Mock tx hash
            blockNumber: Math.floor(Math.random() * 1000000),
            gasUsed: '21000'
        };
    }
    
    async joinGameOnChain(gameId, stakeAmount) {
        try {
            if (!this.signer && !this.isDemoMode) {
                throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
            }
            
            // Rate limiting check
            if (!SecurityManager.checkRateLimit('game_join', 10, 3600000)) { // 10 joins per hour
                throw new GameError('Rate limit exceeded', 'RATE_LIMIT_ERROR');
            }
            
            // FIX: Handle demo mode
            if (this.isDemoMode) {
                return await this.joinDemoGame(gameId, stakeAmount);
            }
            
            const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
            
            // Validate game exists and get details
            const gameDetails = await this.contract.getGame(gameId);
            if (!gameDetails || gameDetails.player1 === ethers.constants.AddressZero) {
                throw new GameError('Game not found', 'GAME_NOT_FOUND');
            }
            
            if (gameDetails.player2 !== ethers.constants.AddressZero) {
                throw new GameError('Game already has two players', 'GAME_FULL');
            }
            
            // Estimate gas
            const gasLimit = await this.estimateGas({
                method: 'joinGame',
                params: [gameId],
                value: stakeWei
            });
            
            console.log('🎯 Joining game on blockchain...', {
                gameId,
                stake: stakeAmount,
                gasLimit: gasLimit.toString()
            });
            
            // Create transaction
            const tx = await this.contract.joinGame(gameId, {
                value: stakeWei,
                gasLimit: gasLimit,
                gasPrice: this.gasPrice
            });
            
            console.log('📤 Join transaction submitted:', tx.hash);
            
            TransactionManager.showTransaction(
                'Joining game...',
                tx.hash,
                `Joining game #${gameId}`
            );
            
            // Wait for confirmation
            const receipt = await tx.wait();
            console.log('✅ Join transaction confirmed:', receipt);
            
            TransactionManager.showTransaction(
                'Successfully joined game!',
                tx.hash,
                `Joined game #${gameId}`
            );
            
            return {
                gameId: gameId,
                transactionHash: tx.hash,
                blockNumber: receipt.blockNumber,
                gasUsed: receipt.gasUsed.toString()
            };
            
        } catch (error) {
            ErrorManager.logError(error, 'Blockchain game join');
            
            if (error.code === 'INSUFFICIENT_FUNDS') {
                throw new GameError('Insufficient CORE balance', 'INSUFFICIENT_FUNDS');
            } else if (error.code === 'USER_REJECTED' || error.code === 4001) {
                throw new GameError('Transaction rejected by user', 'USER_REJECTED');
            }
            
            throw error;
        }
    }
    
    // FIX: Demo game joining
    async joinDemoGame(gameId, stakeAmount) {
        // Simulate blockchain delay
        await Utils.sleep(800);
        
        const game = this.demoGames.get(gameId);
        if (!game) {
            throw new GameError('Game not found', 'GAME_NOT_FOUND');
        }
        
        if (game.player2 !== '0x0000000000000000000000000000000000000000') {
            throw new GameError('Game already has two players', 'GAME_FULL');
        }
        
        const userAccount = StateManager.get('userAccount');
        game.player2 = userAccount;
        game.status = 1; // active
        
        console.log('🎯 Demo game joined:', { gameId, player: userAccount });
        
        return {
            gameId: gameId,
            transactionHash: `0x${Math.random().toString(16).substr(2, 64)}`, // Mock tx hash
            blockNumber: Math.floor(Math.random() * 1000000),
            gasUsed: '21000'
        };
    }
    
    async getPlayerBalance(address) {
        try {
            if (this.isDemoMode) {
                // Return demo balance
                return StateManager.get('userBalance') || 10.5432;
            }
            
            if (!this.provider) {
                return 0;
            }
            
            const balance = await this.provider.getBalance(address);
            return parseFloat(ethers.utils.formatEther(balance));
            
        } catch (error) {
            ErrorManager.logError(error, 'Get player balance');
            return 0;
        }
    }
    
    async getGameDetails(gameId) {
        try {
            if (this.isDemoMode) {
                const game = this.demoGames.get(parseInt(gameId));
                if (!game) return null;
                
                return {
                    player1: game.creator,
                    player2: game.player2,
                    stake: game.stake,
                    status: game.status.toString(),
                    gameType: game.gameType
                };
            }
            
            if (!this.contract) {
                return null;
            }
            
            const gameDetails = await this.contract.getGame(gameId);
            
            return {
                player1: gameDetails.player1,
                player2: gameDetails.player2,
                stake: parseFloat(ethers.utils.formatEther(gameDetails.stake)),
                status: gameDetails.status.toString(),
                gameType: gameDetails.gameType
            };
            
        } catch (error) {
            ErrorManager.logError(error, 'Get game details');
            return null;
        }
    }
    
    validateGameCreation(gameType, stakeAmount) {
        // Validate game type
        const gameTypeValidation = SecurityManager.validateInput(gameType, 'game_type');
        if (!gameTypeValidation.valid) {
            NotificationManager.show('Invalid Game Type', gameTypeValidation.error, 'error');
            return false;
        }
        
        // Validate stake amount
        const stakeValidation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
        if (!stakeValidation.valid) {
            NotificationManager.show('Invalid Stake Amount', stakeValidation.error, 'error');
            return false;
        }
        
        return true;
    }
    
    updateContractStatus(status, message) {
        const contractStatus = document.getElementById('contractStatus');
        const contractAddress = document.getElementById('contractAddress');
        
        if (contractStatus) {
            const statusClasses = {
                'connected': 'online',
                'demo': 'pending',
                'disconnected': 'offline'
            };
            
            contractStatus.innerHTML = `
                <span class="status-indicator ${statusClasses[status]}"></span>
                <span>${message}</span>
            `;
        }
        
        if (contractAddress) {
            const addressText = contractAddress.querySelector('.address-text');
            if (addressText) {
                addressText.textContent = Config.get('CONTRACT_ADDRESS');
            }
        }
    }
    
    cleanup() {
        if (this.contract && !this.isDemoMode) {
            this.contract.removeAllListeners();
        }
    }
}

// ===========================
// ENHANCED WALLET MANAGER (FIXED)
// ===========================

class WalletManager {
    constructor() {
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3;
        this.accountChangeHandlers = new Set();
        this.networkChangeHandlers = new Set();
        this.isDemoMode = false;
    }
    
    async connect() {
        if (this.isConnecting) {
            console.log('⏳ Wallet connection already in progress');
            return false;
        }
        
        try {
            this.isConnecting = true;
            
            PerformanceMonitor.startMeasure('wallet_connect');
            
            // FIX: Check if Web3 provider is available
            if (typeof window.ethereum === 'undefined') {
                // Demo mode for users without MetaMask
                return await this.connectDemoMode();
            }
            
            console.log('🔌 Connecting to wallet...');
            
            // FIX: Request account access with timeout
            let accounts;
            try {
                const accountsPromise = window.ethereum.request({
                    method: 'eth_requestAccounts'
                });
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Wallet connection timeout')), 15000)
                );
                
                accounts = await Promise.race([accountsPromise, timeoutPromise]);
            } catch (error) {
                if (error.code === 4001) {
                    throw new GameError('User rejected wallet connection', 'USER_REJECTED');
                } else if (error.message.includes('timeout')) {
                    console.warn('Wallet connection timeout, using demo mode');
                    return await this.connectDemoMode();
                }
                throw error;
            }
            
            if (!accounts || accounts.length === 0) {
                throw new GameError('No accounts found', 'NO_ACCOUNTS');
            }
            
            const userAccount = accounts[0];
            console.log('👤 Wallet connected:', userAccount);
            
            // Validate wallet address
            const addressValidation = SecurityManager.validateInput(userAccount, 'wallet_address');
            if (!addressValidation.valid) {
                throw new GameError('Invalid wallet address', 'INVALID_ADDRESS');
            }
            
            // Initialize blockchain manager
            await BlockchainManager.initialize();
            
            // Set up signer
            if (BlockchainManager.provider && !BlockchainManager.isDemoMode) {
                BlockchainManager.signer = BlockchainManager.provider.getSigner();
                
                // Connect contract to signer
                if (BlockchainManager.contract) {
                    BlockchainManager.contract = BlockchainManager.contract.connect(BlockchainManager.signer);
                }
            }
            
            // Get user balance
            const balance = await BlockchainManager.getPlayerBalance(userAccount);
            
            // Update state
            StateManager.set('userAccount', userAccount);
            StateManager.set('userBalance', balance);
            StateManager.set('isWalletConnected', true);
            StateManager.set('walletProvider', BlockchainManager.isDemoMode ? 'demo' : 'metamask');
            
            // Load user data
            await this.loadUserData(userAccount);
            
            // Update UI
            this.updateWalletUI(true, userAccount, balance);
            
            // Setup event listeners
            if (!BlockchainManager.isDemoMode) {
                this.setupWalletEventListeners();
            }
            
            // Save connection state
            try {
                sessionStorage.setItem('walletConnected', 'true');
                sessionStorage.setItem('walletAccount', userAccount);
            } catch (error) {
                console.warn('Failed to save wallet state:', error);
            }
            
            NotificationManager.show(
                'Wallet Connected',
                `Connected to ${userAccount.substring(0, 10)}... with ${balance.toFixed(4)} CORE`,
                'success'
            );
            
            PerformanceMonitor.endMeasure('wallet_connect');
            
            return true;
            
        } catch (error) {
            ErrorManager.logError(error, 'Wallet connection');
            
            if (error.code === 4001) {
                NotificationManager.show(
                    'Connection Rejected',
                    'Wallet connection was rejected by user',
                    'warning'
                );
            } else if (error.code === -32002) {
                NotificationManager.show(
                    'Connection Pending',
                    'Please check your wallet for pending connection request',
                    'info'
                );
            } else {
                NotificationManager.show(
                    'Connection Failed',
                    `Failed to connect wallet: ${error.message}`,
                    'error'
                );
            }
            
            return false;
            
        } finally {
            this.isConnecting = false;
        }
    }
    
    async connectDemoMode() {
        console.log('🎮 Connecting in demo mode...');
        
        this.isDemoMode = true;
        
        // Generate demo account
        const demoAccount = '0x1234567890123456789012345678901234567890';
        const demoBalance = 10.5432;
        
        // Update state
        StateManager.set('userAccount', demoAccount);
        StateManager.set('userBalance', demoBalance);
        StateManager.set('isWalletConnected', true);
        StateManager.set('walletProvider', 'demo');
        
        // Update UI
        this.updateWalletUI(true, demoAccount, demoBalance);
        
        NotificationManager.show(
            'Demo Mode Connected',
            `Demo wallet connected with ${demoBalance.toFixed(4)} CORE`,
            'info'
        );
        
        PerformanceMonitor.endMeasure('wallet_connect');
        
        return true;
    }
    
    async disconnect() {
        try {
            console.log('🔌 Disconnecting wallet...');
            
            // Clean up blockchain connections
            BlockchainManager.cleanup();
            
            // Clear state
            StateManager.set('userAccount', null);
            StateManager.set('userBalance', 0);
            StateManager.set('isWalletConnected', false);
            StateManager.set('walletProvider', null);
            
            // Update UI
            this.updateWalletUI(false, null, 0);
            
            // Clear session storage
            try {
                sessionStorage.removeItem('walletConnected');
                sessionStorage.removeItem('walletAccount');
            } catch (error) {
                console.warn('Failed to clear wallet state:', error);
            }
            
            // Remove event listeners
            this.removeWalletEventListeners();
            
            this.isDemoMode = false;
            
            NotificationManager.show(
                'Wallet Disconnected',
                'Wallet has been disconnected',
                'info'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Wallet disconnection');
        }
    }
    
    async loadUserData(userAccount) {
        try {
            const userData = StateManager.loadFromStorage('userData');
            if (userData) {
                StateManager.set('playerStats', userData.playerStats || StateManager.get('playerStats'));
                StateManager.set('skillRatings', userData.skillRatings || StateManager.get('skillRatings'));
                StateManager.set('platformSettings', { ...StateManager.get('platformSettings'), ...userData.platformSettings });
            }
        } catch (error) {
            ErrorManager.logError(error, 'Loading user data');
        }
    }
    
    async saveUserData() {
        try {
            const userAccount = StateManager.get('userAccount');
            if (userAccount) {
                const userData = {
                    playerStats: StateManager.get('playerStats'),
                    skillRatings: StateManager.get('skillRatings'),
                    platformSettings: StateManager.get('platformSettings'),
                    lastSaved: Date.now()
                };
                
                StateManager.saveToStorage('userData', userData);
            }
        } catch (error) {
            ErrorManager.logError(error, 'Saving user data');
        }
    }
    
    setupWalletEventListeners() {
        if (!window.ethereum || this.isDemoMode) return;
        
        // Account changes
        const handleAccountsChanged = (accounts) => {
            console.log('👤 Accounts changed:', accounts);
            
            if (accounts.length === 0) {
                this.disconnect();
            } else if (accounts[0] !== StateManager.get('userAccount')) {
                // Account switched
                this.handleAccountSwitch(accounts[0]);
            }
        };
        
        // Network changes
        const handleChainChanged = (chainId) => {
            console.log('🌐 Network changed:', chainId);
            
            if (chainId !== Config.get('CORE_CHAIN_ID')) {
                NotificationManager.show(
                    'Wrong Network',
                    'Please switch to Core Network',
                    'warning',
                    0
                );
                
                StateManager.set('contractStatus', 'wrong_network');
            } else {
                StateManager.set('contractStatus', 'connected');
                NotificationManager.show(
                    'Network Correct',
                    'Connected to Core Network',
                    'success'
                );
            }
        };
        
        // Add event listeners
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);
        
        // Store handlers for cleanup
        this.accountChangeHandlers.add(handleAccountsChanged);
        this.networkChangeHandlers.add(handleChainChanged);
    }
    
    removeWalletEventListeners() {
        if (!window.ethereum || this.isDemoMode) return;
        
        // Remove all stored handlers
        this.accountChangeHandlers.forEach(handler => {
            window.ethereum.removeListener('accountsChanged', handler);
        });
        
        this.networkChangeHandlers.forEach(handler => {
            window.ethereum.removeListener('chainChanged', handler);
        });
        
        this.accountChangeHandlers.clear();
        this.networkChangeHandlers.clear();
    }
    
    async handleAccountSwitch(newAccount) {
        try {
            console.log('🔄 Switching account to:', newAccount);
            
            // Save current user data
            await this.saveUserData();
            
            // Validate new account
            const addressValidation = SecurityManager.validateInput(newAccount, 'wallet_address');
            if (!addressValidation.valid) {
                throw new GameError('Invalid wallet address', 'INVALID_ADDRESS');
            }
            
            // Get new balance
            const balance = await BlockchainManager.getPlayerBalance(newAccount);
            
            // Update state
            StateManager.set('userAccount', newAccount);
            StateManager.set('userBalance', balance);
            
            // Load data for new account
            await this.loadUserData(newAccount);
            
            // Update UI
            this.updateWalletUI(true, newAccount, balance);
            
            NotificationManager.show(
                'Account Switched',
                `Switched to ${newAccount.substring(0, 10)}...`,
                'info'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Account switch');
            this.disconnect();
        }
    }
    
    updateWalletUI(connected, account, balance) {
        const connectionStatus = document.getElementById('connectionStatus');
        const balanceDisplay = document.getElementById('balanceDisplay');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        
        if (connectionStatus) {
            const statusIndicator = connectionStatus.querySelector('.status-indicator');
            const statusText = connectionStatus.querySelector('.status-text');
            
            if (statusIndicator && statusText) {
                if (connected) {
                    statusIndicator.className = 'status-indicator online';
                    statusText.textContent = 'Connected';
                } else {
                    statusIndicator.className = 'status-indicator offline';
                    statusText.textContent = 'Not Connected';
                }
            }
        }
        
        if (balanceDisplay) {
            const hideBalance = StateManager.get('platformSettings')?.hideBalance;
            if (hideBalance && connected) {
                balanceDisplay.textContent = '••••• CORE';
            } else {
                balanceDisplay.textContent = `${balance.toFixed(4)} CORE`;
            }
        }
        
        if (connectBtn && disconnectBtn) {
            if (connected) {
                connectBtn.classList.add('hidden');
                disconnectBtn.classList.remove('hidden');
            } else {
                connectBtn.classList.remove('hidden');
                disconnectBtn.classList.add('hidden');
            }
        }
    }
    
    async autoConnect() {
        try {
            // Check if wallet was previously connected
            const wasConnected = sessionStorage.getItem('walletConnected') === 'true';
            const previousAccount = sessionStorage.getItem('walletAccount');
            
            if (!wasConnected || !previousAccount) {
                return false;
            }
            
            // Check if accounts are still available
            if (window.ethereum) {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.includes(previousAccount)) {
                        console.log('🔄 Auto-connecting to wallet...');
                        return await this.connect();
                    }
                } catch (error) {
                    console.warn('Auto-connect check failed:', error);
                }
            }
            
            return false;
            
        } catch (error) {
            console.warn('Auto-connect failed:', error);
            // Clear stale session data
            sessionStorage.removeItem('walletConnected');
            sessionStorage.removeItem('walletAccount');
            return false;
        }
    }
}

// ===========================
// ENHANCED TRANSACTION MANAGER (FIXED)
// ===========================

class TransactionManager {
    constructor() {
        this.activeTransactions = new Map();
        this.container = null;
        
        // Initialize after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initialize());
        } else {
            this.initialize();
        }
    }
    
    initialize() {
        this.container = document.getElementById('transactionStatus');
        if (!this.container) {
            console.warn('Transaction status container not found');
        }
        
        // Setup close button
        const closeBtn = document.getElementById('txClose');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.hide());
        }
    }
    
    showTransaction(message, hash = null, description = null) {
        if (!this.container) {
            console.log(`Transaction: ${message}${hash ? ' - ' + hash : ''}`);
            return;
        }
        
        const messageEl = document.getElementById('txMessage');
        const hashEl = document.getElementById('txHash');
        
        if (messageEl) {
            messageEl.textContent = message;
        }
        
        if (hashEl && hash) {
            const explorerUrl = BlockchainManager.isDemoMode ? 
                '#' : `${Config.get('CORE_EXPLORER_URL')}/tx/${hash}`;
            
            hashEl.innerHTML = `
                <strong>Hash:</strong> 
                <a href="${explorerUrl}" 
                   target="_blank" 
                   rel="noopener noreferrer"
                   title="View on Core Explorer">
                    ${hash.substring(0, 10)}...${hash.substring(hash.length - 8)}
                </a>
            `;
            hashEl.style.display = 'block';
        } else if (hashEl) {
            hashEl.style.display = 'none';
        }
        
        this.container.classList.add('show');
        
        // Auto-hide after 10 seconds for success messages
        if (message.includes('success') || message.includes('confirmed')) {
            setTimeout(() => {
                this.hide();
            }, 10000);
        }
    }
    
    hide() {
        if (this.container) {
            this.container.classList.remove('show');
        }
    }
    
    showStatus(status, hash = null) {
        const statusMessages = {
            'pending': 'Transaction pending...',
            'confirmed': 'Transaction confirmed!',
            'failed': 'Transaction failed!',
            'rejected': 'Transaction rejected by user'
        };
        
        this.showTransaction(statusMessages[status] || status, hash);
    }
}

// ===========================
// ENHANCED API MANAGER (FIXED)
// ===========================

class APIManager {
    constructor() {
        this.baseURL = Config.get('API_BASE_URL');
        this.retryAttempts = 3;
        this.retryDelay = 1000;
        this.requestQueue = new Map();
        this.isDemoMode = true; // FIX: Default to demo mode for hackathon
    }
    
    async request(endpoint, options = {}) {
        // FIX: Handle demo mode with mock responses
        if (this.isDemoMode) {
            return this.handleDemoRequest(endpoint, options);
        }
        
        // Rate limiting check
        if (!SecurityManager.checkRateLimit('api_request')) {
            throw new GameError('API rate limit exceeded', 'RATE_LIMIT_ERROR');
        }
        
        const url = `${this.baseURL}${endpoint}`;
        const requestId = Utils.generateId();
        
        const defaultOptions = {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
            ...options
        };
        
        try {
            console.log(`📡 API Request [${requestId}]:`, url);
            
            PerformanceMonitor.startMeasure(`api_request_${requestId}`);
            
            const response = await this.fetchWithRetry(url, defaultOptions);
            
            if (!response.ok) {
                throw new GameError(
                    `API request failed: ${response.status} ${response.statusText}`,
                    'API_ERROR',
                    { status: response.status, url }
                );
            }
            
            const data = await response.json();
            
            PerformanceMonitor.endMeasure(`api_request_${requestId}`);
            
            console.log(`✅ API Response [${requestId}]:`, data);
            
            return data;
            
        } catch (error) {
            PerformanceMonitor.endMeasure(`api_request_${requestId}`);
            ErrorManager.logError(error, `API Request: ${endpoint}`);
            throw error;
        }
    }
    
    // FIX: Demo mode request handler
    async handleDemoRequest(endpoint, options) {
        // Simulate network delay
        await Utils.sleep(Utils.getRandomInt(200, 800));
        
        // Mock responses based on endpoint
        switch (endpoint) {
            case '/games':
                return this.getMockGames();
            case '/stats':
                return this.getMockStats();
            default:
                if (endpoint.startsWith('/games/') && options.method === 'POST') {
                    return this.createMockGame(JSON.parse(options.body || '{}'));
                }
                return { success: true, demo: true };
        }
    }
    
    getMockGames() {
        const gameTypes = ['chess', 'checkers', 'words'];
        const stakes = [0.1, 0.25, 0.5, 1.0];
        const skills = ['bronze', 'silver', 'gold'];
        
        const games = [];
        for (let i = 0; i < Utils.getRandomInt(3, 8); i++) {
            games.push({
                id: `demo-${Utils.generateId()}`,
                gameType: gameTypes[Math.floor(Math.random() * gameTypes.length)],
                stake: stakes[Math.floor(Math.random() * stakes.length)],
                skillLevel: skills[Math.floor(Math.random() * skills.length)],
                creator: `0x${Math.random().toString(16).substr(2, 40)}`,
                createdAt: Date.now() - Utils.getRandomInt(60000, 3600000),
                timeControl: Utils.getRandomInt(5, 30),
                status: 'waiting'
            });
        }
        
        return { games, total: games.length };
    }
    
    getMockStats() {
        return {
            onlinePlayers: Utils.getRandomInt(15, 45),
            activeGames: Utils.getRandomInt(3, 12),
            totalVolume: (Math.random() * 1000 + 500).toFixed(2),
            lastUpdated: Date.now()
        };
    }
    
    createMockGame(gameData) {
        return {
            success: true,
            gameId: Utils.generateId(),
            transactionHash: `0x${Math.random().toString(16).substr(2, 64)}`,
            ...gameData
        };
    }
    
    async fetchWithRetry(url, options, attempt = 1) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            return response;
            
        } catch (error) {
            if (attempt < this.retryAttempts && error.name !== 'AbortError') {
                console.warn(`⚠️ Request failed, retrying (${attempt}/${this.retryAttempts}):`, error.message);
                await Utils.sleep(this.retryDelay * attempt);
                return this.fetchWithRetry(url, options, attempt + 1);
            }
            throw error;
        }
    }
    
    // Secure game data operations using proxy endpoints
    async getGames() {
        return this.request('/games');
    }
    
    async createGame(gameData) {
        return this.request('/games', {
            method: 'POST',
            body: JSON.stringify(gameData)
        });
    }
    
    async updateGame(gameId, gameData) {
        return this.request(`/games/${gameId}`, {
            method: 'PUT',
            body: JSON.stringify(gameData)
        });
    }
    
    async deleteGame(gameId) {
        return this.request(`/games/${gameId}`, {
            method: 'DELETE'
        });
    }
    
    async getServerStats() {
        return this.request('/stats');
    }
    
    async validateMove(gameId, moveData) {
        return this.request(`/games/${gameId}/validate-move`, {
            method: 'POST',
            body: JSON.stringify(moveData)
        });
    }
}

// ===========================
// GLOBAL INSTANCES
// ===========================

const BlockchainManager = new BlockchainManager();
const WalletManager = new WalletManager();
const TransactionManager = new TransactionManager();
const APIManager = new APIManager();

// Export to global scope
window.BlockchainManager = BlockchainManager;
window.WalletManager = WalletManager;
window.TransactionManager = TransactionManager;
window.APIManager = APIManager;

// ===========================
// INITIALIZATION (FIXED)
// ===========================

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('🚀 Initializing Blockchain & Wallet Integration...');
        
        // Initialize blockchain manager
        await BlockchainManager.initialize();
        
        // Try auto-connect wallet after a delay
        setTimeout(async () => {
            try {
                await WalletManager.autoConnect();
            } catch (error) {
                console.warn('Auto-connect failed:', error);
            }
        }, 1000);
        
        console.log('✅ Blockchain & Wallet Integration Initialized');
        
    } catch (error) {
        ErrorManager.logError(error, 'Blockchain & Wallet Integration Initialization');
    }
});

// Cleanup on page unload
LifecycleManager.addCleanupTask(() => {
    BlockchainManager.cleanup();
    WalletManager.removeWalletEventListeners();
    WalletManager.saveUserData();
});

console.log('✅ Blockchain & Wallet Integration (FIXED) Loaded');
  </script>
    <script>
      /* ===========================
   CROSSREALM GAMING PLATFORM
   GAME LOGIC & UI MANAGEMENT WITH COMPLETE VALIDATION (FIXED)
   =========================== */

'use strict';

// ===========================
// ENHANCED GAME STATE MANAGEMENT (FIXED)
// ===========================

class GameStateManager {
    constructor() {
        this.gameStates = new Map();
        this.gameValidators = new Map();
        this.gameRenderers = new Map();
        this.isInitialized = false;
        
        this.initializeGameTypes();
    }
    
    initializeGameTypes() {
        try {
            // Register chess game
            this.registerGame('chess', new ChessGame(), new ChessValidator(), new ChessRenderer());
            
            // Register checkers game  
            this.registerGame('checkers', new CheckersGame(), new CheckersValidator(), new CheckersRenderer());
            
            // Register word game
            this.registerGame('words', new WordGame(), new WordValidator(), new WordRenderer());
            
            this.isInitialized = true;
            console.log('🎮 Game types initialized successfully');
        } catch (error) {
            ErrorManager.logError(error, 'Game types initialization');
        }
    }
    
    registerGame(gameType, gameLogic, validator, renderer) {
        this.gameStates.set(gameType, gameLogic);
        this.gameValidators.set(gameType, validator);
        this.gameRenderers.set(gameType, renderer);
    }
    
    createGame(gameType, gameId, players) {
        const gameLogic = this.gameStates.get(gameType);
        if (!gameLogic) {
            throw new GameError(`Unknown game type: ${gameType}`, 'INVALID_GAME_TYPE');
        }
        
        return gameLogic.createNewGame(gameId, players);
    }
    
    validateMove(gameType, gameState, move, playerId) {
        const validator = this.gameValidators.get(gameType);
        if (!validator) {
            throw new GameError(`No validator for game type: ${gameType}`, 'VALIDATOR_NOT_FOUND');
        }
        
        return validator.validateMove(gameState, move, playerId);
    }
    
    makeMove(gameType, gameState, move, playerId) {
        const validator = this.gameValidators.get(gameType);
        const gameLogic = this.gameStates.get(gameType);
        
        // Validate move first
        const validation = validator.validateMove(gameState, move, playerId);
        if (!validation.valid) {
            throw new GameError(`Invalid move: ${validation.reason}`, 'INVALID_MOVE');
        }
        
        // Apply move
        return gameLogic.applyMove(gameState, move, playerId);
    }
    
    renderGame(gameType, gameState, containerId) {
        const renderer = this.gameRenderers.get(gameType);
        if (!renderer) {
            throw new GameError(`No renderer for game type: ${gameType}`, 'RENDERER_NOT_FOUND');
        }
        
        return renderer.render(gameState, containerId);
    }
}

// ===========================
// ENHANCED CHESS GAME IMPLEMENTATION (FIXED)
// ===========================

class ChessGame {
    constructor() {
        this.initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];
        
        this.pieceValues = {
            'P': 1, 'p': 1,
            'N': 3, 'n': 3, 
            'B': 3, 'b': 3,
            'R': 5, 'r': 5,
            'Q': 9, 'q': 9,
            'K': 0, 'k': 0
        };
    }
    
    createNewGame(gameId, players) {
        return {
            gameId: gameId,
            gameType: 'chess',
            players: players,
            board: JSON.parse(JSON.stringify(this.initialBoard)),
            currentPlayer: 0, // 0 = white, 1 = black
            moveHistory: [],
            gameStatus: 'active',
            castlingRights: {
                whiteKingside: true,
                whiteQueenside: true,
                blackKingside: true,
                blackQueenside: true
            },
            enPassantTarget: null,
            halfMoveClock: 0,
            fullMoveNumber: 1,
            checkStatus: {
                inCheck: false,
                checkedPlayer: null,
                checkingPieces: []
            },
            lastMove: null,
            capturedPieces: { white: [], black: [] },
            gameStartTime: Date.now(),
            timeControls: {
                white: 600000, // 10 minutes in milliseconds
                black: 600000
            }
        };
    }
    
    applyMove(gameState, move, playerId) {
        const newState = JSON.parse(JSON.stringify(gameState));
        const { from, to, promotion } = move;
        
        // Get piece being moved
        const piece = newState.board[from.row][from.col];
        const targetPiece = newState.board[to.row][to.col];
        
        // Handle captures
        if (targetPiece) {
            const isWhitePiece = targetPiece === targetPiece.toUpperCase();
            const captureColor = isWhitePiece ? 'white' : 'black';
            newState.capturedPieces[captureColor].push(targetPiece);
        }
        
        // Make the move
        newState.board[to.row][to.col] = piece;
        newState.board[from.row][from.col] = null;
        
        // Handle special moves
        this.handleSpecialMoves(newState, move, piece);
        
        // Handle pawn promotion
        if (promotion && (piece === 'P' || piece === 'p')) {
            newState.board[to.row][to.col] = promotion;
        }
        
        // Update castling rights
        this.updateCastlingRights(newState, move, piece);
        
        // Update en passant target
        this.updateEnPassantTarget(newState, move, piece);
        
        // Record move
        newState.moveHistory.push({
            move: move,
            piece: piece,
            captured: targetPiece,
            timestamp: Date.now(),
            playerId: playerId
        });
        
        newState.lastMove = move;
        
        // Update move counters
        this.updateMoveCounters(newState, piece, targetPiece);
        
        // Switch players
        newState.currentPlayer = 1 - newState.currentPlayer;
        
        // Check for game end conditions
        this.updateGameStatus(newState);
        
        return newState;
    }
    
    handleSpecialMoves(gameState, move, piece) {
        const { from, to } = move;
        
        // Handle castling
        if (piece === 'K' || piece === 'k') {
            const colDiff = to.col - from.col;
            
            if (Math.abs(colDiff) === 2) {
                // Castling detected
                const row = from.row;
                const isKingside = colDiff > 0;
                
                if (isKingside) {
                    // Move rook for kingside castling
                    gameState.board[row][5] = gameState.board[row][7];
                    gameState.board[row][7] = null;
                } else {
                    // Move rook for queenside castling
                    gameState.board[row][3] = gameState.board[row][0];
                    gameState.board[row][0] = null;
                }
            }
        }
        
        // Handle en passant capture
        if ((piece === 'P' || piece === 'p') && 
            gameState.enPassantTarget &&
            to.row === gameState.enPassantTarget.row &&
            to.col === gameState.enPassantTarget.col) {
            
            // Remove the captured pawn
            const capturedRow = piece === 'P' ? to.row + 1 : to.row - 1;
            const capturedPiece = gameState.board[capturedRow][to.col];
            gameState.board[capturedRow][to.col] = null;
            
            // Add to captured pieces
            const captureColor = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';
            gameState.capturedPieces[captureColor].push(capturedPiece);
        }
    }
    
    updateCastlingRights(gameState, move, piece) {
        const { from } = move;
        
        // King moves lose all castling rights
        if (piece === 'K') {
            gameState.castlingRights.whiteKingside = false;
            gameState.castlingRights.whiteQueenside = false;
        } else if (piece === 'k') {
            gameState.castlingRights.blackKingside = false;
            gameState.castlingRights.blackQueenside = false;
        }
        
        // Rook moves lose corresponding castling rights
        if (piece === 'R') {
            if (from.row === 7 && from.col === 0) {
                gameState.castlingRights.whiteQueenside = false;
            } else if (from.row === 7 && from.col === 7) {
                gameState.castlingRights.whiteKingside = false;
            }
        } else if (piece === 'r') {
            if (from.row === 0 && from.col === 0) {
                gameState.castlingRights.blackQueenside = false;
            } else if (from.row === 0 && from.col === 7) {
                gameState.castlingRights.blackKingside = false;
            }
        }
    }
    
    updateEnPassantTarget(gameState, move, piece) {
        const { from, to } = move;
        
        gameState.enPassantTarget = null;
        
        // Set en passant target for pawn double moves
        if ((piece === 'P' || piece === 'p') && Math.abs(to.row - from.row) === 2) {
            gameState.enPassantTarget = {
                row: (from.row + to.row) / 2,
                col: from.col
            };
        }
    }
    
    updateMoveCounters(gameState, piece, captured) {
        // Update half-move clock (50-move rule)
        if (piece === 'P' || piece === 'p' || captured) {
            gameState.halfMoveClock = 0;
        } else {
            gameState.halfMoveClock++;
        }
        
        // Update full move number
        if (gameState.currentPlayer === 1) {
            gameState.fullMoveNumber++;
        }
    }
    
    updateGameStatus(gameState) {
        // Check for check
        const checkResult = this.isInCheck(gameState, gameState.currentPlayer);
        gameState.checkStatus = checkResult;
        
        // Check for checkmate or stalemate
        const legalMoves = this.getAllLegalMoves(gameState, gameState.currentPlayer);
        
        if (legalMoves.length === 0) {
            if (checkResult.inCheck) {
                gameState.gameStatus = 'checkmate';
                gameState.winner = 1 - gameState.currentPlayer;
            } else {
                gameState.gameStatus = 'stalemate';
            }
        } else if (gameState.halfMoveClock >= 100) {
            gameState.gameStatus = 'draw_50_move';
        } else if (this.isInsufficientMaterial(gameState)) {
            gameState.gameStatus = 'draw_insufficient_material';
        }
    }
    
    isInCheck(gameState, playerIndex) {
        const isWhite = playerIndex === 0;
        const kingSymbol = isWhite ? 'K' : 'k';
        
        // Find king position
        let kingPos = null;
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                if (gameState.board[row][col] === kingSymbol) {
                    kingPos = { row, col };
                    break;
                }
            }
            if (kingPos) break;
        }
        
        if (!kingPos) {
            return { inCheck: false, checkedPlayer: null, checkingPieces: [] };
        }
        
        // Check if any opponent piece can attack the king
        const checkingPieces = [];
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece && this.isOpponentPiece(piece, isWhite)) {
                    if (this.canPieceAttackSquare(gameState, { row, col }, kingPos, piece)) {
                        checkingPieces.push({ row, col, piece });
                    }
                }
            }
        }
        
        return {
            inCheck: checkingPieces.length > 0,
            checkedPlayer: checkingPieces.length > 0 ? playerIndex : null,
            checkingPieces: checkingPieces
        };
    }
    
    getAllLegalMoves(gameState, playerIndex) {
        const legalMoves = [];
        const isWhite = playerIndex === 0;
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece && !this.isOpponentPiece(piece, isWhite)) {
                    const pieceMoves = this.getPossibleMoves(gameState, { row, col }, piece);
                    
                    for (const move of pieceMoves) {
                        if (this.isMoveLegal(gameState, { from: { row, col }, to: move }, playerIndex)) {
                            legalMoves.push({ from: { row, col }, to: move, piece });
                        }
                    }
                }
            }
        }
        
        return legalMoves;
    }
    
    isMoveLegal(gameState, move, playerIndex) {
        // Create temporary state
        const tempState = JSON.parse(JSON.stringify(gameState));
        
        // Apply move temporarily
        const piece = tempState.board[move.from.row][move.from.col];
        tempState.board[move.to.row][move.to.col] = piece;
        tempState.board[move.from.row][move.from.col] = null;
        
        // Check if move leaves king in check
        const checkResult = this.isInCheck(tempState, playerIndex);
        return !checkResult.inCheck;
    }
    
    getPossibleMoves(gameState, position, piece) {
        const moves = [];
        
        try {
            switch (piece.toLowerCase()) {
                case 'p':
                    moves.push(...this.getPawnMoves(gameState, position, piece));
                    break;
                case 'r':
                    moves.push(...this.getRookMoves(gameState, position));
                    break;
                case 'n':
                    moves.push(...this.getKnightMoves(gameState, position));
                    break;
                case 'b':
                    moves.push(...this.getBishopMoves(gameState, position));
                    break;
                case 'q':
                    moves.push(...this.getQueenMoves(gameState, position));
                    break;
                case 'k':
                    moves.push(...this.getKingMoves(gameState, position));
                    break;
            }
        } catch (error) {
            ErrorManager.logError(error, 'Get possible moves');
        }
        
        return moves;
    }
    
    getPawnMoves(gameState, position, piece) {
        const moves = [];
        const { row, col } = position;
        const isWhite = piece === 'P';
        const direction = isWhite ? -1 : 1;
        const startRow = isWhite ? 6 : 1;
        
        // Forward move
        if (this.isValidSquare(row + direction, col) && !gameState.board[row + direction][col]) {
            moves.push({ row: row + direction, col });
            
            // Double move from starting position
            if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                moves.push({ row: row + 2 * direction, col });
            }
        }
        
        // Captures
        for (const deltaCol of [-1, 1]) {
            const newRow = row + direction;
            const newCol = col + deltaCol;
            
            if (this.isValidSquare(newRow, newCol)) {
                const targetPiece = gameState.board[newRow][newCol];
                
                // Regular capture
                if (targetPiece && this.isOpponentPiece(targetPiece, isWhite)) {
                    moves.push({ row: newRow, col: newCol });
                }
                
                // En passant capture
                if (gameState.enPassantTarget &&
                    newRow === gameState.enPassantTarget.row &&
                    newCol === gameState.enPassantTarget.col) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        }
        
        return moves;
    }
    
    getRookMoves(gameState, position) {
        return this.getSlidingMoves(gameState, position, [
            [-1, 0], [1, 0], [0, -1], [0, 1]
        ]);
    }
    
    getBishopMoves(gameState, position) {
        return this.getSlidingMoves(gameState, position, [
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ]);
    }
    
    getQueenMoves(gameState, position) {
        return this.getSlidingMoves(gameState, position, [
            [-1, 0], [1, 0], [0, -1], [0, 1],
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ]);
    }
    
    getSlidingMoves(gameState, position, directions) {
        const moves = [];
        const { row, col } = position;
        const piece = gameState.board[row][col];
        const isWhite = piece === piece.toUpperCase();
        
        for (const [deltaRow, deltaCol] of directions) {
            let newRow = row + deltaRow;
            let newCol = col + deltaCol;
            
            while (this.isValidSquare(newRow, newCol)) {
                const targetPiece = gameState.board[newRow][newCol];
                
                if (!targetPiece) {
                    moves.push({ row: newRow, col: newCol });
                } else if (this.isOpponentPiece(targetPiece, isWhite)) {
                    moves.push({ row: newRow, col: newCol });
                    break;
                } else {
                    break;
                }
                
                newRow += deltaRow;
                newCol += deltaCol;
            }
        }
        
        return moves;
    }
    
    getKnightMoves(gameState, position) {
        const moves = [];
        const { row, col } = position;
        const piece = gameState.board[row][col];
        const isWhite = piece === piece.toUpperCase();
        
        const knightMoves = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1]
        ];
        
        for (const [deltaRow, deltaCol] of knightMoves) {
            const newRow = row + deltaRow;
            const newCol = col + deltaCol;
            
            if (this.isValidSquare(newRow, newCol)) {
                const targetPiece = gameState.board[newRow][newCol];
                
                if (!targetPiece || this.isOpponentPiece(targetPiece, isWhite)) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        }
        
        return moves;
    }
    
    getKingMoves(gameState, position) {
        const moves = [];
        const { row, col } = position;
        const piece = gameState.board[row][col];
        const isWhite = piece === piece.toUpperCase();
        
        // Regular king moves
        for (let deltaRow = -1; deltaRow <= 1; deltaRow++) {
            for (let deltaCol = -1; deltaCol <= 1; deltaCol++) {
                if (deltaRow === 0 && deltaCol === 0) continue;
                
                const newRow = row + deltaRow;
                const newCol = col + deltaCol;
                
                if (this.isValidSquare(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    
                    if (!targetPiece || this.isOpponentPiece(targetPiece, isWhite)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
        }
        
        return moves;
    }
    
    canPieceAttackSquare(gameState, piecePos, targetPos, piece) {
        const possibleMoves = this.getPossibleMoves(gameState, piecePos, piece);
        return possibleMoves.some(move => move.row === targetPos.row && move.col === targetPos.col);
    }
    
    isValidSquare(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }
    
    isOpponentPiece(piece, isCurrentPlayerWhite) {
        const pieceIsWhite = piece === piece.toUpperCase();
        return pieceIsWhite !== isCurrentPlayerWhite;
    }
    
    isInsufficientMaterial(gameState) {
        const pieces = { white: [], black: [] };
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece) {
                    const color = piece === piece.toUpperCase() ? 'white' : 'black';
                    pieces[color].push(piece.toLowerCase());
                }
            }
        }
        
        // King vs King
        if (pieces.white.length === 1 && pieces.black.length === 1) {
            return true;
        }
        
        // King and Bishop vs King or King and Knight vs King
        if ((pieces.white.length === 2 && pieces.black.length === 1) ||
            (pieces.white.length === 1 && pieces.black.length === 2)) {
            const allPieces = [...pieces.white, ...pieces.black];
            return allPieces.includes('b') || allPieces.includes('n');
        }
        
        return false;
    }
}

// ===========================
// ENHANCED CHESS VALIDATOR (FIXED)
// ===========================

class ChessValidator {
    constructor() {
        this.chessGame = new ChessGame();
    }
    
    validateMove(gameState, move, playerId) {
        try {
            // Check if it's the player's turn
            if (gameState.currentPlayer !== playerId) {
                return { valid: false, reason: 'Not your turn' };
            }
            
            // Check if game is active
            if (gameState.gameStatus !== 'active') {
                return { valid: false, reason: 'Game is not active' };
            }
            
            // Validate move format
            if (!this.isValidMoveFormat(move)) {
                return { valid: false, reason: 'Invalid move format' };
            }
            
            const { from, to } = move;
            
            // Check if source square has a piece
            const piece = gameState.board[from.row][from.col];
            if (!piece) {
                return { valid: false, reason: 'No piece at source square' };
            }
            
            // Check if piece belongs to current player
            const isWhite = gameState.currentPlayer === 0;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (isWhite !== pieceIsWhite) {
                return { valid: false, reason: 'Not your piece' };
            }
            
            // Check if the move is possible for this piece
            const possibleMoves = this.chessGame.getPossibleMoves(gameState, from, piece);
            const moveExists = possibleMoves.some(m => m.row === to.row && m.col === to.col);
            
            if (!moveExists) {
                return { valid: false, reason: 'Invalid move for this piece' };
            }
            
            // Check if move leaves king in check
            if (!this.chessGame.isMoveLegal(gameState, move, playerId)) {
                return { valid: false, reason: 'Move leaves king in check' };
            }
            
            return { valid: true };
            
        } catch (error) {
            ErrorManager.logError(error, 'Chess move validation');
            return { valid: false, reason: 'Validation error' };
        }
    }
    
    isValidMoveFormat(move) {
        return move &&
               typeof move.from === 'object' &&
               typeof move.to === 'object' &&
               Number.isInteger(move.from.row) &&
               Number.isInteger(move.from.col) &&
               Number.isInteger(move.to.row) &&
               Number.isInteger(move.to.col) &&
               move.from.row >= 0 && move.from.row < 8 &&
               move.from.col >= 0 && move.from.col < 8 &&
               move.to.row >= 0 && move.to.row < 8 &&
               move.to.col >= 0 && move.to.col < 8;
    }
}

// ===========================
// ENHANCED CHESS RENDERER (FIXED)
// ===========================

class ChessRenderer {
    constructor() {
        this.pieceSymbols = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };
        
        this.selectedSquare = null;
        this.highlightedSquares = new Set();
    }
    
    render(gameState, containerId) {
        const container = document.getElementById(containerId);
        if (!container) {
            throw new GameError(`Container not found: ${containerId}`, 'CONTAINER_NOT_FOUND');
        }
        
        container.innerHTML = this.generateChessHTML(gameState);
        this.attachEventListeners(container, gameState);
        this.updateGameInfo(gameState);
    }
    
    generateChessHTML(gameState) {
        return `
            <div class="chess-game-container">
                <div class="chess-players">
                    <div class="player-info">
                        <span class="player-name">${this.getPlayerName(gameState, 1)} (Black)</span>
                        <div class="player-timer" id="blackTimer">${this.formatTime(gameState.timeControls.black)}</div>
                    </div>
                    <div class="player-info">
                        <span class="player-name">${this.getPlayerName(gameState, 0)} (White)</span>
                        <div class="player-timer" id="whiteTimer">${this.formatTime(gameState.timeControls.white)}</div>
                    </div>
                </div>
                
                <div class="chess-board-container">
                    <div class="chess-board" id="chessBoard">
                        ${this.generateBoardHTML(gameState)}
                    </div>
                </div>
                
                <div class="chess-controls">
                    <div class="game-status" id="chessGameStatus">
                        ${this.getStatusMessage(gameState)}
                    </div>
                    
                    <div class="chess-actions">
                        <button class="btn btn-sm btn-danger" onclick="GameUIManager.resignGame && GameUIManager.resignGame('chess')">
                            <i class="fas fa-flag"></i> Resign
                        </button>
                        <button class="btn btn-sm btn-secondary" onclick="GameUIManager.offerDraw && GameUIManager.offerDraw('chess')">
                            <i class="fas fa-handshake"></i> Draw
                        </button>
                        <button class="btn btn-sm btn-warning" onclick="GameUIManager.requestUndo && GameUIManager.requestUndo('chess')">
                            <i class="fas fa-undo"></i> Undo
                        </button>
                    </div>
                    
                    <div class="move-history" id="chessMoveHistory">
                        <h4>Move History</h4>
                        <div class="moves-list">
                            ${this.generateMoveHistoryHTML(gameState)}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    generateBoardHTML(gameState) {
        let html = '';
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const isLight = (row + col) % 2 === 0;
                const piece = gameState.board[row][col];
                const squareId = `chess-square-${row}-${col}`;
                
                let cssClasses = `chess-square ${isLight ? 'light' : 'dark'}`;
                
                // Highlight last move
                if (gameState.lastMove) {
                    const { from, to } = gameState.lastMove;
                    if ((row === from.row && col === from.col) || (row === to.row && col === to.col)) {
                        cssClasses += ' last-move';
                    }
                }
                
                // Highlight check
                if (gameState.checkStatus.inCheck) {
                    const piece = gameState.board[row][col];
                    if (piece === 'K' || piece === 'k') {
                        const pieceOwner = piece === 'K' ? 0 : 1;
                        if (pieceOwner === gameState.checkStatus.checkedPlayer) {
                            cssClasses += ' in-check';
                        }
                    }
                }
                
                html += `
                    <div class="${cssClasses}" 
                         id="${squareId}"
                         data-row="${row}" 
                         data-col="${col}">
                        ${piece ? this.pieceSymbols[piece] : ''}
                    </div>
                `;
            }
        }
        
        return html;
    }
    
    generateMoveHistoryHTML(gameState) {
        let html = '';
        const moves = gameState.moveHistory;
        
        for (let i = 0; i < moves.length; i += 2) {
            const moveNumber = Math.floor(i / 2) + 1;
            const whiteMove = moves[i];
            const blackMove = moves[i + 1];
            
            html += `
                <div class="move-pair">
                    <span class="move-number">${moveNumber}.</span>
                    <span class="white-move">${this.formatMove(whiteMove)}</span>
                    ${blackMove ? `<span class="black-move">${this.formatMove(blackMove)}</span>` : ''}
                </div>
            `;
        }
        
        return html || '<div class="no-moves">No moves yet</div>';
    }
    
    formatMove(moveEntry) {
        if (!moveEntry) return '';
        
        const { move } = moveEntry;
        const { from, to } = move;
        
        return `${this.squareToNotation(from)}${this.squareToNotation(to)}`;
    }
    
    squareToNotation(square) {
        return String.fromCharCode(97 + square.col) + (8 - square.row);
    }
    
    getPlayerName(gameState, playerIndex) {
        if (gameState.players && gameState.players[playerIndex]) {
            const address = gameState.players[playerIndex];
            return address.substring(0, 8) + '...';
        }
        return `Player ${playerIndex + 1}`;
    }
    
    getStatusMessage(gameState) {
        if (gameState.gameStatus === 'checkmate') {
            const winner = gameState.winner === 0 ? 'White' : 'Black';
            return `Checkmate! ${winner} wins!`;
        } else if (gameState.gameStatus === 'stalemate') {
            return 'Stalemate! Game is a draw.';
        } else if (gameState.gameStatus.startsWith('draw_')) {
            return 'Game is a draw.';
        } else if (gameState.checkStatus.inCheck) {
            const checkedPlayer = gameState.checkStatus.checkedPlayer === 0 ? 'White' : 'Black';
            return `${checkedPlayer} is in check!`;
        } else {
            const currentPlayer = gameState.currentPlayer === 0 ? 'White' : 'Black';
            return `${currentPlayer} to move`;
        }
    }
    
    formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    attachEventListeners(container, gameState) {
        const squares = container.querySelectorAll('.chess-square');
        
        squares.forEach(square => {
            square.addEventListener('click', (event) => {
                this.handleSquareClick(event, gameState);
            });
        });
    }
    
    handleSquareClick(event, gameState) {
        const square = event.currentTarget;
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        
        if (this.selectedSquare) {
            // Attempt to make a move
            const move = {
                from: this.selectedSquare,
                to: { row, col }
            };
            
            if (window.GameManager) {
                GameManager.makeMove('chess', move);
            }
            this.clearSelection();
        } else {
            // Select a piece
            const piece = gameState.board[row][col];
            if (piece) {
                const userAccount = StateManager.get('userAccount');
                const playerIndex = gameState.players.indexOf(userAccount);
                
                if (playerIndex === gameState.currentPlayer) {
                    this.selectSquare({ row, col });
                }
            }
        }
    }
    
    selectSquare(square) {
        this.clearSelection();
        this.selectedSquare = square;
        
        const squareElement = document.getElementById(`chess-square-${square.row}-${square.col}`);
        if (squareElement) {
            squareElement.classList.add('selected');
        }
    }
    
    clearSelection() {
        if (this.selectedSquare) {
            const squareElement = document.getElementById(`chess-square-${this.selectedSquare.row}-${this.selectedSquare.col}`);
            if (squareElement) {
                squareElement.classList.remove('selected');
            }
        }
        
        this.selectedSquare = null;
        this.clearHighlights();
    }
    
    clearHighlights() {
        this.highlightedSquares.forEach(square => {
            const squareElement = document.getElementById(`chess-square-${square.row}-${square.col}`);
            if (squareElement) {
                squareElement.classList.remove('possible-move');
            }
        });
        
        this.highlightedSquares.clear();
    }
    
    updateGameInfo(gameState) {
        // Update any additional game information displays
        const statusElement = document.getElementById('chessGameStatus');
        if (statusElement) {
            statusElement.textContent = this.getStatusMessage(gameState);
            
            // Add appropriate CSS classes
            statusElement.className = 'game-status';
            if (gameState.checkStatus.inCheck) {
                statusElement.classList.add('check');
            }
            if (gameState.gameStatus === 'checkmate') {
                statusElement.classList.add('checkmate');
            }
        }
    }
}

// ===========================
// SIMPLIFIED GAME IMPLEMENTATIONS (FIXED)
// ===========================

// Checkers Game
class CheckersGame {
    createNewGame(gameId, players) {
        return {
            gameId: gameId,
            gameType: 'checkers',
            players: players,
            board: this.createInitialBoard(),
            currentPlayer: 0, // 0 = red, 1 = black
            gameStatus: 'active',
            moveHistory: [],
            capturedPieces: { red: 0, black: 0 },
            mustCapture: false,
            gameStartTime: Date.now()
        };
    }
    
    createInitialBoard() {
        const board = Array(8).fill(null).map(() => Array(8).fill(null));
        
        // Place black pieces (top)
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 8; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'black', king: false };
                }
            }
        }
        
        // Place red pieces (bottom)
        for (let row = 5; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'red', king: false };
                }
            }
        }
        
        return board;
    }
    
    applyMove(gameState, move, playerId) {
        const newState = JSON.parse(JSON.stringify(gameState));
        // Simplified checkers implementation
        return newState;
    }
}

class CheckersValidator {
    validateMove(gameState, move, playerId) {
        return { valid: true };
    }
}

class CheckersRenderer {
    render(gameState, containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div class="checkers-game-container">
                <div class="checkers-board">
                    <div class="game-placeholder">
                        <h3>Checkers Game</h3>
                        <p>Game ID: ${gameState.gameId}</p>
                        <p>Current Player: ${gameState.currentPlayer === 0 ? 'Red' : 'Black'}</p>
                        <div class="demo-note">
                            <i class="fas fa-info-circle"></i>
                            <p>Checkers game implementation coming soon!</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
}

// Word Game
class WordGame {
    createNewGame(gameId, players) {
        return {
            gameId: gameId,
            gameType: 'words',
            players: players,
            currentRound: 1,
            totalRounds: 3,
            timeLeft: 60000,
            availableLetters: this.generateLetters(),
            scores: { 0: 0, 1: 0 },
            foundWords: { 0: [], 1: [] },
            gameStatus: 'active',
            gameStartTime: Date.now()
        };
    }
    
    generateLetters() {
        const letterSets = ['BLOCKCHAIN', 'ETHEREUM', 'BITCOIN', 'GAMING', 'TOKENS'];
        return letterSets[Math.floor(Math.random() * letterSets.length)];
    }
    
    applyMove(gameState, move, playerId) {
        const newState = JSON.parse(JSON.stringify(gameState));
        return newState;
    }
}

class WordValidator {
    validateMove(gameState, move, playerId) {
        return { valid: true };
    }
}

class WordRenderer {
    render(gameState, containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div class="word-game-container">
                <div class="word-game-board">
                    <h3>Word Battle</h3>
                    <p>Game ID: ${gameState.gameId}</p>
                    <p>Round: ${gameState.currentRound}/${gameState.totalRounds}</p>
                    <p>Letters: ${gameState.availableLetters}</p>
                    <div class="demo-note">
                        <i class="fas fa-info-circle"></i>
                        <p>Word Battle game implementation coming soon!</p>
                    </div>
                </div>
            </div>
        `;
    }
}

// ===========================
// ENHANCED GAME MANAGER (FIXED)
// ===========================

class GameManager {
    constructor() {
        this.gameStateManager = new GameStateManager();
        this.activeGames = new Map();
        this.gameWindows = new Map();
        this.isInitialized = false;
    }
    
    initialize() {
        if (this.isInitialized) return;
        
        try {
            // Initialize game state manager
            if (!this.gameStateManager.isInitialized) {
                throw new Error('Game state manager not initialized');
            }
            
            this.isInitialized = true;
            console.log('🎮 Game Manager initialized');
        } catch (error) {
            ErrorManager.logError(error, 'Game Manager initialization');
        }
    }
    
    async createGame(gameType, stakeAmount, players) {
        try {
            // Validate inputs
            const gameTypeValidation = SecurityManager.validateInput(gameType, 'game_type');
            if (!gameTypeValidation.valid) {
                throw new GameError(gameTypeValidation.error, 'INVALID_GAME_TYPE');
            }
            
            const stakeValidation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
            if (!stakeValidation.valid) {
                throw new GameError(stakeValidation.error, 'INVALID_STAKE');
            }
            
            // Create game on blockchain if connected
            let blockchainResult = null;
            if (StateManager.get('isWalletConnected') && StateManager.get('walletProvider') !== 'demo') {
                try {
                    blockchainResult = await BlockchainManager.createGameOnChain(gameType, stakeAmount);
                } catch (error) {
                    console.warn('Blockchain game creation failed, continuing in demo mode:', error);
                }
            }
            
            // Create game state
            const gameId = blockchainResult?.gameId || Utils.generateId();
            const gameState = this.gameStateManager.createGame(gameType, gameId, players);
            
            // Store game
            this.activeGames.set(gameId, gameState);
            
            // Update state manager
            StateManager.update('myActiveGames', games => {
                games.set(gameId, gameState);
                return games;
            });
            
            // Show success notification
            NotificationManager.show(
                'Game Created',
                `${gameType.charAt(0).toUpperCase() + gameType.slice(1)} game created successfully!`,
                'success'
            );
            
            return { gameId, gameState, blockchainResult };
            
        } catch (error) {
            ErrorManager.logError(error, 'Game creation');
            throw error;
        }
    }
    
    openGameWindow(gameType, gameId) {
        try {
            const gameState = this.activeGames.get(gameId);
            if (!gameState) {
                throw new GameError('Game not found', 'GAME_NOT_FOUND');
            }
            
            // Create game window
            const windowId = `game-window-${gameId}`;
            const gameWindow = this.createGameWindow(windowId, gameType, gameState);
            
            // Render game
            this.gameStateManager.renderGame(gameType, gameState, `${windowId}-content`);
            
            // Store window reference
            this.gameWindows.set(gameId, gameWindow);
            
            return gameWindow;
            
        } catch (error) {
            ErrorManager.logError(error, 'Opening game window');
            throw error;
        }
    }
    
    createGameWindow(windowId, gameType, gameState) {
        const gameWindow = document.createElement('div');
        gameWindow.id = windowId;
        gameWindow.className = 'game-window';
        
        gameWindow.innerHTML = `
            <div class="game-window-header">
                <h3><i class="fas fa-gamepad"></i> ${gameType.charAt(0).toUpperCase() + gameType.slice(1)} Game</h3>
                <div class="game-window-controls">
                    <button class="btn btn-sm" onclick="GameManager.minimizeGame('${gameState.gameId}')">
                        <i class="fas fa-minus"></i>
                    </button>
                    <button class="btn btn-sm btn-danger" onclick="GameManager.closeGame('${gameState.gameId}')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div class="game-window-content" id="${windowId}-content">
                <!-- Game content will be rendered here -->
            </div>
        `;
        
        // Add to page
        const container = document.getElementById('gamesSection') || document.body;
        container.appendChild(gameWindow);
        
        return gameWindow;
    }
    
    makeMove(gameType, move) {
        try {
            const userAccount = StateManager.get('userAccount');
            if (!userAccount) {
                throw new GameError('Wallet not connected', 'WALLET_NOT_CONNECTED');
            }
            
            // Find active game for this user and game type
            const activeGame = Array.from(this.activeGames.values()).find(game => 
                game.gameType === gameType && 
                game.players.includes(userAccount) &&
                game.gameStatus === 'active'
            );
            
            if (!activeGame) {
                throw new GameError('No active game found', 'NO_ACTIVE_GAME');
            }
            
            const playerId = activeGame.players.indexOf(userAccount);
            
            // Validate and apply move
            const newGameState = this.gameStateManager.makeMove(gameType, activeGame, move, playerId);
            
            // Update stored game state
            this.activeGames.set(activeGame.gameId, newGameState);
            
            // Re-render game
            this.gameStateManager.renderGame(gameType, newGameState, `game-window-${activeGame.gameId}-content`);
            
            // Check for game end
            if (newGameState.gameStatus !== 'active') {
                this.handleGameEnd(newGameState);
            }
            
            return newGameState;
            
        } catch (error) {
            ErrorManager.logError(error, 'Making move');
            NotificationManager.show(
                'Invalid Move',
                error.message,
                'error'
            );
            throw error;
        }
    }
    
    handleGameEnd(gameState) {
        try {
            console.log('🏁 Game ended:', gameState);
            
            // Update player stats
            const userAccount = StateManager.get('userAccount');
            const playerIndex = gameState.players.indexOf(userAccount);
            
            if (playerIndex !== -1) {
                StateManager.update('playerStats', stats => {
                    stats.gamesPlayed++;
                    
                    if (gameState.winner === playerIndex) {
                        stats.gamesWon++;
                        stats.totalEarned += gameState.stake * 1.94; // 97% of pot minus platform fee
                    }
                    
                    stats.winRate = stats.gamesPlayed > 0 ? (stats.gamesWon / stats.gamesPlayed) * 100 : 0;
                    
                    return stats;
                });
                
                // Save updated stats
                if (window.WalletManager) {
                    WalletManager.saveUserData();
                }
            }
            
            // Show game result
            const isWinner = gameState.winner === playerIndex;
            const resultType = gameState.gameStatus === 'stalemate' || gameState.gameStatus.startsWith('draw_') ? 'draw' : 
                              isWinner ? 'win' : 'lose';
            
            this.showGameResult(gameState, resultType);
            
        } catch (error) {
            ErrorManager.logError(error, 'Handling game end');
        }
    }
    
    showGameResult(gameState, resultType) {
        const messages = {
            win: '🏆 Congratulations! You won!',
            lose: '😞 You lost this game.',
            draw: '🤝 Game ended in a draw.'
        };
        
        const resultActions = `
            <button class="notification-btn" onclick="GameManager.closeGame('${gameState.gameId}')">
                Close Game
            </button>
            <button class="notification-btn secondary" onclick="NavigationManager.showSection('lobby')">
                Back to Lobby
            </button>
        `;
        
        NotificationManager.show(
            'Game Finished',
            messages[resultType],
            resultType === 'win' ? 'success' : resultType === 'lose' ? 'error' : 'info',
            0,
            resultActions
        );
    }
    
    minimizeGame(gameId) {
        const gameWindow = this.gameWindows.get(gameId);
        if (gameWindow) {
            gameWindow.style.display = 'none';
        }
    }
    
    closeGame(gameId) {
        try {
            // Remove from active games
            this.activeGames.delete(gameId);
            
            // Remove game window
            const gameWindow = this.gameWindows.get(gameId);
            if (gameWindow && gameWindow.parentNode) {
                gameWindow.parentNode.removeChild(gameWindow);
            }
            this.gameWindows.delete(gameId);
            
            // Update state
            StateManager.update('myActiveGames', games => {
                games.delete(gameId);
                return games;
            });
            
            NotificationManager.show('Game Closed', 'Game window closed', 'info');
            
        } catch (error) {
            ErrorManager.logError(error, 'Closing game');
        }
    }
}

// ===========================
// ENHANCED NAVIGATION MANAGER (FIXED)
// ===========================

class NavigationManager {
    constructor() {
        this.currentSection = 'lobby';
        this.sectionLoaders = new Map();
        this.isInitialized = false;
        this.initializeSectionLoaders();
    }
    
    initialize() {
        if (this.isInitialized) return;
        
        try {
            this.setupNavigationEventListeners();
            this.isInitialized = true;
            console.log('🧭 Navigation Manager initialized');
        } catch (error) {
            ErrorManager.logError(error, 'Navigation Manager initialization');
        }
    }
    
    setupNavigationEventListeners() {
        // Setup navigation event listeners
        document.querySelectorAll('[data-section]').forEach(element => {
            element.addEventListener('click', (e) => {
                e.preventDefault();
                const section = e.currentTarget.dataset.section;
                this.showSection(section);
            });
        });
    }
    
    initializeSectionLoaders() {
        this.sectionLoaders.set('lobby', () => this.loadLobbySection());
        this.sectionLoaders.set('create', () => this.loadCreateSection());
        this.sectionLoaders.set('games', () => this.loadGamesSection());
        this.sectionLoaders.set('tournaments', () => this.loadTournamentsSection());
        this.sectionLoaders.set('profile', () => this.loadProfileSection());
        this.sectionLoaders.set('settings', () => this.loadSettingsSection());
    }
    
    showSection(sectionName) {
        try {
            if (sectionName === this.currentSection) {
                return; // Already showing this section
            }
            
            // Validate section name
            const validation = SecurityManager.validateInput(sectionName, 'string', {
                maxLength: 20,
                allowSpecialChars: false
            });
            
            if (!validation.valid) {
                throw new GameError('Invalid section name', 'INVALID_SECTION');
            }
            
            console.log(`🧭 Navigating to: ${sectionName}`);
            
            // Hide all sections
            document.querySelectorAll('.section-content').forEach(section => {
                section.classList.remove('active');
            });
            
            // Update navigation
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show target section
            const targetSection = document.getElementById(`${sectionName}Section`);
            if (targetSection) {
                targetSection.classList.add('active');
                
                // Load section content
                const loader = this.sectionLoaders.get(sectionName);
                if (loader) {
                    loader();
                }
            } else {
                console.warn(`Section not found: ${sectionName}Section`);
            }
            
            // Update active nav item
            const navItem = document.querySelector(`[data-section="${sectionName}"]`);
            if (navItem) {
                navItem.classList.add('active');
            }
            
            // Update state
            this.currentSection = sectionName;
            StateManager.set('currentSection', sectionName);
            
        } catch (error) {
            ErrorManager.logError(error, 'Section navigation');
        }
    }
    
    loadLobbySection() {
        const section = document.getElementById('lobbySection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-home"></i> Game Lobby</h2>
                <div class="section-controls">
                    <button class="btn btn-sm btn-primary" onclick="LobbyManager && LobbyManager.refreshLobby && LobbyManager.refreshLobby()">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
            </div>
            
            <div class="lobby-content">
                <div class="lobby-filters">
                    <h3>Filter Games</h3>
                    <div class="filter-controls">
                        <select id="gameTypeFilter" class="form-control">
                            <option value="all">All Games</option>
                            <option value="chess">Chess</option>
                            <option value="checkers">Checkers</option>
                            <option value="words">Word Battle</option>
                        </select>
                        <select id="skillFilter" class="form-control">
                            <option value="all">All Skill Levels</option>
                            <option value="bronze">Bronze</option>
                            <option value="silver">Silver</option>
                            <option value="gold">Gold</option>
                            <option value="diamond">Diamond</option>
                        </select>
                        <button class="btn btn-secondary" onclick="LobbyManager && LobbyManager.applyFilters && LobbyManager.applyFilters()">
                            Apply Filters
                        </button>
                    </div>
                </div>
                
                <div class="games-grid" id="lobbyGamesList">
                    <div class="loading-placeholder">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Loading games...</p>
                    </div>
                </div>
            </div>
        `;
        
        // Load games after rendering
        setTimeout(() => {
            if (window.LobbyManager && window.LobbyManager.loadGames) {
                LobbyManager.loadGames();
            }
        }, 100);
    }
    
    loadCreateSection() {
        const section = document.getElementById('createSection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-plus"></i> Create New Game</h2>
            </div>
            
            <div class="create-game-form">
                <div class="form-group">
                    <label>Game Type</label>
                    <div class="game-type-selector">
                        <button class="game-type-btn" data-game-type="chess">
                            <i class="fas fa-chess"></i>
                            <span>Chess</span>
                        </button>
                        <button class="game-type-btn" data-game-type="checkers">
                            <i class="fas fa-circle"></i>
                            <span>Checkers</span>
                        </button>
                        <button class="game-type-btn" data-game-type="words">
                            <i class="fas fa-font"></i>
                            <span>Words</span>
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="gameStake">Stake Amount (CORE)</label>
                    <input type="number" id="gameStake" class="form-control" 
                           min="0.01" max="100" step="0.01" value="0.1">
                    <small>Minimum: 0.01 CORE, Maximum: 100 CORE</small>
                </div>
                
                <div class="form-group">
                    <label for="gameTimeControl">Time Control</label>
                    <select id="gameTimeControl" class="form-control">
                        <option value="blitz">Blitz (5 min)</option>
                        <option value="rapid" selected>Rapid (10 min)</option>
                        <option value="standard">Standard (30 min)</option>
                    </select>
                </div>
                
                <button class="btn btn-lg btn-primary" id="createGameBtn" onclick="GameCreator && GameCreator.createGame && GameCreator.createGame()" disabled>
                    <i class="fas fa-plus"></i> Create Game
                </button>
            </div>
            
            <div class="player-stats-preview">
                <h3>Your Stats</h3>
                <div class="stats-grid" id="playerStatsDisplay">
                    <!-- Stats will be loaded by JavaScript -->
                </div>
            </div>
        `;
        
        // Load player stats
        setTimeout(() => {
            if (window.StatsManager && window.StatsManager.updatePlayerStatsDisplay) {
                StatsManager.updatePlayerStatsDisplay();
            }
        }, 100);
    }
    
    loadGamesSection() {
        const section = document.getElementById('gamesSection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-gamepad"></i> Active Games</h2>
            </div>
            
            <div class="games-content">
                <div class="game-windows-container" id="gameWindowsContainer">
                    <!-- Game windows will be created here -->
                </div>
                
                <div class="no-active-games" id="noActiveGames">
                    <i class="fas fa-ghost"></i>
                    <h3>No Active Games</h3>
                    <p>You don't have any active games. Create or join a game to start playing!</p>
                    <button class="btn btn-primary" onclick="NavigationManager.showSection('create')">
                        <i class="fas fa-plus"></i> Create Game
                    </button>
                </div>
            </div>
        `;
    }
    
    loadTournamentsSection() {
        const section = document.getElementById('tournamentsSection');
        if (!section) return;
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-trophy"></i> Tournaments</h2>
            </div>
            
            <div class="tournaments-content">
                <div class="tournaments-placeholder">
                    <i class="fas fa-trophy"></i>
                    <h3>Tournaments Coming Soon!</h3>
                    <p>Tournament functionality will be available in the next update.</p>
                    <div class="coming-soon-features">
                        <ul>
                            <li><i class="fas fa-check"></i> Single-elimination tournaments</li>
                            <li><i class="fas fa-check"></i> Multi-game format support</li>
                            <li><i class="fas fa-check"></i> Prize pool distribution</li>
                            <li><i class="fas fa-check"></i> Live leaderboards</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
    }
    
    loadProfileSection() {
        const section = document.getElementById('profileSection');
        if (!section) return;
        
        const userAccount = StateManager.get('userAccount');
        const playerStats = StateManager.get('playerStats');
        const skillRatings = StateManager.get('skillRatings');
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-user"></i> Player Profile</h2>
            </div>
            
            <div class="profile-content">
                <div class="player-identity">
                    <div class="player-avatar">
                        <div class="avatar-circle">
                            ${userAccount ? userAccount.substring(0, 2).toUpperCase() : '??'}
                        </div>
                    </div>
                    <div class="player-info">
                        <h3>${userAccount || 'Not Connected'}</h3>
                        <div class="player-badges">
                            ${userAccount ? '<span class="badge verified">✅ Verified</span>' : ''}
                            ${StateManager.get('isWalletConnected') ? '<span class="badge blockchain">⛓️ On-Chain</span>' : ''}
                        </div>
                    </div>
                </div>
                
                <div class="stats-section">
                    <h3>Gaming Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.gamesPlayed}</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.gamesWon}</div>
                            <div class="stat-label">Games Won</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.winRate.toFixed(1)}%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${playerStats.totalEarned.toFixed(4)}</div>
                            <div class="stat-label">CORE Earned</div>
                        </div>
                    </div>
                </div>
                
                <div class="skills-section">
                    <h3>Skill Ratings</h3>
                    <div class="skills-list">
                        <div class="skill-item">
                            <span class="skill-name">♟️ Chess</span>
                            <span class="skill-rating">${skillRatings.chess}</span>
                        </div>
                        <div class="skill-item">
                            <span class="skill-name">⚫ Checkers</span>
                            <span class="skill-rating">${skillRatings.checkers}</span>
                        </div>
                        <div class="skill-item">
                            <span class="skill-name">📝 Words</span>
                            <span class="skill-rating">${skillRatings.words}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    loadSettingsSection() {
        const section = document.getElementById('settingsSection');
        if (!section) return;
        
        const settings = StateManager.get('platformSettings');
        
        section.innerHTML = `
            <div class="section-header">
                <h2><i class="fas fa-cog"></i> Settings</h2>
            </div>
            
            <div class="settings-content">
                <div class="settings-category">
                    <h3>Game Settings</h3>
                    <div class="settings-list">
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.soundEnabled ? 'checked' : ''} 
                                       onchange="SettingsManager && SettingsManager.updateSetting && SettingsManager.updateSetting('soundEnabled', this.checked)">
                                Enable Sound Effects
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.animationsEnabled ? 'checked' : ''} 
                                       onchange="SettingsManager && SettingsManager.updateSetting && SettingsManager.updateSetting('animationsEnabled', this.checked)">
                                Enable Animations
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.gameInvites ? 'checked' : ''} 
                                       onchange="SettingsManager && SettingsManager.updateSetting && SettingsManager.updateSetting('gameInvites', this.checked)">
                                Allow Game Invitations
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-category">
                    <h3>Privacy Settings</h3>
                    <div class="settings-list">
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.hideBalance ? 'checked' : ''} 
                                       onchange="SettingsManager && SettingsManager.updateSetting && SettingsManager.updateSetting('hideBalance', this.checked)">
                                Hide Balance Display
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.chatNotifications ? 'checked' : ''} 
                                       onchange="SettingsManager && SettingsManager.updateSetting && SettingsManager.updateSetting('chatNotifications', this.checked)">
                                Chat Notifications
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-category">
                    <h3>Advanced Settings</h3>
                    <div class="settings-list">
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.developerMode ? 'checked' : ''} 
                                       onchange="SettingsManager && SettingsManager.updateSetting && SettingsManager.updateSetting('developerMode', this.checked)">
                                Developer Mode
                            </label>
                            <small>Enables advanced debugging features</small>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" ${settings.realTimeSync ? 'checked' : ''} 
                                       onchange="SettingsManager && SettingsManager.updateSetting && SettingsManager.updateSetting('realTimeSync', this.checked)">
                                Real-time Synchronization
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-actions">
                    <button class="btn btn-primary" onclick="SettingsManager && SettingsManager.saveSettings && SettingsManager.saveSettings()">
                        <i class="fas fa-save"></i> Save Settings
                    </button>
                    <button class="btn btn-secondary" onclick="SettingsManager && SettingsManager.resetSettings && SettingsManager.resetSettings()">
                        <i class="fas fa-undo"></i> Reset to Defaults
                    </button>
                </div>
            </div>
        `;
    }
}

// ===========================
// GLOBAL INSTANCES & EXPORTS
// ===========================

const GameManager = new GameManager();
const NavigationManager = new NavigationManager();

// Export to global scope
window.GameManager = GameManager;
window.NavigationManager = NavigationManager;
window.GameStateManager = new GameStateManager();

// FIX: Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    try {
        // Initialize game systems
        GameManager.initialize();
        NavigationManager.initialize();
        
        console.log('✅ Game Logic & UI Management (FIXED) initialized');
    } catch (error) {
        ErrorManager.logError(error, 'Game Logic & UI Management initialization');
    }
});

console.log('✅ Game Logic & UI Management (FIXED) Loaded');
    </script>
    <script>
      /* ===========================
   CROSSREALM GAMING PLATFORM
   PLATFORM INTEGRATION & FINAL MANAGERS (SECTION 6)
   =========================== */

'use strict';

// ===========================
// ENHANCED PLATFORM MANAGER (FIXED)
// ===========================

class PlatformManager {
    constructor() {
        this.initializationSteps = [
            { name: 'Security Systems', handler: () => this.initializeSecurity(), weight: 15 },
            { name: 'Age Verification', handler: () => this.showAgeVerification(), weight: 10 },
            { name: 'Anti-Bot Challenge', handler: () => this.showAntiBotChallenge(), weight: 15 },
            { name: 'Blockchain Connection', handler: () => this.initializeBlockchain(), weight: 20 },
            { name: 'UI Components', handler: () => this.initializeUI(), weight: 15 },
            { name: 'Game Systems', handler: () => this.initializeGameSystems(), weight: 15 },
            { name: 'Final Setup', handler: () => this.finalizeInitialization(), weight: 10 }
        ];
        
        this.currentStep = 0;
        this.totalWeight = this.initializationSteps.reduce((sum, step) => sum + step.weight, 0);
        this.currentProgress = 0;
        this.isInitialized = false;
        this.skipVerification = Config.get('BYPASS_VERIFICATION') || false;
    }
    
    async initializePlatform() {
        try {
            console.log('🚀 Starting CrossRealm Platform initialization...');
            
            // Check if already initialized
            if (this.isInitialized) {
                console.log('✅ Platform already initialized');
                return true;
            }
            
            // Update debug info
            this.updateDebugInfo('Starting platform initialization...');
            
            // Execute initialization steps
            for (let i = 0; i < this.initializationSteps.length; i++) {
                const step = this.initializationSteps[i];
                this.currentStep = i;
                
                try {
                    this.updateLoadingStatus(`${step.name}...`);
                    console.log(`📋 Step ${i + 1}/${this.initializationSteps.length}: ${step.name}`);
                    
                    await step.handler();
                    
                    this.currentProgress += step.weight;
                    this.updateLoadingProgress((this.currentProgress / this.totalWeight) * 100);
                    
                    // Small delay for visual feedback
                    await Utils.sleep(300);
                    
                } catch (error) {
                    ErrorManager.logError(error, `Platform initialization step: ${step.name}`);
                    
                    // Continue with next step for non-critical errors
                    if (!this.isCriticalStep(step.name)) {
                        console.warn(`⚠️ Non-critical step failed: ${step.name}, continuing...`);
                        continue;
                    } else {
                        throw error;
                    }
                }
            }
            
            this.isInitialized = true;
            this.hideLoa dingScreen();
            
            console.log('✅ CrossRealm Platform initialization complete!');
            return true;
            
        } catch (error) {
            ErrorManager.logError(error, 'Platform initialization');
            this.handleInitializationError(error);
            return false;
        }
    }
    
    async initializeSecurity() {
        // Security systems are already initialized in core.js
        this.updateDebugInfo('Security systems initialized');
        return true;
    }
    
    async showAgeVerification() {
        return new Promise((resolve) => {
            // Check if age verification should be skipped
            if (this.skipVerification || sessionStorage.getItem('ageVerified') === 'true') {
                StateManager.set('isAgeVerified', true);
                this.updateDebugInfo('Age verification: BYPASSED');
                resolve();
                return;
            }
            
            const modal = document.getElementById('ageVerificationModal');
            if (!modal) {
                console.warn('Age verification modal not found, skipping...');
                StateManager.set('isAgeVerified', true);
                resolve();
                return;
            }
            
            this.updateDebugInfo('Waiting for age verification...');
            
            modal.style.display = 'flex';
            
            // Setup event listeners
            const handleVerification = (event) => {
                if (event.target.dataset.action === 'verify-age') {
                    const isVerified = event.target.dataset.value === 'true';
                    
                    if (isVerified) {
                        sessionStorage.setItem('ageVerified', 'true');
                        StateManager.set('isAgeVerified', true);
                        modal.style.display = 'none';
                        this.updateDebugInfo('Age verification: PASSED');
                        resolve();
                    } else {
                        // User is under 18
                        alert('You must be 18 years or older to access this platform.');
                        window.location.href = 'about:blank';
                    }
                    
                    // Remove event listeners
                    modal.removeEventListener('click', handleVerification);
                }
            };
            
            modal.addEventListener('click', handleVerification);
        });
    }
    
    async showAntiBotChallenge() {
        return new Promise((resolve) => {
            // Check if anti-bot verification should be skipped
            if (this.skipVerification || sessionStorage.getItem('antiBotVerified') === 'true') {
                StateManager.set('isAntiBotVerified', true);
                this.updateDebugInfo('Anti-bot challenge: BYPASSED');
                resolve();
                return;
            }
            
            const modal = document.getElementById('antiBotModal');
            if (!modal) {
                console.warn('Anti-bot modal not found, skipping...');
                StateManager.set('isAntiBotVerified', true);
                resolve();
                return;
            }
            
            this.updateDebugInfo('Generating anti-bot challenge...');
            
            // Generate captcha challenge
            this.generateCaptchaChallenge();
            
            modal.style.display = 'flex';
            
            // Setup verification button
            const verifyBtn = document.getElementById('verifyCaptchaBtn');
            const refreshBtn = document.getElementById('refreshCaptchaBtn');
            
            const handleVerification = () => {
                if (this.verifyCaptchaAnswer()) {
                    sessionStorage.setItem('antiBotVerified', 'true');
                    StateManager.set('isAntiBotVerified', true);
                    modal.style.display = 'none';
                    this.updateDebugInfo('Anti-bot challenge: PASSED');
                    
                    // Remove event listeners
                    verifyBtn.removeEventListener('click', handleVerification);
                    refreshBtn.removeEventListener('click', refreshChallenge);
                    
                    resolve();
                } else {
                    NotificationManager.show(
                        'Verification Failed',
                        'Please try again and select all chess pieces.',
                        'error'
                    );
                    this.generateCaptchaChallenge();
                }
            };
            
            const refreshChallenge = () => {
                this.generateCaptchaChallenge();
            };
            
            verifyBtn.addEventListener('click', handleVerification);
            refreshBtn.addEventListener('click', refreshChallenge);
        });
    }
    
    generateCaptchaChallenge() {
        const grid = document.getElementById('captchaGrid');
        if (!grid) return;
        
        const pieces = ['♔', '♕', '♖', '♗', '♘', '♙', '🎮', '🎯', '🎲'];
        const chessPieces = ['♔', '♕', '♖', '♗', '♘', '♙'];
        
        grid.innerHTML = '';
        this.captchaAnswer = new Set();
        
        for (let i = 0; i < 9; i++) {
            const tile = document.createElement('div');
            tile.className = 'captcha-tile';
            tile.dataset.index = i;
            
            // Randomly place chess pieces (3-5 out of 9 tiles)
            const shouldHaveChessPiece = i < 5 && Math.random() > 0.3;
            
            if (shouldHaveChessPiece) {
                const piece = chessPieces[Math.floor(Math.random() * chessPieces.length)];
                tile.textContent = piece;
                this.captchaAnswer.add(i);
            } else {
                const piece = pieces[Math.floor(Math.random() * pieces.length)];
                tile.textContent = piece;
            }
            
            tile.addEventListener('click', () => {
                tile.classList.toggle('selected');
                this.updateCaptchaVerifyButton();
            });
            
            grid.appendChild(tile);
        }
        
        // Update verify button state
        this.updateCaptchaVerifyButton();
    }
    
    updateCaptchaVerifyButton() {
        const verifyBtn = document.getElementById('verifyCaptchaBtn');
        const selectedTiles = document.querySelectorAll('.captcha-tile.selected');
        
        if (verifyBtn) {
            verifyBtn.disabled = selectedTiles.length === 0;
        }
    }
    
    verifyCaptchaAnswer() {
        const selectedTiles = document.querySelectorAll('.captcha-tile.selected');
        const userAnswer = new Set();
        
        selectedTiles.forEach(tile => {
            userAnswer.add(parseInt(tile.dataset.index));
        });
        
        // Check if user selected exactly the chess pieces
        return this.setsEqual(userAnswer, this.captchaAnswer);
    }
    
    setsEqual(set1, set2) {
        return set1.size === set2.size && [...set1].every(x => set2.has(x));
    }
    
    async initializeBlockchain() {
        try {
            // Blockchain is already initialized in blockchain.js
            this.updateDebugInfo('Blockchain connection established');
            return true;
        } catch (error) {
            console.warn('Blockchain initialization failed, continuing in demo mode');
            this.updateDebugInfo('Blockchain: Demo mode active');
            return true;
        }
    }
    
    async initializeUI() {
        try {
            // Initialize all UI managers
            await Promise.all([
                LobbyManager.initialize(),
                StatsManager.initialize(),
                SettingsManager.initialize(),
                GameCreator.initialize()
            ]);
            
            this.updateDebugInfo('UI components initialized');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'UI initialization');
            this.updateDebugInfo('UI initialization: Some components failed');
            return true; // Non-critical
        }
    }
    
    async initializeGameSystems() {
        try {
            // Game systems are already initialized in gamelogic.js
            this.updateDebugInfo('Game systems ready');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'Game systems initialization');
            throw error; // This is critical
        }
    }
    
    async finalizeInitialization() {
        try {
            // Set final state
            StateManager.set('isPlatformInitialized', true);
            
            // Try auto-connect wallet
            if (window.WalletManager) {
                setTimeout(async () => {
                    try {
                        await WalletManager.autoConnect();
                    } catch (error) {
                        console.warn('Auto-connect failed:', error);
                    }
                }, 500);
            }
            
            // Load initial lobby data
            if (window.LobbyManager) {
                setTimeout(() => {
                    LobbyManager.loadGames();
                }, 1000);
            }
            
            // Show welcome notification
            setTimeout(() => {
                NotificationManager.show(
                    'Welcome to CrossRealm!',
                    'Platform initialized successfully. Ready to play!',
                    'success',
                    5000
                );
            }, 1500);
            
            this.updateDebugInfo('Platform ready!');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'Final initialization');
            return true; // Non-critical
        }
    }
    
    isCriticalStep(stepName) {
        const criticalSteps = ['Security Systems', 'Game Systems'];
        return criticalSteps.includes(stepName);
    }
    
    updateLoadingStatus(status) {
        const statusElement = document.getElementById('loadingStatus');
        if (statusElement) {
            statusElement.textContent = status;
        }
    }
    
    updateLoadingProgress(percentage) {
        const progressElement = document.getElementById('loadingProgress');
        if (progressElement) {
            progressElement.style.width = `${Math.min(percentage, 100)}%`;
        }
    }
    
    updateDebugInfo(info) {
        const debugElement = document.getElementById('debugInfo');
        if (debugElement) {
            debugElement.textContent = info;
        }
        
        if (Config.get('DEBUG_LOGGING')) {
            console.log(`🔍 Debug: ${info}`);
        }
    }
    
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
        
        // Clear initialization timer
        if (window.LifecycleManager) {
            LifecycleManager.clearInitializationTimer();
        }
    }
    
    handleInitializationError(error) {
        console.error('❌ Platform initialization failed:', error);
        
        this.updateLoadingStatus('Initialization failed');
        this.updateDebugInfo(`Error: ${error.message}`);
        
        // Show emergency bypass after error
        setTimeout(() => {
            const bypassBtn = document.getElementById('emergencyBypass');
            if (bypassBtn) {
                bypassBtn.style.display = 'block';
                bypassBtn.style.backgroundColor = '#e74c3c';
                bypassBtn.textContent = 'Emergency Start (Error Recovery)';
            }
        }, 2000);
    }
}

// ===========================
// ENHANCED LOBBY MANAGER
// ===========================

class LobbyManager {
    constructor() {
        this.games = new Map();
        this.filters = {
            gameType: 'all',
            skillLevel: 'all',
            stakeRange: 'all'
        };
        this.refreshInterval = null;
        this.isInitialized = false;
    }
    
    async initialize() {
        try {
            this.isInitialized = true;
            console.log('🏛️ Lobby Manager initialized');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'Lobby Manager initialization');
            return false;
        }
    }
    
    async loadGames() {
        try {
            console.log('🔄 Loading lobby games...');
            
            // Get games from API
            const response = await APIManager.getGames();
            
            // Update games map
            this.games.clear();
            if (response.games) {
                response.games.forEach(game => {
                    this.games.set(game.id, game);
                });
            }
            
            // Render games
            this.renderGames();
            
            // Update stats
            this.updateLobbyStats();
            
        } catch (error) {
            ErrorManager.logError(error, 'Loading lobby games');
            this.showLoadingError();
        }
    }
    
    renderGames() {
        const container = document.getElementById('lobbyGamesList');
        if (!container) return;
        
        const filteredGames = this.getFilteredGames();
        
        if (filteredGames.length === 0) {
            container.innerHTML = `
                <div class="no-games-found">
                    <i class="fas fa-search"></i>
                    <h3>No Games Found</h3>
                    <p>No games match your current filters. Try adjusting them or create a new game!</p>
                    <button class="btn btn-primary" onclick="NavigationManager.showSection('create')">
                        <i class="fas fa-plus"></i> Create Game
                    </button>
                </div>
            `;
            return;
        }
        
        const gamesHTML = filteredGames.map(game => this.renderGameCard(game)).join('');
        container.innerHTML = gamesHTML;
    }
    
    renderGameCard(game) {
        const gameTypeIcons = {
            chess: 'fas fa-chess',
            checkers: 'fas fa-circle',
            words: 'fas fa-font'
        };
        
        const skillColors = {
            bronze: '#CD7F32',
            silver: '#C0C0C0',
            gold: '#FFD700',
            diamond: '#B9F2FF'
        };
        
        return `
            <div class="game-card" data-game-id="${game.id}">
                <div class="game-card-header">
                    <div class="game-type">
                        <i class="${gameTypeIcons[game.gameType] || 'fas fa-gamepad'}"></i>
                        <span>${game.gameType.charAt(0).toUpperCase() + game.gameType.slice(1)}</span>
                    </div>
                    <div class="game-skill" style="color: ${skillColors[game.skillLevel] || '#888'}">
                        ${game.skillLevel ? game.skillLevel.charAt(0).toUpperCase() + game.skillLevel.slice(1) : 'Casual'}
                    </div>
                </div>
                
                <div class="game-card-body">
                    <div class="game-stake">
                        <span class="stake-amount">${game.stake}</span>
                        <span class="stake-label">CORE</span>
                    </div>
                    
                    <div class="game-info">
                        <div class="info-row">
                            <span class="info-label">Creator:</span>
                            <span class="info-value">${game.creator.substring(0, 8)}...</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Time Control:</span>
                            <span class="info-value">${game.timeControl || 10} min</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Created:</span>
                            <span class="info-value">${Utils.formatTimeAgo(game.createdAt)}</span>
                        </div>
                    </div>
                </div>
                
                <div class="game-card-footer">
                    <button class="btn btn-accent btn-block" 
                            onclick="LobbyManager.joinGame('${game.id}')"
                            ${this.canJoinGame(game) ? '' : 'disabled'}>
                        <i class="fas fa-play"></i> 
                        ${this.getJoinButtonText(game)}
                    </button>
                </div>
            </div>
        `;
    }
    
    canJoinGame(game) {
        const userAccount = StateManager.get('userAccount');
        const userBalance = StateManager.get('userBalance');
        
        // Check if user is logged in
        if (!userAccount) return false;
        
        // Check if user is not the creator
        if (game.creator.toLowerCase() === userAccount.toLowerCase()) return false;
        
        // Check if user has enough balance
        if (userBalance < game.stake) return false;
        
        return true;
    }
    
    getJoinButtonText(game) {
        const userAccount = StateManager.get('userAccount');
        const userBalance = StateManager.get('userBalance');
        
        if (!userAccount) return 'Connect Wallet';
        if (game.creator.toLowerCase() === userAccount.toLowerCase()) return 'Your Game';
        if (userBalance < game.stake) return 'Insufficient Balance';
        return 'Join Game';
    }
    
    async joinGame(gameId) {
        try {
            const game = this.games.get(gameId);
            if (!game) {
                throw new GameError('Game not found', 'GAME_NOT_FOUND');
            }
            
            if (!this.canJoinGame(game)) {
                throw new GameError('Cannot join this game', 'JOIN_NOT_ALLOWED');
            }
            
            console.log('🎯 Joining game:', gameId);
            
            // Show joining notification
            NotificationManager.show(
                'Joining Game',
                'Processing your request to join the game...',
                'info'
            );
            
            // Join game on blockchain
            let joinResult = null;
            if (StateManager.get('isWalletConnected')) {
                try {
                    joinResult = await BlockchainManager.joinGameOnChain(gameId, game.stake);
                } catch (error) {
                    if (error.code === 'USER_REJECTED') {
                        return; // User cancelled
                    }
                    throw error;
                }
            }
            
            // Create local game state
            const userAccount = StateManager.get('userAccount');
            const players = [game.creator, userAccount];
            
            const gameResult = await GameManager.createGame(game.gameType, game.stake, players);
            
            // Open game window
            GameManager.openGameWindow(game.gameType, gameResult.gameId);
            
            // Navigate to games section
            NavigationManager.showSection('games');
            
            // Show success notification
            NotificationManager.show(
                'Game Joined!',
                `Successfully joined ${game.gameType} game. Good luck!`,
                'success'
            );
            
            // Remove game from lobby (it's now active)
            this.games.delete(gameId);
            this.renderGames();
            
        } catch (error) {
            ErrorManager.logError(error, 'Joining game');
            
            let errorMessage = 'Failed to join game. Please try again.';
            if (error.code === 'INSUFFICIENT_FUNDS') {
                errorMessage = 'Insufficient CORE balance to join this game.';
            } else if (error.code === 'GAME_NOT_FOUND') {
                errorMessage = 'Game no longer available.';
            }
            
            NotificationManager.show('Join Failed', errorMessage, 'error');
        }
    }
    
    getFilteredGames() {
        let filtered = Array.from(this.games.values());
        
        // Apply game type filter
        if (this.filters.gameType !== 'all') {
            filtered = filtered.filter(game => game.gameType === this.filters.gameType);
        }
        
        // Apply skill level filter
        if (this.filters.skillLevel !== 'all') {
            filtered = filtered.filter(game => game.skillLevel === this.filters.skillLevel);
        }
        
        // Sort by creation time (newest first)
        filtered.sort((a, b) => b.createdAt - a.createdAt);
        
        return filtered;
    }
    
    applyFilters() {
        const gameTypeFilter = document.getElementById('gameTypeFilter');
        const skillFilter = document.getElementById('skillFilter');
        
        if (gameTypeFilter) {
            this.filters.gameType = gameTypeFilter.value;
        }
        
        if (skillFilter) {
            this.filters.skillLevel = skillFilter.value;
        }
        
        console.log('🔍 Applying filters:', this.filters);
        this.renderGames();
    }
    
    refreshLobby() {
        console.log('🔄 Refreshing lobby...');
        this.loadGames();
        
        NotificationManager.show(
            'Lobby Refreshed',
            'Game list has been updated',
            'info',
            2000
        );
    }
    
    updateLobbyStats() {
        // Update online players count
        const onlineElement = document.getElementById('onlinePlayersCount');
        if (onlineElement) {
            onlineElement.textContent = Utils.getRandomInt(15, 45);
        }
        
        // Update active games count
        const activeElement = document.getElementById('activeGamesCount');
        if (activeElement) {
            activeElement.textContent = this.games.size;
        }
        
        // Update volume
        const volumeElement = document.getElementById('totalVolumeCount');
        if (volumeElement) {
            const totalStake = Array.from(this.games.values())
                .reduce((sum, game) => sum + game.stake, 0);
            volumeElement.textContent = totalStake.toFixed(2);
        }
    }
    
    showLoadingError() {
        const container = document.getElementById('lobbyGamesList');
        if (container) {
            container.innerHTML = `
                <div class="loading-error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3>Failed to Load Games</h3>
                    <p>Unable to connect to game servers. Please check your connection and try again.</p>
                    <button class="btn btn-primary" onclick="LobbyManager.loadGames()">
                        <i class="fas fa-sync-alt"></i> Retry
                    </button>
                </div>
            `;
        }
    }
    
    startAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
        }
        
        this.refreshInterval = setInterval(() => {
            if (StateManager.get('currentSection') === 'lobby') {
                this.loadGames();
            }
        }, 30000); // Refresh every 30 seconds
    }
    
    stopAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    }
}

// ===========================
// ENHANCED GAME CREATOR
// ===========================

class GameCreator {
    constructor() {
        this.selectedGameType = null;
        this.isCreating = false;
        this.isInitialized = false;
    }
    
    async initialize() {
        try {
            this.setupEventListeners();
            this.isInitialized = true;
            console.log('🛠️ Game Creator initialized');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'Game Creator initialization');
            return false;
        }
    }
    
    setupEventListeners() {
        // Setup game type selection
        document.addEventListener('click', (event) => {
            if (event.target.closest('.game-type-btn')) {
                this.selectGameType(event.target.closest('.game-type-btn'));
            }
        });
        
        // Setup form validation
        document.addEventListener('input', (event) => {
            if (event.target.id === 'gameStake') {
                this.validateForm();
            }
        });
        
        document.addEventListener('change', (event) => {
            if (event.target.id === 'gameTimeControl') {
                this.validateForm();
            }
        });
    }
    
    selectGameType(button) {
        // Remove previous selection
        document.querySelectorAll('.game-type-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        
        // Select new game type
        button.classList.add('selected');
        this.selectedGameType = button.dataset.gameType;
        
        console.log('🎮 Selected game type:', this.selectedGameType);
        this.validateForm();
    }
    
    validateForm() {
        const stakeInput = document.getElementById('gameStake');
        const createBtn = document.getElementById('createGameBtn');
        
        if (!createBtn) return;
        
        let isValid = true;
        const errors = [];
        
        // Check if game type is selected
        if (!this.selectedGameType) {
            isValid = false;
            errors.push('Please select a game type');
        }
        
        // Validate stake amount
        if (stakeInput) {
            const stakeAmount = parseFloat(stakeInput.value);
            const validation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
            
            if (!validation.valid) {
                isValid = false;
                errors.push(validation.error);
            }
            
            // Check user balance
            const userBalance = StateManager.get('userBalance');
            if (stakeAmount > userBalance) {
                isValid = false;
                errors.push('Insufficient balance');
            }
        }
        
        // Check wallet connection
        if (!StateManager.get('isWalletConnected')) {
            isValid = false;
            errors.push('Please connect your wallet');
        }
        
        // Update button state
        createBtn.disabled = !isValid || this.isCreating;
        
        // Update button text
        if (this.isCreating) {
            createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating...';
        } else if (!isValid) {
            createBtn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${errors[0]}`;
        } else {
            createBtn.innerHTML = '<i class="fas fa-plus"></i> Create Game';
        }
    }
    
    async createGame() {
        if (this.isCreating) return;
        
        try {
            this.isCreating = true;
            this.validateForm();
            
            // Get form values
            const stakeInput = document.getElementById('gameStake');
            const timeControlSelect = document.getElementById('gameTimeControl');
            
            if (!stakeInput || !timeControlSelect || !this.selectedGameType) {
                throw new GameError('Invalid form data', 'INVALID_FORM');
            }
            
            const stakeAmount = parseFloat(stakeInput.value);
            const timeControl = timeControlSelect.value;
            
            console.log('🏗️ Creating game:', {
                gameType: this.selectedGameType,
                stake: stakeAmount,
                timeControl: timeControl
            });
            
            // Validate inputs
            const stakeValidation = SecurityManager.validateInput(stakeAmount, 'stake_amount');
            if (!stakeValidation.valid) {
                throw new GameError(stakeValidation.error, 'INVALID_STAKE');
            }
            
            // Check rate limiting
            if (!SecurityManager.checkRateLimit('game_creation', 5, 3600000)) {
                throw new GameError('Too many games created recently. Please wait.', 'RATE_LIMIT');
            }
            
            // Show creating notification
            NotificationManager.show(
                'Creating Game',
                'Setting up your game on the blockchain...',
                'info'
            );
            
            // Create game
            const userAccount = StateManager.get('userAccount');
            const players = [userAccount]; // Creator is first player
            
            const result = await GameManager.createGame(this.selectedGameType, stakeAmount, players);
            
            // Reset form
            this.resetForm();
            
            // Show success notification
            NotificationManager.show(
                'Game Created!',
                `Your ${this.selectedGameType} game has been created and is waiting for players.`,
                'success'
            );
            
            // Navigate to lobby to see the created game
            NavigationManager.showSection('lobby');
            
            // Refresh lobby
            if (window.LobbyManager) {
                setTimeout(() => {
                    LobbyManager.loadGames();
                }, 1000);
            }
            
        } catch (error) {
            ErrorManager.logError(error, 'Game creation');
            
            let errorMessage = 'Failed to create game. Please try again.';
            if (error.code === 'INSUFFICIENT_FUNDS') {
                errorMessage = 'Insufficient CORE balance to create this game.';
            } else if (error.code === 'USER_REJECTED') {
                errorMessage = 'Transaction was cancelled.';
            } else if (error.code === 'RATE_LIMIT') {
                errorMessage = error.message;
            }
            
            NotificationManager.show('Creation Failed', errorMessage, 'error');
            
        } finally {
            this.isCreating = false;
            this.validateForm();
        }
    }
    
    resetForm() {
        // Reset game type selection
        document.querySelectorAll('.game-type-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        this.selectedGameType = null;
        
        // Reset stake amount
        const stakeInput = document.getElementById('gameStake');
        if (stakeInput) {
            stakeInput.value = '0.1';
        }
        
        // Reset time control
        const timeControlSelect = document.getElementById('gameTimeControl');
        if (timeControlSelect) {
            timeControlSelect.value = 'rapid';
        }
        
        this.validateForm();
    }
}

// ===========================
// ENHANCED STATS MANAGER
// ===========================

class StatsManager {
    constructor() {
        this.isInitialized = false;
        this.updateInterval = null;
    }
    
    async initialize() {
        try {
            this.startStatsUpdates();
            this.isInitialized = true;
            console.log('📊 Stats Manager initialized');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'Stats Manager initialization');
            return false;
        }
    }
    
    updatePlayerStatsDisplay() {
        const container = document.getElementById('playerStatsDisplay');
        if (!container) return;
        
        const stats = StateManager.get('playerStats');
        const skillRatings = StateManager.get('skillRatings');
        
        container.innerHTML = `
            <div class="stat-card">
                <div class="stat-value">${stats.gamesPlayed}</div>
                <div class="stat-label">Games Played</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${stats.winRate.toFixed(1)}%</div>
                <div class="stat-label">Win Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${stats.totalEarned.toFixed(4)}</div>
                <div class="stat-label">CORE Earned</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${skillRatings.chess}</div>
                <div class="stat-label">Chess Rating</div>
            </div>
        `;
    }
    
    async updateServerStats() {
        try {
            const stats = await APIManager.getServerStats();
            
            // Update online players
            const onlineElement = document.getElementById('onlinePlayersCount');
            if (onlineElement && stats.onlinePlayers) {
                onlineElement.textContent = stats.onlinePlayers;
            }
            
            // Update active games
            const activeElement = document.getElementById('activeGamesCount');
            if (activeElement && stats.activeGames) {
                activeElement.textContent = stats.activeGames;
            }
            
            // Update volume
            const volumeElement = document.getElementById('totalVolumeCount');
            if (volumeElement && stats.totalVolume) {
                volumeElement.textContent = stats.totalVolume;
            }
            
            // Update last sync time
            const syncElement = document.getElementById('lastSync');
            if (syncElement) {
                syncElement.textContent = new Date().toLocaleTimeString();
            }
            
        } catch (error) {
            console.warn('Failed to update server stats:', error);
        }
    }
    
    startStatsUpdates() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        
        this.updateInterval = setInterval(() => {
            this.updateServerStats();
        }, 15000); // Update every 15 seconds
        
        // Initial update
        this.updateServerStats();
    }
    
    stopStatsUpdates() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }
}

// ===========================
// ENHANCED SETTINGS MANAGER
// ===========================

class SettingsManager {
    constructor() {
        this.isInitialized = false;
    }
    
    async initialize() {
        try {
            this.isInitialized = true;
            console.log('⚙️ Settings Manager initialized');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'Settings Manager initialization');
            return false;
        }
    }
    
    updateSetting(key, value) {
        try {
            StateManager.update('platformSettings', settings => {
                settings[key] = value;
                return settings;
            });
            
            // Apply setting immediately
            this.applySetting(key, value);
            
            console.log(`⚙️ Setting updated: ${key} = ${value}`);
            
        } catch (error) {
            ErrorManager.logError(error, 'Updating setting');
        }
    }
    
    applySetting(key, value) {
        switch (key) {
            case 'animationsEnabled':
                document.body.classList.toggle('no-animations', !value);
                break;
                
            case 'soundEnabled':
                // TODO: Implement sound system
                break;
                
            case 'hideBalance':
                if (window.WalletManager) {
                    const userAccount = StateManager.get('userAccount');
                    const balance = StateManager.get('userBalance');
                    WalletManager.updateWalletUI(
                        StateManager.get('isWalletConnected'),
                        userAccount,
                        balance
                    );
                }
                break;
                
            case 'developerMode':
                Config.set('DEV_MODE', value);
                if (value) {
                    console.log('🛠️ Developer mode enabled');
                    NotificationManager.show(
                        'Developer Mode',
                        'Developer mode enabled. Additional debugging features are now available.',
                        'info'
                    );
                }
                break;
        }
    }
    
    saveSettings() {
        try {
            if (window.WalletManager) {
                WalletManager.saveUserData();
            }
            
            NotificationManager.show(
                'Settings Saved',
                'Your settings have been saved successfully.',
                'success'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Saving settings');
            NotificationManager.show(
                'Save Failed',
                'Failed to save settings. Please try again.',
                'error'
            );
        }
    }
    
    resetSettings() {
        try {
            const defaultSettings = {
                autoJoin: false,
                soundEnabled: true,
                animationsEnabled: true,
                defaultStake: 0.1,
                gameInvites: true,
                txNotifications: true,
                chatNotifications: false,
                hideBalance: false,
                developerMode: false,
                realTimeSync: true
            };
            
            StateManager.set('platformSettings', defaultSettings);
            
            // Apply all settings
            Object.entries(defaultSettings).forEach(([key, value]) => {
                this.applySetting(key, value);
            });
            
            // Reload settings section if currently viewing
            if (StateManager.get('currentSection') === 'settings') {
                NavigationManager.showSection('settings');
            }
            
            NotificationManager.show(
                'Settings Reset',
                'All settings have been reset to defaults.',
                'info'
            );
            
        } catch (error) {
            ErrorManager.logError(error, 'Resetting settings');
        }
    }
}

// ===========================
// ENHANCED UI EVENT MANAGER
// ===========================

class UIEventManager {
    constructor() {
        this.isInitialized = false;
    }
    
    initialize() {
        try {
            this.setupGlobalEventListeners();
            this.setupCopyButtons();
            this.setupConnectionTesting();
            this.isInitialized = true;
            console.log('🎨 UI Event Manager initialized');
            return true;
        } catch (error) {
            ErrorManager.logError(error, 'UI Event Manager initialization');
            return false;
        }
    }
    
    setupGlobalEventListeners() {
        // Connect wallet button
        const connectBtn = document.getElementById('connectBtn');
        if (connectBtn) {
            connectBtn.addEventListener('click', async () => {
                try {
                    await WalletManager.connect();
                } catch (error) {
                    console.error('Connect button error:', error);
                }
            });
        }
        
        // Disconnect wallet button
        const disconnectBtn = document.getElementById('disconnectBtn');
        if (disconnectBtn) {
            disconnectBtn.addEventListener('click', async () => {
                try {
                    await WalletManager.disconnect();
                } catch (error) {
                    console.error('Disconnect button error:', error);
                }
            });
        }
        
        // Navigation items
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const section = item.dataset.section;
                if (section) {
                    NavigationManager.showSection(section);
                }
            });
        });
        
        // Footer links
        document.querySelectorAll('[data-action]').forEach(element => {
            element.addEventListener('click', (e) => {
                e.preventDefault();
                this.handleAction(element.dataset.action);
            });
        });
    }
    
    setupCopyButtons() {
        document.querySelectorAll('.btn-copy').forEach(button => {
            button.addEventListener('click', async (e) => {
                e.preventDefault();
                
                const target = button.dataset.copyTarget;
                let textToCopy = '';
                
                if (target === 'contract-address') {
                    textToCopy = Config.get('CONTRACT_ADDRESS');
                } else {
                    const targetElement = document.getElementById(target);
                    if (targetElement) {
                        textToCopy = targetElement.textContent || targetElement.value;
                    }
                }
                
                if (textToCopy) {
                    try {
                        await Utils.copyToClipboard(textToCopy);
                        
                        // Visual feedback
                        const originalIcon = button.innerHTML;
                        button.innerHTML = '<i class="fas fa-check"></i>';
                        setTimeout(() => {
                            button.innerHTML = originalIcon;
                        }, 1000);
                        
                        NotificationManager.show(
                            'Copied!',
                            'Address copied to clipboard',
                            'success',
                            2000
                        );
                    } catch (error) {
                        NotificationManager.show(
                            'Copy Failed',
                            'Failed to copy to clipboard',
                            'error'
                        );
                    }
                }
            });
        });
    }
    
    setupConnectionTesting() {
        const testBtn = document.getElementById('testConnectionBtn');
        if (testBtn) {
            testBtn.addEventListener('click', async () => {
                try {
                    testBtn.disabled = true;
                    testBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
                    
                    const startTime = performance.now();
                    
                    // Test API connection
                    await APIManager.getServerStats();
                    
                    const endTime = performance.now();
                    const latency = Math.round(endTime - startTime);
                    
                    // Update latency display
                    const latencyElement = document.getElementById('serverLatency');
                    if (latencyElement) {
                        latencyElement.textContent = `${latency}ms`;
                    }
                    
                    // Update server status
                    const serverStatus = document.getElementById('serverStatus');
                    if (serverStatus) {
                        serverStatus.innerHTML = `
                            <span class="status-indicator online"></span>
                            <span>Connected</span>
                        `;
                    }
                    
                    const statusText = document.getElementById('serverStatusText');
                    if (statusText) {
                        statusText.textContent = 'Online';
                    }
                    
                    NotificationManager.show(
                        'Connection Test',
                        `Server responding in ${latency}ms`,
                        'success'
                    );
                    
                } catch (error) {
                    // Update server status to offline
                    const serverStatus = document.getElementById('serverStatus');
                    if (serverStatus) {
                        serverStatus.innerHTML = `
                            <span class="status-indicator offline"></span>
                            <span>Disconnected</span>
                        `;
                    }
                    
                    NotificationManager.show(
                        'Connection Failed',
                        'Unable to connect to server',
                        'error'
                    );
                    
                } finally {
                    testBtn.disabled = false;
                    testBtn.innerHTML = '<i class="fas fa-wifi"></i> Test Connection';
                }
            });
        }
    }
    
    handleAction(action) {
        switch (action) {
            case 'show-contract':
                window.open(`${Config.get('CORE_EXPLORER_URL')}/address/${Config.get('CONTRACT_ADDRESS')}`, '_blank');
                break;
                
            case 'show-help':
                NotificationManager.show(
                    'Help Center',
                    'Help documentation is coming soon!',
                    'info'
                );
                break;
                
            case 'show-terms':
                NotificationManager.show(
                    'Terms of Service',
                    'Terms of Service will be available soon.',
                    'info'
                );
                break;
                
            case 'show-privacy':
                NotificationManager.show(
                    'Privacy Policy',
                    'Privacy Policy will be available soon.',
                    'info'
                );
                break;
                
            case 'show-fairplay':
                NotificationManager.show(
                    'Fair Play',
                    'All games use provably fair algorithms verified on the blockchain.',
                    'info'
                );
                break;
                
            default:
                console.warn('Unknown action:', action);
        }
    }
}

// ===========================
// GLOBAL INSTANCES & INITIALIZATION
// ===========================

// Create global instances
const PlatformManager = new PlatformManager();
const LobbyManager = new LobbyManager();
const GameCreator = new GameCreator();
const StatsManager = new StatsManager();
const SettingsManager = new SettingsManager();
const UIEventManager = new UIEventManager();

// Export to global scope
window.PlatformManager = PlatformManager;
window.LobbyManager = LobbyManager;
window.GameCreator = GameCreator;
window.StatsManager = StatsManager;
window.SettingsManager = SettingsManager;
window.UIEventManager = UIEventManager;

// ===========================
// PLATFORM STARTUP SEQUENCE
// ===========================

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('🚀 Starting CrossRealm Gaming Platform...');
        
        // Initialize UI Event Manager first
        UIEventManager.initialize();
        
        // Add small delay to ensure all CSS is loaded
        await Utils.sleep(500);
        
        // Start platform initialization
        await PlatformManager.initializePlatform();
        
        console.log('✅ CrossRealm Gaming Platform startup complete!');
        
    } catch (error) {
        ErrorManager.logError(error, 'Platform startup');
        console.error('❌ Platform startup failed:', error);
    }
});

// Cleanup on page unload
LifecycleManager.addCleanupTask(() => {
    console.log('🧹 Cleaning up platform managers...');
    
    // Stop auto-refresh timers
    if (LobbyManager.refreshInterval) {
        LobbyManager.stopAutoRefresh();
    }
    
    if (StatsManager.updateInterval) {
        StatsManager.stopStatsUpdates();
    }
    
    // Save any pending user data
    if (window.WalletManager) {
        WalletManager.saveUserData();
    }
});

// Subscribe to state changes for auto-refresh
StateManager.subscribe('currentSection', (newSection) => {
    if (newSection === 'lobby') {
        LobbyManager.startAutoRefresh();
    } else {
        LobbyManager.stopAutoRefresh();
    }
});

console.log('✅ Platform Integration & Final Managers (Section 6) Loaded');
    </script>
</body>
</html>
