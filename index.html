<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrossRealm Gaming Ecosystem - Live Blockchain Gaming Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #4e54c8;
            --primary-dark: #363a9e;
            --secondary: #f39c12;
            --dark: #1a1c2c;
            --light: #f5f7fa;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f1c40f;
            --gray: #95a5a6;
            --accent: #4ecdc4;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            --gradient-danger: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        html, body {
            height: 100%;
            overflow-x: hidden;
        }

        body {
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            color: var(--light);
            position: relative;
        }

        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://images.unsplash.com/photo-1620336655052-b57986f5a26a?q=80&w=1920') no-repeat center center;
            background-size: cover;
            opacity: 0.1;
            z-index: -1;
        }

        .hidden {
            display: none !important;
        }

        /* Fix click issues - ensure proper z-index and pointer events */
        button, .clickable, .nav-item, .game-btn, .verify-btn, .connect-btn, .disconnect-btn,
        .game-type-card, .stake-preset, .control-btn, .filter-btn, .tournament-btn,
        .settlement-btn, .empty-action-btn, .create-btn, .tab-btn {
            cursor: pointer;
            pointer-events: auto;
            position: relative;
            z-index: 10;
            user-select: none;
            border: none;
            outline: none;
            transition: all 0.3s ease;
        }

        button:disabled {
            cursor: not-allowed !important;
            opacity: 0.6;
            pointer-events: none;
        }

        button:focus, .nav-item:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* Animation System */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px var(--accent); }
            50% { box-shadow: 0 0 20px var(--accent), 0 0 30px var(--accent); }
        }

        /* Connection Status Indicators */
        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .connected {
            background: #00ff88;
            animation: pulse 2s infinite;
        }

        .disconnected {
            background: #ff6b6b;
        }

        .pending {
            background: #f1c40f;
            animation: blink 1s infinite;
        }

        .error {
            background: #e74c3c;
            animation: shake 0.5s infinite;
        }

        /* Header Styles */
        .header {
            position: relative;
            z-index: 100;
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-height: 80px;
            box-shadow: var(--shadow);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.8rem;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
        }

        .logo-icon {
            font-size: 2.5rem;
            color: var(--secondary);
            animation: spin 10s linear infinite;
        }

        .nav-menu {
            display: flex;
            gap: 1rem;
            align-items: center;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            flex-wrap: wrap;
        }

        .nav-menu::-webkit-scrollbar {
            display: none;
        }

        .nav-item {
            padding: 0.5rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            white-space: nowrap;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .nav-item:hover::before {
            left: 100%;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(78, 205, 196, 0.5);
            transform: translateY(-2px);
        }

        .nav-item.active {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .live-badge {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        /* Enhanced Player Progress Display */
        .player-progress {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-left: 1rem;
        }

        .progress-info {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #4ecdc4;
        }

        .xp-bar {
            width: 100px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            transition: width 0.5s ease;
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .wallet-info {
            text-align: right;
        }

        .connection-status {
            font-size: 0.9rem;
            color: #ff6b6b;
            font-weight: 500;
            display: flex;
            align-items: center;
        }

        .balance {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .connect-btn, .disconnect-btn {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 44px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .disconnect-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            margin-left: 0.5rem;
        }

        .connect-btn:hover, .disconnect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
        }

        /* Main Layout */
        .main-container {
            display: flex;
            min-height: calc(100vh - 80px);
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
            scrollbar-width: thin;
            scrollbar-color: var(--accent) transparent;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        .content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
            scrollbar-width: thin;
            scrollbar-color: var(--accent) transparent;
        }

        .content-area::-webkit-scrollbar {
            width: 6px;
        }

        .content-area::-webkit-scrollbar-track {
            background: transparent;
        }

        .content-area::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        /* Enhanced Mobile Responsiveness */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.5rem;
            }

            .nav-menu {
                order: 3;
                width: 100%;
                justify-content: flex-start;
                gap: 0.5rem;
                padding: 0.5rem 0;
            }

            .nav-item {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }

            .wallet-section {
                order: 2;
                width: 100%;
                justify-content: space-between;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                order: 2;
                padding: 1rem;
                max-height: none;
            }

            .content-area {
                order: 1;
                padding: 1rem;
                max-height: none;
            }

            .player-progress {
                margin-left: 0;
                margin-top: 0.5rem;
            }
        }

        /* Accessibility Enhancements */
        .keyboard-navigation .nav-item:focus,
        .keyboard-navigation .connect-btn:focus,
        .keyboard-navigation .verify-btn:focus,
        .keyboard-navigation button:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High Contrast Mode Support */
        @media (prefers-contrast: high) {
            :root {
                --accent: #00ffff;
                --secondary: #ffff00;
                --primary: #ffffff;
            }
        }

        /* Ensure proper stacking context */
        .modal, .age-verification, .transaction-status, .settlement-modal, 
        .tournament-modal, .anti-bot-challenge, .analysis-modal {
            z-index: 10000;
        }

        .game-overlay {
            z-index: 5000;
        }

        .game-window {
            z-index: 6000;
        }

        .header {
            z-index: 100;
        }

        .main-container {
            z-index: 1;
        }
      
        /* Modal Styles */
        .age-verification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.5s ease;
        }

        .verification-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: var(--shadow);
            border: 2px solid var(--primary);
            position: relative;
            z-index: 10000;
            animation: slideIn 0.5s ease;
        }

        .verification-content h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: var(--secondary);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .verification-content p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: var(--light);
        }

        .verification-content .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid var(--danger);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            text-align: left;
            backdrop-filter: blur(5px);
        }

        .verification-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .verify-btn {
            padding: 1rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-width: 120px;
            position: relative;
            overflow: hidden;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .verify-btn.accept {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .verify-btn.decline {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .verify-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Anti-Bot Protection */
        .anti-bot-challenge {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 2rem;
            z-index: 10000;
            text-align: center;
            max-width: 400px;
            width: 90%;
            animation: fadeIn 0.3s ease;
        }

        .anti-bot-content {
            color: white;
        }

        .captcha-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .captcha-tile {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 60px;
        }

        .captcha-tile:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .captcha-tile.selected {
            background: rgba(78, 205, 196, 0.4);
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
        }

        /* Transaction Status */
        .transaction-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--accent);
            border-radius: 10px;
            padding: 1rem;
            max-width: 350px;
            z-index: 2000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            word-wrap: break-word;
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
        }

        .transaction-status.show {
            transform: translateX(0);
            animation: slideIn 0.3s ease;
        }

        .tx-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .tx-close {
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 20px;
        }

        .tx-close:hover {
            color: white;
        }

        .tx-hash {
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            color: var(--accent);
            margin-top: 0.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .tx-hash:hover {
            color: #44a08d;
        }

        .tx-progress {
            margin-top: 0.5rem;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ff88);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Settlement Modal */
        .settlement-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.5s ease;
        }

        .settlement-content {
            background: var(--dark);
            border-radius: 20px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: var(--shadow);
            border: 2px solid var(--accent);
            animation: bounce 0.6s ease;
        }

        .settlement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settlement-header h2 {
            color: var(--accent);
            font-size: 1.5rem;
            margin: 0;
        }

        .settlement-close {
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.5rem;
            padding: 0;
            transition: color 0.3s ease;
            min-height: 30px;
            min-width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settlement-close:hover {
            color: white;
        }

        .settlement-result {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .settlement-breakdown {
            margin-bottom: 1.5rem;
            text-align: left;
            font-size: 0.9rem;
            color: #aaa;
        }

        .settlement-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .settlement-btn {
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-width: 150px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .settlement-btn.primary {
            background: var(--gradient-success);
            color: white;
        }

        .settlement-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        .settlement-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Game Window Styles */
        .game-window {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 1200px;
            height: 80vh;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--accent);
            border-radius: 15px;
            backdrop-filter: blur(15px);
            z-index: 6000;
            animation: fadeIn 0.5s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .game-window.minimized {
            height: 60px;
            overflow: hidden;
        }

        .game-window.minimized .game-window-content {
            display: none;
        }

        .game-window-header {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .game-window-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .skill-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .skill-bronze {
            background: #cd7f32;
            color: white;
        }

        .skill-silver {
            background: #c0c0c0;
            color: black;
        }

        .skill-gold {
            background: #ffd700;
            color: black;
        }

        .skill-diamond {
            background: linear-gradient(45deg, #b9f2ff, #9ee5ff);
            color: black;
        }

        .validation-status {
            color: #00ff88;
            font-size: 0.8rem;
        }

        .sync-status {
            font-size: 0.8rem;
            animation: spin 2s linear infinite;
        }

        .game-window-controls {
            display: flex;
            gap: 0.5rem;
        }

        .window-btn {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .minimize-btn {
            background: #f1c40f;
            color: black;
        }

        .close-btn {
            background: #e74c3c;
            color: white;
        }

        .window-btn:hover {
            transform: scale(1.1);
        }

        .game-window-content {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .game-info-bar {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            flex-shrink: 0;
        }

        <style>
        .player-info,
        .opponent-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-avatar {
            font-size: 2rem;
            color: var(--accent);
        }

        .player-details {
            flex: 1;
        }

        .timer {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--warning);
            font-family: monospace;
        }

        .move-indicator {
            font-size: 1rem;
            color: var(--accent);
        }

        .game-status-center {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 0.5rem;
        }

        .game-status {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent);
        }

        .move-history {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            padding: 0.5rem;
        }

        .move-list {
            font-family: monospace;
            font-size: 0.8rem;
            color: #aaa;
        }

        /* Chess Board Styles */
        .chess-board-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .chess-coordinates-top,
        .chess-coordinates-bottom {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            width: 100%;
            max-width: 480px;
            text-align: center;
            font-size: 0.8rem;
            color: #aaa;
        }

        .chess-board-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .chess-coordinates-left,
        .chess-coordinates-right {
            display: flex;
            flex-direction: column;
            gap: 2px;
            height: 480px;
            justify-content: space-around;
            font-size: 0.8rem;
            color: #aaa;
            text-align: center;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 480px;
            height: 480px;
            border: 2px solid var(--accent);
            border-radius: 5px;
            overflow: hidden;
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .chess-square.white {
            background: #f0d9b5;
            color: #8b4513;
        }

        .chess-square.black {
            background: #b58863;
            color: #f0d9b5;
        }

        .chess-square:hover {
            box-shadow: inset 0 0 0 3px var(--accent);
        }

        .chess-square.selected {
            box-shadow: inset 0 0 0 3px #ffd700;
        }

        .chess-square.last-move {
            box-shadow: inset 0 0 0 3px #ff6b6b;
        }

        .chess-square.legal-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
        }

        .chess-square.capture-move::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border: 3px solid rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            background: transparent;
        }

        .chess-square.check {
            background: rgba(255, 0, 0, 0.3) !important;
            animation: pulse 1s infinite;
        }

        /* Checkers Board Styles */
        .checkers-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 480px;
            height: 480px;
            border: 2px solid var(--accent);
            border-radius: 5px;
            margin: 0 auto;
            overflow: hidden;
        }

        .checkers-square {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .checkers-square.light {
            background: #f0d9b5;
        }

        .checkers-square.dark {
            background: #b58863;
        }

        .checkers-square:hover {
            box-shadow: inset 0 0 0 3px var(--accent);
        }

        .checkers-square.selected {
            box-shadow: inset 0 0 0 3px #ffd700;
        }

        .checkers-square.legal-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
        }

        .checker-piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            border: 2px solid #333;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .checker-piece.red-piece {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #dc3545);
        }

        .checker-piece.black-piece {
            background: radial-gradient(circle at 30% 30%, #6c757d, #343a40);
        }

        .checker-piece.king::after {
            content: '♔';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: gold;
            font-size: 1.2rem;
        }

        .checker-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        /* Word Game Styles */
        .word-game {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .word-prompt {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 10px;
        }

        .word-prompt h4 {
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .available-letters {
            font-size: 2rem;
            font-weight: bold;
            letter-spacing: 0.2rem;
            color: var(--secondary);
            font-family: monospace;
        }

        .word-input-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .word-input {
            width: 100%;
            padding: 1rem;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1.2rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
        }

        .word-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
        }

        .word-validation {
            text-align: center;
            min-height: 1.5rem;
            font-weight: bold;
        }

        .word-validation.valid {
            color: var(--success);
        }

        .word-validation.invalid {
            color: var(--danger);
        }

        .word-scoring {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 10px;
        }

        .scoring-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-breakdown {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #aaa;
        }

        .total-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .submitted-words {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 10px;
        }

        .submitted-words h5 {
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .words-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .word-chip {
            background: var(--accent);
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .round-indicator {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .round-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .round-dot.active {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
        }

        .round-dot.completed {
            background: var(--success);
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            flex-shrink: 0;
        }

        .game-controls .game-btn {
            padding: 0.8rem 1.5rem;
            border-radius: 20px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 44px;
        }

        .game-controls .game-btn.primary {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .game-controls .game-btn.secondary {
            background: linear-gradient(45deg, var(--secondary), #e67e22);
            color: white;
        }

        .game-controls .game-btn.neutral {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .game-controls .game-btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .game-controls .game-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Game Chat */
        .game-chat {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1rem;
            flex-shrink: 0;
            max-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .game-chat h4 {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .game-chat-messages {
            flex: 1;
            overflow-y: auto;
            max-height: 120px;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            scrollbar-width: thin;
        }

        .game-chat-message {
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .game-chat-message.system {
            color: #ffd700;
            font-style: italic;
        }

        .game-chat-input {
            display: flex;
            gap: 0.5rem;
        }

        .game-chat-input input {
            flex: 1;
            padding: 0.5rem;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 0.9rem;
        }

        .game-chat-input input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .game-chat-input button {
            padding: 0.5rem;
            border: none;
            border-radius: 5px;
            background: var(--accent);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-chat-input button:hover {
            background: #44a08d;
        }

        /* Notification Styles */
        .level-up-notification, .xp-notification, .achievement-notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            padding: 1rem;
            z-index: 9999;
            animation: slideIn 0.5s ease;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        .achievement-notification {
            border-color: #f39c12;
        }

        .xp-notification {
            border-color: #4ecdc4;
        }

        /* Mobile Responsiveness for Game Windows */
        @media (max-width: 768px) {
            .game-window {
                width: 95%;
                height: 90vh;
                top: 5%;
            }

            .game-info-bar {
                grid-template-columns: 1fr;
                gap: 0.5rem;
                text-align: center;
            }

            .player-info,
            .opponent-info {
                justify-content: center;
            }

            .chess-board,
            .checkers-board {
                width: 300px;
                height: 300px;
            }

            .chess-coordinates-left,
            .chess-coordinates-right {
                height: 300px;
            }

            .chess-coordinates-top,
            .chess-coordinates-bottom {
                max-width: 300px;
            }

            .chess-square {
                font-size: 1.5rem;
            }

            .available-letters {
                font-size: 1.5rem;
                letter-spacing: 0.1rem;
            }

            .game-controls {
                flex-direction: column;
                align-items: center;
            }

            .game-controls .game-btn {
                width: 100%;
                max-width: 200px;
                justify-content: center;
            }

            .game-window-header {
                padding: 0.5rem;
            }

            .game-window-title {
                font-size: 1rem;
            }

            .skill-badge {
                font-size: 0.6rem;
            }
        }

        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            .chess-square,
            .checkers-square,
            .checker-piece,
            .game-btn,
            .window-btn {
                transition: none;
            }

            .sync-status {
                animation: none;
            }
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            .chess-square.white {
                background: #ffffff;
                color: #000000;
            }

            .chess-square.black {
                background: #000000;
                color: #ffffff;
            }

            .checkers-square.light {
                background: #ffffff;
            }

            .checkers-square.dark {
                background: #000000;
            }
        }

        /* Focus indicators for accessibility */
        .chess-square:focus,
        .checkers-square:focus,
        .word-input:focus,
        .game-btn:focus,
        .window-btn:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* Ensure all interactive elements have proper touch targets */
        @media (max-width: 768px) {
            .verify-btn,
            .settlement-btn,
            .tab-btn,
            .tx-close,
            .settlement-close,
            .analysis-close,
            .captcha-tile {
                min-height: 44px;
                min-width: 44px;
            }
        }
      
        /* Sidebar Styles */
        .contract-status {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .contract-status h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .contract-address {
            font-family: monospace;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            border-radius: 5px;
            margin-bottom: 1rem;
            word-break: break-all;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .copy-btn {
            background: none;
            border: none;
            color: var(--accent);
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 3px;
            transition: all 0.3s ease;
            min-width: 24px;
            min-height: 24px;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            background: rgba(78, 205, 196, 0.2);
        }

        .contract-verification {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .verification-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .verification-item i.verified {
            color: var(--success);
        }

        .verification-item i.security {
            color: var(--warning);
        }

        .verification-item i.stats {
            color: var(--accent);
        }

        .live-lobby {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .live-lobby h2, .live-lobby h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .lobby-stats {
            display: grid;
            gap: 1rem;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .stat-icon {
            font-size: 1.5rem;
            color: var(--accent);
            width: 40px;
            text-align: center;
        }

        .stat-details {
            flex: 1;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
            line-height: 1;
        }

        .stat-label {
            color: #aaa;
            font-size: 0.8rem;
            margin-top: 0.2rem;
        }

        .activity-feed {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }

        .activity-item {
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.4;
            border-left: 3px solid var(--accent);
            transition: all 0.3s ease;
        }

        .activity-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .activity-refresh {
            width: 100%;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .activity-refresh:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
        }

        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .leaderboard-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .leaderboard-item.gold {
            border-left: 4px solid #ffd700;
        }

        .leaderboard-item.silver {
            border-left: 4px solid #c0c0c0;
        }

        .leaderboard-item.bronze {
            border-left: 4px solid #cd7f32;
        }

        .rank {
            font-size: 1.5rem;
            width: 40px;
            text-align: center;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: bold;
            color: var(--light);
        }

        .player-games {
            font-size: 0.8rem;
            color: #aaa;
        }

        .player-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .leaderboard-view-all {
            width: 100%;
            padding: 0.8rem;
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .leaderboard-view-all:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .server-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .server-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .server-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .server-item.online {
            border-left: 3px solid var(--success);
        }

        .server-item.offline {
            border-left: 3px solid var(--danger);
        }

        .server-icon {
            color: var(--accent);
            font-size: 1.2rem;
            width: 24px;
            text-align: center;
        }

        .server-info {
            flex: 1;
        }

        .server-status {
            font-weight: bold;
            color: var(--light);
            font-size: 0.9rem;
        }

        .server-label {
            font-size: 0.7rem;
            color: #aaa;
        }

        .network-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .network-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            font-size: 0.8rem;
        }

        .network-label {
            color: #aaa;
        }

        .network-value {
            color: var(--accent);
            font-weight: bold;
            font-family: monospace;
        }

        /* Content Area Styles */
        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .lobby-header h2 {
            margin: 0;
        }

        .lobby-controls {
            display: flex;
            gap: 0.5rem;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.5rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
        }

        .control-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }

        .games-list {
            display: grid;
            gap: 1rem;
        }

        .game-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .game-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
      
        .game-type {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .game-stake {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--secondary);
        }

        .game-info {
            color: #aaa;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .game-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .game-btn {
            padding: 0.6rem 1.2rem;
            border-radius: 20px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 40px;
        }

        .game-btn.primary {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .game-btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .game-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        .game-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Create Game Section */
        .create-game-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .create-game-section h2 {
            color: var(--accent);
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .game-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .game-type-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .game-type-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .game-type-card:hover::before {
            left: 100%;
        }

        .game-type-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }

        .game-type-card.selected {
            border-color: var(--accent);
            background: rgba(78, 205, 196, 0.1);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        .game-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .game-type-card h3 {
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .game-type-card p {
            color: #aaa;
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        .game-features {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .feature-tag {
            background: rgba(78, 205, 196, 0.2);
            color: var(--accent);
            padding: 0.3rem 0.7rem;
            border-radius: 15px;
            font-size: 0.7rem;
            font-weight: bold;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .popularity-indicator {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            align-items: center;
        }

        .popularity-bar {
            height: 4px;
            background: var(--accent);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .popularity-text {
            font-size: 0.7rem;
            color: #aaa;
        }

        .stake-section {
            margin: 2rem 0;
        }

        .stake-section label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: var(--light);
        }

        .stake-input {
            width: 100%;
            padding: 1rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .stake-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
        }

        .stake-presets {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .stake-preset {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 0.3rem 0.6rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            min-height: 32px;
        }

        .stake-preset:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
        }

        .create-btn {
            width: 100%;
            padding: 1rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            margin-top: 2rem;
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .create-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .create-btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
        }

        /* Games Showcase */
        .games-showcase {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
        }

        .game-showcase-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .game-showcase-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }

        .showcase-header {
            text-align: center;
            margin-bottom: 1rem;
        }

        .showcase-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .showcase-header h3 {
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .showcase-rating {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .stars {
            color: #ffd700;
            font-size: 0.9rem;
        }

        .showcase-rating span {
            font-size: 0.8rem;
            color: #aaa;
        }

        .game-showcase-card p {
            margin-bottom: 1rem;
            color: #ccc;
            line-height: 1.5;
            text-align: center;
        }

        .showcase-features {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .feature-pill {
            background: rgba(78, 205, 196, 0.2);
            color: var(--accent);
            padding: 0.3rem 0.7rem;
            border-radius: 15px;
            font-size: 0.7rem;
            font-weight: bold;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .showcase-btn {
            width: 100%;
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-height: 44px;
        }

        .showcase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        /* Tournament Styles */
        .tournament-filters {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.05);
            color: #aaa;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            min-height: 36px;
        }

        .filter-btn:hover {
            border-color: var(--accent);
            color: white;
        }

        .filter-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .tournaments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .tournament-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .tournament-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }

        .tournament-card.live-tournament {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.2);
        }

        .tournament-card.upcoming-tournament {
            border-color: var(--warning);
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.2);
        }

        .tournament-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .tournament-type {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent);
        }

        .tournament-status {
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .tournament-status.live {
            background: var(--success);
            color: white;
            animation: pulse 2s infinite;
        }

        .tournament-status.upcoming {
            background: var(--warning);
            color: black;
        }

        .tournament-info {
            display: grid;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tournament-detail {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: #aaa;
        }

        .tournament-detail i {
            color: var(--accent);
            width: 16px;
            text-align: center;
        }

        .tournament-progress {
            margin-bottom: 1rem;
        }

        .progress-text {
            font-size: 0.8rem;
            color: #aaa;
            text-align: center;
            margin-top: 0.5rem;
        }

        .tournament-actions {
            display: flex;
            gap: 0.5rem;
        }

        .tournament-btn {
            flex: 1;
            padding: 0.8rem;
            border-radius: 8px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-height: 40px;
        }

        .tournament-btn.primary {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .tournament-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        .tournament-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Profile Styles */
        .profile-content {
            display: grid;
            gap: 2rem;
        }

        .profile-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 2rem;
            border-radius: 15px;
        }

        .profile-avatar {
            font-size: 4rem;
            color: var(--accent);
        }

        .profile-info {
            flex: 1;
        }

        .profile-name {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .profile-level {
            font-size: 1.2rem;
            color: #f39c12;
            margin-bottom: 0.5rem;
        }

        .profile-xp {
            font-size: 1rem;
            color: #aaa;
        }

        .profile-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }

        .stat-card .stat-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .stat-card .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .stat-card .stat-label {
            color: #aaa;
            font-size: 0.9rem;
        }

        .achievements-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 2rem;
            border-radius: 15px;
        }

        .achievements-section h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .achievement-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .achievement-card.unlocked {
            border-color: var(--accent);
            background: rgba(78, 205, 196, 0.1);
        }

        .achievement-card:hover {
            transform: translateY(-2px);
        }

        .achievement-icon {
            font-size: 2rem;
            width: 60px;
            text-align: center;
        }

        .achievement-info {
            flex: 1;
        }

        .achievement-info h4 {
            color: var(--accent);
            margin-bottom: 0.3rem;
        }

        .achievement-info p {
            color: #aaa;
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
        }

        .achievement-status {
            font-size: 0.7rem;
            font-weight: bold;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #aaa;
        }

        .empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .empty-state p {
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .empty-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .empty-action-btn {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 44px;
        }

        .empty-action-btn.primary {
            background: var(--gradient-primary);
        }

        .empty-action-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--accent);
        }

        .empty-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="background"></div>  
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <i class="fas fa-dice-d20 logo-icon"></i>
            <h1>CROSSREALM</h1>
        </div>
        <div class="nav-menu" id="navMenu">
            <div class="nav-item active" tabindex="0" role="button" aria-label="Game Lobby">🎯 Game Lobby</div>
            <div class="nav-item" tabindex="0" role="button" aria-label="My Games">🎮 My Games</div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Create Game">➕ Create Game</div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Games">♟️ Games</div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Tournaments">🏆 Tournaments</div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Profile">👤 Profile</div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Chat">💬 Chat</div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Settings">⚙️ Settings</div>
        </div>
        <div class="live-badge">🔴 LIVE ON CORE</div>
        
        <!-- Enhanced Player Progress Display -->
        <div class="player-progress">
            <div class="progress-info">
                <div id="playerLevel">Level 1</div>
                <div id="playerXP">0 XP</div>
            </div>
            <div class="xp-bar">
                <div class="xp-fill" id="xpBar" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">
                    <span class="connection-indicator disconnected"></span>Not Connected
                </div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn" aria-label="Connect Wallet">
                <i class="fas fa-plug"></i> Connect Wallet
            </button>
            <button class="disconnect-btn hidden" id="disconnectBtn" aria-label="Disconnect Wallet">Disconnect</button>
        </div>
    </div>

    <!-- Age Verification Modal -->
    <div class="age-verification" id="ageVerificationModal">
        <div class="verification-content">
            <h1><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h1>
            <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
            <div class="warning">
                <p><i class="fas fa-exclamation-circle"></i> Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
            </div>
            <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            <div class="verification-buttons">
                <button class="verify-btn accept" aria-label="I am 18 or older">I am 18+</button>
                <button class="verify-btn decline" aria-label="I am under 18">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Anti-Bot Protection Modal -->
    <div class="anti-bot-challenge hidden" id="antiBotChallenge">
        <div class="anti-bot-content">
            <h3 style="color: #4ecdc4; margin-bottom: 1rem;">🛡️ Human Verification</h3>
            <p style="margin-bottom: 1rem;">Please complete this challenge to continue playing:</p>
            <p id="captchaInstructions" style="margin-bottom: 1rem; font-weight: bold; color: #f39c12;">
                Select all squares containing chess pieces
            </p>
            
            <div class="captcha-grid" id="captchaGrid">
                <!-- Grid will be populated by JavaScript -->
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
                <button class="verify-btn accept" id="verifyCaptchaBtn" disabled>
                    Verify
                </button>
                <button class="verify-btn" style="background: #666;">
                    <i class="fas fa-refresh"></i> New Challenge
                </button>
            </div>
            
            <p style="margin-top: 1rem; font-size: 0.8rem; color: #aaa;">
                This helps us prevent automated bots and ensures fair play for all users.
            </p>
        </div>
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div class="tx-header">
            <span id="txStatusIcon">🔄</span>
            <span id="txStatusTitle">Processing...</span>
            <button class="tx-close" aria-label="Close transaction status">×</button>
        </div>
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
        <div class="tx-progress" id="txProgress">
            <div class="progress-bar">
                <div class="progress-fill" id="txProgressFill" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Game Settlement Modal -->
    <div class="settlement-modal hidden" id="settlementModal">
        <div class="settlement-content">
            <div class="settlement-header">
                <h2 id="settlementTitle">🎉 Game Complete!</h2>
                <button class="settlement-close" aria-label="Close settlement">×</button>
            </div>
            <div class="settlement-body">
                <div class="settlement-result" id="settlementResult">
                    <!-- Settlement details will be populated here -->
                </div>
                <div class="settlement-breakdown" id="settlementBreakdown">
                    <!-- Fee breakdown will be shown here -->
                </div>
                <div class="settlement-actions">
                    <button class="settlement-btn primary" id="claimBtn">
                        <i class="fas fa-coins"></i> Claim Winnings
                    </button>
                    <button class="settlement-btn secondary">
                        <i class="fas fa-chart-line"></i> View Analysis
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Game Windows -->
    <!-- Chess Game Window -->
    <div class="game-window hidden" id="chessGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">♟️ Chess Masters 
                <span class="skill-badge skill-gold" id="chessSkillBadge">Gold</span>
                <span class="validation-status validated" title="Server Validated">✓</span>
                <span class="sync-status" id="chessSyncStatus" title="Synchronized">🔄</span>
            </div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" aria-label="Minimize chess game">−</button>
                <button class="window-btn close-btn" aria-label="Close chess game">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-info-bar">
                <div class="player-info">
                    <div class="player-avatar">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <strong>You:</strong> <span id="chessPlayerName">White</span>
                        <div class="timer" id="chessPlayerTimer">10:00</div>
                        <div class="move-indicator" id="chessPlayerMove">●</div>
                    </div>
                </div>
                <div class="game-status-center">
                    <div class="game-status" id="chessStatus">Waiting for opponent...</div>
                    <div class="move-history" id="chessMoveHistory">
                        <div class="move-list" id="chessMoveList"></div>
                    </div>
                </div>
                <div class="opponent-info">
                    <div class="player-avatar">
                      <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <strong>Opponent:</strong> <span id="chessOpponentName">-</span>
                        <div class="timer" id="chessOpponentTimer">10:00</div>
                        <div class="move-indicator" id="chessOpponentMove">○</div>
                    </div>
                </div>
            </div>
            <div class="chess-board-container">
                <div class="chess-coordinates-top">
                    <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
                <div class="chess-board-wrapper">
                    <div class="chess-coordinates-left">
                        <span>8</span><span>7</span><span>6</span><span>5</span><span>4</span><span>3</span><span>2</span><span>1</span>
                    </div>
                    <div class="chess-board" id="chessBoard"></div>
                    <div class="chess-coordinates-right">
                        <span>8</span><span>7</span><span>6</span><span>5</span><span>4</span><span>3</span><span>2</span><span>1</span>
                    </div>
                </div>
                <div class="chess-coordinates-bottom">
                    <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
            </div>
            <div class="game-controls">
                <button class="game-btn danger" onclick="resignGame()">
                    <i class="fas fa-flag"></i> Resign
                </button>
                <button class="game-btn neutral" onclick="offerDraw()">
                    <i class="fas fa-handshake"></i> Offer Draw
                </button>
                <button class="game-btn neutral" onclick="requestUndo()">
                    <i class="fas fa-undo"></i> Request Undo
                </button>
                <button class="game-btn primary" onclick="analyzePosition()">
                    <i class="fas fa-brain"></i> Analyze
                </button>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">
                    <i class="fas fa-comments"></i> Game Chat
                </h4>
                <div class="game-chat-messages" id="chessGameChat">
                    <div class="game-chat-message system"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="chessChatInput" 
                           maxlength="200" aria-label="Chess game chat input">
                    <button aria-label="Send chess chat message" onclick="sendGameMessage('chess')">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Checkers Game Window -->
    <div class="game-window hidden" id="checkersGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">⚫ Checkers Pro 
                <span class="skill-badge skill-silver" id="checkersSkillBadge">Silver</span>
                <span class="validation-status validated" title="Server Validated">✓</span>
                <span class="sync-status" id="checkersSyncStatus" title="Synchronized">🔄</span>
            </div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" aria-label="Minimize checkers game">−</button>
                <button class="window-btn close-btn" aria-label="Close checkers game">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-info-bar">
                <div class="player-info">
                    <div class="player-avatar">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <strong>You:</strong> <span id="checkersPlayerName">Red</span>
                        <div class="timer" id="checkersPlayerTimer">5:00</div>
                        <div class="captured-pieces" id="checkersPlayerCaptured">
                            <span class="capture-count">0</span> captured
                        </div>
                    </div>
                </div>
                <div class="game-status-center">
                    <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
                    <div class="game-score">
                        <div class="score-item">
                            <span class="score-label">Red Pieces:</span>
                            <span class="score-value" id="redPiecesCount">12</span>
                        </div>
                        <div class="score-item">
                            <span class="score-label">Black Pieces:</span>
                            <span class="score-value" id="blackPiecesCount">12</span>
                        </div>
                    </div>
                </div>
                <div class="opponent-info">
                    <div class="player-avatar">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <strong>Opponent:</strong> <span id="checkersOpponentName">-</span>
                        <div class="timer" id="checkersOpponentTimer">5:00</div>
                        <div class="captured-pieces" id="checkersOpponentCaptured">
                            <span class="capture-count">0</span> captured
                        </div>
                    </div>
                </div>
            </div>
            <div class="checkers-board" id="checkersBoard"></div>
            <div class="game-controls">
                <button class="game-btn danger" onclick="resignGame()">
                    <i class="fas fa-flag"></i> Resign
                </button>
                <button class="game-btn neutral" onclick="requestUndo()">
                    <i class="fas fa-undo"></i> Request Undo
                </button>
                <button class="game-btn primary" onclick="showPossibleMoves()">
                    <i class="fas fa-eye"></i> Show Moves
                </button>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">
                    <i class="fas fa-comments"></i> Game Chat
                </h4>
                <div class="game-chat-messages" id="checkersGameChat">
                    <div class="game-chat-message system"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="checkersChatInput" 
                           maxlength="200" aria-label="Checkers game chat input">
                    <button aria-label="Send checkers chat message" onclick="sendGameMessage('checkers')">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Word Game Window -->
    <div class="game-window hidden" id="wordGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">📝 Word Battle 
                <span class="skill-badge skill-bronze" id="wordSkillBadge">Bronze</span>
                <span class="validation-status validated" title="Server Validated">✓</span>
                <span class="sync-status" id="wordSyncStatus" title="Synchronized">🔄</span>
            </div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" aria-label="Minimize word game">−</button>
                <button class="window-btn close-btn" aria-label="Close word game">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-info-bar">
                <div class="player-info">
                    <div class="player-details">
                        <strong>You:</strong> <span id="wordPlayerName">Player</span>
                        <div class="timer" id="wordPlayerTimer">2:00</div>
                        <div class="word-score">Score: <span id="playerWordScore">0</span></div>
                    </div>
                </div>
                <div class="game-status-center">
                    <div class="game-status" id="wordStatus">Round 1 of 3</div>
                    <div class="round-indicator">
                        <div class="round-dot active"></div>
                        <div class="round-dot"></div>
                        <div class="round-dot"></div>
                    </div>
                </div>
                <div class="opponent-info">
                    <div class="player-details">
                        <strong>Opponent:</strong> <span id="wordOpponentName">-</span>
                        <div class="timer" id="wordOpponentTimer">2:00</div>
                        <div class="word-score">Score: <span id="opponentWordScore">0</span></div>
                    </div>
                </div>
            </div>
            <div class="word-game">
                <div class="word-prompt">
                    <h4 id="wordPrompt">Make a word with these letters:</h4>
                    <div id="wordLetters" class="available-letters">BLOCKCHAIN</div>
                </div>
                <div class="word-input-section">
                    <input type="text" class="word-input" id="wordInput" 
                           placeholder="Enter your word..." maxlength="20" 
                           aria-label="Word input">
                    <div class="word-validation" id="wordValidation"></div>
                </div>
                <div class="word-scoring">
                    <div class="scoring-info">
                        <div class="score-breakdown">
                            <span>Base: +<span id="baseScore">0</span></span>
                            <span>Length: +<span id="lengthBonus">0</span></span>
                            <span>Bonus: +<span id="specialBonus">0</span></span>
                        </div>
                        <div class="total-score">Total: <span id="roundScore">0</span></div>
                    </div>
                </div>
                <div class="submitted-words">
                    <h5>Words This Round:</h5>
                    <div class="words-list" id="submittedWordsList"></div>
                </div>
                <div class="game-controls">
                    <button class="game-btn primary" onclick="submitWord()">
                        <i class="fas fa-check"></i> Submit Word
                    </button>
                    <button class="game-btn neutral" onclick="skipRound()">
                        <i class="fas fa-forward"></i> Skip Round
                    </button>
                    <button class="game-btn secondary" onclick="shuffleLetters()">
                        <i class="fas fa-random"></i> Shuffle
                    </button>
                </div>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">
                    <i class="fas fa-comments"></i> Game Chat
                </h4>
                <div class="game-chat-messages" id="wordGameChat">
                    <div class="game-chat-message system"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="wordChatInput" 
                           maxlength="200" aria-label="Word game chat input">
                    <button aria-label="Send word game chat message" onclick="sendGameMessage('words')">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Enhanced Sidebar -->
        <div class="sidebar">
            <!-- Smart Contract Status -->
            <div class="contract-status">
                <h3><i class="fas fa-shield-alt"></i> Smart Contract Status</h3>
                <div class="contract-address" id="contractAddress">
                    0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A
                    <button class="copy-btn" aria-label="Copy contract address" onclick="copyContractAddress()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <div id="contractStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to Core Blockchain...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="connectionProgress" style="width: 0%"></div>
                </div>
                <div class="contract-verification">
                    <div class="verification-item">
                        <i class="fas fa-check-circle verified"></i>
                        <span>Contract Verified</span>
                    </div>
                    <div class="verification-item">
                        <i class="fas fa-lock security"></i>
                        <span>Security Audited</span>
                    </div>
                    <div class="verification-item">
                        <i class="fas fa-chart-line stats"></i>
                        <span>Live Statistics</span>
                    </div>
                </div>
            </div>

            <!-- Enhanced Live Statistics -->
            <div class="live-lobby">
                <h3><i class="fas fa-chart-bar"></i> Live Platform Stats</h3>
                <div class="lobby-stats">
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-users"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalPlayers">247</div>
                            <div class="stat-label">Online Players</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-gamepad"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalGames">89</div>
                            <div class="stat-label">Active Games</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-coins"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalVolume">156.7</div>
                            <div class="stat-label">CORE Volume (24h)</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-trophy"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalTournaments">3</div>
                            <div class="stat-label">Live Tournaments</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Recent Activity Feed -->
            <div class="live-lobby">
                <h3><i class="fas fa-rss"></i> Recent Activity</h3>
                <div id="activityFeed" class="activity-feed">
                    <div class="activity-item">🎮 Player123 won 0.5 CORE in Chess!</div>
                    <div class="activity-item">⚔️ New tournament starting in 5 minutes</div>
                    <div class="activity-item">🔥 High stakes game: 2.0 CORE</div>
                    <div class="activity-item">📝 WordMaster scored 150 points!</div>
                    <div class="activity-item">🏆 Daily leaderboard updated</div>
                </div>
                <button class="activity-refresh" onclick="refreshActivityFeed()">
                    <i class="fas fa-sync-alt"></i> Refresh Feed
                </button>
            </div>

            <!-- Enhanced Tournament Leaderboard -->
            <div class="live-lobby">
                <h3><i class="fas fa-crown"></i> Tournament Leaders</h3>
                <div id="tournamentLeaderboard" class="leaderboard">
                    <div class="leaderboard-item gold">
                        <div class="rank">🥇</div>
                        <div class="player-info">
                            <div class="player-name">CryptoKing</div>
                            <div class="player-games">15 wins</div>
                        </div>
                        <div class="player-score">127 pts</div>
                    </div>
                    <div class="leaderboard-item silver">
                        <div class="rank">🥈</div>
                        <div class="player-info">
                            <div class="player-name">GameMaster</div>
                            <div class="player-games">12 wins</div>
                        </div>
                        <div class="player-score">89 pts</div>
                    </div>
                    <div class="leaderboard-item bronze">
                        <div class="rank">🥉</div>
                        <div class="player-info">
                            <div class="player-name">ChessGM</div>
                            <div class="player-games">8 wins</div>
                        </div>
                        <div class="player-score">76 pts</div>
                    </div>
                </div>
                <button class="leaderboard-view-all" onclick="viewFullLeaderboard()">
                    <i class="fas fa-list"></i> View Full Leaderboard
                </button>
            </div>

            <!-- Enhanced Server Status -->
            <div class="live-lobby">
                <h3><i class="fas fa-server"></i> Network Status</h3>
                <div class="server-grid">
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-gamepad"></i></div>
                        <div class="server-info">
                            <div class="server-status">Online</div>
                            <div class="server-label">Game Server</div>
                        </div>
                    </div>
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-network-wired"></i></div>
                        <div class="server-info">
                            <div class="server-status" id="serverLatency">12ms</div>
                            <div class="server-label">Latency</div>
                        </div>
                    </div>
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-shield-check"></i></div>
                        <div class="server-info">
                            <div class="server-status">Active</div>
                            <div class="server-label">Validation</div>
                        </div>
                    </div>
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-chart-line"></i></div>
                        <div class="server-info">
                            <div class="server-status">99.9%</div>
                            <div class="server-label">Uptime</div>
                        </div>
                    </div>
                </div>
                <div class="network-info">
                    <div class="network-item">
                        <span class="network-label">Block Height:</span>
                        <span class="network-value" id="blockHeight">15,234,567</span>
                    </div>
                    <div class="network-item">
                        <span class="network-label">Gas Price:</span>
                        <span class="network-value" id="gasPrice">15.2 gwei</span>
                    </div>
                    <div class="network-item">
                        <span class="network-label">CORE Price:</span>
                        <span class="network-value" id="corePrice">$1.234</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- Content Area -->
        <div class="content-area">
            <!-- Game Lobby Section -->
            <div id="lobbySection">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-dice"></i> Live Game Lobby</h2>
                        <div class="lobby-controls">
                            <button class="control-btn" aria-label="Refresh Lobby" onclick="refreshLobby()">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="control-btn" id="autoRefreshBtn" aria-label="Auto Refresh" onclick="toggleAutoRefresh()">
                                <i class="fas fa-play"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="games-list" id="gamesList">
                        <div class="game-item">
                            <div class="game-header">
                                <div class="game-type">♟️ Chess Masters</div>
                                <div class="game-stake">0.05 CORE</div>
                            </div>
                            <div class="game-info">
                                Created by: DemoPlayer1 • Skill: Gold • Time: 10+5
                            </div>
                            <div class="game-actions">
                                <button class="game-btn primary" onclick="joinDemoGameFromLobby('chess', 0.05)">
                                    <i class="fas fa-play"></i> Join Game
                                </button>
                            </div>
                        </div>
                        
                        <div class="game-item">
                            <div class="game-header">
                                <div class="game-type">⚫ Checkers Pro</div>
                                <div class="game-stake">0.02 CORE</div>
                            </div>
                            <div class="game-info">
                                Created by: DemoPlayer2 • Skill: Silver • Time: 5+3
                            </div>
                            <div class="game-actions">
                                <button class="game-btn primary" onclick="joinDemoGameFromLobby('checkers', 0.02)">
                                    <i class="fas fa-play"></i> Join Game
                                </button>
                            </div>
                        </div>
                        
                        <div class="game-item">
                            <div class="game-header">
                                <div class="game-type">📝 Word Battle</div>
                                <div class="game-stake">0.01 CORE</div>
                            </div>
                            <div class="game-info">
                                Created by: DemoPlayer3 • Skill: Bronze • Time: 2+0
                            </div>
                            <div class="game-actions">
                                <button class="game-btn primary" onclick="joinDemoGameFromLobby('words', 0.01)">
                                    <i class="fas fa-play"></i> Join Game
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="noGames" class="hidden empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-gamepad"></i>
                        </div>
                        <h3>No Active Games</h3>
                        <p>Be the first to create a game and start earning CORE!</p>
                        <button class="empty-action-btn" onclick="showSection('create')">
                            <i class="fas fa-plus"></i> Create First Game
                        </button>
                    </div>
                </div>
            </div>

            <!-- Enhanced Active Games Section -->
            <div id="activeSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-play-circle"></i> My Active Games</h2>
                        <div class="lobby-controls">
                            <button class="control-btn" aria-label="Refresh Active Games" onclick="refreshActiveGames()">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="games-list" id="activeGamesList">
                        <!-- Active games will be populated here -->
                    </div>
                    
                    <div id="noActiveGames" class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-chess-board"></i>
                        </div>
                        <h3>No Active Games</h3>
                        <p>Join a game from the lobby or create your own to start playing!</p>
                        <div class="empty-actions">
                            <button class="empty-action-btn primary" onclick="showSection('lobby')">
                                <i class="fas fa-search"></i> Browse Games
                            </button>
                            <button class="empty-action-btn secondary" onclick="showSection('create')">
                                <i class="fas fa-plus"></i> Create Game
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Create Game Section -->
            <div id="createSection" class="hidden">
                <div class="create-game-section">
                    <h2><i class="fas fa-plus-circle"></i> Create New Game</h2>
                    
                    <div class="game-type-selector">
                        <div class="game-type-card" data-type="chess" onclick="selectGameType('chess')">
                            <div class="game-icon">♟️</div>
                            <h3>Chess Masters</h3>
                            <p>Strategic blockchain chess with full move validation</p>
                            <div class="game-features">
                                <span class="feature-tag">5-30 min</span>
                                <span class="feature-tag">Server Validated</span>
                                <span class="feature-tag">Anti-Cheat</span>
                            </div>
                            <div class="popularity-indicator">
                                <div class="popularity-bar" style="width: 85%"></div>
                                <span class="popularity-text">Very Popular</span>
                            </div>
                        </div>
                        <div class="game-type-card" data-type="checkers" onclick="selectGameType('checkers')">
                            <div class="game-icon">⚫</div>
                            <h3>Checkers Pro</h3>
                            <p>Fast-paced checkers with instant settlements</p>
                            <div class="game-features">
                                <span class="feature-tag">3-15 min</span>
                                <span class="feature-tag">Quick Play</span>
                                <span class="feature-tag">Beginner Friendly</span>
                            </div>
                            <div class="popularity-indicator">
                                <div class="popularity-bar" style="width: 65%"></div>
                                <span class="popularity-text">Popular</span>
                            </div>
                        </div>
                        <div class="game-type-card" data-type="words" onclick="selectGameType('words')">
                            <div class="game-icon">📝</div>
                            <h3>Word Battle</h3>
                            <p>Quick word-building competition</p>
                            <div class="game-features">
                                <span class="feature-tag">1-5 min</span>
                                <span class="feature-tag">Dictionary Verified</span>
                                <span class="feature-tag">Educational</span>
                            </div>
                            <div class="popularity-indicator">
                                <div class="popularity-bar" style="width: 45%"></div>
                                <span class="popularity-text">Growing</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stake-section">
                        <label for="gameStake">Stake Amount (CORE)</label>
                        <input type="number" class="stake-input" id="gameStake" 
                               placeholder="Enter stake amount (min 0.01 CORE)" 
                               min="0.01" step="0.01" 
                               aria-label="Game stake amount"
                               oninput="updateCreateButton()">
                        <div class="stake-presets">
                            <button class="stake-preset" onclick="setStake(0.01)">0.01</button>
                            <button class="stake-preset" onclick="setStake(0.1)">0.1</button>
                            <button class="stake-preset" onclick="setStake(0.5)">0.5</button>
                            <button class="stake-preset" onclick="setStake(1.0)">1.0</button>
                        </div>
                    </div>
                    
                    <button class="create-btn" id="createGameBtn" disabled onclick="createGame()">
                        <i class="fas fa-plus"></i> Select Game Type & Enter Stake
                    </button>
                </div>
            </div>

            <!-- Games Section -->
            <div id="gamesSection" class="hidden">
                <div class="live-lobby">
                    <h2><i class="fas fa-gamepad"></i> Available Games</h2>
                    <p style="margin-bottom: 2rem; color: #aaa;">Choose from our collection of blockchain-powered games. All games feature smart contract security and instant payouts.</p>
                    
                    <div class="games-showcase">
                        <div class="game-showcase-card">
                            <div class="showcase-header">
                                <div class="showcase-icon">♟️</div>
                                <h3>Chess Masters</h3>
                                <div class="showcase-rating">
                                    <div class="stars">★★★★★</div>
                                    <span>(4.9/5)</span>
                                </div>
                            </div>
                            <p>Professional chess with blockchain stakes and smart contract security.</p>
                          <div class="showcase-features">
                                <span class="feature-pill">ELO Rating</span>
                                <span class="feature-pill">Move Analysis</span>
                            </div>
                            <button class="showcase-btn" onclick="showSection('create'); selectGameType('chess')">
                                <i class="fas fa-chess-board"></i> Create Chess Game
                            </button>
                        </div>
                        
                        <div class="game-showcase-card">
                            <div class="showcase-header">
                                <div class="showcase-icon">⚫</div>
                                <h3>Checkers Pro</h3>
                                <div class="showcase-rating">
                                    <div class="stars">★★★★☆</div>
                                    <span>(4.6/5)</span>
                                </div>
                            </div>
                            <p>Fast-paced checkers with instant blockchain settlements.</p>
                            <div class="showcase-features">
                                <span class="feature-pill">Quick Play</span>
                                <span class="feature-pill">King Promotion</span>
                            </div>
                            <button class="showcase-btn" onclick="showSection('create'); selectGameType('checkers')">
                                <i class="fas fa-th"></i> Create Checkers Game
                            </button>
                        </div>
                        
                        <div class="game-showcase-card">
                            <div class="showcase-header">
                                <div class="showcase-icon">📝</div>
                                <h3>Word Battle</h3>
                                <div class="showcase-rating">
                                    <div class="stars">★★★★☆</div>
                                    <span>(4.4/5)</span>
                                </div>
                            </div>
                            <p>Competitive word games with dictionary verification.</p>
                            <div class="showcase-features">
                                <span class="feature-pill">Dictionary Check</span>
                                <span class="feature-pill">Scoring System</span>
                            </div>
                            <button class="showcase-btn" onclick="showSection('create'); selectGameType('words')">
                                <i class="fas fa-font"></i> Create Word Game
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tournaments Section -->
            <div id="tournamentsSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-trophy"></i> Tournaments</h2>
                        <button class="empty-action-btn" onclick="createTournament()">
                            <i class="fas fa-plus"></i> Create Tournament
                        </button>
                    </div>
                    
                    <div class="tournament-filters">
                        <button class="filter-btn active" onclick="filterTournaments('all')">All</button>
                        <button class="filter-btn" onclick="filterTournaments('live')">Live</button>
                        <button class="filter-btn" onclick="filterTournaments('upcoming')">Upcoming</button>
                        <button class="filter-btn" onclick="filterTournaments('chess')">Chess</button>
                        <button class="filter-btn" onclick="filterTournaments('checkers')">Checkers</button>
                        <button class="filter-btn" onclick="filterTournaments('words')">Words</button>
                    </div>
                    
                    <div class="tournaments-grid" id="tournamentsGrid">
                        <!-- Sample tournament -->
                        <div class="tournament-card live-tournament">
                            <div class="tournament-header">
                                <div class="tournament-type">♟️ Chess Masters Cup</div>
                                <div class="tournament-status live">LIVE</div>
                            </div>
                            <div class="tournament-info">
                                <div class="tournament-detail">
                                    <i class="fas fa-coins"></i>
                                    <span>Prize Pool: <strong>15.0 CORE</strong></span>
                                </div>
                                <div class="tournament-detail">
                                    <i class="fas fa-users"></i>
                                    <span>Players: <strong>32/64</strong></span>
                                </div>
                                <div class="tournament-detail">
                                    <i class="fas fa-dollar-sign"></i>
                                    <span>Entry: <strong>0.5 CORE</strong></span>
                                </div>
                                <div class="tournament-detail">
                                    <i class="fas fa-clock"></i>
                                    <span>Format: <strong>Single Elimination</strong></span>
                                </div>
                            </div>
                            <div class="tournament-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: 33%"></div>
                                </div>
                                <span class="progress-text">Round 2 of 6</span>
                            </div>
                            <div class="tournament-actions">
                                <button class="tournament-btn primary" onclick="joinTournament('chess_masters_001')">
                                    <i class="fas fa-trophy"></i> Join Tournament
                                </button>
                                <button class="tournament-btn secondary" onclick="viewTournament('chess_masters_001')">
                                    <i class="fas fa-eye"></i> View
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="noTournaments" class="hidden empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-trophy"></i>
                        </div>
                        <h3>No Active Tournaments</h3>
                        <p>Be the first to create a tournament and compete for bigger prizes!</p>
                        <button class="empty-action-btn" onclick="createTournament()">
                            <i class="fas fa-plus"></i> Create First Tournament
                        </button>
                    </div>
                </div>
            </div>

            <!-- Profile Section -->
            <div id="profileSection" class="hidden">
                <div class="live-lobby">
                    <h2><i class="fas fa-user"></i> Player Profile</h2>
                    <p style="margin-bottom: 2rem; color: #aaa;">View your gaming statistics and achievements.</p>
                    
                    <div class="profile-content">
                        <div class="profile-header">
                            <div class="profile-avatar">
                                <i class="fas fa-user-circle"></i>
                            </div>
                            <div class="profile-info">
                                <div class="profile-name" id="profilePlayerName">Player</div>
                                <div class="profile-level">Level <span id="profileLevel">1</span></div>
                                <div class="profile-xp"><span id="profileXP">0</span> XP</div>
                            </div>
                        </div>
                        
                        <div class="profile-stats">
                            <div class="stat-card">
                                <div class="stat-icon">🎮</div>
                                <div class="stat-value" id="profileGamesPlayed">0</div>
                                <div class="stat-label">Games Played</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">🏆</div>
                                <div class="stat-value" id="profileGamesWon">0</div>
                                <div class="stat-label">Games Won</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">💰</div>
                                <div class="stat-value" id="profileTotalEarned">0.000</div>
                                <div class="stat-label">CORE Earned</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">📈</div>
                                <div class="stat-value" id="profileWinRate">0%</div>
                                <div class="stat-label">Win Rate</div>
                            </div>
                        </div>
                        
                        <div class="achievements-section">
                            <h3><i class="fas fa-medal"></i> Achievements</h3>
                            <div class="achievements-grid" id="achievementsGrid">
                                <!-- Achievements will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Section -->
            <div id="chatSection" class="hidden">
                <div class="live-lobby">
                    <h2><i class="fas fa-comments"></i> Global Chat</h2>
                    <p style="margin-bottom: 2rem; color: #aaa;">Connect with other players in the global chat.</p>
                    
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-comments"></i>
                        </div>
                        <h3>Global Chat Coming Soon</h3>
                        <p>Chat with players from around the world, share strategies, and make friends!</p>
                    </div>
                </div>
            </div>

            <!-- Settings Section -->
            <div id="settingsSection" class="hidden">
                <div class="live-lobby">
                    <h2><i class="fas fa-cog"></i> Settings</h2>
                    <p style="margin-bottom: 2rem; color: #aaa;">Customize your gaming experience.</p>
                    
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-cog"></i>
                        </div>
                        <h3>Settings Panel Coming Soon</h3>
                        <p>Customize notifications, display preferences, security settings, and more!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</style>
  <script>
// COMPLETE ENHANCED CROSSREALM GAMING PLATFORM - JAVASCRIPT IMPLEMENTATION
// UPDATED WITH REAL CONTRACT ADDRESS AND COMPLETE GAME LOGIC

// Enhanced Global Configuration with provided credentials
const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = "0x45c"; // Core mainnet
const CROSSREALM_URL = "https://crossrealm.netlify.app";

// Enhanced API Configuration with provided credentials
const JSONBIN_API_CONFIG = {
    MASTER_KEY: '$2a$10$GtV1/gAxPuNYbKEoKNghTu9NiX3OyvrEw6ir4vJA2Nu/U7KGAnkC6',
    ACCESS_KEY: '$2a$10$Ppx.2Z91xbnEF57ad1FmZOIkkmy.0QJbB8b1.IP561Z.px8smIRBe',
    BIN_ID: '686ea4c0c264cf03d2e83902',
    BASE_URL: 'https://api.jsonbin.io/v3'
};

// Dictionary API for word validation
const DICTIONARY_API = {
    BASE_URL: 'https://api.dictionaryapi.dev/api/v2/entries/en/',
    BACKUP_URL: 'https://dictionaryapi.com/api/v3/references/collegiate/json/'
};

// Real Smart Contract ABI for actual blockchain interaction
const GAME_CONTRACT_ABI = [
    "function createGame(string memory gameType, uint256 timeLimit) external payable returns (uint256)",
    "function joinGame(uint256 gameId) external payable",
    "function submitMove(uint256 gameId, bytes memory moveData, bytes32 gameStateHash) external",
    "function finalizeGame(uint256 gameId, address winner, bytes32 finalStateHash) external",
    "function claimWinnings(uint256 gameId) external",
    "function refundStake(uint256 gameId) external",
    "function createTournament(string memory name, uint256 entryFee, uint256 maxPlayers) external payable returns (uint256)",
    "function joinTournament(uint256 tournamentId) external payable",
    "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint256 status, string memory gameType)",
    "function getTotalGames() external view returns (uint256)",
    "function getPlayerGames(address player) external view returns (uint256[] memory)",
    "function getPlayerStats(address player) external view returns (uint256 gamesPlayed, uint256 gamesWon, uint256 totalEarned)",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint256 stake, string gameType)",
    "event GameJoined(uint256 indexed gameId, address indexed player)",
    "event GameFinalized(uint256 indexed gameId, address indexed winner, uint256 payout)",
    "event TournamentCreated(uint256 indexed tournamentId, address indexed creator, uint256 entryFee)",
    "event MoveSubmitted(uint256 indexed gameId, address indexed player, bytes32 moveHash)"
];

// Enhanced Global Variables
let web3Provider = null;
let userAccount = null;
let gameContract = null;
let currentBalance = 0;
let activeGames = [];
let myActiveGames = [];
let globalGamesList = [];
let selectedGameType = null;
let gameUpdateInterval = null;
let multiplayerSession = null;
let gameRoomConnections = new Map();
let pendingMatches = new Map();
let gameTimers = new Map();
let serverLatency = 12;
let currentBlockHeight = 0;
let currentGasPrice = 0;
let corePrice = 0;
let autoRefreshEnabled = false;
let socketConnection = null;
let tournaments = [];
let myTournaments = [];
let currentTournamentFilter = 'all';
let currentSection = 'lobby';
let isGameActive = false;
let activeGameType = null;
let antiBotChallengeActive = false;
let captchaSelection = [];

// Game States
let gameStates = new Map();
let currentGameState = null;

// Enhanced Player Data
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    winRate: 0,
    lastGameTime: 0,
    longestWinStreak: 0,
    currentWinStreak: 0,
    totalStaked: 0,
    averageGameTime: 0
};

let playerSkillRatings = {
    chess: 1200,
    checkers: 1200,
    words: 1200
};

// Enhanced Player Progression System
class PlayerProgression {
    constructor() {
        this.playerLevel = 1;
        this.totalXP = 0;
        this.achievements = [];
        this.skillRatings = {
            chess: 1200,
            checkers: 1200,
            words: 1200
        };
        this.xpSystem = {
            gameWin: 100,
            gameLoss: 25,
            tournamentWin: 500,
            dailyLogin: 10,
            firstGame: 50,
            moveBonus: 5,
            quickWin: 25,
            comeback: 50,
            perfectGame: 75
        };
        this.loadProgress();
    }

    awardXP(amount, reason) {
        this.totalXP += amount;
        const newLevel = Math.floor(this.totalXP / 1000) + 1;
        
        if (newLevel > this.playerLevel) {
            this.levelUp(this.playerLevel, newLevel);
            this.playerLevel = newLevel;
        }
        
        this.updateProgressDisplay();
        this.saveProgress();
        showXPNotification(amount, reason);
        
        return amount;
    }

    levelUp(oldLevel, newLevel) {
        showLevelUpNotification(oldLevel, newLevel);
        this.awardXP(50, 'Level Up Bonus');
        this.unlockLevelRewards(newLevel);
    }

    unlockLevelRewards(level) {
        const rewards = {
            5: { type: 'feature', name: 'Game Analysis' },
            10: { type: 'feature', name: 'Tournament Creation' },
            15: { type: 'feature', name: 'Spectator Mode' },
            20: { type: 'bonus', name: '+10% XP Boost' },
            25: { type: 'feature', name: 'Voice Chat' }
        };

        if (rewards[level]) {
            showUnlockNotification(rewards[level]);
        }
    }

    updateProgressDisplay() {
        const levelEl = document.getElementById('playerLevel');
        const xpEl = document.getElementById('playerXP');
        const xpBar = document.getElementById('xpBar');
        const profileLevel = document.getElementById('profileLevel');
        const profileXP = document.getElementById('profileXP');
        
        if (levelEl) levelEl.textContent = `Level ${this.playerLevel}`;
        if (xpEl) xpEl.textContent = `${this.totalXP} XP`;
        if (profileLevel) profileLevel.textContent = this.playerLevel;
        if (profileXP) profileXP.textContent = this.totalXP;
        
        if (xpBar) {
            const currentLevelXP = (this.playerLevel - 1) * 1000;
            const nextLevelXP = this.playerLevel * 1000;
            const progress = ((this.totalXP - currentLevelXP) / (nextLevelXP - currentLevelXP)) * 100;
            xpBar.style.width = Math.min(progress, 100) + '%';
        }
    }

    saveProgress() {
        try {
            const progressData = {
                level: this.playerLevel,
                xp: this.totalXP,
                achievements: this.achievements,
                skillRatings: this.skillRatings
            };
            localStorage.setItem('crossrealm_progress', JSON.stringify(progressData));
        } catch (error) {
            console.log('Could not save progress:', error);
        }
    }

    loadProgress() {
        try {
            const savedProgress = localStorage.getItem('crossrealm_progress');
            if (savedProgress) {
                const data = JSON.parse(savedProgress);
                this.playerLevel = data.level || 1;
                this.totalXP = data.xp || 0;
                this.achievements = data.achievements || [];
                this.skillRatings = { ...this.skillRatings, ...data.skillRatings };
            }
        } catch (error) {
            console.log('Could not load progress:', error);
        }
    }
}

// Chess Game Engine
class ChessEngine {
    constructor() {
        this.board = this.initializeBoard();
        this.currentPlayer = 'white';
        this.gameState = 'playing';
        this.moveHistory = [];
        this.selectedSquare = null;
        this.legalMoves = [];
        this.isInCheck = false;
        this.lastMove = null;
        this.castlingRights = {
            white: { kingside: true, queenside: true },
            black: { kingside: true, queenside: true }
        };
        this.enPassantTarget = null;
        this.halfMoveClock = 0;
        this.fullMoveNumber = 1;
    }

    initializeBoard() {
        const board = Array(8).fill().map(() => Array(8).fill(null));
        
        // Place pieces
        const pieceOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
        
        // Black pieces
        for (let col = 0; col < 8; col++) {
            board[0][col] = { type: pieceOrder[col], color: 'black' };
            board[1][col] = { type: 'pawn', color: 'black' };
        }
        
        // White pieces
        for (let col = 0; col < 8; col++) {
            board[6][col] = { type: 'pawn', color: 'white' };
            board[7][col] = { type: pieceOrder[col], color: 'white' };
        }
        
        return board;
    }

    getPieceSymbol(piece) {
        if (!piece) return '';
        
        const symbols = {
            white: {
                king: '♔', queen: '♕', rook: '♖', 
                bishop: '♗', knight: '♘', pawn: '♙'
            },
            black: {
                king: '♚', queen: '♛', rook: '♜', 
                bishop: '♝', knight: '♞', pawn: '♟'
            }
        };
        
        return symbols[piece.color][piece.type];
    }

    isValidSquare(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    getPossibleMoves(row, col) {
        const piece = this.board[row][col];
        if (!piece || piece.color !== this.currentPlayer) return [];

        let moves = [];
        
        switch (piece.type) {
            case 'pawn':
                moves = this.getPawnMoves(row, col);
                break;
            case 'rook':
                moves = this.getRookMoves(row, col);
                break;
            case 'knight':
                moves = this.getKnightMoves(row, col);
                break;
            case 'bishop':
                moves = this.getBishopMoves(row, col);
                break;
            case 'queen':
                moves = this.getQueenMoves(row, col);
                break;
            case 'king':
                moves = this.getKingMoves(row, col);
                break;
        }

        // Filter out moves that would leave king in check
        return moves.filter(move => !this.wouldBeInCheck(row, col, move.row, move.col));
    }

    getPawnMoves(row, col) {
        const moves = [];
        const piece = this.board[row][col];
        const direction = piece.color === 'white' ? -1 : 1;
        const startingRow = piece.color === 'white' ? 6 : 1;

        // Forward move
        if (this.isValidSquare(row + direction, col) && !this.board[row + direction][col]) {
            moves.push({ row: row + direction, col });
            
            // Double move from starting position
            if (row === startingRow && !this.board[row + 2 * direction][col]) {
                moves.push({ row: row + 2 * direction, col });
            }
        }

        // Captures
        for (const captureCol of [col - 1, col + 1]) {
            if (this.isValidSquare(row + direction, captureCol)) {
                const target = this.board[row + direction][captureCol];
                if (target && target.color !== piece.color) {
                    moves.push({ row: row + direction, col: captureCol, capture: true });
                }
            }
        }

        // En passant
        if (this.enPassantTarget && 
            Math.abs(col - this.enPassantTarget.col) === 1 && 
            row + direction === this.enPassantTarget.row) {
            moves.push({ 
                row: this.enPassantTarget.row, 
                col: this.enPassantTarget.col, 
                enPassant: true 
            });
        }

        return moves;
    }

    getRookMoves(row, col) {
        const moves = [];
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        
        for (const [dx, dy] of directions) {
            for (let i = 1; i < 8; i++) {
                const newRow = row + dx * i;
                const newCol = col + dy * i;
                
                if (!this.isValidSquare(newRow, newCol)) break;
                
                const target = this.board[newRow][newCol];
                if (!target) {
                    moves.push({ row: newRow, col: newCol });
                } else {
                    if (target.color !== this.board[row][col].color) {
                        moves.push({ row: newRow, col: newCol, capture: true });
                    }
                    break;
                }
            }
        }
        
        return moves;
    }

    getKnightMoves(row, col) {
        const moves = [];
        const knightMoves = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1]
        ];
        
        for (const [dx, dy] of knightMoves) {
            const newRow = row + dx;
            const newCol = col + dy;
            
            if (this.isValidSquare(newRow, newCol)) {
                const target = this.board[newRow][newCol];
                if (!target || target.color !== this.board[row][col].color) {
                    moves.push({ 
                        row: newRow, 
                        col: newCol, 
                        capture: !!target 
                    });
                }
            }
        }
        
        return moves;
    }

    getBishopMoves(row, col) {
        const moves = [];
        const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        
        for (const [dx, dy] of directions) {
            for (let i = 1; i < 8; i++) {
                const newRow = row + dx * i;
                const newCol = col + dy * i;
                
                if (!this.isValidSquare(newRow, newCol)) break;
                
                const target = this.board[newRow][newCol];
                if (!target) {
                    moves.push({ row: newRow, col: newCol });
                } else {
                    if (target.color !== this.board[row][col].color) {
                        moves.push({ row: newRow, col: newCol, capture: true });
                    }
                    break;
                }
            }
        }
        
        return moves;
    }

    getQueenMoves(row, col) {
        return [...this.getRookMoves(row, col), ...this.getBishopMoves(row, col)];
    }

    getKingMoves(row, col) {
        const moves = [];
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];
        
        for (const [dx, dy] of directions) {
            const newRow = row + dx;
            const newCol = col + dy;
            
            if (this.isValidSquare(newRow, newCol)) {
                const target = this.board[newRow][newCol];
                if (!target || target.color !== this.board[row][col].color) {
                    moves.push({ 
                        row: newRow, 
                        col: newCol, 
                        capture: !!target 
                    });
                }
            }
        }

        // Castling
        if (this.canCastle('kingside')) {
            moves.push({ row, col: col + 2, castling: 'kingside' });
        }
        if (this.canCastle('queenside')) {
            moves.push({ row, col: col - 2, castling: 'queenside' });
        }
        
        return moves;
    }

    canCastle(side) {
        const color = this.currentPlayer;
        const row = color === 'white' ? 7 : 0;
        
        // Check castling rights
        if (!this.castlingRights[color][side]) return false;
        
        // Check if king is in check
        if (this.isInCheck) return false;
        
        // Check if squares are empty and not under attack
        if (side === 'kingside') {
            return !this.board[row][5] && !this.board[row][6] &&
                   !this.isSquareUnderAttack(row, 5, color) &&
                   !this.isSquareUnderAttack(row, 6, color);
        } else {
            return !this.board[row][1] && !this.board[row][2] && !this.board[row][3] &&
                   !this.isSquareUnderAttack(row, 2, color) &&
                   !this.isSquareUnderAttack(row, 3, color);
        }
    }

    isSquareUnderAttack(row, col, byColor) {
        const originalPiece = this.board[row][col];
        this.board[row][col] = null;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = this.board[r][c];
                if (piece && piece.color !== byColor) {
                    const moves = this.getPossibleMovesForAttackCheck(r, c);
                    if (moves.some(move => move.row === row && move.col === col)) {
                        this.board[row][col] = originalPiece;
                        return true;
                    }
                }
            }
        }
        
        this.board[row][col] = originalPiece;
        return false;
    }

    getPossibleMovesForAttackCheck(row, col) {
        // Simplified move generation for attack checking (no recursion)
        const piece = this.board[row][col];
        if (!piece) return [];

        switch (piece.type) {
            case 'pawn':
                return this.getPawnAttacks(row, col);
            case 'rook':
                return this.getRookMoves(row, col);
            case 'knight':
                return this.getKnightMoves(row, col);
            case 'bishop':
                return this.getBishopMoves(row, col);
            case 'queen':
                return this.getQueenMoves(row, col);
            case 'king':
                return this.getKingMovesSimple(row, col);
            default:
                return [];
        }
    }

    getPawnAttacks(row, col) {
        const moves = [];
        const piece = this.board[row][col];
        const direction = piece.color === 'white' ? -1 : 1;

        // Only capture moves for attack checking
        for (const captureCol of [col - 1, col + 1]) {
            if (this.isValidSquare(row + direction, captureCol)) {
                moves.push({ row: row + direction, col: captureCol });
            }
        }
        return moves;
    }

    getKingMovesSimple(row, col) {
        const moves = [];
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];
        
        for (const [dx, dy] of directions) {
            const newRow = row + dx;
            const newCol = col + dy;
            
            if (this.isValidSquare(newRow, newCol)) {
                moves.push({ row: newRow, col: newCol });
            }
        }
        return moves;
    }

    wouldBeInCheck(fromRow, fromCol, toRow, toCol) {
        // Temporarily make the move
        const originalPiece = this.board[toRow][toCol];
        const movingPiece = this.board[fromRow][fromCol];
        
        this.board[toRow][toCol] = movingPiece;
        this.board[fromRow][fromCol] = null;
        
        // Find king position
        let kingRow = -1, kingCol = -1;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = this.board[r][c];
                if (piece && piece.type === 'king' && piece.color === this.currentPlayer) {
                    kingRow = r;
                    kingCol = c;
                    break;
                }
            }
            if (kingRow !== -1) break;
        }
        
        // Check if king would be under attack
        const wouldBeInCheck = this.isSquareUnderAttack(kingRow, kingCol, this.currentPlayer);
        
        // Restore board
        this.board[fromRow][fromCol] = movingPiece;
        this.board[toRow][toCol] = originalPiece;
        
        return wouldBeInCheck;
    }

    makeMove(fromRow, fromCol, toRow, toCol) {
        const piece = this.board[fromRow][fromCol];
        if (!piece || piece.color !== this.currentPlayer) return false;

        const possibleMoves = this.getPossibleMoves(fromRow, fromCol);
        const move = possibleMoves.find(m => m.row === toRow && m.col === toCol);
        
        if (!move) return false;

        // Execute the move
        const capturedPiece = this.board[toRow][toCol];
        this.board[toRow][toCol] = piece;
        this.board[fromRow][fromCol] = null;

        // Handle special moves
        if (move.castling) {
            this.executeCastling(move.castling);
        }

        if (move.enPassant) {
            this.board[fromRow][toCol] = null; // Remove captured pawn
        }

        // Handle pawn promotion
        if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
            this.board[toRow][toCol] = { type: 'queen', color: piece.color };
        }

        // Update castling rights
        this.updateCastlingRights(fromRow, fromCol, toRow, toCol);

        // Update en passant target
        this.updateEnPassantTarget(piece, fromRow, toRow, toCol);

        // Record move
        this.lastMove = { fromRow, fromCol, toRow, toCol, piece, captured: capturedPiece };
        this.moveHistory.push(this.lastMove);

        // Switch players
        this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';

        // Check for check/checkmate
        this.updateGameState();

        return true;
    }

    executeCastling(side) {
        const row = this.currentPlayer === 'white' ? 7 : 0;
        
        if (side === 'kingside') {
            // Move rook
            this.board[row][5] = this.board[row][7];
            this.board[row][7] = null;
        } else {
            // Move rook
            this.board[row][3] = this.board[row][0];
            this.board[row][0] = null;
        }
    }

    updateCastlingRights(fromRow, fromCol, toRow, toCol) {
        const piece = this.board[toRow][toCol];
        
        // King moved
        if (piece.type === 'king') {
            this.castlingRights[piece.color].kingside = false;
            this.castlingRights[piece.color].queenside = false;
        }
        
        // Rook moved
        if (piece.type === 'rook') {
            if (fromCol === 0) {
                this.castlingRights[piece.color].queenside = false;
            } else if (fromCol === 7) {
                this.castlingRights[piece.color].kingside = false;
            }
        }
        
        // Rook captured
        if (toRow === 0) {
            if (toCol === 0) this.castlingRights.black.queenside = false;
            if (toCol === 7) this.castlingRights.black.kingside = false;
        } else if (toRow === 7) {
            if (toCol === 0) this.castlingRights.white.queenside = false;
            if (toCol === 7) this.castlingRights.white.kingside = false;
        }
    }

    updateEnPassantTarget(piece, fromRow, toRow, toCol) {
        if (piece.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
            this.enPassantTarget = { row: (fromRow + toRow) / 2, col: toCol };
        } else {
            this.enPassantTarget = null;
        }
    }

    updateGameState() {
        // Check if current player is in check
        this.isInCheck = this.isKingInCheck(this.currentPlayer);
        
        // Check for checkmate or stalemate
        const hasLegalMoves = this.hasLegalMoves(this.currentPlayer);
        
        if (!hasLegalMoves) {
            if (this.isInCheck) {
                this.gameState = this.currentPlayer === 'white' ? 'black-wins' : 'white-wins';
            } else {
                this.gameState = 'stalemate';
            }
        }
    }

    isKingInCheck(color) {
        // Find king
        let kingRow = -1, kingCol = -1;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = this.board[r][c];
                if (piece && piece.type === 'king' && piece.color === color) {
                    kingRow = r;
                    kingCol = c;
                    break;
                }
            }
            if (kingRow !== -1) break;
        }
        
        return this.isSquareUnderAttack(kingRow, kingCol, color);
    }

    hasLegalMoves(color) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = this.board[r][c];
                if (piece && piece.color === color) {
                    const moves = this.getPossibleMoves(r, c);
                    if (moves.length > 0) return true;
                }
            }
        }
        return false;
    }

    getGameStateString() {
        return {
            board: this.board,
            currentPlayer: this.currentPlayer,
            gameState: this.gameState,
            moveHistory: this.moveHistory,
            isInCheck: this.isInCheck,
            castlingRights: this.castlingRights,
            enPassantTarget: this.enPassantTarget
        };
    }
}

// Checkers Game Engine
class CheckersEngine {
    constructor() {
        this.board = this.initializeBoard();
        this.currentPlayer = 'red';
        this.gameState = 'playing';
        this.moveHistory = [];
        this.selectedSquare = null;
        this.mustCapture = false;
        this.captureSequence = [];
        this.redPieces = 12;
        this.blackPieces = 12;
    }

    initializeBoard() {
        const board = Array(8).fill().map(() => Array(8).fill(null));
        
        // Place red pieces (bottom)
        for (let row = 5; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { type: 'man', color: 'red' };
                }
            }
        }
        
        // Place black pieces (top)
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 8; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { type: 'man', color: 'black' };
                }
            }
        }
        
        return board;
    }

    isValidSquare(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8 && (row + col) % 2 === 1;
    }

    getPossibleMoves(row, col) {
        const piece = this.board[row][col];
        if (!piece || piece.color !== this.currentPlayer) return [];

        let moves = [];
        
        if (this.mustCapture) {
            moves = this.getCaptureMoves(row, col);
        } else {
            moves = [...this.getRegularMoves(row, col), ...this.getCaptureMoves(row, col)];
        }

        return moves;
    }

    getRegularMoves(row, col) {
        const moves = [];
        const piece = this.board[row][col];
        const directions = this.getMoveDirections(piece);

        for (const [dr, dc] of directions) {
            const newRow = row + dr;
            const newCol = col + dc;
            
            if (this.isValidSquare(newRow, newCol) && !this.board[newRow][newCol]) {
                moves.push({ row: newRow, col: newCol, type: 'move' });
            }
        }

        return moves;
    }

    getCaptureMoves(row, col) {
        const moves = [];
        const piece = this.board[row][col];
        const directions = this.getMoveDirections(piece);

        for (const [dr, dc] of directions) {
            const jumpRow = row + dr * 2;
            const jumpCol = col + dc * 2;
            const middleRow = row + dr;
            const middleCol = col + dc;
            
            if (this.isValidSquare(jumpRow, jumpCol) && 
                !this.board[jumpRow][jumpCol] &&
                this.board[middleRow] && this.board[middleRow][middleCol] &&
                this.board[middleRow][middleCol].color !== piece.color) {
                
                moves.push({ 
                    row: jumpRow, 
                    col: jumpCol, 
                    type: 'capture',
                    capturedRow: middleRow,
                    capturedCol: middleCol
                });
            }
        }

        return moves;
    }

    getMoveDirections(piece) {
        if (piece.type === 'king') {
            return [[-1, -1], [-1, 1], [1, -1], [1, 1]];
        } else if (piece.color === 'red') {
            return [[-1, -1], [-1, 1]]; // Red moves up
        } else {
            return [[1, -1], [1, 1]]; // Black moves down
        }
    }

    makeMove(fromRow, fromCol, toRow, toCol) {
        const piece = this.board[fromRow][fromCol];
        if (!piece || piece.color !== this.currentPlayer) return false;

        const possibleMoves = this.getPossibleMoves(fromRow, fromCol);
        const move = possibleMoves.find(m => m.row === toRow && m.col === toCol);
        
        if (!move) return false;

        // Execute the move
        this.board[toRow][toCol] = piece;
        this.board[fromRow][fromCol] = null;

        let capturedPiece = null;
        if (move.type === 'capture') {
            capturedPiece = this.board[move.capturedRow][move.capturedCol];
            this.board[move.capturedRow][move.capturedCol] = null;
            
            if (capturedPiece.color === 'red') {
                this.redPieces--;
            } else {
                this.blackPieces--;
            }
        }

        // Check for king promotion
        if (piece.type === 'man') {
            if ((piece.color === 'red' && toRow === 0) || 
                (piece.color === 'black' && toRow === 7)) {
                this.board[toRow][toCol].type = 'king';
            }
        }

        // Record move
        const moveRecord = { 
            fromRow, fromCol, toRow, toCol, 
            piece, captured: capturedPiece, 
            type: move.type 
        };
        this.moveHistory.push(moveRecord);

        // Check for additional captures
        if (move.type === 'capture') {
            const additionalCaptures = this.getCaptureMoves(toRow, toCol);
            if (additionalCaptures.length > 0) {
                this.mustCapture = true;
                this.captureSequence.push(moveRecord);
                return true; // Don't switch players yet
            }
        }

        // Reset capture state and switch players
        this.mustCapture = false;
        this.captureSequence = [];
        this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';

        // Check win condition
        this.updateGameState();

        return true;
    }

    updateGameState() {
        if (this.redPieces === 0) {
            this.gameState = 'black-wins';
        } else if (this.blackPieces === 0) {
            this.gameState = 'red-wins';
        } else if (!this.hasLegalMoves(this.currentPlayer)) {
            this.gameState = this.currentPlayer === 'red' ? 'black-wins' : 'red-wins';
        }
    }

    hasLegalMoves(color) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = this.board[r][c];
                if (piece && piece.color === color) {
                    const moves = this.getPossibleMoves(r, c);
                    if (moves.length > 0) return true;
                }
            }
        }
        return false;
    }

    getGameStateString() {
        return {
            board: this.board,
            currentPlayer: this.currentPlayer,
            gameState: this.gameState,
            moveHistory: this.moveHistory,
            mustCapture: this.mustCapture,
            redPieces: this.redPieces,
            blackPieces: this.blackPieces
        };
    }
}

// Word Game Engine
class WordGameEngine {
    constructor() {
        this.availableLetters = '';
        this.submittedWords = [];
        this.playerScore = 0;
        this.opponentScore = 0;
        this.currentRound = 1;
        this.totalRounds = 3;
        this.timeLimit = 120; // 2 minutes per round
        this.timeRemaining = this.timeLimit;
        this.gameState = 'playing';
        this.wordValidationCache = new Map();
        
        this.generateLetters();
    }

    generateLetters() {
        const letterSets = [
            'BLOCKCHAIN',
            'ETHEREUM',
            'DECENTRAL',
            'SMARTCODE',
            'GAMETOKEN',
            'CRYPTOKEY'
        ];
        
        this.availableLetters = letterSets[Math.floor(Math.random() * letterSets.length)];
    }

    canFormWord(word) {
        const wordUpper = word.toUpperCase();
        const availableCount = {};
        
        // Count available letters
        for (const letter of this.availableLetters) {
            availableCount[letter] = (availableCount[letter] || 0) + 1;
        }
        
        // Check if word can be formed
        for (const letter of wordUpper) {
            if (!availableCount[letter] || availableCount[letter] === 0) {
                return false;
            }
            availableCount[letter]--;
        }
        
        return true;
    }

    async validateWord(word) {
        if (word.length < 3) return false;
        if (!this.canFormWord(word)) return false;
        if (this.submittedWords.includes(word.toUpperCase())) return false;

        // Check cache first
        const wordLower = word.toLowerCase();
        if (this.wordValidationCache.has(wordLower)) {
            return this.wordValidationCache.get(wordLower);
        }

        try {
            // Use dictionary API for validation
            const response = await fetch(`${DICTIONARY_API.BASE_URL}${wordLower}`);
            const isValid = response.ok;
            
            this.wordValidationCache.set(wordLower, isValid);
            return isValid;
        } catch (error) {
            // Fallback to basic word list for demo
            const commonWords = [
                'cat', 'dog', 'car', 'book', 'game', 'code', 'block', 'chain',
                'coin', 'token', 'key', 'lock', 'hack', 'link', 'node', 'data',
                'tech', 'core', 'name', 'rock', 'back', 'lack', 'neck', 'deck'
            ];
            return commonWords.includes(wordLower);
        }
    }

    calculateScore(word) {
        const baseScore = word.length;
        const lengthBonus = word.length > 5 ? (word.length - 5) * 2 : 0;
        let specialBonus = 0;

        // Bonus for using uncommon letters
        const uncommonLetters = 'JQXZ';
        for (const letter of word.toUpperCase()) {
            if (uncommonLetters.includes(letter)) {
                specialBonus += 5;
            }
        }

        return baseScore + lengthBonus + specialBonus;
    }

    async submitWord(word) {
        const isValid = await this.validateWord(word);
        if (!isValid) return false;

        const score = this.calculateScore(word);
        this.submittedWords.push(word.toUpperCase());
        this.playerScore += score;

        return { valid: true, score, totalScore: this.playerScore };
    }

    nextRound() {
        if (this.currentRound < this.totalRounds) {
            this.currentRound++;
            this.submittedWords = [];
            this.timeRemaining = this.timeLimit;
            this.generateLetters();
            return true;
        }
        
        this.gameState = this.playerScore > this.opponentScore ? 'player-wins' : 
                        this.playerScore < this.opponentScore ? 'opponent-wins' : 'tie';
        return false;
    }

    getGameStateString() {
        return {
            availableLetters: this.availableLetters,
            submittedWords: this.submittedWords,
            playerScore: this.playerScore,
            opponentScore: this.opponentScore,
            currentRound: this.currentRound,
            totalRounds: this.totalRounds,
            timeRemaining: this.timeRemaining,
            gameState: this.gameState
        };
    }
}
    // Enhanced Blockchain Manager with real contract integration
class BlockchainManager {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.contract = null;
        this.networkInfo = {};
        this.contractAddress = GAME_CONTRACT_ADDRESS;
        this.coreChainId = CORE_CHAIN_ID;
        this.gameEventListeners = new Map();
    }

    async initialize() {
        try {
            if (typeof window.ethereum === 'undefined') {
                console.log('MetaMask not detected');
                this.showMetaMaskInstallPrompt();
                return false;
            }

            this.provider = new ethers.providers.Web3Provider(window.ethereum);
            await this.updateNetworkInfo();
            
            this.contract = new ethers.Contract(
                this.contractAddress,
                GAME_CONTRACT_ABI,
                this.provider
            );

            this.setupEventListeners();
            return true;
        } catch (error) {
            console.error('Blockchain initialization failed:', error);
            throw error;
        }
    }

    showMetaMaskInstallPrompt() {
        const installModal = document.createElement('div');
        installModal.className = 'age-verification';
        installModal.innerHTML = `
            <div class="verification-content">
                <h1><i class="fas fa-wallet"></i> MetaMask Required</h1>
                <p>To play on CrossRealm with real CORE tokens, you need MetaMask wallet installed.</p>
                <div class="warning">
                    <p><i class="fas fa-info-circle"></i> MetaMask is a secure wallet for interacting with blockchain applications.</p>
                </div>
                <div class="verification-buttons">
                    <button class="verify-btn accept" onclick="window.open('https://metamask.io/download/', '_blank')">
                        Install MetaMask
                    </button>
                    <button class="verify-btn decline" onclick="this.parentElement.parentElement.parentElement.remove(); demoMode();">
                        Continue in Demo Mode
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(installModal);
    }

    async connectWallet() {
        try {
            if (!window.ethereum) {
                throw new Error('MetaMask not installed');
            }

            const accounts = await window.ethereum.request({
                method: 'eth_requestAccounts'
            });

            if (accounts.length === 0) {
                throw new Error('No accounts found');
            }

            userAccount = accounts[0];
            this.signer = this.provider.getSigner();
            
            if (this.contract) {
                this.contract = this.contract.connect(this.signer);
            }

            await this.ensureCorrectNetwork();

            const balance = await this.provider.getBalance(userAccount);
            currentBalance = parseFloat(ethers.utils.formatEther(balance));

            return {
                account: userAccount,
                balance: currentBalance
            };
        } catch (error) {
            console.error('Wallet connection failed:', error);
            throw error;
        }
    }

    async ensureCorrectNetwork() {
        const network = await this.provider.getNetwork();
        const coreChainId = parseInt(this.coreChainId, 16);
        
        if (network.chainId !== coreChainId) {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: this.coreChainId }],
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: this.coreChainId,
                            chainName: 'Core Blockchain Mainnet',
                            nativeCurrency: {
                                name: 'Core',
                                symbol: 'CORE',
                                decimals: 18
                            },
                            rpcUrls: ['https://rpc.coredao.org'],
                            blockExplorerUrls: ['https://scan.coredao.org']
                        }],
                    });
                } else {
                    throw switchError;
                }
            }
        }
    }

    setupEventListeners() {
        if (!this.contract) return;

        this.contract.on('GameCreated', (gameId, creator, stake, gameType, event) => {
            this.handleGameCreated({ gameId, creator, stake, gameType, event });
        });

        this.contract.on('GameJoined', (gameId, player, event) => {
            this.handleGameJoined({ gameId, player, event });
        });

        this.contract.on('GameFinalized', (gameId, winner, payout, event) => {
            this.handleGameFinalized({ gameId, winner, payout, event });
        });
    }

    handleGameCreated(data) {
        console.log('Game created on blockchain:', data);
        if (window.gameManager) {
            window.gameManager.onGameCreated(data);
        }
    }

    handleGameJoined(data) {
        console.log('Game joined on blockchain:', data);
        refreshLobby();
    }

    handleGameFinalized(data) {
        console.log('Game finalized on blockchain:', data);
        if (data.winner === userAccount) {
            showSettlementModal({
                isWinner: true,
                winnings: parseFloat(ethers.utils.formatEther(data.payout)),
                totalStake: parseFloat(ethers.utils.formatEther(data.payout)) * 2,
                platformFee: parseFloat(ethers.utils.formatEther(data.payout)) * 0.03,
                blockchainGameId: data.gameId.toString(),
                gameType: 'demo'
            });
        }
    }

    async updateNetworkInfo() {
        try {
            const network = await this.provider.getNetwork();
            const blockNumber = await this.provider.getBlockNumber();
            const gasPrice = await this.provider.getGasPrice();

            this.networkInfo = {
                chainId: network.chainId,
                name: network.name,
                blockNumber: blockNumber,
                gasPrice: ethers.utils.formatUnits(gasPrice, 'gwei')
            };

            this.updateNetworkDisplay();
        } catch (error) {
            console.error('Failed to update network info:', error);
        }
    }

    updateNetworkDisplay() {
        const blockHeightEl = document.getElementById('blockHeight');
        const gasPriceEl = document.getElementById('gasPrice');
        
        if (blockHeightEl) blockHeightEl.textContent = this.networkInfo.blockNumber?.toLocaleString() || '-';
        if (gasPriceEl) gasPriceEl.textContent = `${this.networkInfo.gasPrice || '-'} gwei`;
    }

    cleanup() {
        if (this.contract) {
            this.contract.removeAllListeners();
        }
    }
}

// Enhanced API Manager for JSONBin.io integration
class APIManager {
    constructor() {
        this.config = JSONBIN_API_CONFIG;
        this.headers = {
            'Content-Type': 'application/json',
            'X-Master-Key': this.config.MASTER_KEY,
            'X-Access-Key': this.config.ACCESS_KEY
        };
    }

    async saveGameData(gameData) {
        try {
            const response = await fetch(`${this.config.BASE_URL}/b/${this.config.BIN_ID}`, {
                method: 'PUT',
                headers: this.headers,
                body: JSON.stringify({
                    games: globalGamesList,
                    activeGames: myActiveGames,
                    tournaments: tournaments,
                    lastUpdated: Date.now()
                })
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            const result = await response.json();
            console.log('Game data saved to API:', result);
            return result;
        } catch (error) {
            console.error('Failed to save game data:', error);
            return null;
        }
    }

    async loadGameData() {
        try {
            const response = await fetch(`${this.config.BASE_URL}/b/${this.config.BIN_ID}/latest`, {
                method: 'GET',
                headers: this.headers
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            const result = await response.json();
            console.log('Game data loaded from API:', result);
            return result.record;
        } catch (error) {
            console.error('Failed to load game data:', error);
            return null;
        }
    }

    async updatePlayerStats(playerAddress, stats) {
        try {
            const currentData = await this.loadGameData() || {};
            if (!currentData.playerStats) {
                currentData.playerStats = {};
            }
            
            currentData.playerStats[playerAddress] = {
                ...currentData.playerStats[playerAddress],
                ...stats,
                lastUpdated: Date.now()
            };

            return await this.saveGameData(currentData);
        } catch (error) {
            console.error('Failed to update player stats:', error);
            return null;
        }
    }
}

// Real-time Multiplayer Manager
class MultiplayerManager {
    constructor() {
        this.socket = null;
      this.gameRooms = new Map();
        this.playerConnections = new Map();
        this.gameStates = new Map();
        this.serverUrl = 'wss://crossrealm-server.herokuapp.com'; // Fallback to demo mode
    }

    async connect() {
        try {
            // For demo purposes, we'll simulate WebSocket connection
            this.simulateConnection();
        } catch (error) {
            console.error('Failed to connect to multiplayer server:', error);
            this.simulateConnection();
        }
    }

    simulateConnection() {
        // Simulate WebSocket events for demo
        this.socket = {
            connected: true,
            emit: (event, data) => {
                console.log('Simulated emit:', event, data);
                // Simulate server responses
                setTimeout(() => {
                    if (event === 'joinGame') {
                        this.handleGameJoined(data);
                    } else if (event === 'makeMove') {
                        this.handleMoveReceived(data);
                    }
                }, 100);
            },
            on: (event, callback) => {
                console.log('Simulated listener for:', event);
            }
        };

        console.log('Multiplayer manager connected (demo mode)');
    }

    joinGameRoom(gameId, gameType) {
        if (this.socket && this.socket.connected) {
            this.socket.emit('joinGame', {
                gameId,
                gameType,
                playerAddress: userAccount
            });
        }
    }

    sendMove(gameId, moveData) {
        if (this.socket && this.socket.connected) {
            this.socket.emit('makeMove', {
                gameId,
                move: moveData,
                playerAddress: userAccount,
                timestamp: Date.now()
            });
        }
    }

    handleGameJoined(data) {
        console.log('Joined game room:', data);
        // Update UI to show opponent connected
        updateGameStatus(data.gameId, 'opponent-joined');
    }

    handleMoveReceived(data) {
        console.log('Move received:', data);
        // Update game state and UI
        if (currentGameState && currentGameState.gameId === data.gameId) {
            // Apply opponent's move
            this.applyOpponentMove(data.move);
        }
    }

    applyOpponentMove(moveData) {
        // Apply move based on game type
        if (activeGameType === 'chess' && window.chessEngine) {
            window.chessEngine.makeMove(
                moveData.fromRow, moveData.fromCol,
                moveData.toRow, moveData.toCol
            );
            updateChessBoard();
        } else if (activeGameType === 'checkers' && window.checkersEngine) {
            window.checkersEngine.makeMove(
                moveData.fromRow, moveData.fromCol,
                moveData.toRow, moveData.toCol
            );
            updateCheckersBoard();
        }
    }

    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
        }
    }
}

// Initialize global managers
window.blockchainManager = new BlockchainManager();
window.playerProgression = new PlayerProgression();
window.apiManager = new APIManager();
window.multiplayerManager = new MultiplayerManager();

// Age verification functions
function checkAgeVerification() {
    try {
        const verified = localStorage.getItem('ageVerified');
        if (verified === 'true') {
            const modal = document.getElementById('ageVerificationModal');
            if (modal) modal.style.display = 'none';
            return true;
        }
        return false;
    } catch (error) {
        console.log('localStorage not available, showing verification modal');
        return false;
    }
}

function verifyAge(isAdult) {
    if (isAdult) {
        try {
            localStorage.setItem('ageVerified', 'true');
        } catch (error) {
            console.log('localStorage not available');
        }
        const modal = document.getElementById('ageVerificationModal');
        if (modal) modal.style.display = 'none';
        initializePlatform();
    } else {
        alert('You must be 18 or older to access this platform.');
        window.location.href = 'https://www.google.com';
    }
}

// Enhanced navigation functions with proper event handling
function showSection(sectionName) {
    // Hide all sections
    const sections = ['lobbySection', 'activeSection', 'createSection', 'gamesSection', 
                     'tournamentsSection', 'profileSection', 'chatSection', 'settingsSection'];
    
    sections.forEach(section => {
        const element = document.getElementById(section);
        if (element) element.classList.add('hidden');
    });

    // Show target section
    const targetSection = document.getElementById(sectionName + 'Section');
    if (targetSection) {
        targetSection.classList.remove('hidden');
    }

    // Update navigation
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Set active nav item based on content
    const navItems = document.querySelectorAll('.nav-item');
    navItems.forEach(item => {
        const itemText = item.textContent.toLowerCase();
        if ((sectionName === 'lobby' && itemText.includes('lobby')) ||
            (sectionName === 'active' && itemText.includes('my games')) ||
            (sectionName === 'create' && itemText.includes('create')) ||
            (sectionName === 'games' && itemText.includes('games') && !itemText.includes('my')) ||
            (sectionName === 'tournaments' && itemText.includes('tournaments')) ||
            (sectionName === 'profile' && itemText.includes('profile')) ||
            (sectionName === 'chat' && itemText.includes('chat')) ||
            (sectionName === 'settings' && itemText.includes('settings'))) {
            item.classList.add('active');
        }
    });

    currentSection = sectionName;
    
    // Load specific section data
    if (sectionName === 'tournaments') {
        refreshTournaments();
    } else if (sectionName === 'profile') {
        updateProfileDisplay();
    } else if (sectionName === 'active') {
        refreshActiveGames();
    } else if (sectionName === 'lobby') {
        refreshLobby();
    }
}

// Enhanced wallet connection with better error handling and real blockchain integration
async function connectWallet() {
    try {
        showTransactionStatus('🔄 Connecting to MetaMask...', '');
        updateConnectionStatus('pending');

        const initialized = await window.blockchainManager.initialize();
        if (!initialized) {
            return demoMode();
        }

        const walletResult = await window.blockchainManager.connectWallet();
        userAccount = walletResult.account;
        currentBalance = walletResult.balance;

        updateConnectionStatus('connected');
        updateBalanceDisplay();
        updateWalletButtons(true);

        showTransactionStatus('✅ Wallet connected to Core Blockchain!', '');

        // Setup event listeners for account/network changes
        if (window.ethereum && window.ethereum.on) {
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
        }

        // Initialize enhanced features
        window.playerProgression.updateProgressDisplay();

        // Load real games from API
        await loadRealGamesFromAPI();
        
        // Save connection state
        try {
            localStorage.setItem('walletConnected', 'true');
        } catch (error) {
            console.log('localStorage not available');
        }

        // Start real-time updates
        startRealTimeUpdates();

        // Connect to multiplayer
        await window.multiplayerManager.connect();

    } catch (error) {
        console.error('Failed to connect wallet:', error);
        showTransactionStatus('❌ Failed to connect wallet: ' + error.message, '');
        updateConnectionStatus('disconnected');
        
        // Offer demo mode as fallback
        setTimeout(() => {
            if (confirm('Wallet connection failed. Would you like to try demo mode instead?')) {
                demoMode();
            }
        }, 2000);
    }
}

// Enhanced demo mode fallback
function demoMode() {
    showTransactionStatus('🎮 Entering demo mode...', '');
    
    setTimeout(() => {
        userAccount = '0x' + Math.random().toString(16).slice(2, 42);
        currentBalance = Math.random() * 10 + 5;
        
        updateConnectionStatus('connected');
        updateBalanceDisplay();
        updateWalletButtons(true);
        
        showTransactionStatus('✅ Demo mode activated!', '');
        updateContractStatus('demo', 'Demo Mode - No Real Transactions');
        
        // Initialize demo features
        window.playerProgression.updateProgressDisplay();
        
        refreshLobby();
        refreshActiveGames();
        
        // Generate demo games
        generateDemoGames();

        // Connect to demo multiplayer
        window.multiplayerManager.simulateConnection();
    }, 1500);
}

// Game creation and management functions
function selectGameType(gameType) {
    selectedGameType = gameType;
    
    // Update UI
    document.querySelectorAll('.game-type-card').forEach(card => {
        card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`[data-type="${gameType}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    
    updateCreateButton();
}

function updateCreateButton() {
    const createBtn = document.getElementById('createGameBtn');
    const stakeInput = document.getElementById('gameStake');
    
    if (!createBtn || !stakeInput) return;

    const stakeAmount = parseFloat(stakeInput.value) || 0;
    const hasGameType = selectedGameType !== null;
    const hasValidStake = stakeAmount >= 0.01;
    
    if (hasGameType && hasValidStake) {
        createBtn.disabled = false;
        createBtn.innerHTML = `<i class="fas fa-plus"></i> Create ${selectedGameType.charAt(0).toUpperCase() + selectedGameType.slice(1)} Game (${stakeAmount} CORE)`;
    } else if (hasGameType) {
        createBtn.disabled = true;
        createBtn.innerHTML = `<i class="fas fa-plus"></i> Enter Stake Amount (min 0.01 CORE)`;
    } else {
        createBtn.disabled = true;
        createBtn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type & Enter Stake`;
    }
}

function setStake(amount) {
    const stakeInput = document.getElementById('gameStake');
    if (stakeInput) {
        stakeInput.value = amount;
        updateCreateButton();
    }
}

// Enhanced game creation with real blockchain integration
async function createGame() {
    const stakeInput = document.getElementById('gameStake');
    if (!stakeInput) {
        showTransactionStatus('❌ Stake input not found', '');
        return;
    }
    
    const stakeAmount = parseFloat(stakeInput.value) || 0;
    
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (!selectedGameType) {
        showTransactionStatus('❌ Please select a game type first', '');
        return;
    }
    
    if (stakeAmount < 0.01) {
        showTransactionStatus('❌ Please enter a valid stake amount (minimum 0.01 CORE)', '');
        return;
    }
    
    if (stakeAmount > currentBalance) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }

    try {
        showTransactionStatus('🔄 Creating game...', '');
        
        // Try to create real blockchain game first
        if (window.blockchainManager.contract && !userAccount.startsWith('0x' + Math.random().toString(16).slice(2, 6))) {
            try {
                const timeLimit = selectedGameType === 'chess' ? 600 : selectedGameType === 'checkers' ? 300 : 120;
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                
                const tx = await window.blockchainManager.contract.createGame(selectedGameType, timeLimit, {
                    value: stakeWei,
                    gasLimit: 300000
                });
                
                showTransactionStatus('⏳ Transaction submitted...', tx.hash);
                
                const receipt = await tx.wait();
                showTransactionStatus('✅ Game created on blockchain!', tx.hash);
                
                // Extract game ID from events
                const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
                const gameId = gameCreatedEvent?.args?.gameId?.toString();
                
                if (gameId) {
                    const newGame = {
                        id: gameId,
                        type: selectedGameType,
                        creator: userAccount,
                        stake: stakeAmount,
                        status: 'waiting',
                        createdAt: Date.now(),
                        isDemo: false,
                        txHash: tx.hash,
                        blockchainGameId: gameId
                    };

                    globalGamesList.push(newGame);
                    
                    // Save to API
                    await window.apiManager.saveGameData({
                        games: globalGamesList,
                        activeGames: myActiveGames,
                        tournaments: tournaments
                    });
                }
                
                // Update balance
                currentBalance -= stakeAmount;
                updateBalanceDisplay();
                
                // Award XP for game creation
                window.playerProgression.awardXP(50, 'Blockchain Game Created');
                
            } catch (blockchainError) {
                console.error('Blockchain game creation failed, falling back to demo:', blockchainError);
                createDemoGame(stakeAmount);
            }
        } else {
            createDemoGame(stakeAmount);
        }

        // Reset form
        stakeInput.value = '';
        selectedGameType = null;
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        updateCreateButton();

        // Update UI
        updateGamesDisplay();
        showSection('lobby');

    } catch (error) {
        console.error('Failed to create game:', error);
        showTransactionStatus('❌ Failed to create game: ' + error.message, '');
    }
}

function createDemoGame(stakeAmount) {
    // Create demo game
    const newGame = {
        id: Date.now().toString(),
        type: selectedGameType,
        creator: userAccount,
        stake: stakeAmount,
        status: 'waiting',
        createdAt: Date.now(),
        isDemo: true
    };

    globalGamesList.push(newGame);
    currentBalance -= stakeAmount;
    updateBalanceDisplay();

    // Award XP for game creation
    window.playerProgression.awardXP(50, 'Game Created');
    
    addActivityFeedItem(`🎮 You created a ${newGame.type} game with ${stakeAmount} CORE stake`);
    showTransactionStatus('✅ Demo game created successfully!', '');
}

// Game joining functions
async function joinGame(gameId, stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stakeAmount) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }

    const game = globalGamesList.find(g => g.id === gameId);
    if (!game) {
        showTransactionStatus('❌ Game not found', '');
        return;
    }

    showTransactionStatus('🎮 Joining game...', '');
    
    try {
        // Try to join real blockchain game
        if (window.blockchainManager.contract && !game.isDemo && game.blockchainGameId) {
            try {
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                
                const tx = await window.blockchainManager.contract.joinGame(game.blockchainGameId, {
                    value: stakeWei,
                    gasLimit: 250000
                });
                
                showTransactionStatus('⏳ Joining blockchain game...', tx.hash);
                
                const receipt = await tx.wait();
                showTransactionStatus('✅ Joined blockchain game!', tx.hash);
                
                // Move game to active games
                game.player2 = userAccount;
                game.status = 'playing';
                game.startedAt = Date.now();
                game.joinTxHash = tx.hash;
                
                myActiveGames.push(game);
                globalGamesList = globalGamesList.filter(g => g.id !== gameId);
                
                currentBalance -= stakeAmount;
                updateBalanceDisplay();
                
                // Award XP for joining game
                window.playerProgression.awardXP(25, 'Blockchain Game Joined');
                
                updateGamesDisplay();
                updateActiveGamesDisplay();
                
                addActivityFeedItem(`⚔️ You joined blockchain game #${gameId} with ${stakeAmount} CORE stake`);
                
                setTimeout(() => {
                    openGameWindow(game.type, game);
                }, 1000);
                
            } catch (blockchainError) {
                console.error('Blockchain join failed, falling back to demo:', blockchainError);
                joinDemoGame(game, stakeAmount);
            }
        } else {
            joinDemoGame(game, stakeAmount);
        }
        
    } catch (error) {
        console.error('Failed to join game:', error);
        showTransactionStatus('❌ Failed to join game: ' + error.message, '');
    }
}

function joinDemoGame(game, stakeAmount) {
    setTimeout(() => {
        game.player2 = userAccount;
        game.status = 'playing';
        game.startedAt = Date.now();
        
        // Move to active games
        myActiveGames.push(game);
        globalGamesList = globalGamesList.filter(g => g.id !== game.id);
        
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        // Award XP for joining game
        window.playerProgression.awardXP(25, 'Game Joined');
        
        updateGamesDisplay();
        updateActiveGamesDisplay();
        
        addActivityFeedItem(`⚔️ You joined game #${game.id} with ${stakeAmount} CORE stake`);
        showTransactionStatus('🎮 Game joined! Opening game window...', '');
        
        setTimeout(() => {
            openGameWindow(game.type, game);
        }, 1000);
    }, 2000);
}

// Enhanced demo game joining for lobby games
function joinDemoGameFromLobby(gameType, stake) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stake) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }

    showTransactionStatus('🎮 Joining demo game...', '');
    
    setTimeout(() => {
        const demoGame = {
            id: Date.now().toString(),
            type: gameType,
            creator: 'DemoPlayer',
            player2: userAccount,
            stake: stake,
            status: 'playing',
            startedAt: Date.now(),
            isDemo: true
        };
        
        myActiveGames.push(demoGame);
        currentBalance -= stake;
        updateBalanceDisplay();
        
        // Award XP for demo game
        window.playerProgression.awardXP(15, 'Demo Game Joined');
        
        updateActiveGamesDisplay();
        
        showTransactionStatus('✅ Demo game joined! Opening game window...', '');
        
        setTimeout(() => {
            openGameWindow(gameType, demoGame);
        }, 1000);
    }, 2000);
}
    // Game window functions with complete game logic
function openGameWindow(gameType, gameData) {
    const windowId = gameType + 'GameWindow';
    const gameWindow = document.getElementById(windowId);
    
    if (!gameWindow) {
        console.error('Game window not found:', windowId);
        return;
    }

    gameWindow.classList.remove('hidden');
    isGameActive = true;
    activeGameType = gameType;
    
    updateGameWindowInfo(gameType, gameData);
    initializeGameBoard(gameType);
    
    // Join multiplayer room
    if (window.multiplayerManager) {
        window.multiplayerManager.joinGameRoom(gameData.id, gameType);
    }
    
    showTransactionStatus(`🎮 ${getGameName(gameType)} opened!`, '');
}

function closeGame(gameType) {
    const windowId = gameType + 'GameWindow';
    const gameWindow = document.getElementById(windowId);
    
    if (gameWindow) {
        gameWindow.classList.add('hidden');
    }
    
    if (activeGameType === gameType) {
        isGameActive = false;
        activeGameType = null;
        
        // Cleanup game engines
        if (gameType === 'chess') {
            window.chessEngine = null;
        } else if (gameType === 'checkers') {
            window.checkersEngine = null;
        } else if (gameType === 'words') {
            window.wordEngine = null;
        }
    }
}

function minimizeGame(gameType) {
    const windowId = gameType + 'GameWindow';
    const gameWindow = document.getElementById(windowId);
    
    if (gameWindow) {
        gameWindow.classList.toggle('minimized');
    }
}

function updateGameWindowInfo(gameType, gameData) {
    const playerNameEl = document.getElementById(gameType + 'PlayerName');
    const opponentNameEl = document.getElementById(gameType + 'OpponentName');
    
    if (playerNameEl) {
        playerNameEl.textContent = gameData.creator === userAccount ? 'You' : 'Player 2';
    }
    
    if (opponentNameEl) {
        const opponent = gameData.creator === userAccount ? gameData.player2 : gameData.creator;
        opponentNameEl.textContent = opponent ? (opponent.substring(0, 6) + '...') : 'Waiting...';
    }
    
    const statusEl = document.getElementById(gameType + 'Status');
    if (statusEl) {
        statusEl.textContent = gameData.status === 'playing' ? 'Game in progress' : 'Waiting for opponent...';
    }
}

function initializeGameBoard(gameType) {
    switch (gameType) {
        case 'chess':
            initializeChessBoard();
            break;
        case 'checkers':
            initializeCheckersBoard();
            break;
        case 'words':
            initializeWordGame();
            break;
    }
}

// Complete Chess Board Implementation
function initializeChessBoard() {
    window.chessEngine = new ChessEngine();
    const board = document.getElementById('chessBoard');
    if (!board) return;

    board.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            square.dataset.square = String.fromCharCode(97 + col) + (8 - row);
            
            const piece = window.chessEngine.board[row][col];
            if (piece) {
                square.textContent = window.chessEngine.getPieceSymbol(piece);
            }
            
            square.addEventListener('click', () => handleChessSquareClick(row, col));
            board.appendChild(square);
        }
    }
    
    updateChessBoard();
}

function handleChessSquareClick(row, col) {
    if (!window.chessEngine) return;
    
    const engine = window.chessEngine;
    const clickedSquare = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (engine.selectedSquare) {
        const [selectedRow, selectedCol] = engine.selectedSquare;
        
        // Try to make a move
        if (engine.makeMove(selectedRow, selectedCol, row, col)) {
            // Move successful
            updateChessBoard();
            clearChessSelection();
            
            // Send move to multiplayer
            if (window.multiplayerManager) {
                window.multiplayerManager.sendMove(currentGameState?.gameId || 'demo', {
                    fromRow: selectedRow,
                    fromCol: selectedCol,
                    toRow: row,
                    toCol: col,
                    gameType: 'chess'
                });
            }
            
            // Check game end
            if (engine.gameState !== 'playing') {
                handleGameEnd(engine.gameState);
            }
            
            // Award XP for move
            window.playerProgression.awardXP(5, 'Chess Move');
            
        } else {
            // Invalid move, try selecting new piece
            clearChessSelection();
            selectChessPiece(row, col);
        }
    } else {
        // Select piece
        selectChessPiece(row, col);
    }
}

function selectChessPiece(row, col) {
    const engine = window.chessEngine;
    const piece = engine.board[row][col];
    
    if (piece && piece.color === engine.currentPlayer) {
        engine.selectedSquare = [row, col];
        engine.legalMoves = engine.getPossibleMoves(row, col);
        
        // Update UI
        const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        square.classList.add('selected');
        
        // Show legal moves
        engine.legalMoves.forEach(move => {
            const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
            if (moveSquare) {
                if (move.capture) {
                    moveSquare.classList.add('capture-move');
                } else {
                    moveSquare.classList.add('legal-move');
                }
            }
        });
    }
}

function clearChessSelection() {
    if (window.chessEngine) {
        window.chessEngine.selectedSquare = null;
        window.chessEngine.legalMoves = [];
    }
    
    document.querySelectorAll('.chess-square').forEach(square => {
        square.classList.remove('selected', 'legal-move', 'capture-move');
    });
}

function updateChessBoard() {
    if (!window.chessEngine) return;
    
    const engine = window.chessEngine;
    
    // Update pieces
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const piece = engine.board[row][col];
            
            if (square) {
                square.textContent = piece ? engine.getPieceSymbol(piece) : '';
                
                // Highlight last move
                if (engine.lastMove && 
                    ((engine.lastMove.fromRow === row && engine.lastMove.fromCol === col) ||
                     (engine.lastMove.toRow === row && engine.lastMove.toCol === col))) {
                    square.classList.add('last-move');
                } else {
                    square.classList.remove('last-move');
                }
                
                // Highlight king in check
                if (piece && piece.type === 'king' && engine.isInCheck && piece.color === engine.currentPlayer) {
                    square.classList.add('check');
                } else {
                    square.classList.remove('check');
                }
            }
        }
    }
    
    // Update move history
    const moveList = document.getElementById('chessMoveList');
    if (moveList) {
        const moves = engine.moveHistory.map((move, index) => {
            const moveNum = Math.floor(index / 2) + 1;
            const player = index % 2 === 0 ? 'White' : 'Black';
            const from = String.fromCharCode(97 + move.fromCol) + (8 - move.fromRow);
            const to = String.fromCharCode(97 + move.toCol) + (8 - move.toRow);
            return `${moveNum}. ${from}-${to}`;
        }).slice(-10).join('\n');
        
        moveList.textContent = moves;
    }
    
    // Update game status
    const statusEl = document.getElementById('chessStatus');
    if (statusEl) {
        if (engine.gameState === 'playing') {
            statusEl.textContent = `${engine.currentPlayer}'s turn`;
            if (engine.isInCheck) {
                statusEl.textContent += ' (Check!)';
            }
        } else {
            statusEl.textContent = getGameEndMessage(engine.gameState);
        }
    }
}

// Complete Checkers Board Implementation
function initializeCheckersBoard() {
    window.checkersEngine = new CheckersEngine();
    const board = document.getElementById('checkersBoard');
    if (!board) return;

    board.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            if ((row + col) % 2 === 1) {
                const piece = window.checkersEngine.board[row][col];
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `checker-piece ${piece.color}-piece`;
                    if (piece.type === 'king') {
                        pieceElement.classList.add('king');
                    }
                    square.appendChild(pieceElement);
                }
            }
            
            square.addEventListener('click', () => handleCheckersSquareClick(row, col));
            board.appendChild(square);
        }
    }
    
    updateCheckersBoard();
}

function handleCheckersSquareClick(row, col) {
    if (!window.checkersEngine) return;
    
    const engine = window.checkersEngine;
    const clickedSquare = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (engine.selectedSquare) {
        const [selectedRow, selectedCol] = engine.selectedSquare;
        
        // Try to make a move
        if (engine.makeMove(selectedRow, selectedCol, row, col)) {
            // Move successful
            updateCheckersBoard();
            clearCheckersSelection();
            
            // Send move to multiplayer
            if (window.multiplayerManager) {
                window.multiplayerManager.sendMove(currentGameState?.gameId || 'demo', {
                    fromRow: selectedRow,
                    fromCol: selectedCol,
                    toRow: row,
                    toCol: col,
                    gameType: 'checkers'
                });
            }
            
            // Check game end
            if (engine.gameState !== 'playing') {
                handleGameEnd(engine.gameState);
            }
            
            // Award XP for move
            window.playerProgression.awardXP(5, 'Checkers Move');
            
        } else {
            // Invalid move, try selecting new piece
            clearCheckersSelection();
            selectCheckersPiece(row, col);
        }
    } else {
        // Select piece
        selectCheckersPiece(row, col);
    }
}

function selectCheckersPiece(row, col) {
    const engine = window.checkersEngine;
    const piece = engine.board[row][col];
    
    if (piece && piece.color === engine.currentPlayer) {
        engine.selectedSquare = [row, col];
        engine.legalMoves = engine.getPossibleMoves(row, col);
        
        // Update UI
        const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        square.classList.add('selected');
        
        // Show legal moves
        engine.legalMoves.forEach(move => {
            const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
            if (moveSquare) {
                moveSquare.classList.add('legal-move');
            }
        });
    }
}

function clearCheckersSelection() {
    if (window.checkersEngine) {
        window.checkersEngine.selectedSquare = null;
        window.checkersEngine.legalMoves = [];
    }
    
    document.querySelectorAll('.checkers-square').forEach(square => {
        square.classList.remove('selected', 'legal-move');
    });
}

function updateCheckersBoard() {
    if (!window.checkersEngine) return;
    
    const engine = window.checkersEngine;
    
    // Update piece counts
    const redCountEl = document.getElementById('redPiecesCount');
    const blackCountEl = document.getElementById('blackPiecesCount');
    
    if (redCountEl) redCountEl.textContent = engine.redPieces;
    if (blackCountEl) blackCountEl.textContent = engine.blackPieces;
    
    // Update pieces on board
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (!square || (row + col) % 2 === 0) continue;
            
            // Clear existing pieces
            const existingPiece = square.querySelector('.checker-piece');
            if (existingPiece) {
                existingPiece.remove();
            }
            
            // Add new piece if exists
            const piece = engine.board[row][col];
            if (piece) {
                const pieceElement = document.createElement('div');
                pieceElement.className = `checker-piece ${piece.color}-piece`;
                if (piece.type === 'king') {
                    pieceElement.classList.add('king');
                }
                square.appendChild(pieceElement);
            }
        }
    }
    
    // Update game status
    const statusEl = document.getElementById('checkersStatus');
    if (statusEl) {
        if (engine.gameState === 'playing') {
            statusEl.textContent = `${engine.currentPlayer}'s turn`;
            if (engine.mustCapture) {
                statusEl.textContent += ' (Must capture!)';
            }
        } else {
            statusEl.textContent = getGameEndMessage(engine.gameState);
        }
    }
}

// Complete Word Game Implementation
function initializeWordGame() {
    window.wordEngine = new WordGameEngine();
    const engine = window.wordEngine;
    
    // Update UI elements
    const lettersEl = document.getElementById('wordLetters');
    const inputEl = document.getElementById('wordInput');
    const validationEl = document.getElementById('wordValidation');
    
    if (lettersEl) {
        lettersEl.textContent = engine.availableLetters;
    }
    
    if (inputEl) {
        inputEl.value = '';
        inputEl.focus();
        
        // Add real-time validation
        inputEl.addEventListener('input', validateWordInput);
        inputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitWord();
            }
        });
    }
    
    updateWordGameUI();
    startWordGameTimer();
}

function validateWordInput() {
    const inputEl = document.getElementById('wordInput');
    const validationEl = document.getElementById('wordValidation');
    const baseScoreEl = document.getElementById('baseScore');
    const lengthBonusEl = document.getElementById('lengthBonus');
    const specialBonusEl = document.getElementById('specialBonus');
    const roundScoreEl = document.getElementById('roundScore');
    
    if (!inputEl || !window.wordEngine) return;
    
    const word = inputEl.value.trim().toUpperCase();
    const engine = window.wordEngine;
    
    if (word.length === 0) {
        if (validationEl) validationEl.textContent = '';
        updateScoreBreakdown(0, 0, 0, 0);
        return;
    }
    
    if (word.length < 3) {
        if (validationEl) {
            validationEl.textContent = 'Word must be at least 3 letters';
            validationEl.className = 'word-validation invalid';
        }
        updateScoreBreakdown(0, 0, 0, 0);
        return;
    }
    
    if (!engine.canFormWord(word)) {
        if (validationEl) {
            validationEl.textContent = 'Cannot form word with available letters';
            validationEl.className = 'word-validation invalid';
        }
        updateScoreBreakdown(0, 0, 0, 0);
        return;
    }
    
    if (engine.submittedWords.includes(word)) {
        if (validationEl) {
            validationEl.textContent = 'Word already used';
            validationEl.className = 'word-validation invalid';
        }
        updateScoreBreakdown(0, 0, 0, 0);
        return;
    }
    
    // Calculate potential score
    const baseScore = word.length;
    const lengthBonus = word.length > 5 ? (word.length - 5) * 2 : 0;
    let specialBonus = 0;
    
    const uncommonLetters = 'JQXZ';
    for (const letter of word) {
        if (uncommonLetters.includes(letter)) {
            specialBonus += 5;
        }
    }
    
    const totalScore = baseScore + lengthBonus + specialBonus;
    
    if (validationEl) {
        validationEl.textContent = 'Ready to submit!';
        validationEl.className = 'word-validation valid';
    }
    
    updateScoreBreakdown(baseScore, lengthBonus, specialBonus, totalScore);
}

function updateScoreBreakdown(base, length, special, total) {
    const baseScoreEl = document.getElementById('baseScore');
    const lengthBonusEl = document.getElementById('lengthBonus');
    const specialBonusEl = document.getElementById('specialBonus');
    const roundScoreEl = document.getElementById('roundScore');
    
    if (baseScoreEl) baseScoreEl.textContent = base;
    if (lengthBonusEl) lengthBonusEl.textContent = length;
    if (specialBonusEl) specialBonusEl.textContent = special;
    if (roundScoreEl) roundScoreEl.textContent = total;
}

async function submitWord() {
    const inputEl = document.getElementById('wordInput');
    const validationEl = document.getElementById('wordValidation');
    
    if (!inputEl || !window.wordEngine) return;
    
    const word = inputEl.value.trim();
    if (word.length < 3) return;
    
    const engine = window.wordEngine;
    
    try {
        validationEl.textContent = 'Validating...';
        validationEl.className = 'word-validation';
        
        const result = await engine.submitWord(word);
        
        if (result.valid) {
            // Add word to submitted list
            const wordsListEl = document.getElementById('submittedWordsList');
            if (wordsListEl) {
                const wordChip = document.createElement('div');
                wordChip.className = 'word-chip';
                wordChip.textContent = `${word.toUpperCase()} (${result.score})`;
                wordsListEl.appendChild(wordChip);
            }
            
            // Update scores
            const playerScoreEl = document.getElementById('playerWordScore');
            if (playerScoreEl) {
                playerScoreEl.textContent = result.totalScore;
            }
            
            // Clear input
            inputEl.value = '';
            validationEl.textContent = `+${result.score} points!`;
            validationEl.className = 'word-validation valid';
            
            // Award XP
            window.playerProgression.awardXP(result.score, 'Word Submitted');
            
            // Send to multiplayer
            if (window.multiplayerManager) {
                window.multiplayerManager.sendMove(currentGameState?.gameId || 'demo', {
                    word: word.toUpperCase(),
                    score: result.score,
                    gameType: 'words'
                });
            }
            
            setTimeout(() => {
                if (validationEl) validationEl.textContent = '';
                updateScoreBreakdown(0, 0, 0, 0);
            }, 2000);
            
        } else {
            validationEl.textContent = 'Invalid word';
            validationEl.className = 'word-validation invalid';
        }
        
    } catch (error) {
        console.error('Word validation error:', error);
        validationEl.textContent = 'Validation failed';
        validationEl.className = 'word-validation invalid';
    }
}

function shuffleLetters() {
    if (!window.wordEngine) return;
    
    const lettersEl = document.getElementById('wordLetters');
    if (lettersEl) {
        // Shuffle the display of letters
        const letters = window.wordEngine.availableLetters.split('');
        for (let i = letters.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [letters[i], letters[j]] = [letters[j], letters[i]];
        }
        lettersEl.textContent = letters.join('');
    }
}

function skipRound() {
    if (!window.wordEngine) return;
    
    const engine = window.wordEngine;
    
    if (engine.nextRound()) {
        // Continue to next round
        const lettersEl = document.getElementById('wordLetters');
        const wordsListEl = document.getElementById('submittedWordsList');
        const inputEl = document.getElementById('wordInput');
        const validationEl = document.getElementById('wordValidation');
        
        if (lettersEl) lettersEl.textContent = engine.availableLetters;
        if (wordsListEl) wordsListEl.innerHTML = '';
        if (inputEl) inputEl.value = '';
        if (validationEl) validationEl.textContent = '';
        
        updateWordGameUI();
        startWordGameTimer();
        
    } else {
        // Game finished
        handleGameEnd(engine.gameState);
    }
}

function startWordGameTimer() {
    if (!window.wordEngine) return;
    
    const engine = window.wordEngine;
    const timerEl = document.getElementById('wordPlayerTimer');
    
    if (window.wordGameTimer) {
        clearInterval(window.wordGameTimer);
    }
    
    window.wordGameTimer = setInterval(() => {
        engine.timeRemaining--;
        
        if (timerEl) {
            const minutes = Math.floor(engine.timeRemaining / 60);
            const seconds = engine.timeRemaining % 60;
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        if (engine.timeRemaining <= 0) {
            clearInterval(window.wordGameTimer);
            skipRound();
        }
    }, 1000);
}

function updateWordGameUI() {
    if (!window.wordEngine) return;
    
    const engine = window.wordEngine;
    
    // Update round indicator
    const roundDots = document.querySelectorAll('.round-dot');
    roundDots.forEach((dot, index) => {
        dot.classList.remove('active', 'completed');
        if (index + 1 === engine.currentRound) {
            dot.classList.add('active');
        } else if (index + 1 < engine.currentRound) {
            dot.classList.add('completed');
        }
    });
    
    // Update status
    const statusEl = document.getElementById('wordStatus');
    if (statusEl) {
        statusEl.textContent = `Round ${engine.currentRound} of ${engine.totalRounds}`;
    }
}

// Game control functions
function resignGame() {
    if (confirm('Are you sure you want to resign? You will lose the game.')) {
        handleGameEnd('resign');
    }
}

function offerDraw() {
    if (confirm('Offer a draw to your opponent?')) {
        showTransactionStatus('Draw offer sent to opponent', '');
        // In a real implementation, this would send a draw offer through multiplayer
    }
}

function requestUndo() {
    if (confirm('Request to undo the last move?')) {
        showTransactionStatus('Undo request sent to opponent', '');
        // In a real implementation, this would send an undo request through multiplayer
    }
}

function analyzePosition() {
    showTransactionStatus('Opening position analysis...', '');
    // In a real implementation, this would open an analysis window
}

function showPossibleMoves() {
    if (!window.checkersEngine) return;
    
    const engine = window.checkersEngine;
    
    // Highlight all possible moves for current player
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = engine.board[row][col];
            if (piece && piece.color === engine.currentPlayer) {
                const moves = engine.getPossibleMoves(row, col);
                moves.forEach(move => {
                    const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                    if (square) {
                        square.classList.add('legal-move');
                    }
                });
            }
        }
    }
    
    // Clear highlights after 3 seconds
    setTimeout(() => {
        document.querySelectorAll('.checkers-square').forEach(square => {
            square.classList.remove('legal-move');
        });
    }, 3000);
}

// Game end handling
function handleGameEnd(gameResult) {
    let isWinner = false;
    let message = '';
    
    switch (gameResult) {
        case 'white-wins':
            isWinner = window.chessEngine?.currentPlayer !== 'white';
            message = isWinner ? 'You won!' : 'You lost!';
            break;
        case 'black-wins':
            isWinner = window.chessEngine?.currentPlayer !== 'black';
            message = isWinner ? 'You won!' : 'You lost!';
            break;
        case 'red-wins':
            isWinner = window.checkersEngine?.currentPlayer !== 'red';
            message = isWinner ? 'You won!' : 'You lost!';
            break;
        case 'black-wins':
            isWinner = window.checkersEngine?.currentPlayer !== 'black';
            message = isWinner ? 'You won!' : 'You lost!';
            break;
        case 'player-wins':
            isWinner = true;
            message = 'You won!';
            break;
        case 'opponent-wins':
            isWinner = false;
            message = 'You lost!';
            break;
        case 'stalemate':
        case 'tie':
            isWinner = false;
            message = 'Game tied!';
            break;
        case 'resign':
            isWinner = false;
            message = 'You resigned';
            break;
    }
    
    // Award XP based on result
    if (isWinner) {
        window.playerProgression.awardXP(100, 'Game Won!');
        playerStats.gamesWon++;
        playerStats.currentWinStreak++;
        if (playerStats.currentWinStreak > playerStats.longestWinStreak) {
            playerStats.longestWinStreak = playerStats.currentWinStreak;
        }
    } else {
        window.playerProgression.awardXP(25, 'Game Completed');
        playerStats.currentWinStreak = 0;
    }
    
    playerStats.gamesPlayed++;
    playerStats.winRate = (playerStats.gamesWon / playerStats.gamesPlayed) * 100;
    
    // Calculate winnings/loss
    const currentGame = myActiveGames.find(g => g.status === 'playing');
    let winnings = 0;
    let totalStake = 0;
    
    if (currentGame) {
        totalStake = currentGame.stake * 2;
        if (isWinner) {
            winnings = totalStake * 0.97; // 3% platform fee
            currentBalance += winnings;
        }
        updateBalanceDisplay();
        
        // Remove from active games
        myActiveGames = myActiveGames.filter(g => g.id !== currentGame.id);
        updateActiveGamesDisplay();
    }
    
    // Show settlement modal
    showSettlementModal({
        isWinner,
        winnings,
        totalStake,
        platformFee: totalStake * 0.03,
        blockchainGameId: currentGame?.blockchainGameId || 'demo',
        gameType: activeGameType
    });
    
    // Close game window after a delay
    setTimeout(() => {
        if (activeGameType) {
            closeGame(activeGameType);
        }
    }, 5000);
}

function getGameEndMessage(gameState) {
    switch (gameState) {
        case 'white-wins': return 'White wins!';
        case 'black-wins': return 'Black wins!';
        case 'red-wins': return 'Red wins!';
        case 'stalemate': return 'Stalemate!';
        case 'tie': return 'It\'s a tie!';
        case 'player-wins': return 'You win!';
        case 'opponent-wins': return 'Opponent wins!';
        default: return 'Game over';
    }
}

// Chat functions
function sendGameMessage(gameType) {
    const inputEl = document.getElementById(gameType + 'ChatInput');
    if (!inputEl) return;
    
    const message = inputEl.value.trim();
    if (!message) return;
    
    // Add message to chat
    const chatEl = document.getElementById(gameType + 'GameChat');
    if (chatEl) {
        const messageEl = document.createElement('div');
        messageEl.className = 'game-chat-message';
        messageEl.innerHTML = `<strong>You:</strong> ${message}`;
        chatEl.appendChild(messageEl);
        chatEl.scrollTop = chatEl.scrollHeight;
    }
    
    // Send to multiplayer
    if (window.multiplayerManager) {
        window.multiplayerManager.socket?.emit('chatMessage', {
            gameId: currentGameState?.gameId || 'demo',
            message,
            sender: userAccount
        });
    }
    
    // Clear input
    inputEl.value = '';
}
    // Utility and management functions
function getGameIcon(gameType) {
    switch (gameType) {
        case 'chess': return '♟️';
        case 'checkers': return '⚫';
        case 'words': return '📝';
        default: return '🎮';
    }
}

function getGameName(gameType) {
    switch (gameType) {
        case 'chess': return 'Chess Masters';
        case 'checkers': return 'Checkers Pro';
        case 'words': return 'Word Battle';
        default: return 'Game';
    }
}

// Display update functions
function updateGamesDisplay() {
    const gamesList = document.getElementById('gamesList');
    const noGames = document.getElementById('noGames');
    
    if (!gamesList) return;

    if (globalGamesList.length === 0) {
        gamesList.innerHTML = '';
        if (noGames) noGames.classList.remove('hidden');
        return;
    }

    if (noGames) noGames.classList.add('hidden');

    gamesList.innerHTML = globalGamesList.map(game => `
        <div class="game-item">
            <div class="game-header">
                <div class="game-type">${getGameIcon(game.type)} ${getGameName(game.type)}</div>
                <div class="game-stake">${game.stake} CORE</div>
            </div>
            <div class="game-info">
                Created by: ${game.creator.substring(0, 6)}...${game.creator.substring(38)} • 
                Skill: ${game.skillLevel || 'Any'} • 
                Time: ${game.timeControl || 'Standard'}
                ${game.isDemo ? ' • DEMO' : ' • BLOCKCHAIN'}
                ${game.txHash ? ' • <a href="https://scan.coredao.org/tx/' + game.txHash + '" target="_blank" style="color: #4ecdc4;">View TX</a>' : ''}
            </div>
            <div class="game-actions">
                <button class="game-btn primary" onclick="joinGame('${game.id}', ${game.stake})">
                    <i class="fas fa-play"></i> Join Game
                </button>
                ${game.creator === userAccount ? `
                    <button class="game-btn danger" onclick="cancelGame('${game.id}')">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                ` : ''}
            </div>
        </div>
    `).join('');
}

function updateActiveGamesDisplay() {
    const activeGamesList = document.getElementById('activeGamesList');
    const noActiveGames = document.getElementById('noActiveGames');
    
    if (!activeGamesList) return;

    if (myActiveGames.length === 0) {
        activeGamesList.innerHTML = '';
        if (noActiveGames) noActiveGames.classList.remove('hidden');
        return;
    }

    if (noActiveGames) noActiveGames.classList.add('hidden');

    activeGamesList.innerHTML = myActiveGames.map(game => `
        <div class="game-item">
            <div class="game-header">
                <div class="game-type">${getGameIcon(game.type)} ${getGameName(game.type)}</div>
                <div class="game-stake">${game.stake} CORE</div>
            </div>
            <div class="game-info">
                Status: ${game.status} • 
                Opponent: ${game.player2 ? (game.player2.substring(0, 6) + '...' + game.player2.substring(38)) : 'Waiting...'} • 
                Started: ${new Date(game.startedAt || game.createdAt).toLocaleTimeString()}
                ${game.isDemo ? ' • DEMO' : ' • BLOCKCHAIN'}
                ${game.joinTxHash ? ' • <a href="https://scan.coredao.org/tx/' + game.joinTxHash + '" target="_blank" style="color: #4ecdc4;">View TX</a>' : ''}
            </div>
            <div class="game-actions">
                <button class="game-btn primary" onclick="openGameWindow('${game.type}', ${JSON.stringify(game).replace(/"/g, '&quot;')})">
                    <i class="fas fa-play"></i> Open Game
                </button>
                <button class="game-btn danger" onclick="forfeitGame('${game.id}')">
                    <i class="fas fa-flag"></i> Forfeit
                </button>
            </div>
        </div>
    `).join('');
}

// Tournament functions
function refreshTournaments() {
    showTransactionStatus('🔄 Refreshing tournaments...', '');
    
    // Generate sample tournaments
    tournaments = [
        {
            id: 'chess_masters_001',
            name: 'Chess Masters Cup',
            gameType: 'chess',
            status: 'live',
            currentPlayers: 32,
            maxPlayers: 64,
            entryFee: 0.5,
            prizePool: 15.0,
            format: 'single_elimination',
            currentRound: 2,
            totalRounds: 6,
            startTime: Date.now() - 3600000
        }
    ];
    
    updateTournamentsDisplay();
    showTransactionStatus('✅ Tournaments refreshed!', '');
}

function updateTournamentsDisplay() {
    const grid = document.getElementById('tournamentsGrid');
    if (!grid) return;

    if (tournaments.length === 0) {
        grid.innerHTML = '<div class="empty-state"><h3>No tournaments available</h3><p>Check back later for new tournaments!</p></div>';
        return;
    }

    grid.innerHTML = tournaments.map(tournament => {
        const isLive = tournament.status === 'live';
        return `
            <div class="tournament-card ${isLive ? 'live-tournament' : 'upcoming-tournament'}">
                <div class="tournament-header">
                    <div class="tournament-type">${getGameIcon(tournament.gameType)} ${tournament.name}</div>
                    <div class="tournament-status ${tournament.status}">
                        ${isLive ? 'LIVE' : 'UPCOMING'}
                    </div>
                </div>
                <div class="tournament-info">
                    <div class="tournament-detail">
                        <i class="fas fa-coins"></i>
                        <span>Prize Pool: <strong>${tournament.prizePool} CORE</strong></span>
                    </div>
                    <div class="tournament-detail">
                        <i class="fas fa-users"></i>
                        <span>Players: <strong>${tournament.currentPlayers}/${tournament.maxPlayers}</strong></span>
                    </div>
                    <div class="tournament-detail">
                        <i class="fas fa-dollar-sign"></i>
                        <span>Entry: <strong>${tournament.entryFee} CORE</strong></span>
                    </div>
                </div>
                ${isLive ? `
                    <div class="tournament-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${(tournament.currentRound / tournament.totalRounds) * 100}%"></div>
                        </div>
                        <span class="progress-text">Round ${tournament.currentRound} of ${tournament.totalRounds}</span>
                    </div>
                ` : ''}
                <div class="tournament-actions">
                    <button class="tournament-btn primary" onclick="joinTournament('${tournament.id}')">
                        <i class="fas fa-trophy"></i> Join Tournament
                    </button>
                    <button class="tournament-btn secondary" onclick="viewTournament('${tournament.id}')">
                        <i class="fas fa-eye"></i> View
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

async function joinTournament(tournamentId) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    const tournament = tournaments.find(t => t.id === tournamentId);
    if (!tournament) {
        showTransactionStatus('❌ Tournament not found', '');
        return;
    }
    
    if (currentBalance < tournament.entryFee) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }

    showTransactionStatus('🔄 Joining tournament...', '');
    
    setTimeout(() => {
        tournament.currentPlayers++;
        currentBalance -= tournament.entryFee;
        updateBalanceDisplay();
        updateTournamentsDisplay();

        window.playerProgression.awardXP(200, 'Tournament Joined');
        
        addActivityFeedItem(`🏆 You joined ${tournament.name} tournament!`);
        showTransactionStatus('✅ Tournament joined successfully!', '');
    }, 2000);
}

function viewTournament(tournamentId) {
    showTransactionStatus('👁️ Opening tournament details...', '');
    // Could open a detailed tournament view modal
}

function createTournament() {
    showTransactionStatus('🏆 Tournament creation coming soon!', '');
}

function filterTournaments(filter) {
    currentTournamentFilter = filter;
    
    // Update filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Filter tournaments (in a real implementation)
    updateTournamentsDisplay();
}

// Activity feed functions
function refreshActivityFeed() {
    const activityFeed = document.getElementById('activityFeed');
    if (!activityFeed) return;

    const activities = [
        '🎮 Player123 won 0.5 CORE in Chess!',
        '⚔️ New tournament starting in 5 minutes',
        '🔥 High stakes game: 2.0 CORE',
        '📝 WordMaster scored 150 points!',
        '🏆 Daily leaderboard updated',
        '💰 BigWinner claimed 5.0 CORE!',
        '🎯 Perfect game by ChessMaster',
        '🚀 Platform reaching new highs!',
        '⚡ Lightning-fast settlement on Core!',
        '🎨 New game features released!'
    ];

    const shuffled = activities.sort(() => 0.5 - Math.random()).slice(0, 5);
    
    activityFeed.innerHTML = shuffled.map(activity => 
        `<div class="activity-item">${activity}</div>`
    ).join('');
}

function addActivityFeedItem(message) {
    const activityFeed = document.getElementById('activityFeed');
    if (!activityFeed) return;

    const item = document.createElement('div');
    item.className = 'activity-item';
    item.textContent = message;
    
    activityFeed.insertBefore(item, activityFeed.firstChild);
    
    while (activityFeed.children.length > 10) {
        activityFeed.removeChild(activityFeed.lastChild);
    }
}

// Refresh functions
function refreshLobby() {
    showTransactionStatus('🔄 Refreshing lobby...', '');
    updateGamesDisplay();
    updateLiveStats();
    setTimeout(() => {
        showTransactionStatus('✅ Lobby refreshed!', '');
    }, 1000);
}

function refreshActiveGames() {
    showTransactionStatus('🔄 Refreshing active games...', '');
    updateActiveGamesDisplay();
    setTimeout(() => {
        showTransactionStatus('✅ Active games refreshed!', '');
    }, 1000);
}

function toggleAutoRefresh() {
    autoRefreshEnabled = !autoRefreshEnabled;
    const btn = document.getElementById('autoRefreshBtn');
    
    if (btn) {
        if (autoRefreshEnabled) {
            btn.innerHTML = '<i class="fas fa-pause"></i>';
            btn.classList.add('active');
            startAutoRefresh();
        } else {
            btn.innerHTML = '<i class="fas fa-play"></i>';
            btn.classList.remove('active');
            stopAutoRefresh();
        }
    }
}

function startAutoRefresh() {
    if (gameUpdateInterval) clearInterval(gameUpdateInterval);
    
    gameUpdateInterval = setInterval(() => {
        if (autoRefreshEnabled) {
            updateGamesDisplay();
            updateActiveGamesDisplay();
            updateLiveStats();
        }
    }, 10000);
}

function stopAutoRefresh() {
    if (gameUpdateInterval) {
        clearInterval(gameUpdateInterval);
        gameUpdateInterval = null;
    }
}

function updateLiveStats() {
    const stats = {
        totalPlayers: Math.floor(Math.random() * 50) + 200,
        totalGames: Math.floor(Math.random() * 20) + 80,
        totalVolume: (Math.random() * 100 + 100).toFixed(1),
        totalTournaments: Math.floor(Math.random() * 3) + 2
    };

    Object.keys(stats).forEach(key => {
        const element = document.getElementById(key);
        if (element) {
            element.textContent = stats[key];
        }
    });

    const networkStats = {
        blockHeight: (15234567 + Math.floor(Math.random() * 1000)).toLocaleString(),
        gasPrice: (Math.random() * 10 + 10).toFixed(1) + ' gwei',
        corePrice: '$' + (Math.random() * 0.5 + 1.0).toFixed(3)
    };

    Object.keys(networkStats).forEach(key => {
        const element = document.getElementById(key);
        if (element) {
            element.textContent = networkStats[key];
        }
    });
}

// Status update functions
function updateConnectionStatus(status) {
    const statusElement = document.getElementById('connectionStatus');
    if (!statusElement) return;

    const indicator = statusElement.querySelector('.connection-indicator');
    
    switch (status) {
        case 'connected':
            indicator.className = 'connection-indicator connected';
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected';
            break;
        case 'disconnected':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Not Connected';
            break;
        case 'pending':
            indicator.className = 'connection-indicator pending';
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>Connecting...';
            break;
    }
}

function updateContractStatus(status, message = '') {
    const statusElement = document.getElementById('contractStatus');
    if (!statusElement) return;

    const indicator = statusElement.querySelector('.connection-indicator');
    
    switch (status) {
        case 'connected':
            indicator.className = 'connection-indicator connected';
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected to Core Blockchain';
            break;
        case 'connecting':
            indicator.className = 'connection-indicator pending';
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>Connecting to Core Blockchain...';
            break;
        case 'disconnected':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Disconnected';
            break;
        case 'demo':
            indicator.className = 'connection-indicator pending';
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>' + (message || 'Demo Mode');
            break;
    }
}

function updateBalanceDisplay() {
    const balanceEl = document.getElementById('balanceDisplay');
    if (balanceEl) {
        balanceEl.textContent = currentBalance.toFixed(4) + ' CORE';
    }
}

function updateWalletButtons(connected) {
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    if (connectBtn && disconnectBtn) {
        if (connected) {
            connectBtn.classList.add('hidden');
            disconnectBtn.classList.remove('hidden');
        } else {
            connectBtn.classList.remove('hidden');
            disconnectBtn.classList.add('hidden');
        }
    }
}

// Transaction status functions
function showTransactionStatus(message, txHash = '') {
    const statusEl = document.getElementById('transactionStatus');
    const messageEl = document.getElementById('txStatusMessage');
    const hashEl = document.getElementById('txHash');
    
    if (!statusEl || !messageEl) return;

    messageEl.textContent = message;
    
    if (hashEl && txHash) {
        hashEl.innerHTML = `<a href="https://scan.coredao.org/tx/${txHash}" target="_blank" rel="noopener">${txHash.substring(0, 10)}...${txHash.substring(txHash.length - 8)}</a>`;
        hashEl.style.display = 'block';
    } else if (hashEl) {
        hashEl.style.display = 'none';
    }

    statusEl.classList.add('show');
    
    if (!message.includes('❌')) {
        setTimeout(() => {
            hideTransactionStatus();
        }, 5000);
    }
}

function hideTransactionStatus() {
    const statusEl = document.getElementById('transactionStatus');
    if (statusEl) {
        statusEl.classList.remove('show');
    }
}

// Profile functions
function updateProfileDisplay() {
    updateProfileStats();
    updateAchievementsDisplay();
}

function updateProfileStats() {
    const elements = {
        profilePlayerName: userAccount ? userAccount.substring(0, 8) + '...' : 'Player',
        profileGamesPlayed: playerStats.gamesPlayed,
        profileGamesWon: playerStats.gamesWon,
        profileTotalEarned: playerStats.totalEarned.toFixed(3),
        profileWinRate: playerStats.winRate.toFixed(1) + '%'
    };

    Object.keys(elements).forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = elements[id];
        }
    });
}

function updateAchievementsDisplay() {
    const achievementsGrid = document.getElementById('achievementsGrid');
    if (!achievementsGrid) return;

    const sampleAchievements = [
        { icon: '🎮', name: 'First Game', description: 'Play your first game', unlocked: playerStats.gamesPlayed > 0 },
        { icon: '🏆', name: 'Winner', description: 'Win your first game', unlocked: playerStats.gamesWon > 0 },
        { icon: '🔥', name: 'Win Streak', description: 'Win 3 games in a row', unlocked: playerStats.longestWinStreak >= 3 },
        { icon: '💰', name: 'Big Winner', description: 'Earn 1 CORE in total', unlocked: playerStats.totalEarned >= 1 },
        { icon: '🎯', name: 'Sharpshooter', description: 'Win 10 games', unlocked: playerStats.gamesWon >= 10 },
        { icon: '⚡', name: 'Speed Demon', description: 'Win a game in under 5 minutes', unlocked: false }
    ];

    achievementsGrid.innerHTML = sampleAchievements.map(achievement => `
        <div class="achievement-card ${achievement.unlocked ? 'unlocked' : ''}">
            <div class="achievement-icon">${achievement.icon}</div>
            <div class="achievement-info">
                <h4>${achievement.name}</h4>
                <p>${achievement.description}</p>
                <div class="achievement-status ${achievement.unlocked ? 'unlocked' : 'locked'}">
                    ${achievement.unlocked ? 'Unlocked' : 'Locked'}
                </div>
            </div>
        </div>
    `).join('');
}

// Notification functions
function showXPNotification(amount, reason) {
    const notification = document.createElement('div');
    notification.className = 'xp-notification';
    notification.innerHTML = `
        <div style="color: #4ecdc4; font-weight: bold;">+${amount} XP</div>
        <div style="font-size: 0.8rem; color: #aaa;">${reason}</div>
    `;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.remove(), 3000);
}

function showLevelUpNotification(oldLevel, newLevel) {
    const notification = document.createElement('div');
    notification.className = 'level-up-notification';
    notification.innerHTML = `
        <div style="text-align: center;">
            <h3 style="color: #4ecdc4; margin-bottom: 0.5rem;">🎉 Level Up!</h3>
            <p style="margin-bottom: 0.5rem;">Level ${oldLevel} → Level ${newLevel}</p>
            <div style="color: #f39c12; font-weight: bold;">+50 XP Bonus</div>
        </div>
    `;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.remove(), 5000);
}

function showUnlockNotification(reward) {
    const notification = document.createElement('div');
    notification.className = 'level-up-notification';
    notification.innerHTML = `
        <div style="text-align: center;">
            <h3 style="color: #f39c12; margin-bottom: 0.5rem;">🔓 Feature Unlocked!</h3>
            <p style="font-weight: bold;">${reward.name}</p>
        </div>
    `;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.remove(), 4000);
}

// Settlement modal functions
function showSettlementModal(settlement) {
    const modal = document.getElementById('settlementModal');
    const titleEl = document.getElementById('settlementTitle');
    const resultEl = document.getElementById('settlementResult');
    const breakdownEl = document.getElementById('settlementBreakdown');

    if (settlement.isWinner) {
        titleEl.textContent = '🎉 Congratulations! You Won!';
        resultEl.innerHTML = `
            <div style="text-align: center; margin: 1rem 0;">
                <div style="font-size: 2rem; color: #00ff88;">+${settlement.winnings.toFixed(4)} CORE</div>
                <div style="font-size: 1rem; color: #aaa;">You defeated your opponent!</div>
            </div>
        `;
        
        window.playerProgression.awardXP(100, 'Game Won');
        playerStats.currentWinStreak++;
        playerStats.gamesWon++;
    } else {
        titleEl.textContent = '😔 Game Over - You Lost';
        resultEl.innerHTML = `
            <div style="text-align: center; margin: 1rem 0;">
                <div style="font-size: 2rem; color: #ff6b6b;">-${(settlement.totalStake / 2).toFixed(4)} CORE</div>
                <div style="font-size: 1rem; color: #aaa;">Better luck next time!</div>
            </div>
        `;
        
        window.playerProgression.awardXP(25, 'Game Completed');
        playerStats.currentWinStreak = 0;
    }

    playerStats.gamesPlayed++;
    playerStats.winRate = (playerStats.gamesWon / playerStats.gamesPlayed) * 100;

    breakdownEl.innerHTML = `
        <h4>Settlement Breakdown:</h4>
        <div>Total Stakes: ${settlement.totalStake.toFixed(4)} CORE</div>
        <div>Platform Fee (3%): ${settlement.platformFee.toFixed(4)} CORE</div>
        <div>Your ${settlement.isWinner ? 'Winnings' : 'Loss'}: ${settlement.isWinner ? settlement.winnings.toFixed(4) : (settlement.totalStake / 2).toFixed(4)} CORE</div>
        <div style="margin-top: 1rem; font-size: 0.8rem; color: #aaa;">
            ${settlement.blockchainGameId ? '🔗 Blockchain settlement' : '💫 Demo mode settlement'}
        </div>
    `;

    if (modal) modal.classList.remove('hidden');
    updateProfileStats();
}

function closeSettlement() {
    const modal = document.getElementById('settlementModal');
    if (modal) modal.classList.add('hidden');
}

async function claimWinnings() {
    showTransactionStatus('✅ Winnings credited to your account!', '');
    
    // Update balance (in real implementation, this would be handled by the smart contract)
    if (currentBalance) {
        // Refresh balance from blockchain
        if (window.blockchainManager.provider && userAccount) {
            try {
                const balance = await window.blockchainManager.provider.getBalance(userAccount);
                currentBalance = parseFloat(ethers.utils.formatEther(balance));
                updateBalanceDisplay();
            } catch (error) {
                console.log('Could not refresh balance:', error);
            }
        }
    }
    
    closeSettlement();
}

// Utility functions
function copyContractAddress() {
    const address = GAME_CONTRACT_ADDRESS;
    navigator.clipboard.writeText(address).then(() => {
        showTransactionStatus('📋 Contract address copied!', '');
    }).catch(() => {
        showTransactionStatus('❌ Failed to copy address', '');
    });
}

async function cancelGame(gameId) {
    const game = globalGamesList.find(g => g.id === gameId);
    if (game && game.creator === userAccount) {
        try {
            globalGamesList = globalGamesList.filter(g => g.id !== gameId);
            currentBalance += game.stake;
            updateBalanceDisplay();
            updateGamesDisplay();
            
            showTransactionStatus('Game cancelled and stake refunded', '');
        } catch (error) {
            console.error('Failed to cancel game:', error);
            showTransactionStatus('❌ Failed to cancel game: ' + error.message, '');
        }
    }
}

function forfeitGame(gameId) {
    if (confirm('Are you sure you want to forfeit this game? You will lose your stake.')) {
        const game = myActiveGames.find(g => g.id === gameId);
        if (game) {
            myActiveGames = myActiveGames.filter(g => g.id !== gameId);
            updateActiveGamesDisplay();
            
            playerStats.gamesPlayed++;
            playerStats.currentWinStreak = 0;
            playerStats.winRate = (playerStats.gamesWon / playerStats.gamesPlayed) * 100;
            
            window.playerProgression.awardXP(10, 'Game Completed');
            
            showTransactionStatus('Game forfeited', '');
        }
    }
}

function viewFullLeaderboard() {
    showTransactionStatus('🏆 Full leaderboard coming soon!', '');
}

function generateDemoGames() {
    globalGamesList = [
        {
            id: Date.now() + '1',
            type: 'chess',
            creator: 'DemoPlayer1',
            stake: 0.05,
            status: 'waiting',
            createdAt: Date.now() - 60000,
            isDemo: true
        },
        {
            id: Date.now() + '2',
            type: 'checkers',
            creator: 'DemoPlayer2',
            stake: 0.02,
            status: 'waiting',
            createdAt: Date.now() - 120000,
            isDemo: true
        },
        {
            id: Date.now() + '3',
            type: 'words',
            creator: 'DemoPlayer3',
            stake: 0.01,
            status: 'waiting',
            createdAt: Date.now() - 180000,
            isDemo: true
        }
    ];
    
    updateGamesDisplay();
}

// Account/network change handlers
function handleAccountsChanged(accounts) {
    if (accounts.length === 0) {
        disconnectWallet();
    } else if (accounts[0] !== userAccount) {
        userAccount = accounts[0];
        location.reload();
    }
}

function handleChainChanged(chainId) {
    location.reload();
}

// Enhanced disconnect function
function disconnectWallet() {
    if (window.blockchainManager) {
        window.blockchainManager.cleanup();
    }
    
    if (window.realTimeInterval) {
        clearInterval(window.realTimeInterval);
        window.realTimeInterval = null;
    }
    
    if (window.multiplayerManager) {
        window.multiplayerManager.disconnect();
    }
    
    userAccount = null;
    currentBalance = 0;
    myActiveGames.length = 0;
    globalGamesList.length = 0;
    
    updateConnectionStatus('disconnected');
    updateBalanceDisplay();
    updateWalletButtons(false);
    updateGamesDisplay();
    updateActiveGamesDisplay();
    
    try {
        localStorage.removeItem('walletConnected');
    } catch (error) {
        console.log('localStorage not available');
    }
    
    showTransactionStatus('👋 Wallet disconnected', '');
}

// Start real-time updates
function startRealTimeUpdates() {
    if (window.realTimeInterval) {
        clearInterval(window.realTimeInterval);
    }

    window.realTimeInterval = setInterval(async () => {
        if (userAccount) {
            updateLiveStats();
            refreshActivityFeed();
            
            // Update blockchain data if available
            if (window.blockchainManager.provider) {
                try {
                    const balance = await window.blockchainManager.provider.getBalance(userAccount);
                    const newBalance = parseFloat(ethers.utils.formatEther(balance));
                    if (Math.abs(newBalance - currentBalance) > 0.001) {
                        currentBalance = newBalance;
                        updateBalanceDisplay();
                    }
                    
                    await window.blockchainManager.updateNetworkInfo();
                } catch (error) {
                    console.log('Blockchain update failed:', error);
                }
            }
        }
    }, 30000); // Every 30 seconds
}

// Load real games from API
async function loadRealGamesFromAPI() {
    try {
        showTransactionStatus('🔄 Loading games from blockchain...', '');
        
        const apiData = await window.apiManager.loadGameData();
        if (apiData) {
            globalGamesList = apiData.games || [];
            myActiveGames = apiData.activeGames || [];
            tournaments = apiData.tournaments || [];
            
            updateGamesDisplay();
            updateActiveGamesDisplay();
            updateTournamentsDisplay();
            
            showTransactionStatus('✅ Games loaded from API!', '');
        } else {
            generateDemoGames();
        }
        
    } catch (error) {
        console.error('Failed to load real games from API:', error);
        generateDemoGames();
    }
}

// Enhanced initialization with real API integration
async function initializePlatform() {
    console.log('🚀 Initializing Enhanced CrossRealm Gaming Platform...');
    
    try {
        updateConnectionProgress(20);
        updateContractStatus('connecting');
        
        // Initialize enhanced managers
        window.playerProgression = new PlayerProgression();
        window.apiManager = new APIManager();
        
        setTimeout(() => updateConnectionProgress(50), 500);
        setTimeout(() => updateConnectionProgress(80), 1000);
        setTimeout(async () => {
            updateConnectionProgress(100);
            updateContractStatus('connected');
            
            // Load initial data
            try {
                const apiData = await window.apiManager.loadGameData();
                if (apiData) {
                    globalGamesList = apiData.games || [];
                    tournaments = apiData.tournaments || [];
                    updateGamesDisplay();
                    updateTournamentsDisplay();
                }
            } catch (error) {
                console.log('Could not load from API:', error);
            }
            
            // Check for existing wallet connection
            try {
                const wasConnected = localStorage.getItem('walletConnected');
                if (wasConnected === 'true' && window.ethereum) {
                    connectWallet();
                }
            } catch (error) {
                console.log('Auto-connect failed:', error);
            }
            
            // Initialize with demo data if not connected
            if (!userAccount) {
                updateGamesDisplay();
                updateActiveGamesDisplay();
                updateLiveStats();
                refreshActivityFeed();
                generateDemoGames();
            }
            
            console.log('✅ Enhanced platform initialization complete!');
        }, 1500);

    } catch (error) {
        console.error('❌ Platform initialization failed:', error);
        updateContractStatus('demo', 'Demo Mode - Limited Features');
    }
}

function updateConnectionProgress(percentage) {
    const progressFill = document.getElementById('connectionProgress');
    if (progressFill) {
        progressFill.style.width = percentage + '%';
    }
}

// Event listeners setup
function setupEventListeners() {
    // Enhanced click handling for navigation
    document.querySelectorAll('.nav-item').forEach((item, index) => {
        const sections = ['lobby', 'active', 'create', 'games', 'tournaments', 'profile', 'chat', 'settings'];
        item.addEventListener('click', () => showSection(sections[index]));
        item.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                showSection(sections[index]);
            }
        });
    });

    // Wallet buttons
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    if (connectBtn) connectBtn.addEventListener('click', connectWallet);
    if (disconnectBtn) disconnectBtn.addEventListener('click', disconnectWallet);

    // Age verification
    document.querySelectorAll('.verify-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const isAccept = btn.classList.contains('accept');
            verifyAge(isAccept);
        });
    });

    // Transaction status close
    const txClose = document.querySelector('.tx-close');
    if (txClose) txClose.addEventListener('click', hideTransactionStatus);

    // Settlement modal
    const claimBtn = document.getElementById('claimBtn');
    if (claimBtn) claimBtn.addEventListener('click', claimWinnings);

    const settlementClose = document.querySelectorAll('.settlement-close');
    settlementClose.forEach(btn => btn.addEventListener('click', closeSettlement));

    // Game window controls
    document.querySelectorAll('.close-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const gameWindow = e.target.closest('.game-window');
            if (gameWindow) {
                const gameType = gameWindow.id.replace('GameWindow', '').toLowerCase();
                closeGame(gameType);
            }
        });
    });

    document.querySelectorAll('.minimize-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const gameWindow = e.target.closest('.game-window');
            if (gameWindow) {
                const gameType = gameWindow.id.replace('GameWindow', '').toLowerCase();
                minimizeGame(gameType);
            }
        });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isGameActive) {
            const confirmClose = confirm('Are you sure you want to close the game?');
            if (confirmClose && activeGameType) {
                closeGame(activeGameType);
            }
        }
    });
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', async () => {
    console.log('🎮 Enhanced CrossRealm Platform Loading...');
    
    setupEventListeners();
    
    // Check age verification
    if (checkAgeVerification()) {
        await initializePlatform();
    }
    
    console.log('🚀 Platform Ready!');
});

// Auto-refresh activity feed every 30 seconds
setInterval(() => {
    if (document.getElementById('activityFeed')) {
        refreshActivityFeed();
    }
}, 30000);

// Auto-save progress every 5 minutes
setInterval(() => {
    if (window.playerProgression) {
        window.playerProgression.saveProgress();
    }
}, 300000);

console.log('✨ Enhanced CrossRealm Gaming Platform - Complete Implementation with Real Blockchain Integration Ready!');
console.log('🔗 Contract Address:', GAME_CONTRACT_ADDRESS);
console.log('🌐 API Endpoint:', JSONBIN_API_CONFIG.BASE_URL);
console.log('📊 Bin ID:', JSONBIN_API_CONFIG.BIN_ID);

    // Add this to fix wallet disconnect
function forceDisconnectWallet() {
    console.log("Force disconnecting wallet...");
    
    // Clear all wallet data
    userAccount = null;
    currentBalance = 0;
    myActiveGames = [];
    
    // Update UI immediately
    updateConnectionStatus('disconnected');
    updateBalanceDisplay();
    updateWalletButtons(false);
    updateGamesDisplay();
    updateActiveGamesDisplay();
    
    // Clear localStorage
    try {
        localStorage.removeItem('walletConnected');
        localStorage.removeItem('crossrealm_progress');
    } catch (error) {
        console.log('Could not clear localStorage');
    }
    
    // Cleanup blockchain manager
    if (window.blockchainManager) {
        window.blockchainManager.cleanup();
    }
    
    // Force page reload to ensure clean state
    setTimeout(() => {
        location.reload();
    }, 1000);
    
    showTransactionStatus('👋 Wallet disconnected - Reloading...', '');
}

// Fix the disconnect button binding
document.addEventListener('DOMContentLoaded', () => {
    const disconnectBtn = document.getElementById('disconnectBtn');
    if (disconnectBtn) {
        // Remove existing listeners and add new one
        disconnectBtn.onclick = forceDisconnectWallet;
        disconnectBtn.addEventListener('click', forceDisconnectWallet);
    }
});

    // Enhanced real-time game synchronization
class RealTimeGameSync {
    constructor() {
        this.syncInterval = null;
        this.lastSyncTime = 0;
    }

    async startRealTimeSync() {
        // Sync every 5 seconds for real-time multiplayer
        this.syncInterval = setInterval(async () => {
            await this.syncGames();
        }, 5000);
        
        console.log("🔄 Real-time game sync started");
    }

    async syncGames() {
        try {
            // Load latest games from API
            const apiData = await window.apiManager.loadGameData();
            
            if (apiData && apiData.lastUpdated > this.lastSyncTime) {
                // Update global games list with new games from other players
                const newGames = apiData.games || [];
                
                // Keep games that aren't created by current user
                const otherPlayerGames = newGames.filter(game => 
                    game.creator !== userAccount && 
                    game.status === 'waiting'
                );
                
                // Keep current user's games
                const myGames = globalGamesList.filter(game => 
                    game.creator === userAccount
                );
                
                // Combine both
                globalGamesList = [...myGames, ...otherPlayerGames];
                
                // Update display
                updateGamesDisplay();
                
                this.lastSyncTime = apiData.lastUpdated;
                console.log(`🔄 Synced ${otherPlayerGames.length} games from other players`);
            }
        } catch (error) {
            console.error('Sync failed:', error);
        }
    }

    async createAndSyncGame(gameData) {
        try {
            // Add to local list
            globalGamesList.push(gameData);
            
            // Immediately save to API for other players to see
            await window.apiManager.saveGameData({
                games: globalGamesList,
                activeGames: myActiveGames,
                tournaments: tournaments,
                lastUpdated: Date.now()
            });
            
            console.log("🎮 Game created and synced to server");
            updateGamesDisplay();
            
        } catch (error) {
            console.error('Failed to sync new game:', error);
        }
    }

    stopSync() {
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }
    }
}

// Initialize real-time sync
window.gameSync = new RealTimeGameSync();

// Enhanced create game function with real sync
async function createGameWithSync() {
    const stakeInput = document.getElementById('gameStake');
    if (!stakeInput || !selectedGameType || !userAccount) {
        showTransactionStatus('❌ Please fill all requirements', '');
        return;
    }
    
    const stakeAmount = parseFloat(stakeInput.value) || 0;
    
    if (stakeAmount < 0.01 || stakeAmount > currentBalance) {
        showTransactionStatus('❌ Invalid stake amount', '');
        return;
    }

    try {
        showTransactionStatus('🔄 Creating game for all players...', '');
        
        const newGame = {
            id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
            type: selectedGameType,
            creator: userAccount,
            creatorName: userAccount.substring(0, 8) + '...',
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now(),
            isDemo: false, // Mark as real game
            platform: 'crossrealm'
        };

        // Use the real-time sync to create and share the game
        await window.gameSync.createAndSyncGame(newGame);
        
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        // Award XP
        window.playerProgression.awardXP(50, 'Game Created');
        
        // Reset form
        stakeInput.value = '';
        selectedGameType = null;
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        updateCreateButton();
        
        showTransactionStatus('✅ Game created and visible to all players!', '');
        showSection('lobby');
        
    } catch (error) {
        console.error('Failed to create game:', error);
        showTransactionStatus('❌ Failed to create game: ' + error.message, '');
    }
}

// Start real-time sync when platform initializes
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        if (window.gameSync) {
            window.gameSync.startRealTimeSync();
        }
    }, 3000);
});

// Replace the original createGame function
window.createGame = createGameWithSync;

    // Force real mode configuration
const FORCE_REAL_MODE = true; // Set to true to avoid demo fallbacks

// Enhanced connection with real mode enforcement
async function connectWalletReal() {
    try {
        showTransactionStatus('🔄 Connecting to MetaMask (Real Mode)...', '');
        updateConnectionStatus('pending');

        if (typeof window.ethereum === 'undefined') {
            if (FORCE_REAL_MODE) {
                showTransactionStatus('❌ MetaMask required for real mode', '');
                return false;
            } else {
                return demoMode();
            }
        }

        // Force real blockchain connection
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
        });

        if (accounts.length === 0) {
            throw new Error('No accounts found');
        }

        userAccount = accounts[0];
        const balance = await provider.getBalance(userAccount);
        currentBalance = parseFloat(ethers.utils.formatEther(balance));

        updateConnectionStatus('connected');
        updateBalanceDisplay();
        updateWalletButtons(true);

        showTransactionStatus('✅ Connected in REAL MODE - Games will be shared!', '');

        // Start real-time sync immediately
        if (window.gameSync) {
            await window.gameSync.startRealTimeSync();
        }

        // Load real games
        await loadRealGamesFromAPI();
        
        // Save connection state
        try {
            localStorage.setItem('walletConnected', 'true');
            localStorage.setItem('realMode', 'true');
        } catch (error) {
            console.log('localStorage not available');
        }

        return true;

    } catch (error) {
        console.error('Real wallet connection failed:', error);
        showTransactionStatus('❌ Connection failed: ' + error.message, '');
        
        if (FORCE_REAL_MODE) {
            showTransactionStatus('❌ Real mode required - Please install MetaMask', '');
            return false;
        } else {
            return demoMode();
        }
    }
}

// Enhanced game visibility check
function checkGameVisibility() {
    const isRealMode = localStorage.getItem('realMode') === 'true';
    const statusMessage = document.createElement('div');
    statusMessage.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        background: ${isRealMode ? '#2ecc71' : '#f39c12'};
        color: white;
        padding: 1rem;
        border-radius: 10px;
        z-index: 10000;
        max-width: 300px;
    `;
    
    statusMessage.innerHTML = `
        <h4>${isRealMode ? '🟢 REAL MODE ACTIVE' : '🟡 DEMO MODE'}</h4>
        <p>${isRealMode ? 'Games are shared with all players via API' : 'Games are local only'}</p>
        <p>Games visible: ${globalGamesList.length}</p>
    `;
    
    document.body.appendChild(statusMessage);
    
    setTimeout(() => {
        statusMessage.remove();
    }, 5000);
}

// Override the original connect function
window.connectWallet = connectWalletReal;

// Add status checker button (temporary for debugging)
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        const header = document.querySelector('.header');
        if (header) {
            const statusBtn = document.createElement('button');
            statusBtn.textContent = '📊 Check Status';
            statusBtn.style.cssText = `
                background: #4ecdc4;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 5px;
                color: white;
                cursor: pointer;
                margin-left: 1rem;
            `;
            statusBtn.onclick = checkGameVisibility;
            header.appendChild(statusBtn);
        }
    }, 2000);
});
    // Real-time Move Synchronization and Turn Management
class RealTimeMoveSync {
    constructor() {
        this.currentGameId = null;
        this.isMyTurn = false;
        this.gameState = null;
        this.opponentAddress = null;
        this.moveHistory = [];
        this.syncInterval = null;
        this.lastMoveTime = 0;
    }

    startGameSync(gameId, gameType, isCreator = false) {
        this.currentGameId = gameId;
        this.isMyTurn = isCreator; // Creator goes first
        this.gameState = { gameId, gameType, moves: [], currentPlayer: isCreator ? userAccount : 'waiting' };
        
        console.log(`🎮 Starting game sync for ${gameType} - Your turn: ${this.isMyTurn}`);
        
        // Sync moves every 2 seconds for real-time gameplay
        this.syncInterval = setInterval(async () => {
            await this.syncMoves();
        }, 2000);
        
        // Update UI to show turn status
        this.updateTurnDisplay();
        
        // Save initial game state
        this.saveGameState();
    }

    async syncMoves() {
        if (!this.currentGameId) return;

        try {
            // Load latest game state from API
            const apiData = await window.apiManager.loadGameData();
            const gameStates = apiData.gameStates || {};
            const serverGameState = gameStates[this.currentGameId];

            if (serverGameState && serverGameState.lastMoveTime > this.lastMoveTime) {
                console.log("📥 New move received from opponent");
                
                // Apply opponent's move
                const lastMove = serverGameState.moves[serverGameState.moves.length - 1];
                if (lastMove && lastMove.player !== userAccount) {
                    await this.applyOpponentMove(lastMove);
                    this.isMyTurn = true; // Now it's my turn
                    this.lastMoveTime = serverGameState.lastMoveTime;
                    this.updateTurnDisplay();
                }
            }
        } catch (error) {
            console.error('Failed to sync moves:', error);
        }
    }

    async makeMove(moveData) {
        if (!this.isMyTurn) {
            showTransactionStatus('❌ Not your turn! Wait for opponent.', '');
            return false;
        }

        try {
            // Create move object
            const move = {
                player: userAccount,
                timestamp: Date.now(),
                moveData: moveData,
                gameType: activeGameType
            };

            // Add to local move history
            this.moveHistory.push(move);
            this.gameState.moves.push(move);
            this.gameState.currentPlayer = this.opponentAddress;
            this.gameState.lastMoveTime = Date.now();

            // It's now opponent's turn
            this.isMyTurn = false;
            this.updateTurnDisplay();

            // Save to server immediately
            await this.saveGameState();

            console.log("📤 Move sent to opponent:", moveData);
            showTransactionStatus('✅ Move sent! Waiting for opponent...', '');

            return true;
        } catch (error) {
            console.error('Failed to make move:', error);
            return false;
        }
    }

    async applyOpponentMove(move) {
        console.log("🎯 Applying opponent move:", move);

        // Apply move based on game type
        switch (move.gameType) {
            case 'chess':
                if (window.chessEngine && move.moveData) {
                    const success = window.chessEngine.makeMove(
                        move.moveData.fromRow, 
                        move.moveData.fromCol,
                        move.moveData.toRow, 
                        move.moveData.toCol
                    );
                    if (success) {
                        updateChessBoard();
                        // Add move to chat
                        addGameChatMessage('chess', `Opponent moved: ${move.moveData.fromRow},${move.moveData.fromCol} → ${move.moveData.toRow},${move.moveData.toCol}`);
                    }
                }
                break;

            case 'checkers':
                if (window.checkersEngine && move.moveData) {
                    const success = window.checkersEngine.makeMove(
                        move.moveData.fromRow, 
                        move.moveData.fromCol,
                        move.moveData.toRow, 
                        move.moveData.toCol
                    );
                    if (success) {
                        updateCheckersBoard();
                        addGameChatMessage('checkers', `Opponent moved: ${move.moveData.fromRow},${move.moveData.fromCol} → ${move.moveData.toRow},${move.moveData.toCol}`);
                    }
                }
                break;

            case 'words':
                if (window.wordEngine && move.moveData) {
                    // Update opponent score
                    window.wordEngine.opponentScore += move.moveData.score;
                    const opponentScoreEl = document.getElementById('opponentWordScore');
                    if (opponentScoreEl) {
                        opponentScoreEl.textContent = window.wordEngine.opponentScore;
                    }
                    addGameChatMessage('words', `Opponent played: ${move.moveData.word} (+${move.moveData.score})`);
                }
                break;
        }

        // Check for game end conditions
        this.checkGameEnd();
    }

    updateTurnDisplay() {
        const gameTypes = ['chess', 'checkers', 'words'];
        
        gameTypes.forEach(gameType => {
            const statusEl = document.getElementById(gameType + 'Status');
            if (statusEl && activeGameType === gameType) {
                if (this.isMyTurn) {
                    statusEl.textContent = '🟢 Your Turn - Make a move!';
                    statusEl.style.color = '#2ecc71';
                } else {
                    statusEl.textContent = '🔴 Opponent\'s Turn - Please wait...';
                    statusEl.style.color = '#e74c3c';
                }
            }
        });

        // Enable/disable game controls based on turn
        this.toggleGameControls(this.isMyTurn);
    }

    toggleGameControls(enabled) {
        // Disable/enable chess board squares
        document.querySelectorAll('.chess-square').forEach(square => {
            square.style.pointerEvents = enabled ? 'auto' : 'none';
            square.style.opacity = enabled ? '1' : '0.7';
        });

        // Disable/enable checkers board squares  
        document.querySelectorAll('.checkers-square').forEach(square => {
            square.style.pointerEvents = enabled ? 'auto' : 'none';
            square.style.opacity = enabled ? '1' : '0.7';
        });

        // Disable/enable word input
        const wordInput = document.getElementById('wordInput');
        if (wordInput) {
            wordInput.disabled = !enabled;
            wordInput.style.opacity = enabled ? '1' : '0.7';
        }

        // Disable/enable submit buttons
        document.querySelectorAll('.game-btn.primary').forEach(btn => {
            if (btn.textContent.includes('Submit') || btn.textContent.includes('Move')) {
                btn.disabled = !enabled;
                btn.style.opacity = enabled ? '1' : '0.6';
            }
        });
    }

    async saveGameState() {
        try {
            // Load current API data
            const apiData = await window.apiManager.loadGameData() || {};
            
            // Initialize gameStates if it doesn't exist
            if (!apiData.gameStates) {
                apiData.gameStates = {};
            }

            // Save current game state
            apiData.gameStates[this.currentGameId] = {
                ...this.gameState,
                lastMoveTime: Date.now()
            };

            // Save back to API
            await window.apiManager.saveGameData({
                ...apiData,
                lastUpdated: Date.now()
            });

            console.log("💾 Game state saved to server");
        } catch (error) {
            console.error('Failed to save game state:', error);
        }
    }

    checkGameEnd() {
        let gameEnded = false;
        let winner = null;

        // Check game end conditions based on game type
        switch (activeGameType) {
            case 'chess':
                if (window.chessEngine && window.chessEngine.gameState !== 'playing') {
                    gameEnded = true;
                    winner = window.chessEngine.gameState === 'white-wins' ? 'white' : 
                            window.chessEngine.gameState === 'black-wins' ? 'black' : 'draw';
                }
                break;

            case 'checkers':
                if (window.checkersEngine && window.checkersEngine.gameState !== 'playing') {
                    gameEnded = true;
                    winner = window.checkersEngine.gameState === 'red-wins' ? 'red' : 
                            window.checkersEngine.gameState === 'black-wins' ? 'black' : 'draw';
                }
                break;

            case 'words':
                if (window.wordEngine && window.wordEngine.gameState !== 'playing') {
                    gameEnded = true;
                    winner = window.wordEngine.gameState === 'player-wins' ? 'player' : 
                            window.wordEngine.gameState === 'opponent-wins' ? 'opponent' : 'tie';
                }
                break;
        }

        if (gameEnded) {
            this.endGame(winner);
        }
    }

    async endGame(winner) {
        console.log("🏁 Game ended. Winner:", winner);
        
        // Stop syncing
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }

        // Determine if current user won
        const isWinner = this.isUserWinner(winner);
        
        // Show settlement modal
        const currentGame = myActiveGames.find(g => g.id === this.currentGameId);
        if (currentGame) {
            handleGameEnd(isWinner ? 'player-wins' : 'opponent-wins');
        }

        // Clean up
        this.currentGameId = null;
        this.isMyTurn = false;
        this.gameState = null;
    }

    isUserWinner(winner) {
        // This logic depends on the game and player colors
        // For now, simplified logic
        return winner === 'white' || winner === 'red' || winner === 'player';
    }

    stopSync() {
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }
        this.currentGameId = null;
        this.isMyTurn = false;
    }
}

// Initialize the move sync system
window.moveSync = new RealTimeMoveSync();

// Helper function to add chat messages
function addGameChatMessage(gameType, message) {
    const chatEl = document.getElementById(gameType + 'GameChat');
    if (chatEl) {
        const messageEl = document.createElement('div');
        messageEl.className = 'game-chat-message system';
        messageEl.innerHTML = `<strong>System:</strong> ${message}`;
        chatEl.appendChild(messageEl);
        chatEl.scrollTop = chatEl.scrollHeight;
    }
}
    // Enhanced Game Move Handlers with Real-time Sync

// Enhanced Chess Square Click Handler
function handleChessSquareClickWithSync(row, col) {
    if (!window.chessEngine || !window.moveSync) return;
    
    // Check if it's player's turn
    if (!window.moveSync.isMyTurn) {
        showTransactionStatus('❌ Wait for your turn!', '');
        return;
    }
    
    const engine = window.chessEngine;
    const clickedSquare = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (engine.selectedSquare) {
        const [selectedRow, selectedCol] = engine.selectedSquare;
        
        // Try to make a move
        if (engine.makeMove(selectedRow, selectedCol, row, col)) {
            // Move successful - send to opponent
            const moveData = {
                fromRow: selectedRow,
                fromCol: selectedCol,
                toRow: row,
                toCol: col,
                gameType: 'chess',
                timestamp: Date.now()
            };
            
            // Sync the move with opponent
            window.moveSync.makeMove(moveData);
            
            updateChessBoard();
            clearChessSelection();
            
            // Check game end
            if (engine.gameState !== 'playing') {
                window.moveSync.checkGameEnd();
            }
            
            // Award XP for move
            window.playerProgression.awardXP(5, 'Chess Move');
            
        } else {
            // Invalid move, try selecting new piece
            clearChessSelection();
            selectChessPiece(row, col);
        }
    } else {
        // Select piece
        selectChessPiece(row, col);
    }
}

// Enhanced Checkers Square Click Handler
function handleCheckersSquareClickWithSync(row, col) {
    if (!window.checkersEngine || !window.moveSync) return;
    
    // Check if it's player's turn
    if (!window.moveSync.isMyTurn) {
        showTransactionStatus('❌ Wait for your turn!', '');
        return;
    }
    
    const engine = window.checkersEngine;
    const clickedSquare = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (engine.selectedSquare) {
        const [selectedRow, selectedCol] = engine.selectedSquare;
        
        // Try to make a move
        if (engine.makeMove(selectedRow, selectedCol, row, col)) {
            // Move successful - send to opponent
            const moveData = {
                fromRow: selectedRow,
                fromCol: selectedCol,
                toRow: row,
                toCol: col,
                gameType: 'checkers',
                timestamp: Date.now()
            };
            
            // Sync the move with opponent
            window.moveSync.makeMove(moveData);
            
            updateCheckersBoard();
            clearCheckersSelection();
            
            // Check game end
            if (engine.gameState !== 'playing') {
                window.moveSync.checkGameEnd();
            }
            
            // Award XP for move
            window.playerProgression.awardXP(5, 'Checkers Move');
            
        } else {
            // Invalid move, try selecting new piece
            clearCheckersSelection();
            selectCheckersPiece(row, col);
        }
    } else {
        // Select piece
        selectCheckersPiece(row, col);
    }
}

// Enhanced Word Submission with Turn Sync
async function submitWordWithSync() {
    if (!window.wordEngine || !window.moveSync) return;
    
    // Check if it's player's turn
    if (!window.moveSync.isMyTurn) {
        showTransactionStatus('❌ Wait for your turn!', '');
        return;
    }
    
    const inputEl = document.getElementById('wordInput');
    const validationEl = document.getElementById('wordValidation');
    
    if (!inputEl) return;
    
    const word = inputEl.value.trim();
    if (word.length < 3) return;
    
    const engine = window.wordEngine;
    
    try {
        validationEl.textContent = 'Validating...';
        validationEl.className = 'word-validation';
        
        const result = await engine.submitWord(word);
        
        if (result.valid) {
            // Send move to opponent
            const moveData = {
                word: word.toUpperCase(),
                score: result.score,
                gameType: 'words',
                timestamp: Date.now()
            };
            
            // Sync the move
            await window.moveSync.makeMove(moveData);
            
            // Update UI
            const wordsListEl = document.getElementById('submittedWordsList');
            if (wordsListEl) {
                const wordChip = document.createElement('div');
                wordChip.className = 'word-chip';
                wordChip.textContent = `${word.toUpperCase()} (${result.score})`;
                wordsListEl.appendChild(wordChip);
            }
            
            // Update scores
            const playerScoreEl = document.getElementById('playerWordScore');
            if (playerScoreEl) {
                playerScoreEl.textContent = result.totalScore;
            }
            
            // Clear input
            inputEl.value = '';
            validationEl.textContent = `+${result.score} points! Opponent's turn...`;
            validationEl.className = 'word-validation valid';
            
            // Award XP
            window.playerProgression.awardXP(result.score, 'Word Submitted');
            
            setTimeout(() => {
                if (validationEl) validationEl.textContent = '';
                updateScoreBreakdown(0, 0, 0, 0);
            }, 3000);
            
        } else {
            validationEl.textContent = 'Invalid word';
            validationEl.className = 'word-validation invalid';
        }
        
    } catch (error) {
        console.error('Word validation error:', error);
        validationEl.textContent = 'Validation failed';
        validationEl.className = 'word-validation invalid';
    }
}

// Enhanced Game Window Opening with Move Sync
function openGameWindowWithSync(gameType, gameData) {
    const windowId = gameType + 'GameWindow';
    const gameWindow = document.getElementById(windowId);
    
    if (!gameWindow) {
        console.error('Game window not found:', windowId);
        return;
    }

    gameWindow.classList.remove('hidden');
    isGameActive = true;
    activeGameType = gameType;
    
    updateGameWindowInfo(gameType, gameData);
    initializeGameBoard(gameType);
    
    // Determine if this player is the creator (goes first)
    const isCreator = gameData.creator === userAccount;
    
    // Start move synchronization
    if (window.moveSync) {
        window.moveSync.startGameSync(gameData.id, gameType, isCreator);
        
        // Set opponent address
        window.moveSync.opponentAddress = isCreator ? gameData.player2 : gameData.creator;
    }
    
    showTransactionStatus(`🎮 ${getGameName(gameType)} started! ${isCreator ? 'Your turn first!' : 'Opponent goes first!'}`, '');
}

// Enhanced Game Board Initialization with Sync Handlers
function initializeGameBoardWithSync(gameType) {
    switch (gameType) {
        case 'chess':
            initializeChessBoardWithSync();
            break;
        case 'checkers':
            initializeCheckersBoardWithSync();
            break;
        case 'words':
            initializeWordGameWithSync();
            break;
    }
}

function initializeChessBoardWithSync() {
    window.chessEngine = new ChessEngine();
    const board = document.getElementById('chessBoard');
    if (!board) return;

    board.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            square.dataset.square = String.fromCharCode(97 + col) + (8 - row);
            
            const piece = window.chessEngine.board[row][col];
            if (piece) {
                square.textContent = window.chessEngine.getPieceSymbol(piece);
            }
            
            // Use the enhanced sync handler
            square.addEventListener('click', () => handleChessSquareClickWithSync(row, col));
            board.appendChild(square);
        }
    }
    
    updateChessBoard();
}

function initializeCheckersBoardWithSync() {
    window.checkersEngine = new CheckersEngine();
    const board = document.getElementById('checkersBoard');
    if (!board) return;

    board.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            if ((row + col) % 2 === 1) {
                const piece = window.checkersEngine.board[row][col];
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `checker-piece ${piece.color}-piece`;
                    if (piece.type === 'king') {
                        pieceElement.classList.add('king');
                    }
                    square.appendChild(pieceElement);
                }
            }
            
            // Use the enhanced sync handler
            square.addEventListener('click', () => handleCheckersSquareClickWithSync(row, col));
            board.appendChild(square);
        }
    }
    
    updateCheckersBoard();
}

function initializeWordGameWithSync() {
    window.wordEngine = new WordGameEngine();
    const engine = window.wordEngine;
    
    // Update UI elements
    const lettersEl = document.getElementById('wordLetters');
    const inputEl = document.getElementById('wordInput');
    
    if (lettersEl) {
        lettersEl.textContent = engine.availableLetters;
    }
    
    if (inputEl) {
        inputEl.value = '';
        
        // Add real-time validation
        inputEl.addEventListener('input', validateWordInput);
        inputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitWordWithSync(); // Use sync version
            }
        });
    }
    
    updateWordGameUI();
    startWordGameTimer();
}

// Override the original functions with sync versions
window.openGameWindow = openGameWindowWithSync;
window.initializeGameBoard = initializeGameBoardWithSync;
window.handleChessSquareClick = handleChessSquareClickWithSync;
window.handleCheckersSquareClick = handleCheckersSquareClickWithSync;
window.submitWord = submitWordWithSync;

// Enhanced join game function with sync initialization
async function joinGameWithSync(gameId, stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stakeAmount) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }

    const game = globalGamesList.find(g => g.id === gameId);
    if (!game) {
        showTransactionStatus('❌ Game not found', '');
        return;
    }

    showTransactionStatus('🎮 Joining game with real-time sync...', '');
    
    try {
        // Update game with player 2
        game.player2 = userAccount;
        game.status = 'playing';
        game.startedAt = Date.now();
        
        // Move to active games
        myActiveGames.push(game);
        globalGamesList = globalGamesList.filter(g => g.id !== gameId);
        
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        // Update displays
        updateGamesDisplay();
        updateActiveGamesDisplay();
        
        // Save updated game state to API
        await window.gameSync.createAndSyncGame(game);
        
        // Award XP
        window.playerProgression.awardXP(25, 'Game Joined');
        
        showTransactionStatus('✅ Game joined! Opening with real-time sync...', '');
        
        setTimeout(() => {
            openGameWindowWithSync(game.type, game);
        }, 1000);
        
    } catch (error) {
        console.error('Failed to join game:', error);
        showTransactionStatus('❌ Failed to join game: ' + error.message, '');
    }
}

// Override join game function
window.joinGame = joinGameWithSync;

    // Enhanced Turn Indicator UI and Game Status Management

// Add visual turn indicators to the CSS
const turnIndicatorStyles = `
<style>
.turn-indicator {
    position: fixed;
    top: 120px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #4ecdc4;
    border-radius: 15px;
    padding: 1rem;
    z-index: 8000;
    min-width: 250px;
    backdrop-filter: blur(10px);
    animation: slideIn 0.5s ease;
}

.turn-indicator.my-turn {
    border-color: #2ecc71;
    background: rgba(46, 204, 113, 0.1);
}

.turn-indicator.opponent-turn {
    border-color: #e74c3c;
    background: rgba(231, 76, 60, 0.1);
}

.turn-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: bold;
    font-size: 1.1rem;
}

.turn-timer {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    color: #aaa;
}

.game-status-bar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    border: 1px solid #4ecdc4;
    border-radius: 25px;
    padding: 0.8rem 1.5rem;
    z-index: 8000;
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    gap: 1rem;
    min-width: 300px;
    justify-content: center;
}

.move-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    animation: pulse 2s infinite;
}

.move-indicator.active {
    background: #2ecc71;
}

.move-indicator.waiting {
    background: #e74c3c;
}

.game-controls-overlay {
    position: fixed;
    top: 50%;
    left: 20px;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.8);
    border-radius: 15px;
    padding: 1rem;
    z-index: 7000;
    backdrop-filter: blur(10px);
}

.disabled-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(231, 76, 60, 0.2);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 1.2rem;
    backdrop-filter: blur(2px);
}

@media (max-width: 768px) {
    .turn-indicator {
        top: 80px;
        right: 10px;
        left: 10px;
        min-width: auto;
    }
    
    .game-status-bar {
        bottom: 10px;
        left: 10px;
        right: 10px;
        transform: none;
        min-width: auto;
    }
    
    .game-controls-overlay {
        left: 10px;
        right: 10px;
        top: auto;
        bottom: 80px;
        transform: none;
    }
}
</style>
`;

// Inject the turn indicator styles
document.head.insertAdjacentHTML('beforeend', turnIndicatorStyles);

// Enhanced Turn Management UI
class TurnIndicatorUI {
    constructor() {
        this.turnIndicator = null;
        this.gameStatusBar = null;
        this.gameControlsOverlay = null;
        this.turnTimer = null;
        this.turnStartTime = 0;
        this.maxTurnTime = 300; // 5 minutes per turn
    }

    createTurnIndicator() {
        // Remove existing indicator
        this.removeTurnIndicator();

        // Create turn indicator
        this.turnIndicator = document.createElement('div');
        this.turnIndicator.className = 'turn-indicator';
        this.turnIndicator.innerHTML = `
            <div class="turn-status">
                <div class="move-indicator"></div>
                <span class="status-text">Initializing...</span>
            </div>
            <div class="turn-timer">
                <span class="timer-text">Time: --:--</span>
            </div>
        `;
        document.body.appendChild(this.turnIndicator);

        // Create game status bar
        this.gameStatusBar = document.createElement('div');
        this.gameStatusBar.className = 'game-status-bar';
        this.gameStatusBar.innerHTML = `
            <span class="game-info">Waiting for game...</span>
        `;
        document.body.appendChild(this.gameStatusBar);
    }

    updateTurnStatus(isMyTurn, gameType = '', opponentName = '') {
        if (!this.turnIndicator) this.createTurnIndicator();

        const indicator = this.turnIndicator.querySelector('.move-indicator');
        const statusText = this.turnIndicator.querySelector('.status-text');
        const gameInfo = this.gameStatusBar.querySelector('.game-info');

        if (isMyTurn) {
            this.turnIndicator.className = 'turn-indicator my-turn';
            indicator.className = 'move-indicator active';
            statusText.textContent = '🟢 Your Turn!';
            gameInfo.textContent = `${gameType.toUpperCase()}: Make your move`;
            this.startTurnTimer();
        } else {
            this.turnIndicator.className = 'turn-indicator opponent-turn';
            indicator.className = 'move-indicator waiting';
            statusText.textContent = '🔴 Opponent\'s Turn';
            gameInfo.textContent = `${gameType.toUpperCase()}: Waiting for ${opponentName || 'opponent'}`;
            this.stopTurnTimer();
        }

        // Add game controls overlay for disabled state
        this.updateGameControlsState(isMyTurn);
    }

    updateGameControlsState(enabled) {
        // Remove existing overlay
        const existingOverlay = document.querySelector('.disabled-overlay');
        if (existingOverlay) {
            existingOverlay.remove();
        }

        if (!enabled) {
            // Add disabled overlay to game boards
            const gameBoards = [
                document.getElementById('chessBoard'),
                document.getElementById('checkersBoard'),
                document.querySelector('.word-game')
            ];

            gameBoards.forEach(board => {
                if (board && board.closest('.game-window:not(.hidden)')) {
                    const overlay = document.createElement('div');
                    overlay.className = 'disabled-overlay';
                    overlay.innerHTML = '⏳ Waiting for opponent...';
                    board.style.position = 'relative';
                    board.appendChild(overlay);
                }
            });
        }
    }

    startTurnTimer() {
        this.turnStartTime = Date.now();
        this.turnTimer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - this.turnStartTime) / 1000);
            const remaining = Math.max(0, this.maxTurnTime - elapsed);
            
            const minutes = Math.floor(remaining / 60);
            const seconds = remaining % 60;
            
            const timerText = this.turnIndicator.querySelector('.timer-text');
            if (timerText) {
                timerText.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Change color as time runs out
                if (remaining < 30) {
                    timerText.style.color = '#e74c3c';
                } else if (remaining < 60) {
                    timerText.style.color = '#f39c12';
                } else {
                    timerText.style.color = '#2ecc71';
                }
            }

            // Auto-forfeit if time runs out
            if (remaining === 0) {
                this.handleTimeOut();
            }
        }, 1000);
    }

    stopTurnTimer() {
        if (this.turnTimer) {
            clearInterval(this.turnTimer);
            this.turnTimer = null;
        }
        
        const timerText = this.turnIndicator.querySelector('.timer-text');
        if (timerText) {
            timerText.textContent = 'Time: Opponent\'s turn';
            timerText.style.color = '#aaa';
        }
    }

    handleTimeOut() {
        this.stopTurnTimer();
        showTransactionStatus('⏰ Time\'s up! You forfeit this turn.', '');
        
        // Auto-forfeit or pass turn
        if (window.moveSync) {
            window.moveSync.isMyTurn = false;
            window.moveSync.updateTurnDisplay();
        }
    }

    showMoveNotification(moveData, isOpponent = false) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 200px;
            right: 20px;
            background: ${isOpponent ? 'rgba(231, 76, 60, 0.9)' : 'rgba(46, 204, 113, 0.9)'};
            color: white;
            padding: 1rem;
            border-radius: 10px;
            z-index: 9000;
            max-width: 300px;
            animation: slideIn 0.5s ease;
        `;
        
        const moveDescription = this.getMoveDescription(moveData);
        notification.innerHTML = `
            <div style="font-weight: bold;">${isOpponent ? '🔴 Opponent Move' : '🟢 Your Move'}</div>
            <div style="font-size: 0.9rem; margin-top: 0.5rem;">${moveDescription}</div>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 4000);
    }

    getMoveDescription(moveData) {
        switch (moveData.gameType) {
            case 'chess':
                const fromSquare = String.fromCharCode(97 + moveData.fromCol) + (8 - moveData.fromRow);
                const toSquare = String.fromCharCode(97 + moveData.toCol) + (8 - moveData.toRow);
                return `♟️ ${fromSquare} → ${toSquare}`;
            
            case 'checkers':
                return `⚫ ${moveData.fromRow},${moveData.fromCol} → ${moveData.toRow},${moveData.toCol}`;
            
            case 'words':
                return `📝 "${moveData.word}" (+${moveData.score} points)`;
            
            default:
                return 'Move made';
        }
    }

    removeTurnIndicator() {
        if (this.turnIndicator) {
            this.turnIndicator.remove();
            this.turnIndicator = null;
        }
        
        if (this.gameStatusBar) {
            this.gameStatusBar.remove();
            this.gameStatusBar = null;
        }
        
        this.stopTurnTimer();
        
        // Remove disabled overlays
        document.querySelectorAll('.disabled-overlay').forEach(overlay => {
            overlay.remove();
        });
    }

    showGameEndNotification(result) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 2rem;
            border-radius: 20px;
            z-index: 10000;
            text-align: center;
            border: 3px solid ${result.isWinner ? '#2ecc71' : '#e74c3c'};
            backdrop-filter: blur(15px);
            animation: bounce 0.6s ease;
        `;
        
        notification.innerHTML = `
            <div style="font-size: 3rem; margin-bottom: 1rem;">
                ${result.isWinner ? '🎉' : '😔'}
            </div>
            <h2 style="margin-bottom: 1rem; color: ${result.isWinner ? '#2ecc71' : '#e74c3c'};">
                ${result.isWinner ? 'You Won!' : 'You Lost!'}
            </h2>
            <p style="font-size: 1.1rem; margin-bottom: 1rem;">
                ${result.isWinner ? `+${result.winnings} CORE earned!` : 'Better luck next time!'}
            </p>
            <button onclick="this.parentElement.remove()" style="
                background: #4ecdc4;
                border: none;
                padding: 0.8rem 2rem;
                border-radius: 25px;
                color: white;
                font-weight: bold;
                cursor: pointer;
                font-size: 1rem;
            ">Continue</button>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 10000);
    }
}

// Initialize the turn UI system
window.turnUI = new TurnIndicatorUI();

// Enhanced Real-time Move Sync with UI Integration
class EnhancedMoveSync extends RealTimeMoveSync {
    constructor() {
        super();
        this.ui = window.turnUI;
    }

    startGameSync(gameId, gameType, isCreator = false) {
        super.startGameSync(gameId, gameType, isCreator);
        
        // Initialize UI
        this.ui.createTurnIndicator();
        this.ui.updateTurnStatus(this.isMyTurn, gameType, 'Opponent');
        
        console.log(`🎮 Enhanced game sync started - Turn UI active`);
    }

    async makeMove(moveData) {
        const success = await super.makeMove(moveData);
        
        if (success) {
            // Show move notification
            this.ui.showMoveNotification(moveData, false);
            
            // Update UI for opponent's turn
            this.ui.updateTurnStatus(false, moveData.gameType, 'Opponent');
        }
        
        return success;
    }

    async applyOpponentMove(move) {
        await super.applyOpponentMove(move);
        
        // Show opponent move notification
        this.ui.showMoveNotification(move.moveData, true);
        
        // Update UI for player's turn
        this.ui.updateTurnStatus(true, move.gameType, 'You');
    }

    async endGame(winner) {
        await super.endGame(winner);
        
        // Show game end notification
        const isWinner = this.isUserWinner(winner);
        const currentGame = myActiveGames.find(g => g.id === this.currentGameId);
        const winnings = isWinner && currentGame ? currentGame.stake * 1.94 : 0; // 97% after 3% fee
        
        this.ui.showGameEndNotification({
            isWinner,
            winnings,
            result: winner
        });
        
        // Clean up UI
        setTimeout(() => {
            this.ui.removeTurnIndicator();
        }, 5000);
    }

    stopSync() {
        super.stopSync();
        this.ui.removeTurnIndicator();
    }
}

// Replace the move sync system with enhanced version
window.moveSync = new EnhancedMoveSync();

// Enhanced Game Status Updates
function updateGameStatusWithTurn(gameType, status) {
    // Update the game window status
    const statusEl = document.getElementById(gameType + 'Status');
    if (statusEl) {
        statusEl.textContent = status;
    }
    
    // Update turn indicator if active
    if (window.turnUI && window.turnUI.turnIndicator) {
        const gameInfo = window.turnUI.gameStatusBar.querySelector('.game-info');
        if (gameInfo) {
            gameInfo.textContent = `${gameType.toUpperCase()}: ${status}`;
        }
    }
}

// Connection Quality Indicator
class ConnectionQualityIndicator {
    constructor() {
        this.lastPingTime = 0;
        this.pingInterval = null;
        this.indicator = null;
    }

    startMonitoring() {
        this.createIndicator();
        this.pingInterval = setInterval(() => {
            this.measureConnection();
        }, 10000); // Check every 10 seconds
    }

    createIndicator() {
        this.indicator = document.createElement('div');
        this.indicator.style.cssText = `
            position: fixed;
            top: 180px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.5rem;
            border-radius: 8px;
            z-index: 7500;
            font-size: 0.8rem;
            backdrop-filter: blur(5px);
        `;
        this.indicator.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div class="connection-dot" style="width: 8px; height: 8px; border-radius: 50%; background: #2ecc71;"></div>
                <span>Connection: Good</span>
            </div>
        `;
        document.body.appendChild(this.indicator);
    }

    async measureConnection() {
        const startTime = Date.now();
        
        try {
            // Simple ping test using API
            await window.apiManager.loadGameData();
            const pingTime = Date.now() - startTime;
            this.updateIndicator(pingTime);
        } catch (error) {
            this.updateIndicator(-1); // Connection failed
        }
    }

    updateIndicator(pingTime) {
        if (!this.indicator) return;

        const dot = this.indicator.querySelector('.connection-dot');
        const text = this.indicator.querySelector('span');

        if (pingTime === -1) {
            dot.style.background = '#e74c3c';
            text.textContent = 'Connection: Poor';
        } else if (pingTime < 1000) {
            dot.style.background = '#2ecc71';
            text.textContent = `Connection: Good (${pingTime}ms)`;
        } else if (pingTime < 3000) {
            dot.style.background = '#f39c12';
            text.textContent = `Connection: Fair (${pingTime}ms)`;
        } else {
            dot.style.background = '#e74c3c';
            text.textContent = `Connection: Poor (${pingTime}ms)`;
        }
    }

    remove() {
        if (this.indicator) {
            this.indicator.remove();
            this.indicator = null;
        }
        
        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }
    }
}

// Initialize connection quality monitoring
window.connectionMonitor = new ConnectionQualityIndicator();

// Auto-start monitoring when game starts
const originalOpenGameWindow = window.openGameWindow;
window.openGameWindow = function(gameType, gameData) {
    originalOpenGameWindow(gameType, gameData);
    
    // Start connection monitoring
    if (window.connectionMonitor) {
        window.connectionMonitor.startMonitoring();
    }
};

// Clean up when game closes
const originalCloseGame = window.closeGame;
window.closeGame = function(gameType) {
    originalCloseGame(gameType);
    
    // Stop monitoring and clean up UI
    if (window.connectionMonitor) {
        window.connectionMonitor.remove();
    }
    
    if (window.turnUI) {
        window.turnUI.removeTurnIndicator();
    }
    
    if (window.moveSync) {
        window.moveSync.stopSync();
    }
};

// Enhanced move synchronization message
function showEnhancedMoveSync() {
    showTransactionStatus('🔄 Real-time move sync active - opponent will see your moves instantly!', '');
}

// Initialize enhanced features when document loads
document.addEventListener('DOMContentLoaded', () => {
    console.log('🎮 Enhanced Turn-based Gaming System Loaded!');
    console.log('✅ Real-time move synchronization active');
    console.log('✅ Turn validation enabled');
    console.log('✅ Visual turn indicators ready');
    console.log('✅ Connection quality monitoring ready');
});

console.log('🎯 Complete Turn-based Multiplayer System Initialized!');

// CRITICAL FIX: Real Move Synchronization & Blockchain Restoration

// Enhanced API Manager with improved game state sync
class ImprovedAPIManager extends APIManager {
    async saveGameState(gameId, gameState) {
        try {
            console.log("💾 Saving game state for game:", gameId);
            
            // Load current data
            const currentData = await this.loadGameData() || {};
            
            // Initialize gameStates if needed
            if (!currentData.gameStates) {
                currentData.gameStates = {};
            }
            
            // Save the specific game state
            currentData.gameStates[gameId] = {
                ...gameState,
                lastUpdated: Date.now(),
                lastMoveTime: Date.now()
            };
            
            // Save back to API
            const response = await fetch(`${this.config.BASE_URL}/b/${this.config.BIN_ID}`, {
                method: 'PUT',
                headers: this.headers,
                body: JSON.stringify({
                    ...currentData,
                    lastUpdated: Date.now()
                })
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            console.log("✅ Game state saved successfully");
            return true;
        } catch (error) {
            console.error('Failed to save game state:', error);
            return false;
        }
    }

    async loadGameState(gameId) {
        try {
            const data = await this.loadGameData();
            if (data && data.gameStates && data.gameStates[gameId]) {
                console.log("📥 Loaded game state for game:", gameId);
                return data.gameStates[gameId];
            }
            return null;
        } catch (error) {
            console.error('Failed to load game state:', error);
            return null;
        }
    }
}

// Replace API manager with improved version
window.apiManager = new ImprovedAPIManager();

// Fixed Real-time Move Sync with proper API integration
class FixedRealTimeMoveSync {
    constructor() {
        this.currentGameId = null;
        this.isMyTurn = false;
        this.gameState = null;
        this.opponentAddress = null;
        this.moveHistory = [];
        this.syncInterval = null;
        this.lastSyncTime = 0;
        this.gameType = null;
    }

    startGameSync(gameId, gameType, isCreator = false) {
        this.currentGameId = gameId;
        this.gameType = gameType;
        this.isMyTurn = isCreator; // Creator goes first
        this.gameState = { 
            gameId, 
            gameType, 
            moves: [], 
            currentPlayer: isCreator ? userAccount : 'waiting',
            players: {
                creator: isCreator ? userAccount : 'opponent',
                joiner: isCreator ? 'opponent' : userAccount
            }
        };
        
        console.log(`🎮 Starting FIXED game sync for ${gameType}`);
        console.log(`🎯 Your turn: ${this.isMyTurn} | Game ID: ${gameId}`);
        
        // Save initial state
        this.saveGameStateToAPI();
        
        // Start aggressive sync for real-time play (every 1 second)
        this.syncInterval = setInterval(async () => {
            await this.syncMovesFromAPI();
        }, 1000);
        
        // Update UI
        this.updateTurnDisplay();
        
        showTransactionStatus(`🎮 Game sync started! ${isCreator ? 'You go first!' : 'Opponent goes first!'}`, '');
    }

    async syncMovesFromAPI() {
        if (!this.currentGameId) return;

        try {
            // Load latest game state from API
            const serverGameState = await window.apiManager.loadGameState(this.currentGameId);
            
            if (serverGameState && serverGameState.lastMoveTime > this.lastSyncTime) {
                console.log("📥 NEW MOVE DETECTED from API!");
                console.log("Server state:", serverGameState);
                
                // Get the latest move
                const serverMoves = serverGameState.moves || [];
                const lastMove = serverMoves[serverMoves.length - 1];
                
                if (lastMove && lastMove.player !== userAccount) {
                    console.log("🎯 Applying opponent move:", lastMove);
                    
                    // Apply the opponent's move
                    await this.applyOpponentMoveToBoard(lastMove);
                    
                    // Update local state
                    this.isMyTurn = true;
                    this.lastSyncTime = serverGameState.lastMoveTime;
                    this.moveHistory = serverMoves;
                    
                    // Update UI
                    this.updateTurnDisplay();
                    
                    // Show notification
                    showTransactionStatus('📥 Opponent moved! Your turn now.', '');
                }
            }
        } catch (error) {
            console.error('Sync failed:', error);
        }
    }

    async makeMove(moveData) {
        if (!this.isMyTurn) {
            showTransactionStatus('❌ Not your turn! Wait for opponent.', '');
            return false;
        }

        console.log("📤 Making move:", moveData);

        try {
            // Create move object
            const move = {
                player: userAccount,
                timestamp: Date.now(),
                moveData: moveData,
                gameType: this.gameType,
                moveIndex: this.moveHistory.length
            };

            // Add to move history
            this.moveHistory.push(move);
            
            // Update game state
            this.gameState.moves = this.moveHistory;
            this.gameState.currentPlayer = this.opponentAddress;
            this.gameState.lastMoveTime = Date.now();

            // Save to API immediately
            const saved = await this.saveGameStateToAPI();
            
            if (saved) {
                // Switch turns
                this.isMyTurn = false;
                this.updateTurnDisplay();
                
                console.log("✅ Move saved to API successfully!");
                showTransactionStatus('✅ Move sent to opponent!', '');
                
                return true;
            } else {
                showTransactionStatus('❌ Failed to send move. Try again.', '');
                return false;
            }
        } catch (error) {
            console.error('Failed to make move:', error);
            showTransactionStatus('❌ Move failed: ' + error.message, '');
            return false;
        }
    }

    async applyOpponentMoveToBoard(move) {
        console.log("🎯 Applying move to board:", move);

        try {
            // Apply move based on game type
            switch (move.gameType) {
                case 'chess':
                    if (window.chessEngine && move.moveData) {
                        const success = window.chessEngine.makeMove(
                            move.moveData.fromRow, 
                            move.moveData.fromCol,
                            move.moveData.toRow, 
                            move.moveData.toCol
                        );
                        if (success) {
                            updateChessBoard();
                            console.log("✅ Chess move applied successfully");
                        }
                    }
                    break;

                case 'checkers':
                    if (window.checkersEngine && move.moveData) {
                        const success = window.checkersEngine.makeMove(
                            move.moveData.fromRow, 
                            move.moveData.fromCol,
                            move.moveData.toRow, 
                            move.moveData.toCol
                        );
                        if (success) {
                            updateCheckersBoard();
                            console.log("✅ Checkers move applied successfully");
                        }
                    }
                    break;

                case 'words':
                    if (window.wordEngine && move.moveData) {
                        // Update opponent score
                        window.wordEngine.opponentScore += move.moveData.score;
                        const opponentScoreEl = document.getElementById('opponentWordScore');
                        if (opponentScoreEl) {
                            opponentScoreEl.textContent = window.wordEngine.opponentScore;
                        }
                        console.log("✅ Word move applied successfully");
                    }
                    break;
            }
        } catch (error) {
            console.error('Failed to apply opponent move:', error);
        }
    }

    async saveGameStateToAPI() {
        if (!this.currentGameId || !this.gameState) return false;
        
        return await window.apiManager.saveGameState(this.currentGameId, this.gameState);
    }

    updateTurnDisplay() {
        const gameTypes = ['chess', 'checkers', 'words'];
        
        gameTypes.forEach(gameType => {
            const statusEl = document.getElementById(gameType + 'Status');
            if (statusEl && this.gameType === gameType) {
                if (this.isMyTurn) {
                    statusEl.textContent = '🟢 Your Turn - Make a move!';
                    statusEl.style.color = '#2ecc71';
                } else {
                    statusEl.textContent = '🔴 Opponent\'s Turn - Please wait...';
                    statusEl.style.color = '#e74c3c';
                }
            }
        });

        // Enable/disable controls
        this.toggleGameControls(this.isMyTurn);
    }

    toggleGameControls(enabled) {
        // Chess board
        document.querySelectorAll('.chess-square').forEach(square => {
            square.style.pointerEvents = enabled ? 'auto' : 'none';
            square.style.opacity = enabled ? '1' : '0.7';
        });

        // Checkers board
        document.querySelectorAll('.checkers-square').forEach(square => {
            square.style.pointerEvents = enabled ? 'auto' : 'none';
            square.style.opacity = enabled ? '1' : '0.7';
        });

        // Word input
        const wordInput = document.getElementById('wordInput');
        if (wordInput) {
            wordInput.disabled = !enabled;
            wordInput.style.opacity = enabled ? '1' : '0.7';
        }
    }

    stopSync() {
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }
        this.currentGameId = null;
        this.isMyTurn = false;
        console.log("🛑 Game sync stopped");
    }
}

// Replace move sync with fixed version
window.moveSync = new FixedRealTimeMoveSync();

// RESTORE BLOCKCHAIN FUNCTIONALITY
async function createGameWithBlockchain() {
    const stakeInput = document.getElementById('gameStake');
    if (!stakeInput) {
        showTransactionStatus('❌ Stake input not found', '');
        return;
    }
    
    const stakeAmount = parseFloat(stakeInput.value) || 0;
    
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (!selectedGameType) {
        showTransactionStatus('❌ Please select a game type first', '');
        return;
    }
    
    if (stakeAmount < 0.01) {
        showTransactionStatus('❌ Please enter a valid stake amount (minimum 0.01 CORE)', '');
        return;
    }
    
    if (stakeAmount > currentBalance) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }

    try {
        showTransactionStatus('🔄 Creating blockchain game...', '');
        
        // Try blockchain first
        let blockchainSuccess = false;
        let txHash = '';
        
        if (window.blockchainManager && window.blockchainManager.contract) {
            try {
                const timeLimit = selectedGameType === 'chess' ? 600 : selectedGameType === 'checkers' ? 300 : 120;
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                
                showTransactionStatus('⏳ Submitting blockchain transaction...', '');
                
                const tx = await window.blockchainManager.contract.createGame(selectedGameType, timeLimit, {
                    value: stakeWei,
                    gasLimit: 300000
                });
                
                txHash = tx.hash;
                showTransactionStatus('⏳ Transaction submitted! Waiting for confirmation...', txHash);
                
                const receipt = await tx.wait();
                showTransactionStatus('✅ Blockchain game created successfully!', txHash);
                
                blockchainSuccess = true;
                
                // Update balance immediately
                currentBalance -= stakeAmount;
                updateBalanceDisplay();
                
            } catch (blockchainError) {
                console.error('Blockchain creation failed:', blockchainError);
                showTransactionStatus('⚠️ Blockchain failed, creating demo game...', '');
            }
        }
        
        // Create game object
        const newGame = {
            id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
            type: selectedGameType,
            creator: userAccount,
            creatorName: userAccount.substring(0, 8) + '...',
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now(),
            isDemo: !blockchainSuccess,
            txHash: txHash,
            blockchainGame: blockchainSuccess
        };

        // Add to global games and sync
        globalGamesList.push(newGame);
        await window.gameSync.createAndSyncGame(newGame);
        
        if (!blockchainSuccess) {
            currentBalance -= stakeAmount;
            updateBalanceDisplay();
        }
        
        // Award XP
        window.playerProgression.awardXP(blockchainSuccess ? 100 : 50, blockchainSuccess ? 'Blockchain Game Created' : 'Demo Game Created');
        
        // Reset form
        stakeInput.value = '';
        selectedGameType = null;
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        updateCreateButton();

        updateGamesDisplay();
        showSection('lobby');
        
        showTransactionStatus(`✅ Game created! ${blockchainSuccess ? 'Blockchain secured!' : 'Demo mode active.'}`, txHash);

    } catch (error) {
        console.error('Failed to create game:', error);
        showTransactionStatus('❌ Failed to create game: ' + error.message, '');
    }
}

// RESTORE BLOCKCHAIN JOIN GAME
async function joinGameWithBlockchain(gameId, stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stakeAmount) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }

    const game = globalGamesList.find(g => g.id === gameId);
    if (!game) {
        showTransactionStatus('❌ Game not found', '');
        return;
    }

    showTransactionStatus('🎮 Joining game...', '');
    
    try {
        let blockchainSuccess = false;
        let txHash = '';
        
        // Try blockchain join if it's a blockchain game
        if (game.blockchainGame && window.blockchainManager && window.blockchainManager.contract) {
            try {
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                
                showTransactionStatus('⏳ Submitting blockchain join...', '');
                
                const tx = await window.blockchainManager.contract.joinGame(game.blockchainGameId || 1, {
                    value: stakeWei,
                    gasLimit: 250000
                });
                
                txHash = tx.hash;
                showTransactionStatus('⏳ Join transaction submitted!', txHash);
                
                const receipt = await tx.wait();
                showTransactionStatus('✅ Blockchain join successful!', txHash);
                
                blockchainSuccess = true;
                
            } catch (blockchainError) {
                console.error('Blockchain join failed:', blockchainError);
                showTransactionStatus('⚠️ Blockchain join failed, using demo mode...', '');
            }
        }
        
        // Update game state
        game.player2 = userAccount;
        game.status = 'playing';
        game.startedAt = Date.now();
        game.joinTxHash = txHash;
        
        // Move to active games
        myActiveGames.push(game);
        globalGamesList = globalGamesList.filter(g => g.id !== gameId);
        
        currentBalance -= stakeAmount;
        updateBalanceDisplay();
        
        // Save state
        await window.gameSync.createAndSyncGame(game);
        
        updateGamesDisplay();
        updateActiveGamesDisplay();
        
        // Award XP
        window.playerProgression.awardXP(blockchainSuccess ? 50 : 25, blockchainSuccess ? 'Blockchain Game Joined' : 'Demo Game Joined');
        
        showTransactionStatus(`✅ Game joined! ${blockchainSuccess ? 'Blockchain secured!' : 'Demo mode.'} Opening game...`, txHash);
        
        setTimeout(() => {
            openGameWindowWithSync(game.type, game);
        }, 1000);
        
    } catch (error) {
        console.error('Failed to join game:', error);
        showTransactionStatus('❌ Failed to join game: ' + error.message, '');
    }
}

// Replace the original functions
window.createGame = createGameWithBlockchain;
window.joinGame = joinGameWithBlockchain;

// Debug function to check sync status
window.checkSyncStatus = function() {
    console.log("🔍 SYNC STATUS DEBUG:");
    console.log("Current Game ID:", window.moveSync.currentGameId);
    console.log("Is My Turn:", window.moveSync.isMyTurn);
    console.log("Game Type:", window.moveSync.gameType);
    console.log("Move History:", window.moveSync.moveHistory);
    console.log("Sync Interval Active:", !!window.moveSync.syncInterval);
};

// Add sync status checker to UI
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        const header = document.querySelector('.header');
        if (header) {
            const debugBtn = document.createElement('button');
            debugBtn.textContent = '🔍 Debug';
            debugBtn.style.cssText = `
                background: #e74c3c;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 5px;
                color: white;
                cursor: pointer;
                margin-left: 0.5rem;
                font-size: 0.8rem;
            `;
            debugBtn.onclick = window.checkSyncStatus;
            header.appendChild(debugBtn);
        }
    }, 3000);
});

console.log("🔧 FIXED: Move sync and blockchain integration restored!");

      // CRITICAL FIXES - Copy and paste this entire section to replace the broken parts

// 1. FIX API MANAGER - Add the missing saveGameState function
class FixedAPIManager extends APIManager {
    async saveGameState(gameId, gameState) {
        try {
            console.log("💾 Saving game state for game:", gameId);
            
            // Load current data
            const currentData = await this.loadGameData() || {};
            
            // Initialize gameStates if needed
            if (!currentData.gameStates) {
                currentData.gameStates = {};
            }
            
            // Save the specific game state
            currentData.gameStates[gameId] = {
                ...gameState,
                lastUpdated: Date.now(),
                lastMoveTime: Date.now()
            };
            
            // Save back to API
            const response = await fetch(`${this.config.BASE_URL}/b/${this.config.BIN_ID}`, {
                method: 'PUT',
                headers: this.headers,
                body: JSON.stringify({
                    ...currentData,
                    lastUpdated: Date.now()
                })
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            console.log("✅ Game state saved successfully");
            return true;
        } catch (error) {
            console.error('Failed to save game state:', error);
            return false;
        }
    }

    async loadGameState(gameId) {
        try {
            const data = await this.loadGameData();
            if (data && data.gameStates && data.gameStates[gameId]) {
                console.log("📥 Loaded game state for game:", gameId);
                return data.gameStates[gameId];
            }
            return null;
        } catch (error) {
            console.error('Failed to load game state:', error);
            return null;
        }
    }
}

// Replace the API manager
window.apiManager = new FixedAPIManager();

// 2. FIX CHECKERS BOARD INITIALIZATION
function initializeCheckersBoard() {
    window.checkersEngine = new CheckersEngine();
    const board = document.getElementById('checkersBoard');
    if (!board) {
        console.error('Checkers board element not found!');
        return;
    }

    board.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            // Only dark squares can have pieces
            if ((row + col) % 2 === 1) {
                const piece = window.checkersEngine.board[row][col];
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `checker-piece ${piece.color}-piece`;
                    if (piece.type === 'king') {
                        pieceElement.classList.add('king');
                    }
                    square.appendChild(pieceElement);
                }
            }
            
            square.addEventListener('click', () => handleCheckersSquareClick(row, col));
            board.appendChild(square);
        }
    }
    
    updateCheckersBoard();
    console.log("✅ Checkers board initialized successfully");
}

// 3. FIX WORD GAME INITIALIZATION
function initializeWordGame() {
    window.wordEngine = new WordGameEngine();
    const engine = window.wordEngine;
    
    // Update UI elements
    const lettersEl = document.getElementById('wordLetters');
    const inputEl = document.getElementById('wordInput');
    
    if (lettersEl) {
        lettersEl.textContent = engine.availableLetters;
    }
    
    if (inputEl) {
        inputEl.value = '';
        inputEl.focus();
        
        // Add real-time validation
        inputEl.addEventListener('input', validateWordInput);
        inputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitWord();
            }
        });
    }
    
    updateWordGameUI();
    startWordGameTimer();
    console.log("✅ Word game initialized successfully");
}

// 4. FIX MOVE SYNC WITH PROPER ERROR HANDLING
class FixedRealTimeMoveSync {
    constructor() {
        this.currentGameId = null;
        this.isMyTurn = false;
        this.gameState = null;
        this.opponentAddress = null;
        this.moveHistory = [];
        this.syncInterval = null;
        this.lastSyncTime = 0;
        this.gameType = null;
    }

    startGameSync(gameId, gameType, isCreator = false) {
        this.currentGameId = gameId;
        this.gameType = gameType;
        this.isMyTurn = isCreator;
        this.gameState = { 
            gameId, 
            gameType, 
            moves: [], 
            currentPlayer: isCreator ? userAccount : 'waiting'
        };
        
        console.log(`🎮 Starting game sync for ${gameType} - Your turn: ${this.isMyTurn}`);
        
        // Save initial state
        this.saveGameStateToAPI();
        
        // Start sync every 2 seconds
        this.syncInterval = setInterval(async () => {
            await this.syncMovesFromAPI();
        }, 2000);
        
        this.updateTurnDisplay();
        showTransactionStatus(`🎮 Game started! ${isCreator ? 'You go first!' : 'Opponent goes first!'}`, '');
    }

    async syncMovesFromAPI() {
        if (!this.currentGameId || !window.apiManager) return;

        try {
            const serverGameState = await window.apiManager.loadGameState(this.currentGameId);
            
            if (serverGameState && serverGameState.lastMoveTime > this.lastSyncTime) {
                console.log("📥 New move detected from server");
                
                const serverMoves = serverGameState.moves || [];
                const lastMove = serverMoves[serverMoves.length - 1];
                
                if (lastMove && lastMove.player !== userAccount) {
                    console.log("🎯 Applying opponent move:", lastMove);
                    
                    await this.applyOpponentMove(lastMove);
                    
                    this.isMyTurn = true;
                    this.lastSyncTime = serverGameState.lastMoveTime;
                    this.moveHistory = serverMoves;
                    
                    this.updateTurnDisplay();
                    showTransactionStatus('📥 Opponent moved! Your turn now.', '');
                }
            }
        } catch (error) {
            console.error('Sync failed:', error);
        }
    }

    async makeMove(moveData) {
        if (!this.isMyTurn) {
            showTransactionStatus('❌ Not your turn! Wait for opponent.', '');
            return false;
        }

        try {
            const move = {
                player: userAccount,
                timestamp: Date.now(),
                moveData: moveData,
                gameType: this.gameType
            };

            this.moveHistory.push(move);
            this.gameState.moves = this.moveHistory;
            this.gameState.lastMoveTime = Date.now();

            const saved = await this.saveGameStateToAPI();
            
            if (saved) {
                this.isMyTurn = false;
                this.updateTurnDisplay();
                showTransactionStatus('✅ Move sent!', '');
                return true;
            } else {
                showTransactionStatus('❌ Failed to send move. Try again.', '');
                return false;
            }
        } catch (error) {
            console.error('Failed to make move:', error);
            showTransactionStatus('❌ Move failed: ' + error.message, '');
            return false;
        }
    }

    async applyOpponentMove(move) {
        try {
            switch (move.gameType) {
                case 'chess':
                    if (window.chessEngine && move.moveData) {
                        const success = window.chessEngine.makeMove(
                            move.moveData.fromRow, 
                            move.moveData.fromCol,
                            move.moveData.toRow, 
                            move.moveData.toCol
                        );
                        if (success) {
                            updateChessBoard();
                        }
                    }
                    break;

                case 'checkers':
                    if (window.checkersEngine && move.moveData) {
                        const success = window.checkersEngine.makeMove(
                            move.moveData.fromRow, 
                            move.moveData.fromCol,
                            move.moveData.toRow, 
                            move.moveData.toCol
                        );
                        if (success) {
                            updateCheckersBoard();
                        }
                    }
                    break;

                case 'words':
                    if (window.wordEngine && move.moveData) {
                        window.wordEngine.opponentScore += move.moveData.score;
                        const opponentScoreEl = document.getElementById('opponentWordScore');
                        if (opponentScoreEl) {
                            opponentScoreEl.textContent = window.wordEngine.opponentScore;
                        }
                    }
                    break;
            }
        } catch (error) {
            console.error('Failed to apply opponent move:', error);
        }
    }

    async saveGameStateToAPI() {
        if (!this.currentGameId || !this.gameState || !window.apiManager) return false;
        
        try {
            return await window.apiManager.saveGameState(this.currentGameId, this.gameState);
        } catch (error) {
            console.error('Failed to save game state:', error);
            return false;
        }
    }

    updateTurnDisplay() {
        const gameTypes = ['chess', 'checkers', 'words'];
        
        gameTypes.forEach(gameType => {
            const statusEl = document.getElementById(gameType + 'Status');
            if (statusEl && this.gameType === gameType) {
                if (this.isMyTurn) {
                    statusEl.textContent = '🟢 Your Turn';
                    statusEl.style.color = '#2ecc71';
                } else {
                    statusEl.textContent = '🔴 Opponent\'s Turn';
                    statusEl.style.color = '#e74c3c';
                }
            }
        });

        this.toggleGameControls(this.isMyTurn);
    }

    toggleGameControls(enabled) {
        // Chess board
        document.querySelectorAll('.chess-square').forEach(square => {
            square.style.pointerEvents = enabled ? 'auto' : 'none';
            square.style.opacity = enabled ? '1' : '0.7';
        });

        // Checkers board
        document.querySelectorAll('.checkers-square').forEach(square => {
            square.style.pointerEvents = enabled ? 'auto' : 'none';
            square.style.opacity = enabled ? '1' : '0.7';
        });

        // Word input
        const wordInput = document.getElementById('wordInput');
        if (wordInput) {
            wordInput.disabled = !enabled;
            wordInput.style.opacity = enabled ? '1' : '0.7';
        }
    }

    stopSync() {
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }
        this.currentGameId = null;
        this.isMyTurn = false;
        console.log("🛑 Game sync stopped");
    }
}

// Replace the move sync system
window.moveSync = new FixedRealTimeMoveSync();

// 5. FIX GAME HANDLERS WITH SYNC
function handleCheckersSquareClick(row, col) {
    if (!window.checkersEngine || !window.moveSync) return;
    
    if (!window.moveSync.isMyTurn) {
        showTransactionStatus('❌ Wait for your turn!', '');
        return;
    }
    
    const engine = window.checkersEngine;
    
    if (engine.selectedSquare) {
        const [selectedRow, selectedCol] = engine.selectedSquare;
        
        if (engine.makeMove(selectedRow, selectedCol, row, col)) {
            // Send move to opponent
            const moveData = {
                fromRow: selectedRow,
                fromCol: selectedCol,
                toRow: row,
                toCol: col,
                gameType: 'checkers'
            };
            
            window.moveSync.makeMove(moveData);
            updateCheckersBoard();
            clearCheckersSelection();
            
            if (engine.gameState !== 'playing') {
                handleGameEnd(engine.gameState);
            }
        } else {
            clearCheckersSelection();
            selectCheckersPiece(row, col);
        }
    } else {
        selectCheckersPiece(row, col);
    }
}

function selectCheckersPiece(row, col) {
    const engine = window.checkersEngine;
    const piece = engine.board[row][col];
    
    if (piece && piece.color === engine.currentPlayer) {
        engine.selectedSquare = [row, col];
        engine.legalMoves = engine.getPossibleMoves(row, col);
        
        const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        square.classList.add('selected');
        
        engine.legalMoves.forEach(move => {
            const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
            if (moveSquare) {
                moveSquare.classList.add('legal-move');
            }
        });
    }
}

function clearCheckersSelection() {
    if (window.checkersEngine) {
        window.checkersEngine.selectedSquare = null;
        window.checkersEngine.legalMoves = [];
    }
    
    document.querySelectorAll('.checkers-square').forEach(square => {
        square.classList.remove('selected', 'legal-move');
    });
}

// Enhanced word submission with sync
async function submitWord() {
    if (!window.wordEngine || !window.moveSync) return;
    
    if (!window.moveSync.isMyTurn) {
        showTransactionStatus('❌ Wait for your turn!', '');
        return;
    }
    
    const inputEl = document.getElementById('wordInput');
    if (!inputEl) return;
    
    const word = inputEl.value.trim();
    if (word.length < 3) return;
    
    try {
        const result = await window.wordEngine.submitWord(word);
        
        if (result.valid) {
            // Send move to opponent
            const moveData = {
                word: word.toUpperCase(),
                score: result.score,
                gameType: 'words'
            };
            
            await window.moveSync.makeMove(moveData);
            
            // Update UI
            const wordsListEl = document.getElementById('submittedWordsList');
            if (wordsListEl) {
                const wordChip = document.createElement('div');
                wordChip.className = 'word-chip';
                wordChip.textContent = `${word.toUpperCase()} (${result.score})`;
                wordsListEl.appendChild(wordChip);
            }
            
            const playerScoreEl = document.getElementById('playerWordScore');
            if (playerScoreEl) {
                playerScoreEl.textContent = result.totalScore;
            }
            
            inputEl.value = '';
            showTransactionStatus(`+${result.score} points! Opponent's turn...`, '');
            
        } else {
            showTransactionStatus('❌ Invalid word', '');
        }
        
    } catch (error) {
        console.error('Word submission error:', error);
        showTransactionStatus('❌ Word validation failed', '');
    }
}

// 6. FIX GAME WINDOW OPENING
function openGameWindowWithSync(gameType, gameData) {
    const windowId = gameType + 'GameWindow';
    const gameWindow = document.getElementById(windowId);
    
    if (!gameWindow) {
        console.error('Game window not found:', windowId);
        return;
    }

    gameWindow.classList.remove('hidden');
    isGameActive = true;
    activeGameType = gameType;
    
    updateGameWindowInfo(gameType, gameData);
    
    // Initialize the correct game board
    switch (gameType) {
        case 'chess':
            initializeChessBoard();
            break;
        case 'checkers':
            initializeCheckersBoard();
            break;
        case 'words':
            initializeWordGame();
            break;
    }
    
    // Start move synchronization
    const isCreator = gameData.creator === userAccount;
    if (window.moveSync) {
        window.moveSync.startGameSync(gameData.id, gameType, isCreator);
        window.moveSync.opponentAddress = isCreator ? gameData.player2 : gameData.creator;
    }
    
    showTransactionStatus(`🎮 ${getGameName(gameType)} opened!`, '');
}

// Replace the original functions
window.openGameWindow = openGameWindowWithSync;
window.handleCheckersSquareClick = handleCheckersSquareClick;
window.submitWord = submitWord;

// 7. ADD DEBUG FUNCTION
window.debugGameState = function() {
    console.log("🔍 GAME DEBUG INFO:");
    console.log("Current Game ID:", window.moveSync?.currentGameId);
    console.log("Is My Turn:", window.moveSync?.isMyTurn);
    console.log("Game Type:", window.moveSync?.gameType);
    console.log("Chess Engine:", !!window.chessEngine);
    console.log("Checkers Engine:", !!window.checkersEngine);
    console.log("Word Engine:", !!window.wordEngine);
    console.log("API Manager:", !!window.apiManager);
    console.log("Move Sync:", !!window.moveSync);
};

console.log("🔧 CRITICAL FIXES APPLIED:");
console.log("✅ API Manager saveGameState function added");
console.log("✅ Checkers board initialization fixed");
console.log("✅ Word game initialization fixed");
console.log("✅ Move sync with proper error handling");
console.log("✅ Game handlers with turn validation");
console.log("📝 Use window.debugGameState() to check status");
    
</script>
</body>
</html>
                            
