<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypticus - Live Blockchain Gaming Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
        }
        
        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .logo {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .nav-menu {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        
        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .nav-item {
            padding: 0.5rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        
        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(78, 205, 196, 0.5);
        }
        
        .nav-item.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }
        
        .live-badge {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .wallet-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .wallet-info {
            text-align: right;
        }
        
        .connection-status {
            font-size: 0.9rem;
            color: #ff6b6b;
        }
        
        .balance {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .connect-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
        }
        
        .disconnect-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 0.5rem;
        }
        
        .main-container {
            display: flex;
            min-height: calc(100vh - 80px);
        }
        
        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            overflow-y: auto;
        }
        
        .content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }
        
        .fee-info {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .fee-info h3 {
            color: #ffd700;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }
        
        .fee-info p {
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }
        
        .game-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            border-color: rgba(78, 205, 196, 0.5);
        }
        
        .coming-soon {
            opacity: 0.7;
            position: relative;
        }
        
        .coming-soon::after {
            content: "COMING SOON";
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.7rem;
            font-weight: bold;
        }
        
        .create-game-btn {
            width: 100%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            padding: 1rem;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            margin-top: 1rem;
        }
        
        .create-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 107, 107, 0.3);
        }
        
        .stake-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            color: white;
            font-size: 1rem;
            margin: 1rem 0;
        }
        
        .stake-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .news-feed {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .news-item {
            padding: 1rem;
            margin: 0.5rem 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #4ecdc4;
        }
        
        .news-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #4ecdc4;
        }
        
        .news-time {
            font-size: 0.8rem;
            color: #aaa;
        }
        
        .hidden {
            display: none;
        }

        /* Chess Game Styles */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 3px solid #4ecdc4;
            border-radius: 10px;
            margin: 1rem auto;
            background: #f4f4f4;
        }
        
        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .chess-square.white {
            background: #f0d9b5;
        }
        
        .chess-square.black {
            background: #b58863;
        }
        
        .chess-square.selected {
            background: #ff6b6b !important;
            box-shadow: inset 0 0 10px rgba(255, 107, 107, 0.5);
        }
        
        .chess-square.possible-move {
            background: rgba(78, 205, 196, 0.3) !important;
        }
        
        .chess-square.possible-move::after {
            content: '‚óè';
            color: #4ecdc4;
            position: absolute;
            font-size: 1rem;
        }

        /* Checkers Game Styles */
        .checkers-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 3px solid #4ecdc4;
            border-radius: 10px;
            margin: 1rem auto;
        }
        
        .checkers-square {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .checkers-square.dark {
            background: #8b4513;
        }
        
        .checkers-square.light {
            background: #deb887;
        }
        
        .checker-piece {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 2px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .red-piece {
            background: radial-gradient(circle, #ff4444, #cc0000);
        }
        
        .black-piece {
            background: radial-gradient(circle, #444444, #000000);
        }
        
        .king {
            font-size: 1.2rem;
        }

        /* Word Game Styles */
        .word-game {
            max-width: 500px;
            margin: 1rem auto;
            text-align: center;
        }
        
        .word-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
            color: white;
            font-size: 1.2rem;
            text-align: center;
            margin: 1rem 0;
        }
        
        .word-score {
            display: flex;
            justify-content: space-between;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .game-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
        }
        
        .game-controls {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            justify-content: center;
        }
        
        .game-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }
        
        .game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Transaction Status */
        .transaction-status {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #4ecdc4;
            border-radius: 10px;
            padding: 1rem;
            max-width: 300px;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        
        .transaction-status.show {
            transform: translateX(0);
        }
        
        .tx-hash {
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            color: #4ecdc4;
            margin-top: 0.5rem;
        }

        /* Game Window Styles */
        .game-window {
¬† ¬† position: fixed;
¬† ¬† top: 50%;
¬† ¬† left: 50%;
¬† ¬† transform: translate(-50%, -50%);
¬† ¬† background: rgba(0, 0, 0, 0.95);
¬† ¬† backdrop-filter: blur(15px);
¬† ¬† border: 2px solid #4ecdc4;
¬† ¬† border-radius: 15px;
¬† ¬† padding: 1.5rem;
¬† ¬† z-index: 1000;
¬† ¬† max-width: 90vw;
¬† ¬† max-height: 90vh;
¬† ¬† overflow-y: auto;
¬† ¬† box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
}

/* Different z-index for each game window */
#chessGameWindow {
¬† ¬† z-index: 1001;
}

#checkersGameWindow {
¬† ¬† z-index: 1002;
}

#wordGameWindow {
¬† ¬† z-index: 1003;
}

/* Stagger window positions to prevent exact overlap */
#chessGameWindow {
¬† ¬† top: 45%;
¬† ¬† left: 45%;
}

#checkersGameWindow {
¬† ¬† top: 50%;
¬† ¬† left: 50%;
}

#wordGameWindow {
¬† ¬† top: 55%;
¬† ¬† left: 55%;
}

.game-window.minimized {
¬† ¬† top: auto;
¬† ¬† bottom: 20px;
¬† ¬† right: 20px;
¬† ¬† left: auto;
¬† ¬† transform: none;
¬† ¬† width: 300px;
¬† ¬† height: 60px;
¬† ¬† overflow: hidden;
¬† ¬† cursor: pointer;
}

/* Stack minimized windows */
#chessGameWindow.minimized {
¬† ¬† bottom: 90px;
}

#checkersGameWindow.minimized {
¬† ¬† bottom: 160px;
}

#wordGameWindow.minimized {
¬† ¬† bottom: 230px;
}

/* Active Game Lobby Styles */
.active-games {
¬† ¬† background: rgba(255, 255, 255, 0.05);
¬† ¬† border-radius: 15px;
¬† ¬† padding: 1.5rem;
¬† ¬† margin-bottom: 2rem;
}

.game-lobby-item {
¬† ¬† display: flex;
¬† ¬† justify-content: space-between;
¬† ¬† align-items: center;
¬† ¬† padding: 1rem;
¬† ¬† margin: 0.5rem 0;
¬† ¬† background: rgba(255, 255, 255, 0.05);
¬† ¬† border-radius: 8px;
¬† ¬† border-left: 3px solid #4ecdc4;
¬† ¬† transition: all 0.3s ease;
}

.game-lobby-item:hover {
¬† ¬† background: rgba(255, 255, 255, 0.1);
¬† ¬† transform: translateX(5px);
}

.join-game-btn {
¬† ¬† background: linear-gradient(45deg, #00ff88, #00cc6a);
¬† ¬† border: none;
¬† ¬† padding: 0.5rem 1rem;
¬† ¬† border-radius: 20px;
¬† ¬† color: black;
¬† ¬† font-weight: bold;
¬† ¬† cursor: pointer;
¬† ¬† transition: all 0.3s ease;
}

.join-game-btn:hover {
¬† ¬† transform: translateY(-2px);
¬† ¬† box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
}

        
        .game-window.minimized {
            top: auto;
            bottom: 20px;
            right: 20px;
            left: auto;
            transform: none;
            width: 300px;
            height: 60px;
            overflow: hidden;
            cursor: pointer;
        }
        
        .game-window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-window-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .game-window-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .window-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }
        
        .window-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .minimize-btn {
            background: rgba(255, 193, 7, 0.3);
        }
        
        .close-btn {
            background: rgba(220, 53, 69, 0.3);
        }
        
        .game-window-content {
            display: block;
        }
        
        .game-window.minimized .game-window-content {
            display: none;
        }
        
        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
        }
        
        .game-overlay.hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
                flex-wrap: wrap;
            }
            
            .nav-menu {
                position: fixed;
                top: 80px;
                left: -100%;
                width: 100%;
                height: calc(100vh - 80px);
                background: rgba(0, 0, 0, 0.95);
                backdrop-filter: blur(10px);
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                padding-top: 2rem;
                gap: 2rem;
                transition: left 0.3s ease;
                z-index: 1000;
            }
            
            .nav-menu.active {
                left: 0;
            }
            
            .mobile-menu-btn {
                display: block;
            }
            
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                order: 2;
                padding: 1rem;
            }
            
            .content-area {
                order: 1;
                padding: 1rem;
            }
            
            .games-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .chess-board, .checkers-board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }
            
            .chess-square, .checkers-square {
                font-size: 1.5rem;
            }
            
            .checker-piece {
                width: 35px;
                height: 35px;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="logo">CRYPTICUS</div>
        <button class="mobile-menu-btn" onclick="toggleMobileMenu()">‚ò∞</button>
        <div class="nav-menu" id="navMenu">
            <div class="nav-item active" onclick="showSection('games')">üéÆ Games</div>
            <div class="nav-item" onclick="showSection('leaderboard')">üèÜ Leaderboard</div>
            <div class="nav-item" onclick="showSection('profile')">üë§ Profile</div>
            <div class="nav-item" onclick="showSection('chat')">üí¨ Chat</div>
            <div class="nav-item" onclick="showSection('news')">üì∞ News</div>
            <div class="nav-item" onclick="showSection('settings')">‚öôÔ∏è Settings</div>
        </div>
        <div class="live-badge">üî¥ LIVE ON CORE</div>
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">üî¥ Not Connected</div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn">Connect Wallet</button>
            <button class="disconnect-btn hidden" id="disconnectBtn">Disconnect</button>
        </div>
    </div>
    
    <!-- Transaction Status Popup -->
    <div class="transaction-status" id="transactionStatus">
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="news-feed">
                <h3>üì∞ Live Game Feed</h3>
                <div id="gameFeed">
                    <div class="news-item">
                        <div class="news-title">üéÆ Active Games: 12</div>
                        <div class="news-time">Players online now</div>
                    </div>
                    <div class="news-item">
                        <div class="news-title">üí∞ Total Pool: 156.7 CORE</div>
                        <div class="news-time">Live betting volume</div>
                    </div>
                    <div class="news-item">
                        <div class="news-title">üèÜ Last Winner: CryptoKing</div>
                        <div class="news-time">Won 5.2 CORE in Chess</div>
                    </div>
                </div>
            </div>
        </div>
                <!-- Age Verification Modal -->
        <div id="ageVerificationModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; align-items: center; justify-content: center;">
            <div style="background: rgba(0,0,0,0.95); border: 2px solid #4ecdc4; border-radius: 15px; padding: 2rem; text-align: center; max-width: 400px;">
                <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üîû Age Verification Required</h3>
                <p style="margin-bottom: 1.5rem;">You must be 18 or older to use this platform.</p>
                <p style="margin-bottom: 1.5rem; font-size: 0.9rem; color: #aaa;">By proceeding, you confirm you meet age requirements and agree to our terms.</p>
                <button onclick="verifyAge(true)" style="background: linear-gradient(45deg, #4ecdc4, #44a08d); border: none; padding: 1rem 2rem; border-radius: 25px; color: white; font-weight: bold; margin: 0.5rem; cursor: pointer;">I am 18+</button>
                <button onclick="verifyAge(false)" style="background: linear-gradient(45deg, #ff6b6b, #ee5a52); border: none; padding: 1rem 2rem; border-radius: 25px; color: white; font-weight: bold; margin: 0.5rem; cursor: pointer;">Under 18</button>
            </div>
        </div>

        <!-- Game Windows -->
    <div class="game-overlay hidden" id="gameOverlay"></div>

    <!-- Chess Game Window -->
    <div class="game-window hidden" id="chessGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">‚ôüÔ∏è Chess Masters</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('chess')">‚àí</button>
                <button class="window-btn close-btn" onclick="closeGame('chess')">√ó</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="chessStatus">Waiting for opponent...</div>
            <div class="chess-board" id="chessBoard"></div>
            <div class="game-controls">
                <button class="game-btn" onclick="resignChess()">Resign</button>
                <button class="game-btn" onclick="drawChess()">Offer Draw</button>
            </div>
        </div>
    </div>

    <!-- Checkers Game Window -->
    <div class="game-window hidden" id="checkersGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">‚ö´ Checkers Pro</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('checkers')">‚àí</button>
                <button class="window-btn close-btn" onclick="closeGame('checkers')">√ó</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
            <div class="checkers-board" id="checkersBoard"></div>
            <div class="game-controls">
                <button class="game-btn" onclick="resignCheckers()">Resign</button>
            </div>
        </div>
    </div>

    <!-- Word Game Window -->
    <div class="game-window hidden" id="wordGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">üìù Word Battle</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('word')">‚àí</button>
                <button class="window-btn close-btn" onclick="closeGame('word')">√ó</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="wordStatus">Round 1 of 3</div>
            <div class="word-game">
                <h4 id="wordPrompt">Make a word with these letters:</h4>
                <div id="wordLetters" style="font-size: 2rem; color: #4ecdc4; margin: 1rem 0;">BLOCKCHAIN</div>
                <input type="text" class="word-input" id="wordInput" placeholder="Enter your word..." maxlength="20">
                <div class="word-score">
                    <div>Your Score: <span id="playerScore">0</span></div>
                    <div>Opponent: <span id="opponentScore">0</span></div>
                </div>
                <div class="game-controls">
                    <button class="game-btn" onclick="submitWord()">Submit Word</button>
                    <button class="game-btn" onclick="skipRound()">Skip Round</button>
                </div>
            </div>
        </div>
    </div>
        
        <div class="content-area">
            <!-- Games Section -->
            <div id="gamesSection">
    <div class="fee-info">
        <h3>üèÜ Smart Contract Gaming</h3>
        <p><strong>97% of every stake goes directly to the winner!</strong></p>
        <p>Powered by Core Blockchain ‚Ä¢ Instant payouts ‚Ä¢ Provably fair</p>
        <p>Contract Address: 0x1234...5678 (Verified ‚úÖ)</p>
    </div>

    <div class="legal-notice">
        <h4>‚öñÔ∏è Legal Notice</h4>
        <p>‚Ä¢ Educational gaming platform for skill development</p>
        <p>‚Ä¢ Minimum age: 18+ required</p>
        <p>‚Ä¢ Tax obligations: Players responsible for local tax compliance</p>
        <p>‚Ä¢ Not available in restricted jurisdictions</p>
    </div>
                
    <div class="active-games">
        <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üéØ Active Games - Join Now!</h3>
        <div id="activeGamesList">
            <div class="game-lobby-item">
                <div>
                    <strong>‚ôüÔ∏è Chess Masters</strong>
                    <div style="font-size: 0.9rem; color: #aaa;">CryptoKing ‚Ä¢ Stake: 0.5 CORE</div>
                </div>
                <button class="join-game-btn" onclick="joinGame('chess', '0x123...', 0.5)">Join Game</button>
            </div>
            
            <div class="game-lobby-item">
                <div>
                    <strong>‚ö´ Checkers Pro</strong>
                    <div style="font-size: 0.9rem; color: #aaa;">GameMaster ‚Ä¢ Stake: 0.3 CORE</div>
                </div>
                <button class="join-game-btn" onclick="joinGame('checkers', '0x456...', 0.3)">Join Game</button>
            </div>
            
            <div class="game-lobby-item">
                <div>
                    <strong>üìù Word Battle</strong>
                    <div style="font-size: 0.9rem; color: #aaa;">WordWizard ‚Ä¢ Stake: 0.8 CORE</div>
                </div>
                <button class="join-game-btn" onclick="joinGame('words', '0x789...', 0.8)">Join Game</button>
            </div>
            
            <div id="noActiveGames" class="hidden" style="text-align: center; padding: 2rem; color: #aaa;">
                No active games right now. Create one below! üéÆ
            </div>
        </div>
    </div>
                
    <h2>üéÆ Blockchain Games (LIVE)</h2>
    <div class="games-grid">
        <div class="game-card" id="chessCard">
            <h3>‚ôüÔ∏è Chess Masters</h3>
            <p>Play chess with real CORE stakes! Smart contract ensures fair play.</p>
            <input type="number" class="stake-input" id="chessStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
            <button class="create-game-btn" onclick="startChessGame()">Start Chess Game</button>
        </div>
        
        <div class="game-card" id="checkersCard">
            <h3>‚ö´ Checkers Pro</h3>
            <p>Fast checkers with blockchain stakes! Quick games, instant rewards.</p>
            <input type="number" class="stake-input" id="checkersStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
            <button class="create-game-btn" onclick="startCheckersGame()">Start Checkers Game</button>
        </div>
        
        <div class="game-card" id="wordCard">
            <h3>üìù Word Battle</h3>
            <p>Compete in word games with crypto stakes! Test your vocabulary.</p>
            <input type="number" class="stake-input" id="wordStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
            <button class="create-game-btn" onclick="startWordGame()">Start Word Game</button>
        </div>
        
        <div class="game-card coming-soon">
            <h3>‚öîÔ∏è Crypto Kombat</h3>
            <p>Epic fighting game with NFT characters! Stake tokens and battle for supremacy.</p>
            <input type="number" class="stake-input" placeholder="Enter stake (min 0.01 CORE)" disabled>
            <button class="create-game-btn" disabled>Coming Soon</button>
        </div>
        
        <div class="game-card coming-soon">
            <h3>‚öΩ Block League</h3>
            <p>FIFA-style soccer with blockchain stakes! Build teams with NFT players.</p>
            <input type="number" class="stake-input" placeholder="Enter stake (min 0.01 CORE)" disabled>
            <button class="create-game-btn" disabled>Coming Soon</button>
        </div>
    </div>
</div>
            <!-- Leaderboard Section -->
            <div id="leaderboardSection" class="hidden">
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h3 style="color: #ffd700; margin-bottom: 1rem;">üèÜ Top Players This Week</h3>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.8rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                        <div>
                            <strong>ü•á CryptoKing</strong>
                            <div style="font-size: 0.9rem; color: #4ecdc4;">23 wins ‚Ä¢ 156.7 CORE earned</div>
                        </div>
                        <div style="color: #ffd700; font-weight: bold;">156.7 CORE</div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.8rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                        <div>
                            <strong>ü•à BlockMaster</strong>
                            <div style="font-size: 0.9rem; color: #4ecdc4;">19 wins ‚Ä¢ 134.2 CORE earned</div>
                        </div>
                        <div style="color: #ffd700; font-weight: bold;">134.2 CORE</div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.8rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                        <div>
                            <strong>ü•â GameWarrior</strong>
                            <div style="font-size: 0.9rem; color: #4ecdc4;">17 wins ‚Ä¢ 98.5 CORE earned</div>
                        </div>
                        <div style="color: #ffd700; font-weight: bold;">98.5 CORE</div>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 2rem 0 1rem 0;">üéØ Recent Matches</h3>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>‚ôüÔ∏è Chess:</strong> CryptoKing vs BlockMaster
                                <div style="font-size: 0.8rem; color: #aaa;">5 minutes ago</div>
                            </div>
                            <div style="color: #00ff88;">Winner: CryptoKing (+2.3 CORE)</div>
                        </div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>‚ö´ Checkers:</strong> GameWarrior vs TokenMaster
                                <div style="font-size: 0.8rem; color: #aaa;">12 minutes ago</div>
                            </div>
                            <div style="color: #00ff88;">Winner: GameWarrior (+1.8 CORE)</div>
                        </div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>üìù Words:</strong> WordWizard vs VocabKing
                                <div style="font-size: 0.8rem; color: #aaa;">18 minutes ago</div>
                            </div>
                            <div style="color: #00ff88;">Winner: WordWizard (+0.9 CORE)</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Profile Section -->
            <div id="profileSection" class="hidden">
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üë§ Player Profile</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Games Played</h4>
                            <p style="font-size: 2rem; color: #4ecdc4;" id="profileGamesPlayed">0</p>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Games Won</h4>
                            <p style="font-size: 2rem; color: #00ff88;" id="profileGamesWon">0</p>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Total Earned</h4>
                            <p style="font-size: 2rem; color: #ffd700;" id="profileTotalEarned">0 CORE</p>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                            <h4>Win Rate</h4>
                            <p style="font-size: 2rem; color: #ff6b6b;" id="profileWinRate">0%</p>
                        </div>
                    </div>
                    
                    <h4 style="color: #4ecdc4; margin-bottom: 1rem;">üéÆ Game Breakdown</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem;">‚ôüÔ∏è</div>
                            <div><strong>Chess</strong></div>
                            <div style="font-size: 0.9rem; color: #aaa;" id="chessStats">0W / 0L</div>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem;">‚ö´</div>
                            <div><strong>Checkers</strong></div>
                            <div style="font-size: 0.9rem; color: #aaa;" id="checkersStats">0W / 0L</div>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem;">üìù</div>
                            <div><strong>Words</strong></div>
                            <div style="font-size: 0.9rem; color: #aaa;" id="wordStats">0W / 0L</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Section -->
           <div id="chatSection" class="hidden">
    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; height: 500px; display: flex; flex-direction: column;">
        <h3 style="margin-bottom: 1rem;">üí¨ Global Chat</h3>
        <div style="flex: 1; overflow-y: auto; margin-bottom: 1rem; padding: 1rem; background: rgba(0, 0, 0, 0.2); border-radius: 8px;" id="chatMessages">
            <div style="margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);">
                <strong>CryptoKing:</strong> Just won 2.5 CORE in Chess! üéâ
            </div>
            <div style="margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);">
                <strong>GameMaster:</strong> New high stakes game starting soon!
            </div>
            <div style="margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);">
                <strong>BlockchainBro:</strong> Anyone up for Word Battle?
            </div>
            <div style="margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);">
                <strong>TokenMaster:</strong> Chess game starting! 1 CORE stake üí∞
            </div>
            <div style="margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);">
                <strong>WordWizard:</strong> Beat that score! 847 points in Word Battle üìù
            </div>
        </div>
        <div style="display: flex; gap: 0.5rem;">
            <input type="text" style="flex: 1; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; padding: 0.8rem; color: white;" placeholder="Type your message..." id="chatInput" onkeypress="handleChatKeyPress(event)">
            <button style="background: linear-gradient(45deg, #4ecdc4, #44a08d); border: none; padding: 0.8rem 1.5rem; border-radius: 8px; color: white; font-weight: bold; cursor: pointer;" onclick="sendChatMessage()">Send</button>
        </div>
    </div>
</div>

<!-- News Section - REPLACE EXISTING -->
<div id="newsSection" class="hidden">
    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem;">
        <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üì∞ Crypto Breaking News</h3>
        <div id="mainNewsDisplay">
            <div class="news-item">
                <div class="news-title">üöÄ Bitcoin Surges Past $45,000 as Institutional Adoption Grows</div>
                <p style="margin: 0.5rem 0; font-size: 0.9rem;">Major financial institutions continue to embrace cryptocurrency as a legitimate asset class, driving unprecedented demand.</p>
                <div class="news-time">2 hours ago ‚Ä¢ CoinDesk</div>
            </div>
            
            <div class="news-item">
                <div class="news-title">‚ö° Ethereum Layer 2 Networks See Record Volume</div>
                <p style="margin: 0.5rem 0; font-size: 0.9rem;">Polygon, Arbitrum, and Optimism process over $2B in daily transactions as users seek lower fees.</p>
                <div class="news-time">4 hours ago ‚Ä¢ The Block</div>
            </div>
            
            <div class="news-item">
                <div class="news-title">üéÆ Gaming NFTs Market Explodes with $500M Monthly Volume</div>
                <p style="margin: 0.5rem 0; font-size: 0.9rem;">Blockchain gaming platforms like Axie Infinity and Gods Unchained drive massive NFT trading volumes.</p>
                <div class="news-time">6 hours ago ‚Ä¢ NFT Evening</div>
            </div>
            
            <div class="news-item">
                <div class="news-title">üî• DeFi Total Value Locked Reaches New All-Time High</div>
                <p style="margin: 0.5rem 0; font-size: 0.9rem;">Decentralized finance protocols now secure over $100 billion in assets across multiple blockchains.</p>
                <div class="news-time">8 hours ago ‚Ä¢ DeFi Pulse</div>
            </div>
        </div>
    </div>
    
    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem;">
        <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üéÆ Gaming Industry News</h3>
        <div class="news-item">
            <div class="news-title">‚öîÔ∏è Blockchain Gaming Revenue Hits $4.6B in 2024</div>
            <p style="margin: 0.5rem 0; font-size: 0.9rem;">Play-to-earn games dominate the gaming landscape with over 1.3 million daily active users across all platforms.</p>
            <div class="news-time">3 hours ago ‚Ä¢ GameFi Today</div>
        </div>
        
        <div class="news-item">
            <div class="news-title">üèÜ Esports Prize Pools Now Include Cryptocurrency</div>
            <p style="margin: 0.5rem 0; font-size: 0.9rem;">Major tournaments offering Bitcoin and Ethereum prizes, with total crypto prizes exceeding $50M this year.</p>
            <div class="news-time">5 hours ago ‚Ä¢ Esports Insider</div>
        </div>
    </div>
</div>

<!-- Settings Section - REPLACE EXISTING -->
<div id="settingsSection" class="hidden">
    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem;">
        <h3 style="margin-bottom: 1rem;">‚öôÔ∏è Platform Settings</h3>
        
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
            <div>
                <strong>Sound Effects</strong>
                <div style="font-size: 0.9rem; color: #aaa;">Game sounds and notifications</div>
            </div>
            <div class="toggle-switch active" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                <div style="position: absolute; top: 3px; left: 33px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
            </div>
        </div>
        
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
            <div>
                <strong>Chat Notifications</strong>
                <div style="font-size: 0.9rem; color: #aaa;">Global chat message alerts</div>
            </div>
            <div class="toggle-switch active" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                <div style="position: absolute; top: 3px; left: 33px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
            </div>
        </div>
        
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
            <div>
                <strong>High Stakes Warnings</strong>
                <div style="font-size: 0.9rem; color: #aaa;">Confirm games over 1 CORE</div>
            </div>
            <div class="toggle-switch active" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                <div style="position: absolute; top: 3px; left: 33px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
            </div>
        </div>
    </div>
    
    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem;">
        <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üîß Smart Contract Settings</h3>
        
        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
            <strong>Contract Address:</strong>
            <div style="font-family: monospace; font-size: 0.9rem; color: #4ecdc4; margin-top: 0.5rem;">0x1234567890abcdef1234567890abcdef12345678</div>
            <div style="font-size: 0.8rem; color: #00ff88; margin-top: 0.3rem;">‚úÖ Verified on Core Blockchain</div>
        </div>
        
        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
            <strong>Network Status:</strong>
            <div style="margin-top: 0.5rem; color: #00ff88;">üü¢ Core Blockchain - Connected</div>
            <div style="font-size: 0.9rem; color: #aaa;">Block: 1,234,567 | Gas: 15 GWEI</div>
        </div>
    </div>
</div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                        <div>
                            <strong>Chat Notifications</strong>
                            <div style="font-size: 0.9rem; color: #aaa;">Global chat message alerts</div>
                        </div>
                        <div class="toggle-switch active" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 3px; left: 33px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                        <div>
                            <strong>Auto-Connect Wallet</strong>
                            <div style="font-size: 0.9rem; color: #aaa;">Remember wallet for future sessions</div>
                        </div>
                        <div class="toggle-switch" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: rgba(255, 255, 255, 0.2); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 3px; left: 3px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                        <div>
                            <strong>High Stakes Warnings</strong>
                            <div style="font-size: 0.9rem; color: #aaa;">Confirm games over 1 CORE</div>
                        </div>
                        <div class="toggle-switch active" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 3px; left: 33px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                        <div>
                            <strong>Transaction Confirmations</strong>
                            <div style="font-size: 0.9rem; color: #aaa;">Show blockchain transaction status</div>
                        </div>
                        <div class="toggle-switch active" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 3px; left: 33px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                        <div>
                            <strong>Live News Updates</strong>
                            <div style="font-size: 0.9rem; color: #aaa;">Real-time crypto news feed</div>
                        </div>
                        <div class="toggle-switch active" onclick="toggleSetting(this)" style="position: relative; width: 60px; height: 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border-radius: 15px; cursor: pointer; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 3px; left: 33px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: all 0.3s ease;"></div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem;">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üîß Smart Contract Settings</h3>
                    
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <strong>Contract Address:</strong>
                        <div style="font-family: monospace; font-size: 0.9rem; color: #4ecdc4; margin-top: 0.5rem;">0x1234567890abcdef1234567890abcdef12345678</div>
                        <div style="font-size: 0.8rem; color: #00ff88; margin-top: 0.3rem;">‚úÖ Verified on Core Blockchain</div>
                    </div>
                    
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <strong>Gas Settings:</strong>
                        <div style="margin-top: 0.5rem;">
                            <label style="display: block; margin-bottom: 0.5rem;">Gas Price (GWEI):</label>
                            <input type="number" style="width: 100%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px; padding: 0.5rem; color: white;" value="20" min="1" max="100">
                        </div>
                    </div>
                    
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; margin: 0.5rem 0;">
                        <strong>Network Status:</strong>
                        <div style="margin-top: 0.5rem; color: #00ff88;">üü¢ Core Blockchain - Connected</div>
                        <div style="font-size: 0.9rem; color: #aaa;">Block: 1,234,567 | Gas: 15 GWEI</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let provider = null;
        let signer = null;
        let userAddress = null;
        let currentSection = 'games';
        let gameContract = null;

        let ageVerified = false;
        let kycCompleted = false;
        
        // Smart Contract ABI (simplified for demo)
        const CONTRACT_ABI = [
            "function createGame(uint8 gameType, uint256 stake) external payable",
            "function joinGame(uint256 gameId) external payable",
            "function makeMove(uint256 gameId, string memory move) external",
            "function declareWinner(uint256 gameId, address winner) external",
            "function getGameInfo(uint256 gameId) external view returns (tuple(address player1, address player2, uint256 stake, uint8 gameType, uint8 status))",
            "event GameCreated(uint256 indexed gameId, address indexed creator, uint8 gameType, uint256 stake)",
            "event GameJoined(uint256 indexed gameId, address indexed joiner)",
            "event MoveMade(uint256 indexed gameId, address indexed player, string move)",
            "event GameEnded(uint256 indexed gameId, address indexed winner, uint256 prize)"
        ];
        
        const CONTRACT_ADDRESS = "0x1234567890abcdef1234567890abcdef12345678"; // Demo address
        

// Global variables
let provider = null;
let signer = null;
let userAddress = null;
let gameContract = null;

// Smart Contract ABI (simplified for demo)
const CONTRACT_ABI = [
    "function createGame(uint8 gameType, uint256 stake) external payable",
    "function joinGame(uint256 gameId) external payable",
    "function makeMove(uint256 gameId, string memory move) external",
    "function declareWinner(uint256 gameId, address winner) external",
    "function getGameInfo(uint256 gameId) external view returns (tuple(address player1, address player2, uint256 stake, uint8 gameType, uint8 status))",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint8 gameType, uint256 stake)",
    "event GameJoined(uint256 indexed gameId, address indexed joiner)",
    "event MoveMade(uint256 indexed gameId, address indexed player, string move)",
    "event GameEnded(uint256 indexed gameId, address indexed winner, uint256 prize)"
];

const CONTRACT_ADDRESS = "0x1234567890abcdef1234567890abcdef12345678"; // Demo address

// WORKING Wallet connection - this is the key fix
function initializeWalletConnection() {
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    if (connectBtn) {
        connectBtn.addEventListener('click', async () => {
            try {
                if (typeof window.ethereum === 'undefined') {
                    alert('Please install MetaMask or Core Wallet to play!');
                    return;
                }
                
                showTransactionStatus('Connecting wallet...');
                
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts.length > 0) {
                    userAddress = accounts[0];
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    
                    // Initialize smart contract
                    gameContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                    
                    // Update UI
                    document.getElementById('connectionStatus').innerHTML = 
                        `üü¢ ${userAddress.substring(0, 6)}...${userAddress.substring(38)}`;
                    connectBtn.classList.add('hidden');
                    disconnectBtn.classList.remove('hidden');
                    
                    // Update balance
                    const balance = await provider.getBalance(userAddress);
                    const balanceInCore = ethers.utils.formatEther(balance);
                    document.getElementById('balanceDisplay').textContent = 
                        parseFloat(balanceInCore).toFixed(4) + ' CORE';
                    
                    showTransactionStatus('‚úÖ Wallet connected successfully!');
                    
                    // Listen for contract events
                    setupContractListeners();
                } else {
                    throw new Error('No accounts returned from wallet');
                }
                
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showTransactionStatus('‚ùå Error connecting wallet: ' + error.message);
            }
        });
    }
    
    if (disconnectBtn) {
        disconnectBtn.addEventListener('click', () => {
            userAddress = null;
            provider = null;
            signer = null;
            gameContract = null;
            
            // Reset UI
            document.getElementById('connectionStatus').innerHTML = 'üî¥ Not Connected';
            document.getElementById('balanceDisplay').textContent = '0.00 CORE';
            connectBtn.classList.remove('hidden');
            disconnectBtn.classList.add('hidden');
            
            showTransactionStatus('üëã Wallet disconnected');
        });
    }
}

// Setup contract event listeners
function setupContractListeners() {
    if (!gameContract) return;
    
    gameContract.on('GameCreated', (gameId, creator, gameType, stake) => {
        console.log('Game created:', gameId.toString(), creator, gameType, stake.toString());
        addChatMessage('System', `üéÆ New game created! ID: ${gameId.toString()}`);
    });
    
    gameContract.on('GameJoined', (gameId, joiner) => {
        console.log('Game joined:', gameId.toString(), joiner);
        addChatMessage('System', `üéØ Player joined game ${gameId.toString()}!`);
    });
    
    gameContract.on('MoveMade', (gameId, player, move) => {
        console.log('Move made:', gameId.toString(), player, move);
        // Handle move in UI
    });
    
    gameContract.on('GameEnded', (gameId, winner, prize) => {
        console.log('Game ended:', gameId.toString(), winner, prize.toString());
        const prizeInCore = ethers.utils.formatEther(prize);
        addChatMessage('System', `üèÜ Game ${gameId.toString()} won! Prize: ${prizeInCore} CORE`);
        
        // Update player stats if they won
        if (winner.toLowerCase() === userAddress.toLowerCase()) {
            playerStats.gamesWon++;
            playerStats.totalEarned += parseFloat(prizeInCore);
            updateProfileDisplay();
        }
    });
}

        
// Initialize wallet connection when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    initializeWalletConnection();
});

        // Player stats (stored locally for demo)
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    chess: { wins: 0, losses: 0 },
    checkers: { wins: 0, losses: 0 },
    words: { wins: 0, losses: 0 }
};

// Game state variables
let currentGame = null;
let chessBoard = [];
let checkersBoard = [];
let selectedSquare = null;
let currentPlayer = 'white';
let gameId = null;

// Show transaction status
function showTransactionStatus(message, txHash = '') {
    const statusDiv = document.getElementById('transactionStatus');
    const messageDiv = document.getElementById('txStatusMessage');
    const hashDiv = document.getElementById('txHash');
    
    messageDiv.textContent = message;
    if (txHash) {
        hashDiv.textContent = `TX: ${txHash.substring(0, 10)}...${txHash.substring(56)}`;
    } else {
        hashDiv.textContent = '';
    }
    
    statusDiv.classList.add('show');
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
        statusDiv.classList.remove('show');
    }, 5000);
}

// WORKING Chess Game Function
async function startChessGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('chessStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating chess game...');
        
        // Simulate contract interaction for demo
        setTimeout(async () => {
            try {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(0, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                // Open game window
                openGameWindow('chess');
                document.getElementById('chessStatus').textContent = 'Waiting for opponent...';
                initializeChessBoard();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Chess game created successfully!');
                addChatMessage('System', `üéÆ New chess game created! Stake: ${stakeAmount} CORE`);
                
                // Clear input
                document.getElementById('chessStake').value = '';
                
            } catch (error) {
                console.error('Contract error:', error);
                showTransactionStatus('‚ùå Demo mode: Chess game created locally');
                
                // Fallback for demo - still create the game
                openGameWindow('chess');
                initializeChessBoard();
                document.getElementById('chessStake').value = '';
            }
        }, 1000);
        
    } catch (error) {
        console.error('Error creating chess game:', error);
        showTransactionStatus('‚ùå Error creating game: ' + error.message);
    }
}

// WORKING Checkers Game Function
async function startCheckersGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating checkers game...');
        
        setTimeout(async () => {
            try {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(1, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                openGameWindow('checkers');
                document.getElementById('checkersStatus').textContent = 'Waiting for opponent...';
                initializeCheckersBoard();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Checkers game created!');
                addChatMessage('System', `üéÆ New checkers game created! Stake: ${stakeAmount} CORE`);
                
                document.getElementById('checkersStake').value = '';
                
            } catch (error) {
                console.error('Contract error:', error);
                showTransactionStatus('‚ùå Demo: Checkers game created locally');
                
                openGameWindow('checkers');
                initializeCheckersBoard();
                document.getElementById('checkersStake').value = '';
            }
        }, 1000);
        
    } catch (error) {
        console.error('Error creating checkers game:', error);
        showTransactionStatus('‚ùå Error: ' + error.message);
    }
}

// WORKING Word Game Function
async function startWordGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('wordStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating word game...');
        
        setTimeout(async () => {
            try {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(2, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                openGameWindow('word');
                startWordRound();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Word game created!');
                addChatMessage('System', `üéÆ New word game created! Stake: ${stakeAmount} CORE`);
                
                document.getElementById('wordStake').value = '';
                
            } catch (error) {
                console.error('Contract error:', error);
                showTransactionStatus('‚ùå Demo: Word game created locally');
                
                openGameWindow('word');
                startWordRound();
                document.getElementById('wordStake').value = '';
            }
        }, 1000);
        
    } catch (error) {
        console.error('Error creating word game:', error);
        showTransactionStatus('‚ùå Error: ' + error.message);
    }
}

        
      // Game window management
function openGameWindow(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (!gameWindow || !overlay) {
        console.error('Game window elements not found');
        return;
    }
    
    gameWindow.classList.remove('hidden', 'minimized');
    overlay.classList.remove('hidden');
    
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            closeGame(gameType);
        }
    };
    
    gameWindow.onclick = (e) => {
        if (gameWindow.classList.contains('minimized')) {
            restoreGame(gameType);
            e.stopPropagation();
        }
    };
}

function minimizeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (gameWindow && overlay) {
        gameWindow.classList.add('minimized');
        overlay.classList.add('hidden');
    }
}

function restoreGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (gameWindow && overlay) {
        gameWindow.classList.remove('minimized');
        overlay.classList.remove('hidden');
    }
}

function closeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (confirm('Are you sure you want to close this game?')) {
        if (gameWindow && overlay) {
            gameWindow.classList.add('hidden');
            overlay.classList.add('hidden');
        }
        
        // Reset game state
        if (gameType === 'chess') {
            selectedSquare = null;
            currentPlayer = 'white';
        } else if (gameType === 'checkers') {
            currentPlayer = 'red';
        } else if (gameType === 'word') {
            currentWordRound = 1;
            playerScore = 0;
            opponentScore = 0;
        }
        
        // Clear stake input
        const stakeInput = document.getElementById(gameType + 'Stake');
        if (stakeInput) {
            stakeInput.value = '';
        }
        
        showTransactionStatus('Game closed');
    }
}

// Resign functions
function resignChess() {
    if (confirm('Are you sure you want to resign?')) {
        document.getElementById('chessStatus').textContent = 'Game resigned';
        playerStats.chess.losses++;
        updateProfileDisplay();
        addChatMessage('System', 'Chess game resigned');
        
        setTimeout(() => {
            closeGame('chess');
        }, 2000);
    }
}

function drawChess() {
    alert('Draw offer sent to opponent');
}

function resignCheckers() {
    if (confirm('Are you sure you want to resign?')) {
        document.getElementById('checkersStatus').textContent = 'Game resigned';
        playerStats.checkers.losses++;
        updateProfileDisplay();
        addChatMessage('System', 'Checkers game resigned');
        
        setTimeout(() => {
            closeGame('checkers');
        }, 2000);
    }
}
        
       // Chess game functions
function initializeChessBoard() {
    chessBoard = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    
    const boardElement = document.getElementById('chessBoard');
    if (!boardElement) return;
    
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            square.onclick = () => handleChessClick(row, col);
            
            const piece = chessBoard[row][col];
            if (piece) {
                square.textContent = getChessPieceSymbol(piece);
            }
            
            boardElement.appendChild(square);
        }
    }
}

function getChessPieceSymbol(piece) {
    const symbols = {
        'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
        'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
    };
    return symbols[piece] || '';
}

function handleChessClick(row, col) {
    const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    if (!square) return;
    
    if (selectedSquare) {
        // Clear previous selection
        document.querySelectorAll('.chess-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
        });
        
        // Make move if valid
        if (isValidChessMove(selectedSquare.row, selectedSquare.col, row, col)) {
            makeChessMove(selectedSquare.row, selectedSquare.col, row, col);
        }
        selectedSquare = null;
    } else {
        // Select piece
        const piece = chessBoard[row][col];
        if (piece && isPlayerPiece(piece, currentPlayer)) {
            selectedSquare = { row, col };
            square.classList.add('selected');
            highlightPossibleMoves(row, col);
        }
    }
}

function isPlayerPiece(piece, player) {
    if (player === 'white') {
        return piece === piece.toUpperCase();
    } else {
        return piece === piece.toLowerCase();
    }
}

function isValidChessMove(fromRow, fromCol, toRow, toCol) {
    // Simplified chess validation for demo
    const piece = chessBoard[fromRow][fromCol];
    const targetPiece = chessBoard[toRow][toCol];
    
    // Can't capture own piece
    if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) {
        return false;
    }
    
    // Basic movement validation (simplified for demo)
    return true;
}

function makeChessMove(fromRow, fromCol, toRow, toCol) {
    const piece = chessBoard[fromRow][fromCol];
    chessBoard[toRow][toCol] = piece;
    chessBoard[fromRow][fromCol] = null;
    
    // Update display
    initializeChessBoard();
    
    // Switch players
    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
    document.getElementById('chessStatus').textContent = `${currentPlayer}'s turn`;
    
    // Add move to chat
    const moveNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow} to ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
    addChatMessage('You', `Chess move: ${moveNotation}`);
}

function highlightPossibleMoves(row, col) {
    // Simplified - highlight adjacent squares for demo
    for (let r = Math.max(0, row-1); r <= Math.min(7, row+1); r++) {
        for (let c = Math.max(0, col-1); c <= Math.min(7, col+1); c++) {
            if (r !== row || c !== col) {
                const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (square) square.classList.add('possible-move');
            }
        }
    }
}
        // Checkers game functions
function initializeCheckersBoard() {
    checkersBoard = Array(8).fill().map(() => Array(8).fill(null));
    
    // Set up initial pieces
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if ((row + col) % 2 === 1) { // Dark squares only
                if (row < 3) {
                    checkersBoard[row][col] = 'red';
                } else if (row > 4) {
                    checkersBoard[row][col] = 'black';
                }
            }
        }
    }
    
    const boardElement = document.getElementById('checkersBoard');
    if (!boardElement) return;
    
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            square.onclick = () => handleCheckersClick(row, col);
            
            const piece = checkersBoard[row][col];
            if (piece) {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = `checker-piece ${piece}-piece`;
                square.appendChild(pieceDiv);
            }
            
            boardElement.appendChild(square);
        }
    }
}

function handleCheckersClick(row, col) {
    // Simplified checkers logic for demo
    const piece = checkersBoard[row][col];
    if (piece && piece === currentPlayer) {
        // Select piece and show possible moves
        document.querySelectorAll('.checkers-square').forEach(s => s.classList.remove('selected'));
        const square = document.querySelector(`.checkers-square[data-row="${row}"][data-col="${col}"]`);
        if (square) square.classList.add('selected');
        
        addChatMessage('You', `Selected ${piece} piece at ${String.fromCharCode(97 + col)}${8 - row}`);
    }
}
        // Word Battle game variables
const wordPrompts = [
    { letters: "BLOCKCHAIN", category: "Technology" },
    { letters: "CRYPTICUS", category: "Gaming" },
    { letters: "ETHEREUM", category: "Cryptocurrency" },
    { letters: "SMARTCONTRACT", category: "DeFi" },
    { letters: "DECENTRALIZED", category: "Web3" }
];

let currentWordRound = 1;
let playerScore = 0;
let opponentScore = 0;
let currentPrompt = null;

// Word game functions
function startWordRound() {
    currentPrompt = wordPrompts[Math.floor(Math.random() * wordPrompts.length)];
    document.getElementById('wordStatus').textContent = `Round ${currentWordRound} of 3`;
    document.getElementById('wordPrompt').textContent = `Make a word with these letters:`;
    document.getElementById('wordLetters').textContent = currentPrompt.letters;
    document.getElementById('wordInput').value = '';
    document.getElementById('playerScore').textContent = playerScore;
    document.getElementById('opponentScore').textContent = opponentScore;
}

function submitWord() {
    const word = document.getElementById('wordInput').value.toUpperCase().trim();
    if (!word) {
        alert('Please enter a word!');
        return;
    }
    
    // Simple validation - check if word uses only available letters
    const availableLetters = currentPrompt.letters.split('');
    const wordLetters = word.split('');
    
    let isValid = true;
    const usedLetters = [...availableLetters];
    
    for (let letter of wordLetters) {
        const index = usedLetters.indexOf(letter);
        if (index === -1) {
            isValid = false;
            break;
        }
        usedLetters.splice(index, 1);
    }
    
    if (!isValid) {
        alert('Invalid word! Use only the available letters.');
        return;
    }
    
    // Calculate score
    let wordScore = word.length * 10;
    if (word.length >= 6) wordScore += 20; // Bonus for long words
    
    playerScore += wordScore;
    opponentScore += Math.floor(Math.random() * 80) + 40; // Simulated opponent
    
    addChatMessage('You', `Made word: ${word} (${wordScore} points)`);
    
    currentWordRound++;
    if (currentWordRound <= 3) {
        setTimeout(startWordRound, 1500);
    } else {
        endWordGame();
    }
}

function skipRound() {
    opponentScore += Math.floor(Math.random() * 60) + 30;
    currentWordRound++;
    if (currentWordRound <= 3) {
        setTimeout(startWordRound, 1000);
    } else {
        endWordGame();
    }
}

function endWordGame() {
    const winner = playerScore > opponentScore ? 'You' : 'Opponent';
    document.getElementById('wordStatus').textContent = 
        `Game Over! ${winner} wins! Final: ${playerScore} - ${opponentScore}`;
    
    if (winner === 'You') {
        playerStats.gamesWon++;
        playerStats.words.wins++;
        addChatMessage('System', 'üèÜ You won the Word Battle!');
    } else {
        playerStats.words.losses++;
    }
    
    updateProfileDisplay();
}
        // Navigation functions
let currentSection = 'games';

function toggleMobileMenu() {
    const navMenu = document.getElementById('navMenu');
    if (navMenu) {
        navMenu.classList.toggle('active');
    }
}

function showSection(section) {
    // Hide all sections
    const sections = ['gamesSection', 'leaderboardSection', 'profileSection', 'chatSection', 'newsSection', 'settingsSection'];
    sections.forEach(s => {
        const element = document.getElementById(s);
        if (element) element.classList.add('hidden');
    });
    
    // Show selected section
    const targetSection = document.getElementById(section + 'Section');
    if (targetSection) {
        targetSection.classList.remove('hidden');
    }
    
    // Update nav active state
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Find and activate the clicked nav item
    const clickedItem = event ? event.target : null;
    if (clickedItem && clickedItem.classList.contains('nav-item')) {
        clickedItem.classList.add('active');
    }
    
    currentSection = section;
    
    // Close mobile menu
    const navMenu = document.getElementById('navMenu');
    if (navMenu) {
        navMenu.classList.remove('active');
    }
    
    // Update profile stats when viewing profile
    if (section === 'profile') {
        updateProfileDisplay();
    }
}

// Chat functionality
function addChatMessage(user, message) {
    const chatMessages = document.getElementById('chatMessages');
    if (!chatMessages) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = 'margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);';
    messageDiv.innerHTML = `<strong>${user}:</strong> ${message}`;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Limit messages to prevent memory issues
    while (chatMessages.children.length > 50) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    if (!chatInput) return;
    
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    if (!userAddress) {
        alert('Please connect your wallet to chat!');
        return;
    }
    
    addChatMessage('You', message);
    chatInput.value = '';
    
    // Simulate responses
    setTimeout(() => {
        const responses = [
            "Nice! Good luck with your games! üéÆ",
            "Welcome to Crypticus! Ready to win some CORE? üí∞",
            "Great to see another player! Let's compete! ‚öîÔ∏è",
            "The blockchain gaming revolution is here! üöÄ",
            "Just finished an epic chess match! ‚ôüÔ∏è",
            "Word Battle is so addictive! üìù"
        ];
        const randomUser = ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster', 'WordWizard'][Math.floor(Math.random() * 5)];
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        addChatMessage(randomUser, randomResponse);
    }, 2000);
}

function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendChatMessage();
    }
}

// Profile display function
function updateProfileDisplay() {
    const elements = {
        profileGamesPlayed: playerStats.gamesPlayed,
        profileGamesWon: playerStats.gamesWon,
        profileTotalEarned: playerStats.totalEarned.toFixed(4) + ' CORE',
        profileWinRate: playerStats.gamesPlayed > 0 ? 
            ((playerStats.gamesWon / playerStats.gamesPlayed) * 100).toFixed(1) + '%' : '0%',
        chessStats: `${playerStats.chess.wins}W / ${playerStats.chess.losses}L`,
        checkersStats: `${playerStats.checkers.wins}W / ${playerStats.checkers.losses}L`,
        wordStats: `${playerStats.words.wins}W / ${playerStats.words.losses}L`
    };
    
    Object.keys(elements).forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = elements[id];
        }
    });
}
    
    const stakeAmount = parseFloat(document.getElementById('chessStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating chess game...');
        
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        const tx = await gameContract.createGame(0, stakeWei, { value: stakeWei });
        
        showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
        const receipt = await tx.wait();
        
        // Open game window instead of showing inline
        openGameWindow('chess');
        document.getElementById('chessStatus').textContent = 'Waiting for opponent...';
        initializeChessBoard();
        
        playerStats.gamesPlayed++;
        updateProfileDisplay();
        
        showTransactionStatus('‚úÖ Chess game created successfully!');
        
    } catch (error) {
        console.error('Error creating chess game:', error);
        showTransactionStatus('‚ùå Error creating game: ' + error.message);
    }
}

        // Checkers game functions
        function initializeCheckersBoard() {
            checkersBoard = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up initial pieces
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row + col) % 2 === 1) { // Dark squares only
                        if (row < 3) {
                            checkersBoard[row][col] = 'red';
                        } else if (row > 4) {
                            checkersBoard[row][col] = 'black';
                        }
                    }
                }
            }
            
            const boardElement = document.getElementById('checkersBoard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleCheckersClick(row, col);
                    
                    const piece = checkersBoard[row][col];
                    if (piece) {
                        const pieceDiv = document.createElement('div');
                        pieceDiv.className = `checker-piece ${piece}-piece`;
                        square.appendChild(pieceDiv);
                    }
                    
                    boardElement.appendChild(square);
                }
            }
        }
        
        function handleCheckersClick(row, col) {
            // Simplified checkers logic for demo
            const piece = checkersBoard[row][col];
            if (piece && piece === currentPlayer) {
                // Select piece and show possible moves
                document.querySelectorAll('.checkers-square').forEach(s => s.classList.remove('selected'));
                const square = document.querySelector(`.checkers-square[data-row="${row}"][data-col="${col}"]`);
                square.classList.add('selected');
            }
        }
        
        async function startCheckersGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating checkers game...');
        
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        const tx = await gameContract.createGame(1, stakeWei, { value: stakeWei });
        
        showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
        await tx.wait();
        
        // Open game window instead of showing inline
        openGameWindow('checkers');
        document.getElementById('checkersStatus').textContent = 'Waiting for opponent...';
        initializeCheckersBoard();
        
        playerStats.gamesPlayed++;
        updateProfileDisplay();
        
        showTransactionStatus('‚úÖ Checkers game created!');
        
    } catch (error) {
        console.error('Error creating checkers game:', error);
        showTransactionStatus('‚ùå Error: ' + error.message);
    }
}
        
        // Word Battle game functions
        const wordPrompts = [
            { letters: "BLOCKCHAIN", category: "Technology" },
            { letters: "CRYPTICUS", category: "Gaming" },
            { letters: "ETHEREUM", category: "Cryptocurrency" },
            { letters: "SMARTCONTRACT", category: "DeFi" },
            { letters: "DECENTRALIZED", category: "Web3" }
        ];
        
        let currentWordRound = 1;
        let playerScore = 0;
        let opponentScore = 0;
        let currentPrompt = null;
        
        async function startWordGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('wordStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating word game...');
        
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        const tx = await gameContract.createGame(2, stakeWei, { value: stakeWei });
        
        showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
        await tx.wait();
        
        // Open game window instead of showing inline
        openGameWindow('word');
        startWordRound();
        
        playerStats.gamesPlayed++;
        updateProfileDisplay();
        
        showTransactionStatus('‚úÖ Word game created!');
        
    } catch (error) {
        console.error('Error creating word game:', error);
        showTransactionStatus('‚ùå Error: ' + error.message);
    }
}
        
        function startWordRound() {
            currentPrompt = wordPrompts[Math.floor(Math.random() * wordPrompts.length)];
            document.getElementById('wordStatus').textContent = `Round ${currentWordRound} of 3`;
            document.getElementById('wordPrompt').textContent = `Make a word with these letters:`;
            document.getElementById('wordLetters').textContent = currentPrompt.letters;
            document.getElementById('wordInput').value = '';
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('opponentScore').textContent = opponentScore;
        }
        
        function submitWord() {
            const word = document.getElementById('wordInput').value.toUpperCase().trim();
            if (!word) {
                alert('Please enter a word!');
                return;
            }
            
            // Simple validation - check if word uses only available letters
            const availableLetters = currentPrompt.letters.split('');
            const wordLetters = word.split('');
            
            let isValid = true;
            const usedLetters = [...availableLetters];
            
            for (let letter of wordLetters) {
                const index = usedLetters.indexOf(letter);
                if (index === -1) {
                    isValid = false;
                    break;
                }
                usedLetters.splice(index, 1);
            }
            
            if (!isValid) {
                alert('Invalid word! Use only the available letters.');
                return;
            }
            
            // Calculate score
            let wordScore = word.length * 10;
            if (word.length >= 6) wordScore += 20; // Bonus for long words
            
            playerScore += wordScore;
            opponentScore += Math.floor(Math.random() * 80) + 40; // Simulated opponent
            
            addChatMessage('You', `Made word: ${word} (${wordScore} points)`);
            
            currentWordRound++;
            if (currentWordRound <= 3) {
                setTimeout(startWordRound, 1500);
            } else {
                endWordGame();
            }
        }
        
        function skipRound() {
            opponentScore += Math.floor(Math.random() * 60) + 30;
            currentWordRound++;
            if (currentWordRound <= 3) {
                setTimeout(startWordRound, 1000);
            } else {
                endWordGame();
            }
        }
        
        function endWordGame() {
            const winner = playerScore > opponentScore ? 'You' : 'Opponent';
            document.getElementById('wordStatus').textContent = 
                `Game Over! ${winner} wins! Final: ${playerScore} - ${opponentScore}`;
            
            if (winner === 'You') {
                playerStats.gamesWon++;
                playerStats.words.wins++;
                addChatMessage('System', 'üèÜ You won the Word Battle!');
            } else {
                playerStats.words.losses++;
            }
            
            updateProfileDisplay();
        }
        
        // Utility functions
        function resignChess() {
    if (confirm('Are you sure you want to resign?')) {
        document.getElementById('chessStatus').textContent = 'Game resigned';
        playerStats.chess.losses++;
        updateProfileDisplay();
        addChatMessage('System', 'Chess game resigned');
        
        // Close the game window after a short delay
        setTimeout(() => {
            closeGame('chess');
        }, 2000);
    }
}
        
        function drawChess() {
            alert('Draw offer sent to opponent');
        }
        
        function resignCheckers() {
    if (confirm('Are you sure you want to resign?')) {
        document.getElementById('checkersStatus').textContent = 'Game resigned';
        playerStats.checkers.losses++;
        updateProfileDisplay();
        addChatMessage('System', 'Checkers game resigned');
        
        // Close the game window after a short delay
        setTimeout(() => {
            closeGame('checkers');
        }, 2000);
    }
}
        
        async function sendMoveToContract(gameId, move) {
            try {
                if (gameContract) {
                    const tx = await gameContract.makeMove(gameId, move);
                    await tx.wait();
                }
            } catch (error) {
                console.error('Error sending move:', error);
            }
        }
        
        function updateProfileDisplay() {
            document.getElementById('profileGamesPlayed').textContent = playerStats.gamesPlayed;
            document.getElementById('profileGamesWon').textContent = playerStats.gamesWon;
            document.getElementById('profileTotalEarned').textContent = playerStats.totalEarned.toFixed(4) + ' CORE';
            
            const winRate = playerStats.gamesPlayed > 0 ? 
                ((playerStats.gamesWon / playerStats.gamesPlayed) * 100).toFixed(1) : 0;
            document.getElementById('profileWinRate').textContent = winRate + '%';
            
            document.getElementById('chessStats').textContent = 
                `${playerStats.chess.wins}W / ${playerStats.chess.losses}L`;
            document.getElementById('checkersStats').textContent = 
                `${playerStats.checkers.wins}W / ${playerStats.checkers.losses}L`;
            document.getElementById('wordStats').textContent = 
                `${playerStats.words.wins}W / ${playerStats.words.losses}L`;
        }
        
        // Chat functionality
        function addChatMessage(user, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = 'margin-bottom: 0.8rem; padding: 0.5rem; border-radius: 8px; background: rgba(255, 255, 255, 0.05);';
            messageDiv.innerHTML = `<strong>${user}:</strong> ${message}`;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }
        
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message) return;
            
            if (!userAddress) {
                alert('Please connect your wallet to chat!');
                return;
            }
            
            addChatMessage('You', message);
            chatInput.value = '';
            
            // Simulate responses
            setTimeout(() => {
                const responses = [
                    "Nice! Good luck with your games! üéÆ",
                    "Welcome to Crypticus! Ready to win some CORE? üí∞",
                    "Great to see another player! Let's compete! ‚öîÔ∏è",
                    "The blockchain gaming revolution is here! üöÄ",
                    "Just finished an epic chess match! ‚ôüÔ∏è",
                    "Word Battle is so addictive! üìù"
                ];
                const randomUser = ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster', 'WordWizard'][Math.floor(Math.random() * 5)];
                const randomResponse = responses[Math.floor(Math.random() * responses.length)];
                addChatMessage(randomUser, randomResponse);
            }, 2000);
        }
        
        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }
        
        // Settings toggle
        function toggleSetting(element) {
            const isActive = element.classList.contains('active');
            const toggleDot = element.querySelector('div');
            
            if (isActive) {
                element.classList.remove('active');
                element.style.background = 'rgba(255, 255, 255, 0.2)';
                toggleDot.style.left = '3px';
            } else {
                element.classList.add('active');
                element.style.background = 'linear-gradient(45deg, #4ecdc4, #44a08d)';
                toggleDot.style.left = '33px';
            }
        }
        
                // Age verification
        function verifyAge(isAdult) {
            if (isAdult) {
                document.getElementById('ageVerificationModal').style.display = 'none';
                sessionStorage.setItem('ageVerified', 'true');
                showTransactionStatus('‚úÖ Age verified. Welcome to Crypticus!');
            } else {
                alert('Sorry, you must be 18 or older to use this platform.');
                window.location.href = 'https://www.google.com';
            }
        }
        
        // Show age verification on first visit
        function checkAgeVerification() {
            const ageVerified = sessionStorage.getItem('ageVerified');
            if (!ageVerified) {
                document.getElementById('ageVerificationModal').style.display = 'flex';
            }
        }
        
        // Enhanced wallet connection with KYC check
        const originalConnectWallet = document.getElementById('connectBtn').onclick;
        document.getElementById('connectBtn').onclick = function() {
            const ageVerified = sessionStorage.getItem('ageVerified');
            if (!ageVerified) {
                alert('Please verify your age first.');
                document.getElementById('ageVerificationModal').style.display = 'flex';
                return;
            }
            // Continue with wallet connection
            originalConnectWallet();
        };
        
        // Terms and conditions modal
        function showTerms() {
            const termsContent = `
            <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 1rem;">
                <div style="background: #1a1a2e; border: 2px solid #4ecdc4; border-radius: 15px; padding: 2rem; max-width: 600px; max-height: 80vh; overflow-y: auto;">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üìú Terms & Conditions</h3>
                    <div style="color: white; font-size: 0.9rem; line-height: 1.6;">
                        <h4>üîû Age Requirement</h4>
                        <p>Users must be 18 years or older to participate in gaming activities.</p>
                        
                        <h4>üéÆ Gaming Nature</h4>
                        <p>Crypticus offers skill-based games including chess, checkers, and word games.</p>
                        
                        <h4>üí∞ Financial Responsibility</h4>
                        <p>Players are responsible for tax compliance in their jurisdiction.</p>
                        
                        <h4>üõ°Ô∏è Responsible Gaming</h4>
                        <p>We promote responsible gaming. Set limits and play within your means.</p>
                        
                        <h4>‚öñÔ∏è Legal Compliance</h4>
                        <p>Platform operates under applicable gaming regulations.</p>
                        
                        <h4>üîê Privacy & Security</h4>
                        <p>We protect user data and ensure secure transactions.</p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: #4ecdc4; color: white; border: none; padding: 1rem 2rem; border-radius: 8px; margin-top: 1rem; cursor: pointer;">Close</button>
                </div>
            </div>`;
            document.body.insertAdjacentHTML('beforeend', termsContent);
        }
        
        // Initialize age verification on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkAgeVerification();
        });
        
        // Auto-update functions
        function updateGameFeed() {
            const feedMessages = [
                "üéÆ Active Games: " + (Math.floor(Math.random() * 20) + 5),
                "üí∞ Total Pool: " + (Math.random() * 500 + 100).toFixed(1) + " CORE",
                "üèÜ Last Winner: " + ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster'][Math.floor(Math.random() * 4)],
                "‚ö° New high score in Word Battle!",
                "üî• Epic chess match in progress!",
                "üíé Checkers tournament starting soon!"
            ];
            
            const gameFeed = document.getElementById('gameFeed');
            if (gameFeed) {
                gameFeed.innerHTML = '';
                feedMessages.slice(0, 3).forEach((message, index) => {
                    const feedDiv = document.createElement('div');
                    feedDiv.className = 'news-item';
                    feedDiv.innerHTML = `
                        <div class="news-title">${message}</div>
                        <div class="news-time">${index * 5 + 2} minutes ago</div>
                    `;
                    gameFeed.appendChild(feedDiv);
                });
            }
        }
        
        function addRandomChatMessage() {
            const messages = [
                { user: "StakeHero", message: "Just won big in Checkers! üéâ" },
                { user: "WordWizard", message: "Word Battle high score: 847! üìù" },
                { user: "ChessMaster", message: "Looking for a chess opponent! ‚ôüÔ∏è" },
                { user: "CryptoGamer", message: "These games are incredible! üöÄ" },
                { user: "BlockchainBro", message: "Best gaming platform ever! üí∞" },
                { user: "TokenTitan", message: "Just earned 5 CORE! üèÜ" }
            ];
            
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            addChatMessage(randomMessage.user, randomMessage.message);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Crypticus blockchain gaming platform loaded!');
            
            // Update game feed every 20 seconds
            updateGameFeed();
            setInterval(updateGameFeed, 20000);
            
            // Add chat messages every 25 seconds
            setInterval(addRandomChatMessage, 25000);
            
            // Close mobile menu when clicking outside
            document.addEventListener('click', (e) => {
                const navMenu = document.getElementById('navMenu');
                const mobileBtn = document.querySelector('.mobile-menu-btn');
                
                if (!navMenu.contains(e.target) && !mobileBtn.contains(e.target)) {
                    navMenu.classList.remove('active');
                }
            });
            
            // Auto-hide transaction status on click
            document.getElementById('transactionStatus').addEventListener('click', () => {
                document.getElementById('transactionStatus').classList.remove('show');
            });
        });
        // Active games management
let activeGames = [
    { id: 1, type: 'chess', creator: 'CryptoKing', stake: 0.5, status: 'waiting' },
    { id: 2, type: 'checkers', creator: 'GameMaster', stake: 0.3, status: 'waiting' },
    { id: 3, type: 'words', creator: 'WordWizard', stake: 0.8, status: 'waiting' }
];

// Update active games display
function updateActiveGames() {
    const gamesList = document.getElementById('activeGamesList');
    const noGamesDiv = document.getElementById('noActiveGames');
    
    if (activeGames.length === 0) {
        gamesList.innerHTML = '';
        noGamesDiv.classList.remove('hidden');
        return;
    }
    
    noGamesDiv.classList.add('hidden');
    gamesList.innerHTML = '';
    
    activeGames.forEach(game => {
        const gameDiv = document.createElement('div');
        gameDiv.className = 'game-lobby-item';
        
        const gameIcon = game.type === 'chess' ? '‚ôüÔ∏è' : game.type === 'checkers' ? '‚ö´' : 'üìù';
        const gameName = game.type === 'chess' ? 'Chess Masters' : game.type === 'checkers' ? 'Checkers Pro' : 'Word Battle';
        
        gameDiv.innerHTML = `
            <div>
                <strong>${gameIcon} ${gameName}</strong>
                <div style="font-size: 0.9rem; color: #aaa;">${game.creator} ‚Ä¢ Stake: ${game.stake} CORE</div>
            </div>
            <button class="join-game-btn" onclick="joinGame('${game.type}', '${game.id}', ${game.stake})">Join Game</button>
        `;
        
        gamesList.appendChild(gameDiv);
    });
}

// Join existing game
async function joinGame(gameType, gameId, stake) {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    try {
        showTransactionStatus('Joining game...');
        
        const stakeWei = ethers.utils.parseEther(stake.toString());
        const tx = await gameContract.joinGame(gameId, { value: stakeWei });
        
        showTransactionStatus('‚è≥ Joining game...', tx.hash);
        await tx.wait();
        
        // Remove from active games and start the game
        activeGames = activeGames.filter(game => game.id != gameId);
        updateActiveGames();
        
        // Open game window
        openGameWindow(gameType);
        
        if (gameType === 'chess') {
            document.getElementById('chessStatus').textContent = 'Game started! Your turn.';
            initializeChessBoard();
        } else if (gameType === 'checkers') {
            document.getElementById('checkersStatus').textContent = 'Game started! Your turn.';
            initializeCheckersBoard();
        } else if (gameType === 'words') {
            document.getElementById('wordStatus').textContent = 'Game started! Round 1 of 3';
            startWordRound();
        }
        
        playerStats.gamesPlayed++;
        updateProfileDisplay();
        
        showTransactionStatus('‚úÖ Joined game successfully!');
        addChatMessage('System', `üéÆ ${userAddress.substring(0, 6)}... joined ${gameType} game!`);
        
    } catch (error) {
        console.error('Error joining game:', error);
        showTransactionStatus('‚ùå Error joining game: ' + error.message);
    }
}

// Enhanced game window management with better stacking
let windowZIndex = 1000;
let openWindows = [];

function openGameWindow(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    // Increment z-index for new windows
    windowZIndex += 10;
    gameWindow.style.zIndex = windowZIndex;
    
    // Add to open windows array
    if (!openWindows.includes(gameType)) {
        openWindows.push(gameType);
    }
    
    // Stagger position based on number of open windows
    const offset = openWindows.indexOf(gameType) * 30;
    gameWindow.style.top = `calc(50% + ${offset}px)`;
    gameWindow.style.left = `calc(50% + ${offset}px)`;
    
    gameWindow.classList.remove('hidden', 'minimized');
    overlay.classList.remove('hidden');
    
    // Event handlers
    overlay.onclick = () => closeGame(gameType);
    gameWindow.onclick = (e) => {
        if (gameWindow.classList.contains('minimized')) {
            restoreGame(gameType);
            e.stopPropagation();
        } else {
            // Bring to front when clicked
            windowZIndex += 10;
            gameWindow.style.zIndex = windowZIndex;
        }
    };
}

function closeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (confirm('Are you sure you want to close this game?')) {
        gameWindow.classList.add('hidden');
        
        // Remove from open windows
        openWindows = openWindows.filter(window => window !== gameType);
        
        // Hide overlay if no windows open
        if (openWindows.length === 0) {
            overlay.classList.add('hidden');
        }
        
        // Reset game state and clear stake input
        if (gameType === 'chess') {
            selectedSquare = null;
            currentPlayer = 'white';
        } else if (gameType === 'checkers') {
            currentPlayer = 'red';
        } else if (gameType === 'word') {
            currentWordRound = 1;
            playerScore = 0;
            opponentScore = 0;
        }
        
        document.getElementById(gameType + 'Stake').value = '';
        showTransactionStatus('Game closed');
    }
}

// Updated start game functions to add to active games lobby
async function startChessGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('chessStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating chess game...');
        
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        const tx = await gameContract.createGame(0, stakeWei, { value: stakeWei });
        
        showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
        const receipt = await tx.wait();
        
        // Add to active games lobby
        const newGame = {
            id: Date.now(),
            type: 'chess',
            creator: userAddress.substring(0, 8) + '...',
            stake: stakeAmount,
            status: 'waiting'
        };
        activeGames.push(newGame);
        updateActiveGames();
        
        // Open game window
        openGameWindow('chess');
        document.getElementById('chessStatus').textContent = 'Waiting for opponent...';
        initializeChessBoard();
        
        playerStats.gamesPlayed++;
        updateProfileDisplay();
        
        showTransactionStatus('‚úÖ Chess game created! Waiting for opponent...');
        addChatMessage('System', `üéÆ New chess game created! Stake: ${stakeAmount} CORE`);
        
    } catch (error) {
        console.error('Error creating chess game:', error);
        showTransactionStatus('‚ùå Error creating game: ' + error.message);
    }
}

// Initialize active games on page load
document.addEventListener('DOMContentLoaded', () => {
    updateActiveGames();
    
    // Update active games every 30 seconds
    setInterval(updateActiveGames, 30000);
    
    // Simulate new games being created by other players
    setInterval(() => {
        if (Math.random() < 0.3 && activeGames.length < 8) {
            const gameTypes = ['chess', 'checkers', 'words'];
            const players = ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster', 'WordWizard'];
            const stakes = [0.1, 0.2, 0.3, 0.5, 0.8, 1.0, 1.5, 2.0];
            
            const newGame = {
                id: Date.now() + Math.random(),
                type: gameTypes[Math.floor(Math.random() * gameTypes.length)],
                creator: players[Math.floor(Math.random() * players.length)],
                stake: stakes[Math.floor(Math.random() * stakes.length)],
                status: 'waiting'
            };
            
            activeGames.push(newGame);
            updateActiveGames();
            
            const gameIcon = newGame.type === 'chess' ? '‚ôüÔ∏è' : newGame.type === 'checkers' ? '‚ö´' : 'üìù';
            addChatMessage('System', `üéÆ ${newGame.creator} created new ${gameIcon} game! Stake: ${newGame.stake} CORE`);
        }
    }, 45000);
});
        // Enhanced Chess Game Logic
function getValidChessMoves(fromRow, fromCol) {
    const piece = chessBoard[fromRow][fromCol];
    const moves = [];
    
    if (!piece) return moves;
    
    const isWhite = piece === piece.toUpperCase();
    const direction = isWhite ? -1 : 1;
    
    switch (piece.toLowerCase()) {
        case 'p': // Pawn
            // Forward move
            if (fromRow + direction >= 0 && fromRow + direction < 8 && !chessBoard[fromRow + direction][fromCol]) {
                moves.push([fromRow + direction, fromCol]);
                // Double move from starting position
                const startRow = isWhite ? 6 : 1;
                if (fromRow === startRow && !chessBoard[fromRow + 2 * direction][fromCol]) {
                    moves.push([fromRow + 2 * direction, fromCol]);
                }
            }
            // Diagonal captures
            [-1, 1].forEach(colDir => {
                const newCol = fromCol + colDir;
                const newRow = fromRow + direction;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = chessBoard[newRow][newCol];
                    if (target && isPlayerPiece(target, isWhite ? 'black' : 'white')) {
                        moves.push([newRow, newCol]);
                    }
                }
            });
            break;
            
        case 'r': // Rook
            const rookDirections = [[-1,0], [1,0], [0,-1], [0,1]];
            rookDirections.forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const newRow = fromRow + dr * i;
                    const newCol = fromCol + dc * i;
                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                    
                    const target = chessBoard[newRow][newCol];
                    if (!target) {
                        moves.push([newRow, newCol]);
                    } else {
                        if (isPlayerPiece(target, isWhite ? 'black' : 'white')) {
                            moves.push([newRow, newCol]);
                        }
                        break;
                    }
                }
            });
            break;
            
        case 'n': // Knight
            const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
            knightMoves.forEach(([dr, dc]) => {
                const newRow = fromRow + dr;
                const newCol = fromCol + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = chessBoard[newRow][newCol];
                    if (!target || isPlayerPiece(target, isWhite ? 'black' : 'white')) {
                        moves.push([newRow, newCol]);
                    }
                }
            });
            break;
            
        case 'b': // Bishop
            const bishopDirections = [[-1,-1], [-1,1], [1,-1], [1,1]];
            bishopDirections.forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const newRow = fromRow + dr * i;
                    const newCol = fromCol + dc * i;
                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                    
                    const target = chessBoard[newRow][newCol];
                    if (!target) {
                        moves.push([newRow, newCol]);
                    } else {
                        if (isPlayerPiece(target, isWhite ? 'black' : 'white')) {
                            moves.push([newRow, newCol]);
                        }
                        break;
                    }
                }
            });
            break;
            
        case 'q': // Queen (combines rook and bishop)
            const queenDirections = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            queenDirections.forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const newRow = fromRow + dr * i;
                    const newCol = fromCol + dc * i;
                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                    
                    const target = chessBoard[newRow][newCol];
                    if (!target) {
                        moves.push([newRow, newCol]);
                    } else {
                        if (isPlayerPiece(target, isWhite ? 'black' : 'white')) {
                            moves.push([newRow, newCol]);
                        }
                        break;
                    }
                }
            });
            break;
            
        case 'k': // King
            const kingMoves = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            kingMoves.forEach(([dr, dc]) => {
                const newRow = fromRow + dr;
                const newCol = fromCol + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = chessBoard[newRow][newCol];
                    if (!target || isPlayerPiece(target, isWhite ? 'black' : 'white')) {
                        moves.push([newRow, newCol]);
                    }
                }
            });
            break;
    }
    
    return moves;
}

// Enhanced Chess Move Validation
function isValidChessMove(fromRow, fromCol, toRow, toCol) {
    const validMoves = getValidChessMoves(fromRow, fromCol);
    return validMoves.some(([r, c]) => r === toRow && c === toCol);
}

// Enhanced Chess Click Handler
function handleChessClick(row, col) {
    const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (selectedSquare) {
        // Clear previous highlights
        document.querySelectorAll('.chess-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
        });
        
        // Try to make move
        if (isValidChessMove(selectedSquare.row, selectedSquare.col, row, col)) {
            makeChessMove(selectedSquare.row, selectedSquare.col, row, col);
            addChatMessage('You', `Chess move: ${String.fromCharCode(97 + selectedSquare.col)}${8 - selectedSquare.row} to ${String.fromCharCode(97 + col)}${8 - row}`);
        }
        selectedSquare = null;
    } else {
        // Select piece
        const piece = chessBoard[row][col];
        if (piece && isPlayerPiece(piece, currentPlayer)) {
            selectedSquare = { row, col };
            square.classList.add('selected');
            
            // Highlight possible moves
            const validMoves = getValidChessMoves(row, col);
            validMoves.forEach(([r, c]) => {
                const moveSquare = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (moveSquare) moveSquare.classList.add('possible-move');
            });
        }
    }
}

// Enhanced Checkers Game Logic
function getValidCheckersMovesForPiece(row, col) {
    const piece = checkersBoard[row][col];
    const moves = [];
    
    if (!piece) return moves;
    
    const isRed = piece === 'red';
    const isKing = piece === 'redKing' || piece === 'blackKing';
    
    // Determine move directions
    const directions = [];
    if (isRed || isKing) {
        directions.push([1, -1], [1, 1]); // Red moves down
    }
    if (!isRed || isKing) {
        directions.push([-1, -1], [-1, 1]); // Black moves up
    }
    
    // Check for captures first (mandatory)
    const captures = [];
    directions.forEach(([dr, dc]) => {
        const jumpRow = row + dr;
        const jumpCol = col + dc;
        const landRow = row + dr * 2;
        const landCol = col + dc * 2;
        
        if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8) {
            const jumpPiece = checkersBoard[jumpRow][jumpCol];
            const landPiece = checkersBoard[landRow][landCol];
            
            // Can capture if there's an enemy piece to jump and empty landing spot
            if (jumpPiece && !isCheckersPlayerPiece(jumpPiece, currentPlayer) && !landPiece) {
                captures.push([landRow, landCol]);
            }
        }
    });
    
    // If captures available, return only captures (mandatory)
    if (captures.length > 0) {
        return captures;
    }
    
    // Otherwise, regular moves
    directions.forEach(([dr, dc]) => {
        const newRow = row + dr;
        const newCol = col + dc;
        
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            if (!checkersBoard[newRow][newCol]) {
                moves.push([newRow, newCol]);
            }
        }
    });
    
    return moves;
}

function isCheckersPlayerPiece(piece, player) {
    if (player === 'red') {
        return piece === 'red' || piece === 'redKing';
    } else {
        return piece === 'black' || piece === 'blackKing';
    }
}

// Enhanced Checkers Click Handler
function handleCheckersClick(row, col) {
    if (selectedSquare) {
        // Clear highlights
        document.querySelectorAll('.checkers-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
        });
        
        // Try to make move
        const validMoves = getValidCheckersMovesForPiece(selectedSquare.row, selectedSquare.col);
        const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
        
        if (isValidMove) {
            makeCheckersMove(selectedSquare.row, selectedSquare.col, row, col);
        }
        selectedSquare = null;
    } else {
        // Select piece
        const piece = checkersBoard[row][col];
        if (piece && isCheckersPlayerPiece(piece, currentPlayer)) {
            selectedSquare = { row, col };
            
            const square = document.querySelector(`.checkers-square[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            
            // Highlight possible moves
            const validMoves = getValidCheckersMovesForPiece(row, col);
            validMoves.forEach(([r, c]) => {
                const moveSquare = document.querySelector(`.checkers-square[data-row="${r}"][data-col="${c}"]`);
                if (moveSquare) moveSquare.classList.add('possible-move');
            });
        }
    }
}

function makeCheckersMove(fromRow, fromCol, toRow, toCol) {
    const piece = checkersBoard[fromRow][fromCol];
    
    // Check if it's a capture
    if (Math.abs(fromRow - toRow) === 2) {
        const captureRow = fromRow + (toRow - fromRow) / 2;
        const captureCol = fromCol + (toCol - fromCol) / 2;
        checkersBoard[captureRow][captureCol] = null; // Remove captured piece
        addChatMessage('You', `Checkers capture! Jumped piece at ${String.fromCharCode(97 + captureCol)}${8 - captureRow}`);
    }
    
    // Move piece
    checkersBoard[toRow][toCol] = piece;
    checkersBoard[fromRow][fromCol] = null;
    
    // Check for king promotion
    if (piece === 'red' && toRow === 7) {
        checkersBoard[toRow][toCol] = 'redKing';
        addChatMessage('System', 'üëë Red piece promoted to King!');
    } else if (piece === 'black' && toRow === 0) {
        checkersBoard[toRow][toCol] = 'blackKing';
        addChatMessage('System', 'üëë Black piece promoted to King!');
    }
    
    // Update display
    initializeCheckersBoard();
    
    // Switch players
    currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
    document.getElementById('checkersStatus').textContent = `${currentPlayer}'s turn`;
    
    // Check for game end
    if (isCheckersGameOver()) {
        endCheckersGame();
    }
}

function isCheckersGameOver() {
    let redPieces = 0;
    let blackPieces = 0;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = checkersBoard[row][col];
            if (piece === 'red' || piece === 'redKing') redPieces++;
            if (piece === 'black' || piece === 'blackKing') blackPieces++;
        }
    }
    
    return redPieces === 0 || blackPieces === 0;
}

function endCheckersGame() {
    let redPieces = 0;
    let blackPieces = 0;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = checkersBoard[row][col];
            if (piece === 'red' || piece === 'redKing') redPieces++;
            if (piece === 'black' || piece === 'blackKing') blackPieces++;
        }
    }
    
    const winner = redPieces === 0 ? 'black' : 'red';
    document.getElementById('checkersStatus').textContent = `Game Over! ${winner} wins!`;
    
    if (winner === 'red') {
        playerStats.checkers.wins++;
        playerStats.gamesWon++;
        addChatMessage('System', 'üèÜ You won the Checkers game!');
    } else {
        playerStats.checkers.losses++;
    }
    
    updateProfileDisplay();
}

// Enhanced Word Game Logic
const enhancedWordList = [
    'BLOCKCHAIN', 'ETHEREUM', 'BITCOIN', 'CRYPTO', 'GAMING', 'SMART', 'CONTRACT',
    'DEFI', 'NFT', 'TOKEN', 'WALLET', 'MINING', 'STAKING', 'YIELD', 'LIQUIDITY',
    'CORE', 'CHAIN', 'HASH', 'NODE', 'PEER', 'BLOCK', 'LEDGER', 'DAPP', 'GAS',
    'FORK', 'MINER', 'PROOF', 'STAKE', 'BURN', 'MINT', 'SWAP', 'POOL', 'FARM'
];

function startWordRound() {
    currentPrompt = enhancedWordList[Math.floor(Math.random() * enhancedWordList.length)];
    document.getElementById('wordStatus').textContent = `Round ${currentWordRound} of 3`;
    document.getElementById('wordPrompt').textContent = `Unscramble this word:`;
    document.getElementById('wordLetters').textContent = scrambleWord(currentPrompt);
    document.getElementById('wordInput').value = '';
    document.getElementById('playerScore').textContent = playerScore;
    document.getElementById('opponentScore').textContent = opponentScore;
}

function scrambleWord(word) {
    const letters = word.split('');
    for (let i = letters.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [letters[i], letters[j]] = [letters[j], letters[i]];
    }
    return letters.join('');
}

function submitWord() {
    const word = document.getElementById('wordInput').value.toUpperCase().trim();
    if (!word) {
        alert('Please enter a word!');
        return;
    }
    
    if (word === currentPrompt) {
        // Correct!
        let wordScore = word.length * 10;
        if (word.length >= 8) wordScore += 20; // Bonus for long words
        
        playerScore += wordScore;
        addChatMessage('You', `Correct word: ${word} (+${wordScore} points)`);
        document.getElementById('wordInput').value = '';
    } else {
        // Wrong
        addChatMessage('You', `Wrong guess: ${word}. Try again!`);
        document.getElementById('wordInput').value = '';
        return;
    }
    
    // Simulate opponent score
    opponentScore += Math.floor(Math.random() * 80) + 40;
    
    currentWordRound++;
    if (currentWordRound <= 3) {
        setTimeout(startWordRound, 1500);
    } else {
        endWordGame();
    }
}

function endWordGame() {
    const winner = playerScore > opponentScore ? 'You' : 'Opponent';
    document.getElementById('wordStatus').textContent = 
        `Game Over! ${winner} wins! Final: ${playerScore} - ${opponentScore}`;
    
    if (winner === 'You') {
        playerStats.gamesWon++;
        playerStats.words.wins++;
        addChatMessage('System', 'üèÜ You won the Word Battle!');
    } else {
        playerStats.words.losses++;
    }
    
    updateProfileDisplay();
}

// Enhanced Game Creation Functions
async function startChessGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('chessStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating chess game...');
        
        // For demo purposes, simulate contract interaction
        setTimeout(async () => {
            if (gameContract) {
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                const tx = await gameContract.createGame(0, stakeWei, { value: stakeWei });
                showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                await tx.wait();
            }
            
            // Add to active games lobby
            const newGame = {
                id: Date.now(),
                type: 'chess',
                creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            // Open game window
            openGameWindow('chess');
            document.getElementById('chessStatus').textContent = 'Waiting for opponent...';
            initializeChessBoard();
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('‚úÖ Chess game created! Waiting for opponent...');
            addChatMessage('System', `üéÆ New chess game created! Stake: ${stakeAmount} CORE`);
        }, 1000);
        
    } catch (error) {
        console.error('Error creating chess game:', error);
        showTransactionStatus('‚ùå Demo mode: Chess game created locally');
        
        // Fallback for demo
        const newGame = {
            id: Date.now(),
            type: 'chess',
            creator: 'You',
            stake: stakeAmount,
            status: 'waiting'
        };
        activeGames.push(newGame);
        updateActiveGames();
        
        openGameWindow('chess');
        initializeChessBoard();
    }
}

async function startCheckersGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating checkers game...');
        
        setTimeout(async () => {
            if (gameContract) {
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                const tx = await gameContract.createGame(1, stakeWei, { value: stakeWei });
                showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                await tx.wait();
            }
            
            const newGame = {
                id: Date.now(),
                type: 'checkers',
                creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('checkers');
            document.getElementById('checkersStatus').textContent = 'Waiting for opponent...';
            initializeCheckersBoard();
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('‚úÖ Checkers game created!');
        }, 1000);
        
    } catch (error) {
        console.error('Error creating checkers game:', error);
        showTransactionStatus('‚ùå Demo: Checkers game created locally');
        
        const newGame = {
            id: Date.now(),
            type: 'checkers',
            creator: 'You',
            stake: stakeAmount,
            status: 'waiting'
        };
        activeGames.push(newGame);
        updateActiveGames();
        
        openGameWindow('checkers');
        initializeCheckersBoard();
    }
}

async function startWordGame() {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    const stakeAmount = parseFloat(document.getElementById('wordStake').value);
    if (!stakeAmount || stakeAmount < 0.01) {
        alert('Please enter a valid stake amount (minimum 0.01 CORE)');
        return;
    }
    
    try {
        showTransactionStatus('Creating word game...');
        
        setTimeout(async () => {
            if (gameContract) {
                const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                const tx = await gameContract.createGame(2, stakeWei, { value: stakeWei });
                showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                await tx.wait();
            }
            
            const newGame = {
                id: Date.now(),
                type: 'words',
                creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('word');
            currentWordRound = 1;
            playerScore = 0;
            opponentScore = 0;
            startWordRound();
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('‚úÖ Word game created!');
        }, 1000);
        
    } catch (error) {
        console.error('Error creating word game:', error);
        showTransactionStatus('‚ùå Demo: Word game created locally');
        
        const newGame = {
            id: Date.now(),
            type: 'words',
            creator: 'You',
            stake: stakeAmount,
            status: 'waiting'
        };
        activeGames.push(newGame);
        updateActiveGames();
        
        openGameWindow('word');
        startWordRound();
    }
}

console.log('‚úÖ Step 1: Enhanced Game Logic - Added successfully!');

        // Enhanced Active Games Management
let activeGames = [
    { id: 1, type: 'chess', creator: 'CryptoKing', stake: 0.5, status: 'waiting' },
    { id: 2, type: 'checkers', creator: 'GameMaster', stake: 0.3, status: 'waiting' },
    { id: 3, type: 'words', creator: 'WordWizard', stake: 0.8, status: 'waiting' }
];

// Update active games display with better formatting
function updateActiveGames() {
    const gamesList = document.getElementById('activeGamesList');
    const noGamesDiv = document.getElementById('noActiveGames');
    
    if (activeGames.length === 0) {
        gamesList.innerHTML = '';
        if (noGamesDiv) noGamesDiv.classList.remove('hidden');
        return;
    }
    
    if (noGamesDiv) noGamesDiv.classList.add('hidden');
    gamesList.innerHTML = '';
    
    activeGames.forEach(game => {
        const gameDiv = document.createElement('div');
        gameDiv.className = 'game-lobby-item';
        
        const gameIcon = game.type === 'chess' ? '‚ôüÔ∏è' : game.type === 'checkers' ? '‚ö´' : 'üìù';
        const gameName = game.type === 'chess' ? 'Chess Masters' : game.type === 'checkers' ? 'Checkers Pro' : 'Word Battle';
        
        gameDiv.innerHTML = `
            <div>
                <strong>${gameIcon} ${gameName}</strong>
                <div style="font-size: 0.9rem; color: #aaa;">${game.creator} ‚Ä¢ Stake: ${game.stake} CORE</div>
            </div>
            <button class="join-game-btn" onclick="joinGame('${game.type}', '${game.id}', ${game.stake})">Join Game</button>
        `;
        
        gamesList.appendChild(gameDiv);
    });
}

// Enhanced join game function
async function joinGame(gameType, gameId, stake) {
    if (!userAddress) {
        alert('Please connect your wallet first!');
        return;
    }
    
    try {
        showTransactionStatus('Joining game...');
        
        // Simulate contract interaction
        setTimeout(async () => {
            if (gameContract) {
                const stakeWei = ethers.utils.parseEther(stake.toString());
                const tx = await gameContract.joinGame(gameId, { value: stakeWei });
                showTransactionStatus('‚è≥ Joining game...', tx.hash);
                await tx.wait();
            }
            
            // Remove from active games and start the game
            activeGames = activeGames.filter(game => game.id != gameId);
            updateActiveGames();
            
            // Open game window
            openGameWindow(gameType);
            
            if (gameType === 'chess') {
                document.getElementById('chessStatus').textContent = 'Game started! Your turn.';
                initializeChessBoard();
                currentPlayer = 'white';
            } else if (gameType === 'checkers') {
                document.getElementById('checkersStatus').textContent = 'Game started! Your turn.';
                initializeCheckersBoard();
                currentPlayer = 'red';
            } else if (gameType === 'words') {
                document.getElementById('wordStatus').textContent = 'Game started! Round 1 of 3';
                currentWordRound = 1;
                playerScore = 0;
                opponentScore = 0;
                startWordRound();
            }
            
            playerStats.gamesPlayed++;
            updateProfileDisplay();
            
            showTransactionStatus('‚úÖ Joined game successfully!');
            addChatMessage('System', `üéÆ You joined ${gameType} game! Stake: ${stake} CORE`);
            
        }, 1000);
        
    } catch (error) {
        console.error('Error joining game:', error);
        showTransactionStatus('‚ùå Demo mode: Joined game locally');
        
        // Fallback for demo
        activeGames = activeGames.filter(game => game.id != gameId);
        updateActiveGames();
        openGameWindow(gameType);
        
        if (gameType === 'chess') {
            initializeChessBoard();
            currentPlayer = 'white';
        } else if (gameType === 'checkers') {
            initializeCheckersBoard();
            currentPlayer = 'red';
        } else if (gameType === 'words') {
            startWordRound();
        }
    }
}

// Simulate new games being created by other players
function simulateNewGames() {
    if (Math.random() < 0.3 && activeGames.length < 8) {
        const gameTypes = ['chess', 'checkers', 'words'];
        const players = ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster', 'WordWizard', 'StakeHero'];
        const stakes = [0.1, 0.2, 0.3, 0.5, 0.8, 1.0, 1.5, 2.0];
        
        const newGame = {
            id: Date.now() + Math.random(),
            type: gameTypes[Math.floor(Math.random() * gameTypes.length)],
            creator: players[Math.floor(Math.random() * players.length)],
            stake: stakes[Math.floor(Math.random() * stakes.length)],
            status: 'waiting'
        };
        
        activeGames.push(newGame);
        updateActiveGames();
        
        const gameIcon = newGame.type === 'chess' ? '‚ôüÔ∏è' : newGame.type === 'checkers' ? '‚ö´' : 'üìù';
        addChatMessage('System', `üéÆ ${newGame.creator} created new ${gameIcon} game! Stake: ${newGame.stake} CORE`);
    }
}

// Auto-remove old games
function removeOldGames() {
    if (activeGames.length > 6) {
        const removed = activeGames.shift();
        updateActiveGames();
        addChatMessage('System', `‚è∞ Game timeout: ${removed.creator}'s ${removed.type} game expired`);
    }
}

console.log('‚úÖ Step 2A: Enhanced Active Games Management - Added successfully!');
        // Enhanced Game Window Management
let windowZIndex = 1000;
let openWindows = [];

// Enhanced open game window with better positioning
function openGameWindow(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    // Increment z-index for new windows
    windowZIndex += 10;
    gameWindow.style.zIndex = windowZIndex;
    
    // Add to open windows array
    if (!openWindows.includes(gameType)) {
        openWindows.push(gameType);
    }
    
    // Stagger position based on number of open windows
    const offset = openWindows.indexOf(gameType) * 30;
    gameWindow.style.top = `calc(50% + ${offset}px)`;
    gameWindow.style.left = `calc(50% + ${offset}px)`;
    
    gameWindow.classList.remove('hidden', 'minimized');
    overlay.classList.remove('hidden');
    
    // Enhanced event handlers
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            // Don't close when clicking on minimized windows
            const minimizedWindows = document.querySelectorAll('.game-window.minimized');
            let clickedMinimized = false;
            minimizedWindows.forEach(window => {
                const rect = window.getBoundingClientRect();
                if (e.clientX >= rect.left && e.clientX <= rect.right && 
                    e.clientY >= rect.top && e.clientY <= rect.bottom) {
                    clickedMinimized = true;
                }
            });
            if (!clickedMinimized) {
                closeAllGames();
            }
        }
    };
    
    gameWindow.onclick = (e) => {
        if (gameWindow.classList.contains('minimized')) {
            restoreGame(gameType);
            e.stopPropagation();
        } else {
            // Bring to front when clicked
            windowZIndex += 10;
            gameWindow.style.zIndex = windowZIndex;
        }
    };
}

// Enhanced minimize game function
function minimizeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    gameWindow.classList.add('minimized');
    
    // Hide overlay if all windows are minimized
    const visibleWindows = openWindows.filter(type => {
        const window = document.getElementById(type + 'GameWindow');
        return !window.classList.contains('minimized');
    });
    
    if (visibleWindows.length === 0) {
        overlay.classList.add('hidden');
    }
    
    showTransactionStatus(`${gameType} game minimized`);
}

// Enhanced restore game function
function restoreGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    // Bring to front
    windowZIndex += 10;
    gameWindow.style.zIndex = windowZIndex;
    
    gameWindow.classList.remove('minimized');
    overlay.classList.remove('hidden');
    
    showTransactionStatus(`${gameType} game restored`);
}

// Enhanced close game function
function closeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    if (confirm(`Are you sure you want to close the ${gameType} game?`)) {
        gameWindow.classList.add('hidden');
        
        // Remove from open windows
        openWindows = openWindows.filter(window => window !== gameType);
        
        // Hide overlay if no windows open
        if (openWindows.length === 0) {
            overlay.classList.add('hidden');
        }
        
        // Reset game state
        resetGameState(gameType);
        
        showTransactionStatus(`${gameType} game closed`);
        addChatMessage('System', `üö™ ${gameType} game closed`);
    }
}

// Close all games function
function closeAllGames() {
    if (openWindows.length > 0 && confirm('Close all open games?')) {
        openWindows.forEach(gameType => {
            const gameWindow = document.getElementById(gameType + 'GameWindow');
            gameWindow.classList.add('hidden');
            resetGameState(gameType);
        });
        
        openWindows = [];
        document.getElementById('gameOverlay').classList.add('hidden');
        showTransactionStatus('All games closed');
    }
}

// Reset game state function
function resetGameState(gameType) {
    if (gameType === 'chess') {
        selectedSquare = null;
        currentPlayer = 'white';
        chessBoard = [];
    } else if (gameType === 'checkers') {
        selectedSquare = null;
        currentPlayer = 'red';
        checkersBoard = [];
    } else if (gameType === 'word') {
        currentWordRound = 1;
        playerScore = 0;
        opponentScore = 0;
        currentPrompt = null;
    }
    
    // Clear stake input
    const stakeInput = document.getElementById(gameType + 'Stake');
    if (stakeInput) stakeInput.value = '';
}

// Add keyboard shortcuts for game management
document.addEventListener('keydown', (e) => {
    // ESC to close all games
    if (e.key === 'Escape' && openWindows.length > 0) {
        closeAllGames();
        e.preventDefault();
    }
    
    // Alt + 1, 2, 3 to switch between games
    if (e.altKey && ['1', '2', '3'].includes(e.key)) {
        const gameIndex = parseInt(e.key) - 1;
        if (openWindows[gameIndex]) {
            restoreGame(openWindows[gameIndex]);
        }
        e.preventDefault();
    }
});

console.log('‚úÖ Step 2B: Enhanced Game Window Management - Added successfully!');
        // Enhanced Game Status Updates
function updateGameStatus(gameType, status, extraInfo = '') {
    const statusElement = document.getElementById(gameType + 'Status');
    if (statusElement) {
        statusElement.textContent = status;
        if (extraInfo) {
            statusElement.innerHTML = `${status}<br><small style="color: #aaa;">${extraInfo}</small>`;
        }
    }
}

// Enhanced Game Creation with Better Feedback
function enhanceGameCreation() {
    // Override existing start functions with enhanced versions
    
    window.startChessGame = async function() {
        if (!userAddress) {
            alert('Please connect your wallet first!');
            return;
        }
        
        const stakeAmount = parseFloat(document.getElementById('chessStake').value);
        if (!stakeAmount || stakeAmount < 0.01) {
            alert('Please enter a valid stake amount (minimum 0.01 CORE)');
            return;
        }
        
        try {
            showTransactionStatus('Creating chess game...');
            
            // Simulate contract interaction with better feedback
            setTimeout(async () => {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(0, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                // Add to active games lobby
                const newGame = {
                    id: Date.now(),
                    type: 'chess',
                    creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                    stake: stakeAmount,
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
                
                // Open game window with enhanced status
                openGameWindow('chess');
                updateGameStatus('chess', 'Waiting for opponent...', `Stake: ${stakeAmount} CORE`);
                initializeChessBoard();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Chess game created! Waiting for opponent...');
                addChatMessage('System', `üéÆ New chess game created! Stake: ${stakeAmount} CORE`);
                
                // Clear input
                document.getElementById('chessStake').value = '';
                
            }, 1000);
            
        } catch (error) {
            console.error('Error creating chess game:', error);
            showTransactionStatus('‚ùå Demo mode: Chess game created locally');
            
            // Fallback for demo
            const newGame = {
                id: Date.now(),
                type: 'chess',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('chess');
            initializeChessBoard();
            document.getElementById('chessStake').value = '';
        }
    };
    
    window.startCheckersGame = async function() {
        if (!userAddress) {
            alert('Please connect your wallet first!');
            return;
        }
        
        const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
        if (!stakeAmount || stakeAmount < 0.01) {
            alert('Please enter a valid stake amount (minimum 0.01 CORE)');
            return;
        }
        
        try {
            showTransactionStatus('Creating checkers game...');
            
            setTimeout(async () => {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(1, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                const newGame = {
                    id: Date.now(),
                    type: 'checkers',
                    creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                    stake: stakeAmount,
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
                
                openGameWindow('checkers');
                updateGameStatus('checkers', 'Waiting for opponent...', `Stake: ${stakeAmount} CORE`);
                initializeCheckersBoard();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Checkers game created!');
                addChatMessage('System', `üéÆ New checkers game created! Stake: ${stakeAmount} CORE`);
                
                document.getElementById('checkersStake').value = '';
                
            }, 1000);
            
        } catch (error) {
            console.error('Error creating checkers game:', error);
            showTransactionStatus('‚ùå Demo: Checkers game created locally');
            
            const newGame = {
                id: Date.now(),
                type: 'checkers',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('checkers');
            initializeCheckersBoard();
            document.getElementById('checkersStake').value = '';
        }
    };
    
    window.startWordGame = async function() {
        if (!userAddress) {
            alert('Please connect your wallet first!');
            return;
        }
        
        const stakeAmount = parseFloat(document.getElementById('wordStake').value);
        if (!stakeAmount || stakeAmount < 0.01) {
            alert('Please enter a valid stake amount (minimum 0.01 CORE)');
            return;
        }
        
        try {
            showTransactionStatus('Creating word game...');
            
            setTimeout(async () => {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(2, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                const newGame = {
                    id: Date.now(),
                    type: 'words',
                    creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                    stake: stakeAmount,
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
                
                openGameWindow('word');
                currentWordRound = 1;
                playerScore = 0;
                opponentScore = 0;
                startWordRound();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Word game created!');
                addChatMessage('System', `üéÆ New word game created! Stake: ${stakeAmount} CORE`);
                
                document.getElementById('wordStake').value = '';
                
            }, 1000);
            
        } catch (error) {
            console.error('Error creating word game:', error);
            showTransactionStatus('‚ùå Demo: Word game created locally');
            
            const newGame = {
                id: Date.now(),
                type: 'words',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('word');
            startWordRound();
            document.getElementById('wordStake').value = '';
        }
    };
}

// Auto-initialize enhanced features
function initializeEnhancements() {
    // Update active games on page load
    updateActiveGames();
    
    // Enhance game creation functions
    enhanceGameCreation();
    
    // Start automatic updates
    setInterval(simulateNewGames, 45000); // New games every 45 seconds
    setInterval(removeOldGames, 60000);   // Remove old games every minute
    setInterval(updateActiveGames, 30000); // Refresh display every 30 seconds
    
    // Add game window dragging capability
    enableWindowDragging();
    
    console.log('üéÆ All game enhancements initialized!');
}

// Enable window dragging
function enableWindowDragging() {
    document.querySelectorAll('.game-window-header').forEach(header => {
        let isDragging = false;
        let currentX = 0;
        let currentY = 0;
        let initialX = 0;
        let initialY = 0;
        
        header.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons
            
            isDragging = true;
            const gameWindow = header.closest('.game-window');
            
            initialX = e.clientX - gameWindow.offsetLeft;
            initialY = e.clientY - gameWindow.offsetTop;
            
            gameWindow.style.cursor = 'grabbing';
            header.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            e.preventDefault();
            const gameWindow = header.closest('.game-window');
            
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            
            gameWindow.style.left = currentX + 'px';
            gameWindow.style.top = currentY + 'px';
            gameWindow.style.transform = 'none'; // Remove centering transform
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                const gameWindow = header.closest('.game-window');
                gameWindow.style.cursor = 'default';
                header.style.cursor = 'grab';
            }
        });
        
        header.style.cursor = 'grab';
    });
}

// Initialize everything when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeEnhancements);
} else {
    initializeEnhancements();
}

console.log('‚úÖ Step 2C: Game Window Polish & Final Touches - Added successfully!');
        // Enhanced Game Status Updates
function updateGameStatus(gameType, status, extraInfo = '') {
    const statusElement = document.getElementById(gameType + 'Status');
    if (statusElement) {
        statusElement.textContent = status;
        if (extraInfo) {
            statusElement.innerHTML = `${status}<br><small style="color: #aaa;">${extraInfo}</small>`;
        }
    }
}

// Enhanced Game Creation with Better Feedback
function enhanceGameCreation() {
    // Override existing start functions with enhanced versions
    
    window.startChessGame = async function() {
        if (!userAddress) {
            alert('Please connect your wallet first!');
            return;
        }
        
        const stakeAmount = parseFloat(document.getElementById('chessStake').value);
        if (!stakeAmount || stakeAmount < 0.01) {
            alert('Please enter a valid stake amount (minimum 0.01 CORE)');
            return;
        }
        
        try {
            showTransactionStatus('Creating chess game...');
            
            // Simulate contract interaction with better feedback
            setTimeout(async () => {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(0, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                // Add to active games lobby
                const newGame = {
                    id: Date.now(),
                    type: 'chess',
                    creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                    stake: stakeAmount,
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
                
                // Open game window with enhanced status
                openGameWindow('chess');
                updateGameStatus('chess', 'Waiting for opponent...', `Stake: ${stakeAmount} CORE`);
                initializeChessBoard();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Chess game created! Waiting for opponent...');
                addChatMessage('System', `üéÆ New chess game created! Stake: ${stakeAmount} CORE`);
                
                // Clear input
                document.getElementById('chessStake').value = '';
                
            }, 1000);
            
        } catch (error) {
            console.error('Error creating chess game:', error);
            showTransactionStatus('‚ùå Demo mode: Chess game created locally');
            
            // Fallback for demo
            const newGame = {
                id: Date.now(),
                type: 'chess',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('chess');
            initializeChessBoard();
            document.getElementById('chessStake').value = '';
        }
    };
    
    window.startCheckersGame = async function() {
        if (!userAddress) {
            alert('Please connect your wallet first!');
            return;
        }
        
        const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
        if (!stakeAmount || stakeAmount < 0.01) {
            alert('Please enter a valid stake amount (minimum 0.01 CORE)');
            return;
        }
        
        try {
            showTransactionStatus('Creating checkers game...');
            
            setTimeout(async () => {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(1, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                const newGame = {
                    id: Date.now(),
                    type: 'checkers',
                    creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                    stake: stakeAmount,
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
                
                openGameWindow('checkers');
                updateGameStatus('checkers', 'Waiting for opponent...', `Stake: ${stakeAmount} CORE`);
                initializeCheckersBoard();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Checkers game created!');
                addChatMessage('System', `üéÆ New checkers game created! Stake: ${stakeAmount} CORE`);
                
                document.getElementById('checkersStake').value = '';
                
            }, 1000);
            
        } catch (error) {
            console.error('Error creating checkers game:', error);
            showTransactionStatus('‚ùå Demo: Checkers game created locally');
            
            const newGame = {
                id: Date.now(),
                type: 'checkers',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('checkers');
            initializeCheckersBoard();
            document.getElementById('checkersStake').value = '';
        }
    };
    
    window.startWordGame = async function() {
        if (!userAddress) {
            alert('Please connect your wallet first!');
            return;
        }
        
        const stakeAmount = parseFloat(document.getElementById('wordStake').value);
        if (!stakeAmount || stakeAmount < 0.01) {
            alert('Please enter a valid stake amount (minimum 0.01 CORE)');
            return;
        }
        
        try {
            showTransactionStatus('Creating word game...');
            
            setTimeout(async () => {
                if (gameContract) {
                    const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
                    const tx = await gameContract.createGame(2, stakeWei, { value: stakeWei });
                    showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
                    await tx.wait();
                }
                
                const newGame = {
                    id: Date.now(),
                    type: 'words',
                    creator: userAddress ? userAddress.substring(0, 8) + '...' : 'You',
                    stake: stakeAmount,
                    status: 'waiting'
                };
                activeGames.push(newGame);
                updateActiveGames();
                
                openGameWindow('word');
                currentWordRound = 1;
                playerScore = 0;
                opponentScore = 0;
                startWordRound();
                
                playerStats.gamesPlayed++;
                updateProfileDisplay();
                
                showTransactionStatus('‚úÖ Word game created!');
                addChatMessage('System', `üéÆ New word game created! Stake: ${stakeAmount} CORE`);
                
                document.getElementById('wordStake').value = '';
                
            }, 1000);
            
        } catch (error) {
            console.error('Error creating word game:', error);
            showTransactionStatus('‚ùå Demo: Word game created locally');
            
            const newGame = {
                id: Date.now(),
                type: 'words',
                creator: 'You',
                stake: stakeAmount,
                status: 'waiting'
            };
            activeGames.push(newGame);
            updateActiveGames();
            
            openGameWindow('word');
            startWordRound();
            document.getElementById('wordStake').value = '';
        }
    };
}

// Auto-initialize enhanced features
function initializeEnhancements() {
    // Update active games on page load
    updateActiveGames();
    
    // Enhance game creation functions
    enhanceGameCreation();
    
    // Start automatic updates
    setInterval(simulateNewGames, 45000); // New games every 45 seconds
    setInterval(removeOldGames, 60000);   // Remove old games every minute
    setInterval(updateActiveGames, 30000); // Refresh display every 30 seconds
    
    // Add game window dragging capability
    enableWindowDragging();
    
    console.log('üéÆ All game enhancements initialized!');
}

// Enable window dragging
function enableWindowDragging() {
    document.querySelectorAll('.game-window-header').forEach(header => {
        let isDragging = false;
        let currentX = 0;
        let currentY = 0;
        let initialX = 0;
        let initialY = 0;
        
        header.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons
            
            isDragging = true;
            const gameWindow = header.closest('.game-window');
            
            initialX = e.clientX - gameWindow.offsetLeft;
            initialY = e.clientY - gameWindow.offsetTop;
            
            gameWindow.style.cursor = 'grabbing';
            header.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            e.preventDefault();
            const gameWindow = header.closest('.game-window');
            
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            
            gameWindow.style.left = currentX + 'px';
            gameWindow.style.top = currentY + 'px';
            gameWindow.style.transform = 'none'; // Remove centering transform
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                const gameWindow = header.closest('.game-window');
                gameWindow.style.cursor = 'default';
                header.style.cursor = 'grab';
            }
        });
        
        header.style.cursor = 'grab';
    });
}

// Initialize everything when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeEnhancements);
} else {
    initializeEnhancements();
}

console.log('‚úÖ Step 2C: Game Window Polish & Final Touches - Added successfully!');
        // Advanced Chess Features
let chessGameState = {
    whiteKingMoved: false,
    blackKingMoved: false,
    whiteRooksMoved: { left: false, right: false },
    blackRooksMoved: { left: false, right: false },
    enPassantTarget: null,
    isInCheck: { white: false, black: false },
    moveHistory: []
};

// Enhanced Chess Move Validation with Special Rules
function isValidChessMove(fromRow, fromCol, toRow, toCol) {
    const piece = chessBoard[fromRow][fromCol];
    const targetPiece = chessBoard[toRow][toCol];
    const isWhite = piece === piece.toUpperCase();
    
    // Can't capture own piece
    if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) {
        return false;
    }
    
    // Check piece-specific movement rules
    if (!isPieceMovementValid(piece, fromRow, fromCol, toRow, toCol)) {
        return false;
    }
    
    // Check if move would leave king in check
    if (wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, currentPlayer)) {
        return false;
    }
    
    return true;
}

// Detailed piece movement validation
function isPieceMovementValid(piece, fromRow, fromCol, toRow, toCol) {
    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);
    const isWhite = piece === piece.toUpperCase();
    
    switch (piece.toLowerCase()) {
        case 'p': // Pawn
            return isValidPawnMove(fromRow, fromCol, toRow, toCol, isWhite);
        case 'r': // Rook
            return isValidRookMove(fromRow, fromCol, toRow, toCol);
        case 'n': // Knight
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        case 'b': // Bishop
            return isValidBishopMove(fromRow, fromCol, toRow, toCol);
        case 'q': // Queen
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                   isValidBishopMove(fromRow, fromCol, toRow, toCol);
        case 'k': // King
            return isValidKingMove(fromRow, fromCol, toRow, toCol, isWhite);
        default:
            return false;
    }
}

// Enhanced pawn movement with en passant
function isValidPawnMove(fromRow, fromCol, toRow, toCol, isWhite) {
    const direction = isWhite ? -1 : 1;
    const startRow = isWhite ? 6 : 1;
    const targetPiece = chessBoard[toRow][toCol];
    
    // Forward move
    if (fromCol === toCol && !targetPiece) {
        if (toRow === fromRow + direction) return true;
        if (fromRow === startRow && toRow === fromRow + 2 * direction) return true;
    }
    
    // Diagonal capture
    if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {
        if (targetPiece) return true;
        
        // En passant
        if (chessGameState.enPassantTarget && 
            toRow === chessGameState.enPassantTarget.row && 
            toCol === chessGameState.enPassantTarget.col) {
            return true;
        }
    }
    
    return false;
}

// Rook movement validation
function isValidRookMove(fromRow, fromCol, toRow, toCol) {
    if (fromRow !== toRow && fromCol !== toCol) return false;
    
    // Check path is clear
    const rowStep = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
    const colStep = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
    
    let currentRow = fromRow + rowStep;
    let currentCol = fromCol + colStep;
    
    while (currentRow !== toRow || currentCol !== toCol) {
        if (chessBoard[currentRow][currentCol]) return false;
        currentRow += rowStep;
        currentCol += colStep;
    }
    
    return true;
}

// Bishop movement validation
function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
    if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
    
    // Check diagonal path is clear
    const rowStep = toRow > fromRow ? 1 : -1;
    const colStep = toCol > fromCol ? 1 : -1;
    
    let currentRow = fromRow + rowStep;
    let currentCol = fromCol + colStep;
    
    while (currentRow !== toRow && currentCol !== toCol) {
        if (chessBoard[currentRow][currentCol]) return false;
        currentRow += rowStep;
        currentCol += colStep;
    }
    
    return true;
}

// King movement with castling
function isValidKingMove(fromRow, fromCol, toRow, toCol, isWhite) {
    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);
    
    // Normal king move
    if (rowDiff <= 1 && colDiff <= 1) return true;
    
    // Castling
    if (rowDiff === 0 && colDiff === 2) {
        return canCastle(fromRow, fromCol, toRow, toCol, isWhite);
    }
    
    return false;
}

// Castling validation
function canCastle(fromRow, fromCol, toRow, toCol, isWhite) {
    // King must not have moved
    if ((isWhite && chessGameState.whiteKingMoved) || 
        (!isWhite && chessGameState.blackKingMoved)) {
        return false;
    }
    
    // King must not be in check
    if (chessGameState.isInCheck[isWhite ? 'white' : 'black']) {
        return false;
    }
    
    const rookCol = toCol > fromCol ? 7 : 0; // Kingside or queenside
    const rooksMoved = isWhite ? chessGameState.whiteRooksMoved : chessGameState.blackRooksMoved;
    
    // Rook must not have moved
    if ((rookCol === 7 && rooksMoved.right) || (rookCol === 0 && rooksMoved.left)) {
        return false;
    }
    
    // Path must be clear
    const step = toCol > fromCol ? 1 : -1;
    for (let col = fromCol + step; col !== rookCol; col += step) {
        if (chessBoard[fromRow][col]) return false;
    }
    
    // King must not pass through check
    for (let col = fromCol; col !== toCol + step; col += step) {
        if (isSquareUnderAttack(fromRow, col, isWhite ? 'black' : 'white')) {
            return false;
        }
    }
    
    return true;
}

// Check if a square is under attack
function isSquareUnderAttack(row, col, byPlayer) {
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = chessBoard[r][c];
            if (piece && isPlayerPiece(piece, byPlayer)) {
                if (canPieceAttackSquare(piece, r, c, row, col)) {
                    return true;
                }
            }
        }
    }
    return false;
}

// Check if piece can attack a square
function canPieceAttackSquare(piece, fromRow, fromCol, toRow, toCol) {
    // Simplified attack pattern check (without considering check)
    const isWhite = piece === piece.toUpperCase();
    
    switch (piece.toLowerCase()) {
        case 'p':
            const direction = isWhite ? -1 : 1;
            return Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction;
        case 'r':
            return isValidRookMove(fromRow, fromCol, toRow, toCol);
        case 'n':
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        case 'b':
            return isValidBishopMove(fromRow, fromCol, toRow, toCol);
        case 'q':
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                   isValidBishopMove(fromRow, fromCol, toRow, toCol);
        case 'k':
            const kRowDiff = Math.abs(toRow - fromRow);
            const kColDiff = Math.abs(toCol - fromCol);
            return kRowDiff <= 1 && kColDiff <= 1;
        default:
            return false;
    }
}

// Check if move would leave king in check
function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, player) {
    // Make temporary move
    const originalPiece = chessBoard[toRow][toCol];
    const movingPiece = chessBoard[fromRow][fromCol];
    
    chessBoard[toRow][toCol] = movingPiece;
    chessBoard[fromRow][fromCol] = null;
    
    // Find king position
    let kingRow, kingCol;
    const kingPiece = player === 'white' ? 'K' : 'k';
    
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if (chessBoard[r][c] === kingPiece) {
                kingRow = r;
                kingCol = c;
                break;
            }
        }
    }
    
    // If king moved, use new position
    if (movingPiece.toLowerCase() === 'k') {
        kingRow = toRow;
        kingCol = toCol;
    }
    
    const wouldBeInCheck = isSquareUnderAttack(kingRow, kingCol, player === 'white' ? 'black' : 'white');
    
    // Restore board
    chessBoard[fromRow][fromCol] = movingPiece;
    chessBoard[toRow][toCol] = originalPiece;
    
    return wouldBeInCheck;
}

// Enhanced chess move execution
function makeChessMove(fromRow, fromCol, toRow, toCol) {
    const piece = chessBoard[fromRow][fromCol];
    const isWhite = piece === piece.toUpperCase();
    const capturedPiece = chessBoard[toRow][toCol];
    
    // Handle special moves
    handleSpecialMoves(piece, fromRow, fromCol, toRow, toCol);
    
    // Make the move
    chessBoard[toRow][toCol] = piece;
    chessBoard[fromRow][fromCol] = null;
    
    // Update game state
    updateChessGameState(piece, fromRow, fromCol, toRow, toCol);
    
    // Check for pawn promotion
    if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
        const promotedPiece = isWhite ? 'Q' : 'q'; // Auto-promote to queen
        chessBoard[toRow][toCol] = promotedPiece;
        addChatMessage('System', `üéâ Pawn promoted to Queen!`);
    }
    
    // Record move in history
    chessGameState.moveHistory.push({
        from: [fromRow, fromCol],
        to: [toRow, toCol],
        piece: piece,
        captured: capturedPiece,
        player: currentPlayer
    });
    
    // Update display
    initializeChessBoard();
    
    // Switch players
    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
    
    // Check for check/checkmate
    updateCheckStatus();
    
    updateGameStatus('chess', `${currentPlayer}'s turn`, 
        chessGameState.isInCheck[currentPlayer] ? 'In Check!' : '');
    
    // Add move to chat
    const moveNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow} to ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
    addChatMessage('You', `Chess move: ${moveNotation}`);
}

// Handle special chess moves
function handleSpecialMoves(piece, fromRow, fromCol, toRow, toCol) {
    // Castling
    if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
        const rookFromCol = toCol > fromCol ? 7 : 0;
        const rookToCol = toCol > fromCol ? 5 : 3;
        const rook = chessBoard[fromRow][rookFromCol];
        
        chessBoard[fromRow][rookToCol] = rook;
        chessBoard[fromRow][rookFromCol] = null;
        
        addChatMessage('System', `üè∞ Castling performed!`);
    }
    
    // En passant capture
    if (piece.toLowerCase() === 'p' && !chessBoard[toRow][toCol] && fromCol !== toCol) {
        chessBoard[fromRow][toCol] = null; // Remove captured pawn
        addChatMessage('System', `‚ö° En passant capture!`);
    }
}

// Update chess game state
function updateChessGameState(piece, fromRow, fromCol, toRow, toCol) {
    const isWhite = piece === piece.toUpperCase();
    
    // Track king movement
    if (piece.toLowerCase() === 'k') {
        if (isWhite) chessGameState.whiteKingMoved = true;
        else chessGameState.blackKingMoved = true;
    }
    
    // Track rook movement
    if (piece.toLowerCase() === 'r') {
        if (isWhite) {
            if (fromCol === 0) chessGameState.whiteRooksMoved.left = true;
            if (fromCol === 7) chessGameState.whiteRooksMoved.right = true;
        } else {
            if (fromCol === 0) chessGameState.blackRooksMoved.left = true;
            if (fromCol === 7) chessGameState.blackRooksMoved.right = true;
        }
    }
    
    // Set en passant target
    chessGameState.enPassantTarget = null;
    if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
        chessGameState.enPassantTarget = {
            row: fromRow + (toRow > fromRow ? 1 : -1),
            col: toCol
        };
    }
}

// Update check status
function updateCheckStatus() {
    chessGameState.isInCheck.white = isKingInCheck('white');
    chessGameState.isInCheck.black = isKingInCheck('black');
}

// Check if king is in check
function isKingInCheck(player) {
    const kingPiece = player === 'white' ? 'K' : 'k';
    let kingRow, kingCol;
    
    // Find king
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if (chessBoard[r][c] === kingPiece) {
                kingRow = r;
                kingCol = c;
                break;
            }
        }
    }
    
    return isSquareUnderAttack(kingRow, kingCol, player === 'white' ? 'black' : 'white');
}

console.log('‚úÖ Step 3A: Advanced Chess Features - Added successfully!');
        // Advanced Checkers Game State
let checkersGameState = {
    mustCapture: false,
    capturingPiece: null,
    consecutiveCaptures: 0,
    moveHistory: []
};

// Enhanced checkers move validation with mandatory captures
function getValidCheckersMovesForPiece(row, col) {
    const piece = checkersBoard[row][col];
    const moves = [];
    
    if (!piece) return moves;
    
    const isRed = piece === 'red' || piece === 'redKing';
    const isKing = piece === 'redKing' || piece === 'blackKing';
    
    // Determine move directions
    const directions = [];
    if (isRed || isKing) {
        directions.push([1, -1], [1, 1]); // Red moves down
    }
    if (!isRed || isKing) {
        directions.push([-1, -1], [-1, 1]); // Black moves up
    }
    
    // Check for captures first (mandatory in checkers)
    const captures = getCaptureMoves(row, col, directions);
    
    // If captures available, return only captures (mandatory)
    if (captures.length > 0) {
        checkersGameState.mustCapture = true;
        return captures;
    }
    
    checkersGameState.mustCapture = false;
    
    // If no captures and we're in a multi-capture sequence, no moves allowed
    if (checkersGameState.capturingPiece && 
        (checkersGameState.capturingPiece.row !== row || checkersGameState.capturingPiece.col !== col)) {
        return [];
    }
    
    // Regular moves (only if no captures available)
    directions.forEach(([dr, dc]) => {
        const newRow = row + dr;
        const newCol = col + dc;
        
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            if (!checkersBoard[newRow][newCol]) {
                moves.push([newRow, newCol]);
            }
        }
    });
    
    return moves;
}

// Get all possible capture moves
function getCaptureMoves(row, col, directions) {
    const captures = [];
    
    directions.forEach(([dr, dc]) => {
        const jumpRow = row + dr;
        const jumpCol = col + dc;
        const landRow = row + dr * 2;
        const landCol = col + dc * 2;
        
        if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8) {
            const jumpPiece = checkersBoard[jumpRow][jumpCol];
            const landPiece = checkersBoard[landRow][landCol];
            
            // Can capture if there's an enemy piece to jump and empty landing spot
            if (jumpPiece && !isCheckersPlayerPiece(jumpPiece, currentPlayer) && !landPiece) {
                captures.push([landRow, landCol]);
            }
        }
    });
    
    return captures;
}

// Get directions a piece can move
function getPieceDirections(piece) {
    const isRed = piece === 'red' || piece === 'redKing';
    const isKing = piece === 'redKing' || piece === 'blackKing';
    const directions = [];
    
    if (isRed || isKing) {
        directions.push([1, -1], [1, 1]); // Red/King moves down
    }
    if (!isRed || isKing) {
        directions.push([-1, -1], [-1, 1]); // Black/King moves up
    }
    
    return directions;
}

// Check if piece belongs to player (enhanced)
function isCheckersPlayerPiece(piece, player) {
    if (player === 'red') {
        return piece === 'red' || piece === 'redKing';
    } else {
        return piece === 'black' || piece === 'blackKing';
    }
}

console.log('‚úÖ Step 3B Part 1: Enhanced Checkers Logic - Added successfully!');
        // Enhanced checkers click handler with better validation
function handleCheckersClick(row, col) {
    if (selectedSquare) {
        // Clear highlights
        document.querySelectorAll('.checkers-square').forEach(s => {
            s.classList.remove('selected', 'possible-move');
        });
        
        // Try to make move
        const validMoves = getValidCheckersMovesForPiece(selectedSquare.row, selectedSquare.col);
        const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
        
        if (isValidMove) {
            makeCheckersMove(selectedSquare.row, selectedSquare.col, row, col);
        } else {
            addChatMessage('System', '‚ùå Invalid move! ' + 
                (checkersGameState.mustCapture ? 'You must capture!' : 'Choose a valid square.'));
        }
        selectedSquare = null;
    } else {
        // Select piece
        const piece = checkersBoard[row][col];
        if (piece && isCheckersPlayerPiece(piece, currentPlayer)) {
            // Check if this piece can move
            const validMoves = getValidCheckersMovesForPiece(row, col);
            
            if (validMoves.length === 0) {
                addChatMessage('System', '‚ùå This piece has no valid moves!');
                return;
            }
            
            // If we're in a capture sequence, only allow the capturing piece
            if (checkersGameState.capturingPiece && 
                (checkersGameState.capturingPiece.row !== row || checkersGameState.capturingPiece.col !== col)) {
                addChatMessage('System', '‚ùå You must continue capturing with the same piece!');
                return;
            }
            
            selectedSquare = { row, col };
            
            const square = document.querySelector(`.checkers-square[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            
            // Highlight possible moves
            validMoves.forEach(([r, c]) => {
                const moveSquare = document.querySelector(`.checkers-square[data-row="${r}"][data-col="${c}"]`);
                if (moveSquare) moveSquare.classList.add('possible-move');
            });
            
            // Show move info in chat
            if (checkersGameState.mustCapture) {
                addChatMessage('System', `üéØ You must capture! ${validMoves.length} capture(s) available.`);
            } else {
                addChatMessage('System', `‚ú® ${validMoves.length} move(s) available for this piece.`);
            }
            
        } else if (piece) {
            addChatMessage('System', `‚ùå It's ${currentPlayer}'s turn!`);
        }
    }
}

console.log('‚úÖ Step 3B Part 2: Enhanced Checkers Click Handler - Added successfully!');
        // Enhanced checkers move execution with multi-jumps
function makeCheckersMove(fromRow, fromCol, toRow, toCol) {
    const piece = checkersBoard[fromRow][fromCol];
    const isCapture = Math.abs(fromRow - toRow) === 2;
    let capturedPiece = null;
    
    // Handle capture
    if (isCapture) {
        const captureRow = fromRow + (toRow - fromRow) / 2;
        const captureCol = fromCol + (toCol - fromCol) / 2;
        capturedPiece = checkersBoard[captureRow][captureCol];
        checkersBoard[captureRow][captureCol] = null; // Remove captured piece
        
        checkersGameState.consecutiveCaptures++;
        addChatMessage('You', `Checkers capture #${checkersGameState.consecutiveCaptures}! Jumped at ${String.fromCharCode(97 + captureCol)}${8 - captureRow}`);
    }
    
    // Move piece
    checkersBoard[toRow][toCol] = piece;
    checkersBoard[fromRow][fromCol] = null;
    
    // Check for king promotion
    let promoted = false;
    if (piece === 'red' && toRow === 7) {
        checkersBoard[toRow][toCol] = 'redKing';
        promoted = true;
        addChatMessage('System', 'üëë Red piece promoted to King!');
    } else if (piece === 'black' && toRow === 0) {
        checkersBoard[toRow][toCol] = 'blackKing';
        promoted = true;
        addChatMessage('System', 'üëë Black piece promoted to King!');
    }
    
    // Record move in history
    checkersGameState.moveHistory.push({
        from: [fromRow, fromCol],
        to: [toRow, toCol],
        piece: piece,
        captured: capturedPiece,
        promoted: promoted,
        player: currentPlayer
    });
    
    // Check for additional captures after this move
    if (isCapture && !promoted) {
        const additionalCaptures = getCaptureMoves(toRow, toCol, getPieceDirections(checkersBoard[toRow][toCol]));
        
        if (additionalCaptures.length > 0) {
            // Must continue capturing with same piece
            checkersGameState.capturingPiece = { row: toRow, col: toCol };
            updateGameStatus('checkers', `${currentPlayer}'s turn`, 
                `Must continue capturing! ${checkersGameState.consecutiveCaptures} captures so far`);
            
            // Update display but don't switch players
            initializeCheckersBoard();
            
            // Auto-select the piece for next capture
            setTimeout(() => {
                handleCheckersClick(toRow, toCol);
            }, 500);
            
            return; // Don't end turn yet
        }
    }
    
    // End of turn - reset capture state
    if (checkersGameState.consecutiveCaptures > 0) {
        addChatMessage('System', `üéØ Capture sequence complete! ${checkersGameState.consecutiveCaptures} pieces captured!`);
    }
    
    checkersGameState.capturingPiece = null;
    checkersGameState.consecutiveCaptures = 0;
    
    // Update display
    initializeCheckersBoard();
    
    // Switch players
    currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
    updateGameStatus('checkers', `${currentPlayer}'s turn`);
    
    // Check for game end
    if (isCheckersGameOver()) {
        endCheckersGame();
    }
}

// Enhanced checkers game over check
function isCheckersGameOver() {
    let redPieces = 0;
    let blackPieces = 0;
    let redCanMove = false;
    let blackCanMove = false;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = checkersBoard[row][col];
            if (piece === 'red' || piece === 'redKing') {
                redPieces++;
                if (!redCanMove && getValidCheckersMovesForPiece(row, col).length > 0) {
                    redCanMove = true;
                }
            }
            if (piece === 'black' || piece === 'blackKing') {
                blackPieces++;
                if (!blackCanMove && getValidCheckersMovesForPiece(row, col).length > 0) {
                    blackCanMove = true;
                }
            }
        }
    }
    
    // Game over if no pieces left or no valid moves
    return redPieces === 0 || blackPieces === 0 || 
           (currentPlayer === 'red' && !redCanMove) || 
           (currentPlayer === 'black' && !blackCanMove);
}

// Enhanced checkers game end with statistics
function endCheckersGame() {
    let redPieces = 0;
    let blackPieces = 0;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = checkersBoard[row][col];
            if (piece === 'red' || piece === 'redKing') redPieces++;
            if (piece === 'black' || piece === 'blackKing') blackPieces++;
        }
    }
    
    let winner;
    if (redPieces === 0) {
        winner = 'black';
    } else if (blackPieces === 0) {
        winner = 'red';
    } else {
        // No valid moves
        winner = currentPlayer === 'red' ? 'black' : 'red';
    }
    
    updateGameStatus('checkers', `Game Over! ${winner} wins!`, 
        `Final: Red ${redPieces} - Black ${blackPieces}`);
    
    if (winner === 'red') {
        playerStats.checkers.wins++;
        playerStats.gamesWon++;
        addChatMessage('System', 'üèÜ You won the Checkers game!');
    } else {
        playerStats.checkers.losses++;
    }
    
    updateProfileDisplay();
    
    // Show game summary
    const totalMoves = checkersGameState.moveHistory.length;
    const captures = checkersGameState.moveHistory.filter(move => move.captured).length;
    const promotions = checkersGameState.moveHistory.filter(move => move.promoted).length;
    
    addChatMessage('System', `üìä Game Summary: ${totalMoves} moves, ${captures} captures, ${promotions} promotions`);
}

console.log('‚úÖ Step 3B Part 3: Enhanced Checkers Move Execution - Added successfully!');
        // Advanced Word Game Features
let wordGameState = {
    timeRemaining: 60,
    timerInterval: null,
    hintsUsed: 0,
    maxHints: 3,
    bonusWordsFound: [],
    currentDifficulty: 'medium'
};

// Enhanced word list with categories and difficulty
const enhancedWordDatabase = {
    easy: [
        { word: 'CORE', category: 'Blockchain', hint: 'The blockchain platform we\'re on!' },
        { word: 'GAME', category: 'Gaming', hint: 'What you\'re playing right now' },
        { word: 'PLAY', category: 'Gaming', hint: 'What gamers do' },
        { word: 'WIN', category: 'Gaming', hint: 'The goal of every game' }
    ],
    medium: [
        { word: 'BLOCKCHAIN', category: 'Technology', hint: 'Distributed ledger technology' },
        { word: 'ETHEREUM', category: 'Cryptocurrency', hint: 'Second largest cryptocurrency' },
        { word: 'BITCOIN', category: 'Cryptocurrency', hint: 'First and largest cryptocurrency' },
        { word: 'CRYPTICUS', category: 'Gaming', hint: 'The name of this platform!' },
        { word: 'STAKING', category: 'DeFi', hint: 'Earning rewards by locking tokens' },
        { word: 'MINING', category: 'Blockchain', hint: 'Process of validating transactions' }
    ],
    hard: [
        { word: 'DECENTRALIZED', category: 'Web3', hint: 'Not controlled by a single entity' },
        { word: 'SMARTCONTRACT', category: 'DeFi', hint: 'Self-executing contract with terms in code' },
        { word: 'CONSENSUS', category: 'Blockchain', hint: 'Agreement mechanism in networks' },
        { word: 'INTEROPERABILITY', category: 'Technology', hint: 'Ability of systems to work together' }
    ]
};

// Enhanced word round start with timer and hints
function startWordRound() {
    // Select difficulty based on round
    let difficulty = 'easy';
    if (currentWordRound >= 2) difficulty = 'medium';
    if (currentWordRound >= 3) difficulty = 'hard';
    
    wordGameState.currentDifficulty = difficulty;
    
    const wordDatabase = enhancedWordDatabase[difficulty];
    const randomWord = wordDatabase[Math.floor(Math.random() * wordDatabase.length)];
    
    currentPrompt = randomWord;
    
    // Reset timer
    wordGameState.timeRemaining = difficulty === 'easy' ? 90 : difficulty === 'medium' ? 60 : 45;
    
    // Update UI
    document.getElementById('wordStatus').textContent = `Round ${currentWordRound} of 3 (${difficulty.toUpperCase()})`;
    document.getElementById('wordPrompt').textContent = `Category: ${randomWord.category} - Unscramble this word:`;
    document.getElementById('wordLetters').textContent = scrambleWord(randomWord.word);
    document.getElementById('wordInput').value = '';
    document.getElementById('playerScore').textContent = playerScore;
    document.getElementById('opponentScore').textContent = opponentScore;
    
    // Add timer display
    updateTimerDisplay();
    startTimer();
    
    // Add hint button if not exists
    addHintButton();
    
    // Reset hints for new round
    wordGameState.hintsUsed = 0;
    updateHintButton();
}

// Enhanced word scrambling with better randomization
function scrambleWord(word) {
    const letters = word.split('');
    
    // Fisher-Yates shuffle algorithm
    for (let i = letters.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [letters[i], letters[j]] = [letters[j], letters[i]];
    }
    
    // Ensure it's actually scrambled (not same as original)
    let scrambled = letters.join('');
    let attempts = 0;
    while (scrambled === word && attempts < 10) {
        for (let i = letters.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [letters[i], letters[j]] = [letters[j], letters[i]];
        }
        scrambled = letters.join('');
        attempts++;
    }
    
    return scrambled;
}

// Timer functions
function startTimer() {
    if (wordGameState.timerInterval) {
        clearInterval(wordGameState.timerInterval);
    }
    
    wordGameState.timerInterval = setInterval(() => {
        wordGameState.timeRemaining--;
        updateTimerDisplay();
        
        if (wordGameState.timeRemaining <= 0) {
            clearInterval(wordGameState.timerInterval);
            timeUp();
        }
    }, 1000);
}

function updateTimerDisplay() {
    const timerElement = document.getElementById('wordTimer');
    if (!timerElement) {
        // Create timer display
        const timerDiv = document.createElement('div');
        timerDiv.id = 'wordTimer';
        timerDiv.style.cssText = 'font-size: 1.2rem; color: #4ecdc4; margin: 1rem 0; font-weight: bold;';
        
        const wordGame = document.querySelector('.word-game');
        const promptElement = document.getElementById('wordPrompt');
        promptElement.parentNode.insertBefore(timerDiv, promptElement.nextSibling);
    }
    
    const minutes = Math.floor(wordGameState.timeRemaining / 60);
    const seconds = wordGameState.timeRemaining % 60;
    const timeColor = wordGameState.timeRemaining <= 10 ? '#ff6b6b' : '#4ecdc4';
    
    document.getElementById('wordTimer').innerHTML = 
        `‚è∞ Time: <span style="color: ${timeColor}">${minutes}:${seconds.toString().padStart(2, '0')}</span>`;
}

function timeUp() {
    addChatMessage('System', '‚è∞ Time\'s up! Moving to next round...');
    
    // Show correct answer
    addChatMessage('System', `üí° The answer was: ${currentPrompt.word} (${currentPrompt.category})`);
    
    // Opponent gets points for timeout
    opponentScore += 50;
    
    setTimeout(() => {
        currentWordRound++;
        if (currentWordRound <= 3) {
            startWordRound();
        } else {
            endWordGame();
        }
    }, 2000);
}

// Add hint system
function addHintButton() {
    if (document.getElementById('hintBtn')) return; // Already exists
    
    const hintBtn = document.createElement('button');
    hintBtn.id = 'hintBtn';
    hintBtn.className = 'game-btn';
    hintBtn.textContent = 'Get Hint (3 available)';
    hintBtn.onclick = useHint;
    
    const gameControls = document.querySelector('#wordGameWindow .game-controls');
    gameControls.appendChild(hintBtn);
}

function updateHintButton() {
    const hintBtn = document.getElementById('hintBtn');
    if (hintBtn) {
        const hintsLeft = wordGameState.maxHints - wordGameState.hintsUsed;
        hintBtn.textContent = `Get Hint (${hintsLeft} left)`;
        hintBtn.disabled = hintsLeft <= 0;
    }
}

function useHint() {
    if (wordGameState.hintsUsed >= wordGameState.maxHints) {
        addChatMessage('System', '‚ùå No more hints available!');
        return;
    }
    
    wordGameState.hintsUsed++;
    updateHintButton();
    
    // Show hint
    addChatMessage('System', `üí° Hint: ${currentPrompt.hint}`);
    
    // Penalty for using hint
    playerScore = Math.max(0, playerScore - 10);
    document.getElementById('playerScore').textContent = playerScore;
    
    addChatMessage('System', 'üìâ -10 points for using hint');
}

// Enhanced word submission with bonus detection
function submitWord() {
    const word = document.getElementById('wordInput').value.toUpperCase().trim();
    if (!word) {
        alert('Please enter a word!');
        return;
    }
    
    // Check if correct answer
    if (word === currentPrompt.word) {
        // Stop timer
        clearInterval(wordGameState.timerInterval);
        
        // Calculate score with time bonus
        let wordScore = calculateWordScore(word, wordGameState.timeRemaining);
        
        playerScore += wordScore;
        addChatMessage('You', `‚úÖ Correct! "${word}" (+${wordScore} points)`);
        
        // Time bonus message
        if (wordGameState.timeRemaining > 30) {
            addChatMessage('System', '‚ö° Speed bonus included!');
        }
        
        document.getElementById('wordInput').value = '';
        
        // Move to next round
        setTimeout(() => {
            currentWordRound++;
            if (currentWordRound <= 3) {
                startWordRound();
            } else {
                endWordGame();
            }
        }, 1500);
        
    } else {
        // Check for bonus words (valid words made from letters)
        if (isValidBonusWord(word)) {
            const bonusScore = Math.floor(word.length * 2);
            playerScore += bonusScore;
            wordGameState.bonusWordsFound.push(word);
            
            addChatMessage('You', `üåü Bonus word: "${word}" (+${bonusScore} points)`);
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('wordInput').value = '';
        } else {
            addChatMessage('You', `‚ùå Wrong: "${word}". Try again!`);
            document.getElementById('wordInput').value = '';
        }
    }
    
    // Simulate opponent progress
    opponentScore += Math.floor(Math.random() * 30) + 20;
    document.getElementById('opponentScore').textContent = opponentScore;
}

// Calculate word score with bonuses
function calculateWordScore(word, timeRemaining) {
    let baseScore = word.length * 10;
    
    // Difficulty bonus
    const difficultyBonus = {
        'easy': 0,
        'medium': 20,
        'hard': 50
    };
    baseScore += difficultyBonus[wordGameState.currentDifficulty];
    
    // Time bonus
    if (timeRemaining > 30) {
        baseScore += 30; // Speed bonus
    } else if (timeRemaining > 15) {
        baseScore += 15; // Good time bonus
    }
    
    // Hint penalty already applied when hint used
    
    return baseScore;
}

// Check if word is a valid bonus word
function isValidBonusWord(word) {
    if (word.length < 3) return false;
    
    // Simple check - word uses only available letters
    const availableLetters = currentPrompt.word.split('');
    const wordLetters = word.split('');
    
    const usedLetters = [...availableLetters];
    for (let letter of wordLetters) {
        const index = usedLetters.indexOf(letter);
        if (index === -1) {
            return false;
        }
        usedLetters.splice(index, 1);
    }
    
    // Don't count same word multiple times
    return !wordGameState.bonusWordsFound.includes(word);
}

// Enhanced skip round function
function skipRound() {
    if (confirm('Skip this round? You\'ll lose potential points!')) {
        clearInterval(wordGameState.timerInterval);
        
        addChatMessage('System', `üí° Skipped! The answer was: ${currentPrompt.word}`);
        
        // Opponent gets bonus for skip
        opponentScore += 60;
        
        currentWordRound++;
        if (currentWordRound <= 3) {
            setTimeout(startWordRound, 1000);
        } else {
            endWordGame();
        }
    }
}

// Enhanced word game end with detailed statistics
function endWordGame() {
    clearInterval(wordGameState.timerInterval);
    
    const winner = playerScore > opponentScore ? 'You' : 'Opponent';
    document.getElementById('wordStatus').textContent = 
        `Game Over! ${winner} wins! Final: ${playerScore} - ${opponentScore}`;
    
    // Hide timer
    const timerElement = document.getElementById('wordTimer');
    if (timerElement) timerElement.style.display = 'none';
    
    if (winner === 'You') {
        playerStats.gamesWon++;
        playerStats.words.wins++;
        addChatMessage('System', 'üèÜ You won the Word Battle!');
    } else {
        playerStats.words.losses++;
    }
    
    // Show game statistics
    addChatMessage('System', `üìä Game Stats: ${wordGameState.bonusWordsFound.length} bonus words, ${wordGameState.hintsUsed} hints used`);
    if (wordGameState.bonusWordsFound.length > 0) {
        addChatMessage('System', `üåü Bonus words: ${wordGameState.bonusWordsFound.join(', ')}`);
    }
    
    updateProfileDisplay();
}

// Enhanced word input with Enter key support
document.addEventListener('DOMContentLoaded', () => {
    // Add event listener for word input
    const wordInput = document.getElementById('wordInput');
    if (wordInput) {
        wordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitWord();
            }
        });
    }
});

console.log('‚úÖ Step 3C: Advanced Word Game Features - Added successfully!');
        // Enhanced Player Statistics
let enhancedPlayerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    totalStaked: 0,
    longestWinStreak: 0,
    currentWinStreak: 0,
    favoriteGame: 'chess',
    playtime: 0, // in minutes
    achievements: [],
    chess: { 
        wins: 0, 
        losses: 0, 
        draws: 0,
        checkmates: 0,
        castles: 0,
        promotions: 0
    },
    checkers: { 
        wins: 0, 
        losses: 0,
        multiJumps: 0,
        kingsCreated: 0,
        totalCaptures: 0
    },
    words: { 
        wins: 0, 
        losses: 0,
        bonusWords: 0,
        hintsUsed: 0,
        averageTime: 0
    },
    sessionStart: Date.now()
};

// Achievement System
const achievements = [
    {
        id: 'first_win',
        name: 'First Victory',
        description: 'Win your first game',
        icon: 'üèÜ',
        requirement: (stats) => stats.gamesWon >= 1
    },
    {
        id: 'chess_master',
        name: 'Chess Master',
        description: 'Win 10 chess games',
        icon: '‚ôüÔ∏è',
        requirement: (stats) => stats.chess.wins >= 10
    },
    {
        id: 'checkers_king',
        name: 'Checkers King',
        description: 'Create 5 king pieces',
        icon: 'üëë',
        requirement: (stats) => stats.checkers.kingsCreated >= 5
    },
    {
        id: 'word_wizard',
        name: 'Word Wizard',
        description: 'Find 20 bonus words',
        icon: 'üìù',
        requirement: (stats) => stats.words.bonusWords >= 20
    },
    {
        id: 'win_streak',
        name: 'On Fire',
        description: 'Win 5 games in a row',
        icon: 'üî•',
        requirement: (stats) => stats.longestWinStreak >= 5
    },
    {
        id: 'high_roller',
        name: 'High Roller',
        description: 'Stake over 10 CORE total',
        icon: 'üíé',
        requirement: (stats) => stats.totalStaked >= 10
    },
    {
        id: 'speed_demon',
        name: 'Speed Demon',
        description: 'Average word game time under 30 seconds',
        icon: '‚ö°',
        requirement: (stats) => stats.words.averageTime > 0 && stats.words.averageTime < 30
    }
];

// Enhanced Profile Display
function updateProfileDisplay() {
    // Update basic stats
    document.getElementById('profileGamesPlayed').textContent = enhancedPlayerStats.gamesPlayed;
    document.getElementById('profileGamesWon').textContent = enhancedPlayerStats.gamesWon;
    document.getElementById('profileTotalEarned').textContent = enhancedPlayerStats.totalEarned.toFixed(4) + ' CORE';
    
    const winRate = enhancedPlayerStats.gamesPlayed > 0 ?
        ((enhancedPlayerStats.gamesWon / enhancedPlayerStats.gamesPlayed) * 100).toFixed(1) : 0;
    document.getElementById('profileWinRate').textContent = winRate + '%';
    
    // Update game-specific stats
    document.getElementById('chessStats').textContent =
        `${enhancedPlayerStats.chess.wins}W / ${enhancedPlayerStats.chess.losses}L / ${enhancedPlayerStats.chess.draws}D`;
    document.getElementById('checkersStats').textContent =
        `${enhancedPlayerStats.checkers.wins}W / ${enhancedPlayerStats.checkers.losses}L`;
    document.getElementById('wordStats').textContent =
        `${enhancedPlayerStats.words.wins}W / ${enhancedPlayerStats.words.losses}L`;
    
    // Add advanced stats section if not exists
    addAdvancedStatsSection();
    
    // Update achievements
    updateAchievements();
}

// Add advanced statistics section
function addAdvancedStatsSection() {
    const profileSection = document.getElementById('profileSection');
    let advancedSection = document.getElementById('advancedStats');
    
    if (!advancedSection) {
        advancedSection = document.createElement('div');
        advancedSection.id = 'advancedStats';
        advancedSection.innerHTML = `
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 1.5rem; margin-top: 2rem;">
                <h4 style="color: #4ecdc4; margin-bottom: 1rem;">üìä Advanced Statistics</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1.5rem;">üéØ</div>
                        <div><strong>Win Streak</strong></div>
                        <div style="font-size: 1.2rem; color: #4ecdc4;" id="winStreakDisplay">0</div>
                        <div style="font-size: 0.8rem; color: #aaa;">Best: <span id="bestStreakDisplay">0</span></div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1.5rem;">üí∞</div>
                        <div><strong>Total Staked</strong></div>
                        <div style="font-size: 1.2rem; color: #ffd700;" id="totalStakedDisplay">0 CORE</div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1.5rem;">‚è±Ô∏è</div>
                        <div><strong>Playtime</strong></div>
                        <div style="font-size: 1.2rem; color: #ff6b6b;" id="playtimeDisplay">0 min</div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1.5rem;">üéÆ</div>
                        <div><strong>Favorite Game</strong></div>
                        <div style="font-size: 1.2rem; color: #4ecdc4;" id="favoriteGameDisplay">Chess</div>
                    </div>
                </div>
                
                <h4 style="color: #4ecdc4; margin: 2rem 0 1rem 0;">üèÜ Achievements</h4>
                <div id="achievementsDisplay" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    <!-- Achievements will be populated here -->
                </div>
            </div>
        `;
        
        profileSection.appendChild(advancedSection);
    }
    
    // Update advanced stats values
    document.getElementById('winStreakDisplay').textContent = enhancedPlayerStats.currentWinStreak;
    document.getElementById('bestStreakDisplay').textContent = enhancedPlayerStats.longestWinStreak;
    document.getElementById('totalStakedDisplay').textContent = enhancedPlayerStats.totalStaked.toFixed(2) + ' CORE';
    
    const playtimeMinutes = Math.floor((Date.now() - enhancedPlayerStats.sessionStart) / 60000);
    document.getElementById('playtimeDisplay').textContent = playtimeMinutes + ' min';
    
    // Determine favorite game
    const gameWins = {
        chess: enhancedPlayerStats.chess.wins,
        checkers: enhancedPlayerStats.checkers.wins,
        words: enhancedPlayerStats.words.wins
    };
    const favoriteGame = Object.keys(gameWins).reduce((a, b) => gameWins[a] > gameWins[b] ? a : b);
    document.getElementById('favoriteGameDisplay').textContent = 
        favoriteGame.charAt(0).toUpperCase() + favoriteGame.slice(1);
}

// Achievement System
function checkAchievements() {
    achievements.forEach(achievement => {
        if (!enhancedPlayerStats.achievements.includes(achievement.id)) {
            if (achievement.requirement(enhancedPlayerStats)) {
                unlockAchievement(achievement);
            }
        }
    });
}

function unlockAchievement(achievement) {
    enhancedPlayerStats.achievements.push(achievement.id);
    
    // Show achievement notification
    showAchievementNotification(achievement);
    
    // Add to chat
    addChatMessage('System', `üèÜ Achievement Unlocked: ${achievement.name}!`);
    
    // Update display
    updateAchievements();
}

function showAchievementNotification(achievement) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 150px;
        right: 20px;
        background: linear-gradient(45deg, #4ecdc4, #44a08d);
        color: white;
        padding: 1rem;
        border-radius: 10px;
        max-width: 300px;
        z-index: 10000;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        transform: translateX(100%);
        transition: transform 0.3s ease;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">
            ${achievement.icon} Achievement Unlocked!
        </div>
        <div style="font-weight: bold;">${achievement.name}</div>
        <div style="font-size: 0.9rem; opacity: 0.9;">${achievement.description}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 100);
    
    // Animate out after 4 seconds
    setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 4000);
}

function updateAchievements() {
    const achievementsDisplay = document.getElementById('achievementsDisplay');
    if (!achievementsDisplay) return;
    
    achievementsDisplay.innerHTML = '';
    
    achievements.forEach(achievement => {
        const isUnlocked = enhancedPlayerStats.achievements.includes(achievement.id);
        const achievementDiv = document.createElement('div');
        
        achievementDiv.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 2px solid ${isUnlocked ? '#4ecdc4' : 'rgba(255, 255, 255, 0.1)'};
            opacity: ${isUnlocked ? '1' : '0.6'};
            transition: all 0.3s ease;
        `;
        
        achievementDiv.innerHTML = `
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">${achievement.icon}</div>
            <div style="font-weight: bold; color: ${isUnlocked ? '#4ecdc4' : '#aaa'};">${achievement.name}</div>
            <div style="font-size: 0.9rem; color: #aaa; margin-top: 0.3rem;">${achievement.description}</div>
            ${isUnlocked ? '<div style="color: #00ff88; font-size: 0.8rem; margin-top: 0.5rem;">‚úÖ Unlocked!</div>' : ''}
        `;
        
        if (isUnlocked) {
            achievementDiv.addEventListener('mouseenter', () => {
                achievementDiv.style.transform = 'scale(1.05)';
                achievementDiv.style.boxShadow = '0 10px 20px rgba(78, 205, 196, 0.3)';
            });
            
            achievementDiv.addEventListener('mouseleave', () => {
                achievementDiv.style.transform = 'scale(1)';
                achievementDiv.style.boxShadow = 'none';
            });
        }
        
        achievementsDisplay.appendChild(achievementDiv);
    });
}

// Update stats when games are won/lost
function updateGameStats(gameType, result, extraData = {}) {
    enhancedPlayerStats.gamesPlayed++;
    
    if (result === 'win') {
        enhancedPlayerStats.gamesWon++;
        enhancedPlayerStats.currentWinStreak++;
        enhancedPlayerStats.longestWinStreak = Math.max(
            enhancedPlayerStats.longestWinStreak, 
            enhancedPlayerStats.currentWinStreak
        );
        enhancedPlayerStats[gameType].wins++;
    } else {
        enhancedPlayerStats.currentWinStreak = 0;
        enhancedPlayerStats[gameType].losses++;
    }
    
    // Game-specific stats
    if (gameType === 'chess') {
        if (extraData.checkmate) enhancedPlayerStats.chess.checkmates++;
        if (extraData.castle) enhancedPlayerStats.chess.castles++;
        if (extraData.promotion) enhancedPlayerStats.chess.promotions++;
        if (result === 'draw') enhancedPlayerStats.chess.draws++;
    } else if (gameType === 'checkers') {
        if (extraData.multiJumps) enhancedPlayerStats.checkers.multiJumps += extraData.multiJumps;
        if (extraData.kingsCreated) enhancedPlayerStats.checkers.kingsCreated += extraData.kingsCreated;
        if (extraData.captures) enhancedPlayerStats.checkers.totalCaptures += extraData.captures;
    } else if (gameType === 'words') {
        if (extraData.bonusWords) enhancedPlayerStats.words.bonusWords += extraData.bonusWords;
        if (extraData.hintsUsed) enhancedPlayerStats.words.hintsUsed += extraData.hintsUsed;
        if (extraData.timeUsed) {
            const currentAvg = enhancedPlayerStats.words.averageTime;
            const gamesPlayed = enhancedPlayerStats.words.wins + enhancedPlayerStats.words.losses;
            enhancedPlayerStats.words.averageTime = 
                ((currentAvg * (gamesPlayed - 1)) + extraData.timeUsed) / gamesPlayed;
        }
    }
    
    // Check for new achievements
    checkAchievements();
    
    // Update profile display
    updateProfileDisplay();
}

// Track staking
function trackStake(amount) {
    enhancedPlayerStats.totalStaked += amount;
    checkAchievements();
}

// Sync old playerStats with new enhancedPlayerStats
function syncPlayerStats() {
    enhancedPlayerStats.gamesPlayed = playerStats.gamesPlayed || 0;
    enhancedPlayerStats.gamesWon = playerStats.gamesWon || 0;
    enhancedPlayerStats.totalEarned = playerStats.totalEarned || 0;
    enhancedPlayerStats.chess.wins = playerStats.chess?.wins || 0;
    enhancedPlayerStats.chess.losses = playerStats.chess?.losses || 0;
    enhancedPlayerStats.checkers.wins = playerStats.checkers?.wins || 0;
    enhancedPlayerStats.checkers.losses = playerStats.checkers?.losses || 0;
    enhancedPlayerStats.words.wins = playerStats.words?.wins || 0;
    enhancedPlayerStats.words.losses = playerStats.words?.losses || 0;
}

// Initialize enhanced stats
syncPlayerStats();

console.log('‚úÖ Step 4A: Advanced Statistics & Profile - Added successfully!');
        // Enhanced Chat System
let chatFeatures = {
    messageHistory: [],
    userColors: {},
    bannedWords: ['spam', 'scam', 'cheat'],
    chatFilters: {
        showGameMessages: true,
        showSystemMessages: true,
        showUserMessages: true
    },
    emojis: ['üòÄ', 'üòé', 'üéÆ', 'üèÜ', 'üí∞', 'üî•', '‚ö°', 'üëë', 'üéØ', 'üíé']
};

// Enhanced add chat message with features
function addChatMessage(user, message, type = 'user') {
    const chatMessages = document.getElementById('chatMessages');
    if (!chatMessages) return;
    
    // Filter check
    if (!shouldShowMessage(type)) return;
    
    // Get user color
    const userColor = getUserColor(user);
    
    // Create message object
    const messageObj = {
        user,
        message,
        type,
        timestamp: new Date(),
        id: Date.now() + Math.random()
    };
    
    // Add to history
    chatFeatures.messageHistory.push(messageObj);
    
    // Create message element
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${type}-message`;
    messageDiv.dataset.messageId = messageObj.id;
    
    messageDiv.style.cssText = `
        margin-bottom: 0.8rem; 
        padding: 0.5rem; 
        border-radius: 8px; 
        background: rgba(255, 255, 255, 0.05);
        border-left: 3px solid ${userColor};
        position: relative;
        animation: slideInMessage 0.3s ease;
    `;
    
    // Format timestamp
    const timeStr = messageObj.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    
    // Process message for emojis and mentions
    const processedMessage = processMessage(message);
    
    messageDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start;">
            <div style="flex: 1;">
                <strong style="color: ${userColor};">${user}:</strong> 
                <span>${processedMessage}</span>
            </div>
            <span style="font-size: 0.7rem; color: #aaa; margin-left: 1rem;">${timeStr}</span>
        </div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Limit message history
    while (chatMessages.children.length > 100) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

// Check if message should be shown based on filters
function shouldShowMessage(type) {
    switch(type) {
        case 'system': return chatFeatures.chatFilters.showSystemMessages;
        case 'game': return chatFeatures.chatFilters.showGameMessages;
        case 'user': return chatFeatures.chatFilters.showUserMessages;
        default: return true;
    }
}

// Get consistent color for user
function getUserColor(user) {
    if (!chatFeatures.userColors[user]) {
        const colors = ['#4ecdc4', '#ff6b6b', '#ffd700', '#00ff88', '#ff8c42', '#c44569', '#6c5ce7', '#a55eea'];
        const colorIndex = Object.keys(chatFeatures.userColors).length % colors.length;
        chatFeatures.userColors[user] = colors[colorIndex];
    }
    return chatFeatures.userColors[user];
}

// Process message for emojis and special formatting
function processMessage(message) {
    let processed = message;
    
    // Convert :emoji: to actual emojis
    const emojiMap = {
        ':smile:': 'üòÄ', ':cool:': 'üòé', ':game:': 'üéÆ', ':trophy:': 'üèÜ',
        ':money:': 'üí∞', ':fire:': 'üî•', ':lightning:': '‚ö°', ':crown:': 'üëë',
        ':target:': 'üéØ', ':diamond:': 'üíé'
    };
    
    Object.keys(emojiMap).forEach(key => {
        processed = processed.replace(new RegExp(key, 'g'), emojiMap[key]);
    });
    
    // Highlight game terms
    const gameTerms = ['chess', 'checkers', 'word', 'CORE', 'bitcoin', 'crypto'];
    gameTerms.forEach(term => {
        const regex = new RegExp(`\\b${term}\\b`, 'gi');
        processed = processed.replace(regex, `<span style="color: #4ecdc4; font-weight: bold;">${term}</span>`);
    });
    
    return processed;
}

console.log('‚úÖ Step 4B Part 1: Enhanced Chat System - Added successfully!');
        // Enhanced send chat message with validation
function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    if (!userAddress) {
        alert('Please connect your wallet to chat!');
        return;
    }
    
    // Check for banned words
    const containsBannedWord = chatFeatures.bannedWords.some(word => 
        message.toLowerCase().includes(word.toLowerCase())
    );
    
    if (containsBannedWord) {
        alert('Message contains inappropriate content!');
        return;
    }
    
    // Check message length
    if (message.length > 200) {
        alert('Message too long! Maximum 200 characters.');
        return;
    }
    
    addChatMessage('You', message, 'user');
    chatInput.value = '';
    
    // Simulate responses with enhanced AI
    setTimeout(() => {
        generateSmartResponse(message);
    }, 1000 + Math.random() * 2000);
}

// Generate smart response based on message content
function generateSmartResponse(userMessage) {
    const responses = {
        greeting: [
            "Hey there! Ready for some epic games? üéÆ",
            "Welcome to Crypticus! Let's play! üöÄ",
            "Hello! Good luck in your games! üèÜ"
        ],
        chess: [
            "Chess is the ultimate strategy game! ‚ôüÔ∏è",
            "Love a good chess match! Good luck! üëë",
            "Chess masters unite! May the best player win! ‚öîÔ∏è"
        ],
        checkers: [
            "Checkers is so underrated! Great choice! ‚ö´",
            "Jump those pieces! Checkers is intense! üéØ",
            "King me! Checkers for the win! üëë"
        ],
        words: [
            "Word games are brain training! üß†",
            "Vocabulary battles are the best! üìù",
            "Words are my weapon of choice! ‚ö°"
        ],
        crypto: [
            "CORE blockchain is amazing! üíé",
            "Crypto gaming is the future! üöÄ",
            "HODL and play! Best combo ever! üí∞"
        ],
        win: [
            "Congrats on the win! üèÜ",
            "Victory tastes sweet! Well played! üéâ",
            "Another one bites the dust! GG! ‚ö°"
        ]
    };
    
    const lowerMessage = userMessage.toLowerCase();
    let responseCategory = 'general';
    
    if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) responseCategory = 'greeting';
    else if (lowerMessage.includes('chess')) responseCategory = 'chess';
    else if (lowerMessage.includes('checkers')) responseCategory = 'checkers';
    else if (lowerMessage.includes('word')) responseCategory = 'words';
    else if (lowerMessage.includes('crypto') || lowerMessage.includes('core') || lowerMessage.includes('bitcoin')) responseCategory = 'crypto';
    else if (lowerMessage.includes('won') || lowerMessage.includes('win')) responseCategory = 'win';
    
    const responseList = responses[responseCategory] || [
        "That's interesting! ü§î",
        "Tell me more! üí≠",
        "Absolutely! üëç",
        "I agree! üéØ",
        "Game on! üéÆ"
    ];
    
    const randomUser = ['CryptoKing', 'GameMaster', 'BlockchainBro', 'TokenMaster', 'WordWizard'][Math.floor(Math.random() * 5)];
    const randomResponse = responseList[Math.floor(Math.random() * responseList.length)];
    
    addChatMessage(randomUser, randomResponse, 'user');
}

// Add chat filters UI
function addChatFilters() {
    const chatSection = document.getElementById('chatSection');
    if (!chatSection || document.getElementById('chatFilters')) return;
    
    const filtersDiv = document.createElement('div');
    filtersDiv.id = 'chatFilters';
    filtersDiv.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 0.8rem;
        margin-bottom: 1rem;
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
        align-items: center;
    `;
    
    filtersDiv.innerHTML = `
        <span style="color: #4ecdc4; font-weight: bold;">Filters:</span>
        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
            <input type="checkbox" id="showSystem" checked onchange="toggleChatFilter('showSystemMessages')">
            <span>System</span>
        </label>
        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
            <input type="checkbox" id="showGame" checked onchange="toggleChatFilter('showGameMessages')">
            <span>Game</span>
        </label>
        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
            <input type="checkbox" id="showUser" checked onchange="toggleChatFilter('showUserMessages')">
            <span>Users</span>
        </label>
        <button onclick="clearChat()" style="background: #ff6b6b; border: none; padding: 0.3rem 0.8rem; border-radius: 5px; color: white; cursor: pointer; margin-left: auto;">Clear Chat</button>
    `;
    
    // Insert before chat messages
    const chatContainer = chatSection.querySelector('div');
    chatContainer.insertBefore(filtersDiv, chatContainer.children[1]);
}

// Toggle chat filter
function toggleChatFilter(filterName) {
    chatFeatures.chatFilters[filterName] = !chatFeatures.chatFilters[filterName];
    refreshChatDisplay();
}

// Clear chat
function clearChat() {
    if (confirm('Clear all chat messages?')) {
        document.getElementById('chatMessages').innerHTML = '';
        chatFeatures.messageHistory = [];
        addChatMessage('System', 'Chat cleared! üßπ');
    }
}

// Refresh chat display based on filters
function refreshChatDisplay() {
    const chatMessages = document.getElementById('chatMessages');
    chatMessages.innerHTML = '';
    
    chatFeatures.messageHistory.forEach(messageObj => {
        if (shouldShowMessage(messageObj.type)) {
            addChatMessage(messageObj.user, messageObj.message, messageObj.type);
        }
    });
}

// Initialize chat features when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    // Add chat filters
    setTimeout(() => {
        addChatFilters();
    }, 1000);
});

console.log('‚úÖ Step 4B Part 2: Smart Chat Responses - Added successfully!');
        // Chat animations and effects
function addChatAnimations() {
    const style = document.createElement('style');
    style.textContent = `
        @keyframes slideInMessage {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutMessage {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(-20px);
                opacity: 0;
            }
        }
        
        .chat-message:hover {
            background: rgba(255, 255, 255, 0.08) !important;
            transform: translateX(2px);
            transition: all 0.2s ease;
        }
        
        .typing-indicator {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    `;
    document.head.appendChild(style);
}

// Enhanced message notifications
function showNewMessageNotification(user, message) {
    // Only show for other users' messages when not focused on chat
    if (user === 'You' || !document.getElementById('chatSection').classList.contains('hidden')) return;
    
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 200px;
        right: 20px;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #4ecdc4;
        border-radius: 8px;
        padding: 0.8rem;
        max-width: 250px;
        z-index: 9999;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        cursor: pointer;
    `;
    
    const shortMessage = message.length > 50 ? message.substring(0, 50) + '...' : message;
    notification.innerHTML = `
        <div style="font-size: 0.9rem; color: #4ecdc4; margin-bottom: 0.3rem;">üí¨ ${user}</div>
        <div style="font-size: 0.8rem; color: white;">${shortMessage}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 100);
    
    // Click to go to chat
    notification.onclick = () => {
        showSection('chat');
        notification.remove();
    };
    
    // Auto-remove after 4 seconds
    setTimeout(() => {
        if (document.body.contains(notification)) {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    notification.remove();
                }
            }, 300);
        }
    }, 4000);
}

// Typing indicator
let typingTimeout;
function showTypingIndicator() {
    clearTimeout(typingTimeout);
    
    const chatMessages = document.getElementById('chatMessages');
    let typingDiv = document.getElementById('typingIndicator');
    
    if (!typingDiv) {
        typingDiv = document.createElement('div');
        typingDiv.id = 'typingIndicator';
        typingDiv.className = 'typing-indicator';
        typingDiv.style.cssText = `
            padding: 0.5rem;
            color: #aaa;
            font-style: italic;
            font-size: 0.9rem;
        `;
        typingDiv.textContent = 'üí≠ Someone is typing...';
        chatMessages.appendChild(typingDiv);
    }
    
    // Remove after 3 seconds
    typingTimeout = setTimeout(() => {
        if (typingDiv && document.body.contains(typingDiv)) {
            typingDiv.remove();
        }
    }, 3000);
}

// Enhanced chat input with features
function enhanceChatInput() {
    const chatInput = document.getElementById('chatInput');
    if (!chatInput) return;
    
    let lastTypingTime = 0;
    
    // Add typing indicator
    chatInput.addEventListener('input', () => {
        const now = Date.now();
        if (now - lastTypingTime > 2000) {
            showTypingIndicator();
            lastTypingTime = now;
        }
    });
    
    // Add emoji picker button
    const chatContainer = chatInput.parentElement;
    if (!document.getElementById('emojiPicker')) {
        const emojiBtn = document.createElement('button');
        emojiBtn.id = 'emojiPicker';
        emojiBtn.style.cssText = `
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            padding: 0.8rem;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            margin-left: 0.5rem;
        `;
        emojiBtn.textContent = 'üòÄ';
        emojiBtn.onclick = toggleEmojiPicker;
        
        chatContainer.appendChild(emojiBtn);
    }
    
    // Add character counter
    if (!document.getElementById('charCounter')) {
        const counter = document.createElement('div');
        counter.id = 'charCounter';
        counter.style.cssText = `
            font-size: 0.7rem;
            color: #aaa;
            text-align: right;
            margin-top: 0.3rem;
        `;
        counter.textContent = '0/200';
        
        chatInput.addEventListener('input', () => {
            const length = chatInput.value.length;
            counter.textContent = `${length}/200`;
            counter.style.color = length > 180 ? '#ff6b6b' : length > 150 ? '#ffd700' : '#aaa';
        });
        
        chatContainer.appendChild(counter);
    }
}

// Emoji picker
function toggleEmojiPicker() {
    let picker = document.getElementById('emojiPickerPanel');
    
    if (picker) {
        picker.remove();
        return;
    }
    
    picker = document.createElement('div');
    picker.id = 'emojiPickerPanel';
    picker.style.cssText = `
        position: absolute;
        bottom: 100%;
        right: 0;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #4ecdc4;
        border-radius: 8px;
        padding: 1rem;
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 0.5rem;
        z-index: 1000;
    `;
    
    chatFeatures.emojis.forEach(emoji => {
        const emojiBtn = document.createElement('button');
        emojiBtn.style.cssText = `
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
        `;
        emojiBtn.textContent = emoji;
        emojiBtn.onclick = () => {
            const chatInput = document.getElementById('chatInput');
            chatInput.value += emoji;
            chatInput.focus();
            picker.remove();
        };
        
        emojiBtn.addEventListener('mouseenter', () => {
            emojiBtn.style.background = 'rgba(78, 205, 196, 0.3)';
        });
        
        emojiBtn.addEventListener('mouseleave', () => {
            emojiBtn.style.background = 'none';
        });
        
        picker.appendChild(emojiBtn);
    });
    
    document.getElementById('emojiPicker').parentElement.style.position = 'relative';
    document.getElementById('emojiPicker').parentElement.appendChild(picker);
    
    // Close picker when clicking outside
    setTimeout(() => {
        document.addEventListener('click', function closePicker(e) {
            if (!picker.contains(e.target) && e.target.id !== 'emojiPicker') {
                picker.remove();
                document.removeEventListener('click', closePicker);
            }
        });
    }, 100);
}

// Chat commands
function processChatCommand(message) {
    if (!message.startsWith('/')) return false;
    
    const [command, ...args] = message.slice(1).split(' ');
    
    switch(command.toLowerCase()) {
        case 'clear':
            clearChat();
            break;
        case 'stats':
            showChatStats();
            break;
        case 'help':
            showChatHelp();
            break;
        case 'emoji':
            showEmojiList();
            break;
        case 'time':
            addChatMessage('System', `‚è∞ Current time: ${new Date().toLocaleTimeString()}`);
            break;
        default:
            addChatMessage('System', `‚ùå Unknown command: /${command}. Type /help for available commands.`);
    }
    
    return true;
}

// Show chat statistics
function showChatStats() {
    const totalMessages = chatFeatures.messageHistory.length;
    const userMessages = chatFeatures.messageHistory.filter(m => m.type === 'user').length;
    const systemMessages = chatFeatures.messageHistory.filter(m => m.type === 'system').length;
    
    addChatMessage('System', `üìä Chat Stats: ${totalMessages} total messages (${userMessages} user, ${systemMessages} system)`);
}

// Show chat help
function showChatHelp() {
    addChatMessage('System', `üí° Chat Commands:
/clear - Clear chat
/stats - Show chat statistics  
/help - Show this help
/emoji - Show emoji codes
/time - Show current time

Emoji codes: :smile: :game: :trophy: :money: :fire: :lightning: :crown: :target: :diamond:`);
}

// Show emoji list
function showEmojiList() {
    addChatMessage('System', `üòÄ Available emojis: ${chatFeatures.emojis.join(' ')}`);
}

// Override send message to handle commands
const originalSendChatMessage = sendChatMessage;
sendChatMessage = function() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    // Check for commands
    if (processChatCommand(message)) {
        chatInput.value = '';
        return;
    }
    
    // Call original function
    originalSendChatMessage();
};

// Initialize all chat enhancements
function initializeChatEnhancements() {
    addChatAnimations();
    enhanceChatInput();
    
    // Override addChatMessage to include notifications
    const originalAddChatMessage = addChatMessage;
    addChatMessage = function(user, message, type = 'user') {
        originalAddChatMessage(user, message, type);
        if (user !== 'You') {
            showNewMessageNotification(user, message);
        }
    };
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeChatEnhancements);
} else {
    initializeChatEnhancements();
}

console.log('‚úÖ Step 4B Part 3: Final Chat Features - Added successfully!');
        
        // Initialize everything when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Crypticus blockchain gaming platform loaded!');
    
    // Initialize age verification
    checkAgeVerification();
    
    // Initialize wallet connection
    initializeWalletConnection();
    
    // Update game feed every 20 seconds
    updateGameFeed();
    setInterval(updateGameFeed, 20000);
    
    // Add chat messages every 25 seconds
    setInterval(addRandomChatMessage, 25000);
    
    // Close mobile menu when clicking outside
    document.addEventListener('click', (e) => {
        const navMenu = document.getElementById('navMenu');
        const mobileBtn = document.querySelector('.mobile-menu-btn');
        
        if (navMenu && mobileBtn && !navMenu.contains(e.target) && !mobileBtn.contains(e.target)) {
            navMenu.classList.remove('active');
        }
    });
    
    // Auto-hide transaction status on click
    const transactionStatus = document.getElementById('transactionStatus');
    if (transactionStatus) {
        transactionStatus.addEventListener('click', () => {
            transactionStatus.classList.remove('show');
        });
    }
    
    // Initialize profile display
    updateProfileDisplay();
    
    console.log('‚úÖ All systems initialized successfully!');
});

// Add Word input Enter key support
document.addEventListener('DOMContentLoaded', () => {
    const wordInput = document.getElementById('wordInput');
    if (wordInput) {
        wordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitWord();
            }
        });
    }
});

// Prevent conflicts - this should be the last thing in your script
console.log('üéÆ Crypticus ready for blockchain gaming!');
	

    </script>
</body>
</html>
