<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypticus - Live Blockchain Gaming Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #4e54c8;
            --primary-dark: #363a9e;
            --secondary: #f39c12;
            --dark: #1a1c2c;
            --light: #f5f7fa;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f1c40f;
            --gray: #95a5a6;
            --accent: #4ecdc4;
        }

        html, body {
            height: 100%;
            overflow-x: hidden;
        }

        body {
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            color: var(--light);
            position: relative;
        }

        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://images.unsplash.com/photo-1620336655052-b57986f5a26a?q=80&w=1920') no-repeat center center;
            background-size: cover;
            opacity: 0.1;
            z-index: -1;
        }

        /* Header Styles */
        .header {
            position: relative;
            z-index: 100;
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-height: 80px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.8rem;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .logo-icon {
            font-size: 2.5rem;
            color: var(--secondary);
        }

        .nav-menu {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-item {
            padding: 0.5rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(78, 205, 196, 0.5);
        }

        .nav-item.active {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .live-badge {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .wallet-info {
            text-align: right;
        }

        .connection-status {
            font-size: 0.9rem;
            color: #ff6b6b;
        }

        .balance {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .connect-btn, .disconnect-btn {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .disconnect-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            margin-left: 0.5rem;
        }

        .connect-btn:hover, .disconnect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
        }

        .hidden {
            display: none;
        }

        /* Connection Status Indicators */
        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .connected {
            background: #00ff88;
            animation: pulse 2s infinite;
        }

        .disconnected {
            background: #ff6b6b;
        }

        .pending {
            background: #f1c40f;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<style>
        /* Main Layout */
        .main-container {
            display: flex;
            min-height: calc(100vh - 80px);
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        /* Enhanced Game Lobby Styles */
        .live-lobby {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .lobby-stats {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }

        /* Game Entry Styles */
        .game-entry {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1));
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .game-entry::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .game-entry:hover::before {
            left: 100%;
        }

        .game-entry:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .game-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent);
        }

        .game-status {
            padding: 0.2rem 0.8rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-waiting {
            background: linear-gradient(45deg, #f1c40f, #f39c12);
            color: #000;
        }

        .status-playing {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .game-details {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .detail-item {
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .detail-label {
            color: #aaa;
            font-size: 0.8rem;
        }

        .detail-value {
            font-weight: bold;
            margin-top: 0.2rem;
        }

        .join-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border: none;
            padding: 0.8rem;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .join-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 255, 136, 0.3);
        }

        .join-btn:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Smart Contract Status */
        .contract-status {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .contract-address {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            border-radius: 5px;
            margin: 0.5rem 0;
            word-break: break-all;
        }

        /* Transaction Status */
        .transaction-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--accent);
            border-radius: 10px;
            padding: 1rem;
            max-width: 350px;
            z-index: 2000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            word-wrap: break-word;
        }

        .transaction-status.show {
            transform: translateX(0);
        }

        .tx-hash {
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            color: var(--accent);
            margin-top: 0.5rem;
            cursor: pointer;
        }

        /* Game Creation Styles */
        .create-game-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .game-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .game-type-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-type-card:hover, .game-type-card.selected {
            border-color: var(--accent);
            background: rgba(78, 205, 196, 0.1);
            transform: translateY(-3px);
        }

        .game-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .stake-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
            color: white;
            font-size: 1.1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .stake-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .create-btn {
            width: 100%;
            background: linear-gradient(45deg, #ff6b6b, var(--accent));
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .create-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(255, 107, 107, 0.3);
        }

        .create-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ff88);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Copy Button */
        .copy-btn {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 0.3rem 0.6rem;
            color: var(--accent);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            margin-left: 0.5rem;
        }

        .copy-btn:hover {
            background: rgba(78, 205, 196, 0.3);
        }
    </style>
    <style>
        /* Age Verification Modal */
        .age-verification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
        }

        .verification-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            position: relative;
            z-index: 10000;
        }

        .verification-content h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: var(--secondary);
        }

        .verification-content p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: var(--light);
        }

        .verification-content .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid var(--danger);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            text-align: left;
        }

        .verification-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .verify-btn {
            padding: 1rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-width: 120px;
        }

        .verify-btn.accept {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            color: white;
        }

        .verify-btn.decline {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .verify-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Game Window Styles */
        .game-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 1.5rem;
            z-index: 1000;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            min-width: 600px;
        }

        .game-window.minimized {
            top: auto;
            bottom: 20px;
            right: 20px;
            left: auto;
            transform: none;
            width: 300px;
            height: 60px;
            overflow: hidden;
            cursor: pointer;
        }

        .game-window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-window-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .game-window-controls {
            display: flex;
            gap: 0.5rem;
        }

        .window-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .window-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .minimize-btn {
            background: rgba(255, 193, 7, 0.3);
        }

        .close-btn {
            background: rgba(220, 53, 69, 0.3);
        }

        .game-window-content {
            display: block;
        }

        .game-window.minimized .game-window-content {
            display: none;
        }

        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
        }

        /* Chess & Checkers Board Styles */
        .chess-board, .checkers-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 3px solid var(--accent);
            border-radius: 10px;
            margin: 1rem auto;
            background: #f4f4f4;
        }

        .chess-square, .checkers-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .chess-square.white, .checkers-square.light {
            background: #f0d9b5;
        }

        .chess-square.black, .checkers-square.dark {
            background: #b58863;
        }

        .chess-square.selected {
            background: #ff6b6b !important;
            box-shadow: inset 0 0 10px rgba(255, 107, 107, 0.5);
        }

        .chess-square.possible-move {
            background: rgba(78, 205, 196, 0.3) !important;
        }

        .chess-square.possible-move::after {
            content: '‚óè';
            color: var(--accent);
            position: absolute;
            font-size: 1rem;
        }

        .checker-piece {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 2px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .red-piece {
            background: radial-gradient(circle, #ff4444, #cc0000);
        }

        .black-piece {
            background: radial-gradient(circle, #444444, #000000);
        }

        .checker-piece.king::after {
            content: '‚ôî';
            position: absolute;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Game Status & Controls */
        .game-status {
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .game-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .game-btn {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .game-over-message {
            color: #00ff88;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        /* In-Game Chat */
        .game-chat {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            max-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .game-chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 0.5rem;
            max-height: 120px;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.5rem;
            border-radius: 5px;
        }

        .game-chat-message {
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
        }

        .game-chat-input {
            display: flex;
            gap: 0.5rem;
        }

        .game-chat-input input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 0.5rem;
            color: white;
        }

        .game-chat-input button {
            background: linear-gradient(45deg, var(--accent), #44a08d);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }

        /* Word Game Styles */
        .word-game {
            text-align: center;
            padding: 1rem;
        }

        .word-input {
            width: 100%;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            color: white;
            font-size: 1.2rem;
            text-align: center;
            margin: 1rem 0;
        }

        .word-score {
            display: flex;
            justify-content: space-around;
            margin: 1rem 0;
            font-size: 1.1rem;
        }
    </style>
    <style>
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                order: 2;
                padding: 1rem;
                max-height: none;
            }

            .content-area {
                order: 1;
                padding: 1rem;
                max-height: none;
            }

            .lobby-stats {
                flex-direction: column;
                gap: 1rem;
            }

            .game-details {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }

            .verification-content {
                margin: 1rem;
                padding: 2rem 1rem;
            }

            .verification-content h1 {
                font-size: 1.8rem;
            }

            .verification-content p {
                font-size: 1rem;
            }

            .verify-btn {
                min-width: 100px;
                padding: 0.8rem 1.5rem;
            }

            .transaction-status {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .nav-menu {
                gap: 1rem;
                flex-wrap: wrap;
            }

            .nav-item {
                padding: 0.3rem 0.8rem;
                font-size: 0.9rem;
            }

            .wallet-section {
                flex-direction: column;
                gap: 0.5rem;
            }

            .game-type-selector {
                grid-template-columns: 1fr;
            }

            .game-window {
                min-width: 95vw;
                max-width: 95vw;
                padding: 1rem;
            }

            .chess-board, .checkers-board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }

            .chess-square, .checkers-square {
                font-size: 1.5rem;
            }

            .checker-piece {
                width: 35px;
                height: 35px;
            }
        }

        /* Additional Utility Classes */
        .pulse {
            animation: pulse 2s infinite;
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .fade-in {
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .glow {
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
    </style>
</head>
<body>
    <div class="background"></div>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <i class="fas fa-dice-d20 logo-icon"></i>
            <h1>CRYPTICUS</h1>
        </div>
        <div class="nav-menu" id="navMenu">
            <div class="nav-item active" onclick="showSection('lobby')">üéØ Game Lobby</div>
            <div class="nav-item" onclick="showSection('create')">üéÆ Create Game</div>
            <div class="nav-item" onclick="showSection('games')">‚ôüÔ∏è Games</div>
            <div class="nav-item" onclick="showSection('profile')">üë§ Profile</div>
            <div class="nav-item" onclick="showSection('chat')">üí¨ Chat</div>
        </div>
        <div class="live-badge">üî¥ LIVE ON CORE</div>
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">
                    <span class="connection-indicator disconnected"></span>Not Connected
                </div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn">
                <i class="fas fa-plug"></i> Connect Wallet
            </button>
            <button class="disconnect-btn hidden" id="disconnectBtn">Disconnect</button>
        </div>
    </div>

    <!-- Age Verification Modal -->
    <div class="age-verification" id="ageVerificationModal">
        <div class="verification-content">
            <h1><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h1>
            <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
            <div class="warning">
                <p><i class="fas fa-exclamation-circle"></i> Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
            </div>
            <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            <div class="verification-buttons">
                <button class="verify-btn accept" onclick="verifyAge(true)">I am 18+</button>
                <button class="verify-btn decline" onclick="verifyAge(false)">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
    </div>

    <!-- Game Overlay -->
    <div class="game-overlay hidden" id="gameOverlay"></div>
    <!-- Chess Game Window -->
    <div class="game-window hidden" id="chessGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">‚ôüÔ∏è Chess Masters</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('chess')">‚àí</button>
                <button class="window-btn close-btn" onclick="closeGame('chess')">√ó</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="chessStatus">Waiting for opponent...</div>
            <div class="chess-board" id="chessBoard"></div>
            <div class="game-controls">
                <button class="game-btn" onclick="resignChess()">Resign</button>
                <button class="game-btn" onclick="drawChess()">Offer Draw</button>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">Game Chat</h4>
                <div class="game-chat-messages" id="chessGameChat">
                    <div class="game-chat-message"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="chessChatInput" onkeypress="handleGameChatKeyPress(event, 'chess')">
                    <button onclick="sendGameChatMessage('chess')">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Checkers Game Window -->
    <div class="game-window hidden" id="checkersGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">‚ö´ Checkers Pro</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('checkers')">‚àí</button>
                <button class="window-btn close-btn" onclick="closeGame('checkers')">√ó</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
            <div class="checkers-board" id="checkersBoard"></div>
            <div class="game-controls">
                <button class="game-btn" onclick="resignCheckers()">Resign</button>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">Game Chat</h4>
                <div class="game-chat-messages" id="checkersGameChat">
                    <div class="game-chat-message"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="checkersChatInput" onkeypress="handleGameChatKeyPress(event, 'checkers')">
                    <button onclick="sendGameChatMessage('checkers')">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Word Game Window -->
    <div class="game-window hidden" id="wordGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">üìù Word Battle</div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('word')">‚àí</button>
                <button class="window-btn close-btn" onclick="closeGame('word')">√ó</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-status" id="wordStatus">Round 1 of 3</div>
            <div class="word-game">
                <h4 id="wordPrompt">Make a word with these letters:</h4>
                <div id="wordLetters" style="font-size: 2rem; color: #4ecdc4; margin: 1rem 0;">BLOCKCHAIN</div>
                <input type="text" class="word-input" id="wordInput" placeholder="Enter your word..." maxlength="20">
                <div class="word-score">
                    <div>Your Score: <span id="playerScore">0</span></div>
                    <div>Opponent: <span id="opponentScore">0</span></div>
                </div>
                <div class="game-controls">
                    <button class="game-btn" onclick="submitWord()">Submit Word</button>
                    <button class="game-btn" onclick="skipRound()">Skip Round</button>
                </div>
            </div>
            <div class="game-chat">
                <h4 style="margin-bottom: 0.5rem; color: #4ecdc4;">Game Chat</h4>
                <div class="game-chat-messages" id="wordGameChat">
                    <div class="game-chat-message"><strong>System:</strong> Game started!</div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="wordChatInput" onkeypress="handleGameChatKeyPress(event, 'word')">
                    <button onclick="sendGameChatMessage('word')">Send</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Smart Contract Status -->
            <div class="contract-status">
                <h3>üîê Smart Contract Status</h3>
                <div class="contract-address" id="contractAddress">
                    0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A
                    <button class="copy-btn" onclick="copyContractAddress()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <div id="contractStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to Core Blockchain...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="connectionProgress" style="width: 0%"></div>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="live-lobby">
                <h3>üìä Live Platform Stats</h3>
                <div class="lobby-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Online Players</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalGames">0</div>
                        <div class="stat-label">Active Games</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalVolume">0</div>
                        <div class="stat-label">CORE Volume</div>
                    </div>
                </div>
            </div>

            <!-- Recent Activity Feed -->
            <div class="live-lobby">
                <h3>üî• Recent Activity</h3>
                <div id="activityFeed">
                    <!-- Activity items will be populated here -->
                </div>
            </div>
        </div>
        <!-- Content Area -->
        <div class="content-area">
            <!-- Game Lobby Section -->
            <div id="lobbySection">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2>üéØ Live Game Lobby</h2>
                        <button onclick="refreshLobby()" class="game-btn" style="width: auto; padding: 0.5rem 1rem;">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                    
                    <div id="gamesList">
                        <!-- Games will be populated here -->
                    </div>
                    
                    <div id="noGames" class="hidden" style="text-align: center; padding: 3rem; color: #aaa;">
                        <i class="fas fa-gamepad" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3>No Active Games</h3>
                        <p>Be the first to create a game and start earning CORE!</p>
                        <button onclick="showSection('create')" class="game-btn" style="margin-top: 1rem;">
                            Create First Game
                        </button>
                    </div>
                </div>
            </div>

            <!-- Create Game Section -->
            <div id="createSection" class="hidden">
                <div class="create-game-section">
                    <h2>üéÆ Create New Game</h2>
                    
                    <div class="game-type-selector">
                        <div class="game-type-card" data-type="chess" onclick="selectGameType('chess')">
                            <div class="game-icon">‚ôüÔ∏è</div>
                            <h3>Chess Masters</h3>
                            <p>Strategic blockchain chess</p>
                            <small>5-30 minutes per game</small>
                        </div>
                        <div class="game-type-card" data-type="checkers" onclick="selectGameType('checkers')">
                            <div class="game-icon">‚ö´</div>
                            <h3>Checkers Pro</h3>
                            <p>Fast-paced checkers</p>
                            <small>3-15 minutes per game</small>
                        </div>
                        <div class="game-type-card" data-type="words" onclick="selectGameType('words')">
                            <div class="game-icon">üìù</div>
                            <h3>Word Battle</h3>
                            <p>Quick word game</p>
                            <small>1-3 minutes per round</small>
                        </div>
                    </div>
                    
                    <div style="margin: 2rem 0;">
                        <label for="gameStake" style="display: block; margin-bottom: 0.5rem; color: #4ecdc4; font-weight: bold;">
                            Stake Amount (CORE)
                        </label>
                        <input type="number" class="stake-input" id="gameStake" 
                               placeholder="Enter stake amount (min 0.01 CORE)" 
                               min="0.01" step="0.01" 
                               oninput="updateCreateButton()">
                        <small style="color: #aaa; display: block; margin-top: 0.5rem;">
                            Winner takes 97% of total pool (3% platform fee)
                        </small>
                    </div>
                    
                    <button class="create-btn" id="createGameBtn" onclick="createGame()" disabled>
                        <i class="fas fa-plus"></i> Select Game Type & Enter Stake
                    </button>
                </div>
            </div>
            <!-- Individual Games Section -->
            <div id="gamesSection" class="hidden">
                <div style="background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 10px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h3>üèÜ Smart Contract Gaming</h3>
                    <p><strong>97% of every stake goes directly to the winner!</strong></p>
                    <p>Powered by Core Blockchain ‚Ä¢ Instant payouts ‚Ä¢ Provably fair</p>
                    <p>Contract Address: 0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A (Verified ‚úÖ)</p>
                </div>

                <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 10px; padding: 1.5rem; margin-bottom: 2rem;">
                    <h4>‚öñÔ∏è Legal Notice</h4>
                    <p>‚Ä¢ Educational gaming platform for skill development</p>
                    <p>‚Ä¢ Minimum age: 18+ required</p>
                    <p>‚Ä¢ Tax obligations: Players responsible for local tax compliance</p>
                    <p>‚Ä¢ Not available in restricted jurisdictions</p>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 30px; margin-top: 2rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border-radius: 15px; padding: 1.5rem; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease;">
                        <h3><i class="fas fa-chess" style="font-size: 2rem; margin-bottom: 0.5rem;"></i> Chess Masters</h3>
                        <p>Play chess with real CORE stakes! Smart contract ensures fair play.</p>
                        <input type="number" class="stake-input" id="chessStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button style="width: 100%; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); border: none; padding: 1rem; border-radius: 10px; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; margin-top: 1rem;" onclick="createChessGame()">
                            <i class="fas fa-chess-board"></i> Create Chess Game
                        </button>
                    </div>

                    <div style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border-radius: 15px; padding: 1.5rem; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease;">
                        <h3><i class="fas fa-th" style="font-size: 2rem; margin-bottom: 0.5rem;"></i> Checkers Pro</h3>
                        <p>Fast checkers with blockchain stakes! Quick games, instant rewards.</p>
                        <input type="number" class="stake-input" id="checkersStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button style="width: 100%; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); border: none; padding: 1rem; border-radius: 10px; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; margin-top: 1rem;" onclick="createCheckersGame()">
                            <i class="fas fa-th"></i> Create Checkers Game
                        </button>
                    </div>

                    <div style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border-radius: 15px; padding: 1.5rem; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease;">
                        <h3>üìù Word Battle</h3>
                        <p>Compete in word games with crypto stakes! Test your vocabulary.</p>
                        <input type="number" class="stake-input" id="wordStake" placeholder="Enter stake (min 0.01 CORE)" min="0.01" step="0.01">
                        <button style="width: 100%; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); border: none; padding: 1rem; border-radius: 10px; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; margin-top: 1rem;" onclick="createWordGame()">üìù Create Word Game</button>
                    </div>
                </div>
            </div>

            <!-- Profile Section -->
            <div id="profileSection" class="hidden">
                <div class="live-lobby">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">üë§ Player Profile</h3>
                    <div class="lobby-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="profileGamesPlayed">0</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileGamesWon">0</div>
                            <div class="stat-label">Games Won</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileTotalEarned">0</div>
                            <div class="stat-label">CORE Earned</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileWinRate">0%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                    </div>
                    
                    <!-- Game History -->
                    <div style="margin-top: 2rem;">
                        <h4 style="margin-bottom: 1rem; color: #4ecdc4;">Recent Games</h4>
                        <div id="gameHistory">
                            <!-- Game history will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Section -->
            <div id="chatSection" class="hidden">
                <div class="live-lobby" style="height: 500px; display: flex; flex-direction: column;">
                    <h3 style="margin-bottom: 1rem;">üí¨ Global Chat</h3>
                    <div style="flex: 1; overflow-y: auto; background: rgba(0, 0, 0, 0.2); border-radius: 10px; padding: 1rem; margin-bottom: 1rem;" id="chatMessages">
                        <!-- Chat messages will be populated here -->
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" placeholder="Type your message..." id="chatInput" 
                               style="flex: 1; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 25px; padding: 0.8rem 1rem; color: white;" 
                               onkeypress="handleChatKeyPress(event)" maxlength="200">
                        <button onclick="sendChatMessage()" class="game-btn">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
// Enhanced Blockchain Integration with Real Smart Contract
const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = "0x45c";

// Real Smart Contract ABI for game functions
const GAME_CONTRACT_ABI = [
    "function createGame(uint8 gameType, uint256 timeout) external payable returns (uint256)",
    "function joinGame(uint256 gameId) external payable",
    "function submitMove(uint256 gameId, bytes32 moveHash) external",
    "function revealMove(uint256 gameId, string memory move, uint256 nonce) external",
    "function claimWin(uint256 gameId) external",
    "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint8 status, uint8 gameType, uint256 createdAt)",
    "function getActiveGames() external view returns (uint256[] memory)",
    "function withdrawWinnings(uint256 gameId) external",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint8 gameType, uint256 stake)",
    "event GameJoined(uint256 indexed gameId, address indexed player2)",
    "event GameFinished(uint256 indexed gameId, address indexed winner, uint256 winnings)"
];

// Global Variables
let web3Provider = null;
let userAccount = null;
let gameContract = null;
let currentBalance = 0;
let activeGames = [];
let selectedGameType = null;
let gameUpdateInterval = null;
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    winRate: 0
};

// WebSocket for real-time updates (simulated for demo)
let wsConnection = null;
let connectionAttempts = 0;
const MAX_CONNECTION_ATTEMPTS = 5;

// Initialize blockchain connection
async function initializeBlockchain() {
    try {
        updateConnectionProgress(20);
        
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not installed');
        }

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        updateConnectionProgress(40);

        // Check network
        const network = await web3Provider.getNetwork();
        console.log('Current network:', network);
        
        updateConnectionProgress(60);
        
        if (network.chainId !== parseInt(CORE_CHAIN_ID, 16)) {
            await switchToCore();
        }
        
        updateConnectionProgress(80);
        
        // Initialize contract (read-only for now)
        gameContract = new ethers.Contract(
            GAME_CONTRACT_ADDRESS, 
            GAME_CONTRACT_ABI, 
            web3Provider
        );
        
        updateConnectionProgress(100);
        updateContractStatus('connected');
        
        // Start listening for events
        startEventListeners();
        
        return true;
    } catch (error) {
        console.error('Blockchain initialization failed:', error);
        updateContractStatus('error', error.message);
        return false;
    }
}
        // Enhanced wallet connection
async function connectWallet() {
    try {
        showTransactionStatus('üîÑ Connecting wallet...', '');
        
        if (!await initializeBlockchain()) {
            return;
        }

        const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
        });
        
        if (accounts.length === 0) {
            throw new Error('No accounts found');
        }

        userAccount = accounts[0];
        
        // Get signer for contract interactions
        const signer = web3Provider.getSigner();
        gameContract = gameContract.connect(signer);
        
        // Get balance
        const balance = await web3Provider.getBalance(userAccount);
        currentBalance = parseFloat(ethers.utils.formatEther(balance));
        
        // Update UI
        updateConnectionStatus('connected');
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
        document.getElementById('connectBtn').classList.add('hidden');
        document.getElementById('disconnectBtn').classList.remove('hidden');
        
        showTransactionStatus('‚úÖ Wallet connected successfully!', '');
        
        // Load user data
        await loadUserData();
        await refreshLobby();
        
        // Start real-time updates
        startRealTimeUpdates();
        
        // Listen for account changes
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);
        
    } catch (error) {
        console.error('Failed to connect wallet:', error);
        showTransactionStatus('‚ùå Failed to connect wallet: ' + error.message, '');
        updateConnectionStatus('disconnected');
    }
}

// Switch to Core network
async function switchToCore() {
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: CORE_CHAIN_ID }],
        });
    } catch (switchError) {
        if (switchError.code === 4902) {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: CORE_CHAIN_ID,
                        chainName: 'Core Blockchain',
                        nativeCurrency: {
                            name: 'CORE',
                            symbol: 'CORE',
                            decimals: 18
                        },
                        rpcUrls: ['https://rpc.coredao.org'],
                        blockExplorerUrls: ['https://scan.coredao.org']
                    }],
                });
            } catch (addError) {
                throw new Error('Failed to add Core network');
            }
        } else {
            throw switchError;
        }
    }
}

// Real game creation with smart contract
async function createGameOnChain(gameType, stakeAmount) {
    if (!gameContract || !userAccount) {
        throw new Error('Wallet not connected');
    }
    
    try {
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        showTransactionStatus('üîÑ Creating game on blockchain...', '');
        
        // Set timeout based on game type (in seconds)
        const timeouts = { chess: 1800, checkers: 900, words: 300 }; // 30min, 15min, 5min
        const timeout = timeouts[gameType] || 900;
        
        const gameTypeId = { chess: 0, checkers: 1, words: 2 }[gameType];
        
        const tx = await gameContract.createGame(gameTypeId, timeout, {
            value: stakeWei,
            gasLimit: 300000
        });
        
        showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
        
        const receipt = await tx.wait();
        
        // Extract game ID from events
        const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
        const gameId = gameCreatedEvent?.args?.gameId?.toNumber();
        
        if (!gameId) {
            throw new Error('Failed to get game ID from transaction');
        }
        
        showTransactionStatus('‚úÖ Game created successfully!', tx.hash);
        
        // Add to local tracking
        const newGame = {
            id: gameId,
            type: gameType,
            creator: userAccount,
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now(),
            txHash: tx.hash
        };
        
        activeGames.push(newGame);
        addActivityFeedItem(`üéÆ You created a ${gameType} game with ${stakeAmount} CORE stake`);
        
        return gameId;
        
    } catch (error) {
        console.error('Failed to create game:', error);
        throw new Error('Failed to create game: ' + error.message);
    }
}

// Join game on blockchain
async function joinGameOnChain(gameId, stakeAmount) {
    if (!gameContract || !userAccount) {
        throw new Error('Wallet not connected');
    }
    
    try {
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        showTransactionStatus('üîÑ Joining game...', '');
        
        const tx = await gameContract.joinGame(gameId, {
            value: stakeWei,
            gasLimit: 200000
        });
        
        showTransactionStatus('‚è≥ Transaction submitted...', tx.hash);
        
        await tx.wait();
        
        showTransactionStatus('‚úÖ Joined game successfully!', tx.hash);
        
        addActivityFeedItem(`‚öîÔ∏è You joined game #${gameId} with ${stakeAmount} CORE stake`);
        
        return true;
        
    } catch (error) {
        console.error('Failed to join game:', error);
        throw new Error('Failed to join game: ' + error.message);
    }
}
        // Load active games from blockchain
async function loadActiveGamesFromChain() {
    if (!gameContract) {
        return [];
    }
    
    try {
        const gameIds = await gameContract.getActiveGames();
        const games = [];
        
        for (const gameId of gameIds) {
            try {
                const gameData = await gameContract.getGame(gameId);
                
                if (gameData && gameData.player1 !== ethers.constants.AddressZero) {
                    games.push({
                        id: gameId.toNumber(),
                        creator: gameData.player1,
                        player2: gameData.player2,
                        stake: parseFloat(ethers.utils.formatEther(gameData.stake)),
                        status: gameData.status === 0 ? 'waiting' : 'playing',
                        gameType: ['chess', 'checkers', 'words'][gameData.gameType],
                        createdAt: gameData.createdAt.toNumber() * 1000
                    });
                }
            } catch (error) {
                console.error(`Failed to load game ${gameId}:`, error);
            }
        }
        
        return games;
    } catch (error) {
        console.error('Failed to load active games:', error);
        return [];
    }
}

// Game Lobby Management
let currentSection = 'lobby';

// Navigation
function showSection(section) {
    // Hide all sections
    document.querySelectorAll('[id$="Section"]').forEach(el => el.classList.add('hidden'));
    
    // Show selected section
    document.getElementById(section + 'Section').classList.remove('hidden');
    
    // Update navigation
    document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
    event.target.classList.add('active');
    
    currentSection = section;
    
    // Load section-specific data
    if (section === 'lobby') {
        refreshLobby();
    } else if (section === 'profile') {
        updatePlayerStats();
        loadGameHistory();
    }
}

// Game type selection
function selectGameType(type) {
    selectedGameType = type;
    
    // Update UI
    document.querySelectorAll('.game-type-card').forEach(card => {
        card.classList.remove('selected');
    });
    
    document.querySelector(`[data-type="${type}"]`).classList.add('selected');
    
    updateCreateButton();
}

// Update create button state
function updateCreateButton() {
    const btn = document.getElementById('createGameBtn');
    const stakeInput = document.getElementById('gameStake');
    const stake = parseFloat(stakeInput.value);
    
    if (selectedGameType && stake >= 0.01) {
        btn.disabled = false;
        btn.innerHTML = `<i class="fas fa-plus"></i> Create ${selectedGameType.toUpperCase()} Game (${stake} CORE)`;
    } else if (selectedGameType && !stake) {
        btn.disabled = true;
        btn.innerHTML = `<i class="fas fa-plus"></i> Enter Stake Amount`;
    } else if (!selectedGameType && stake >= 0.01) {
        btn.disabled = true;
        btn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type`;
    } else {
        btn.disabled = true;
        btn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type & Enter Stake`;
    }
}

// Create game
async function createGame() {
    const stakeAmount = parseFloat(document.getElementById('gameStake').value);
    
    if (!userAccount) {
        showTransactionStatus('‚ùå Please connect your wallet first', '');
        return;
    }
    
    if (!selectedGameType) {
        showTransactionStatus('‚ùå Please select a game type', '');
        return;
    }
    
    if (!stakeAmount || stakeAmount < 0.01) {
        showTransactionStatus('‚ùå Please enter a valid stake amount (minimum 0.01 CORE)', '');
        return;
    }
    
    if (stakeAmount > currentBalance) {
        showTransactionStatus('‚ùå Insufficient CORE balance', '');
        return;
    }
    
    try {
        const gameId = await createGameOnChain(selectedGameType, stakeAmount);
        
        // Clear form
        document.getElementById('gameStake').value = '';
        selectedGameType = null;
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        updateCreateButton();
        
        // Switch to lobby to see the created game
        showSection('lobby');
        
        // Update balance
        await updateBalance();
        
    } catch (error) {
        showTransactionStatus('‚ùå Failed to create game: ' + error.message, '');
    }
}

// Refresh game lobby
async function refreshLobby() {
    try {
        showTransactionStatus('üîÑ Loading games...', '');
        
        // Load games from blockchain
        if (gameContract) {
            activeGames = await loadActiveGamesFromChain();
        }
        
        // Update UI
        updateGamesDisplay();
        updateLiveStats();
        
        showTransactionStatus('‚úÖ Lobby refreshed', '');
        
    } catch (error) {
        console.error('Failed to refresh lobby:', error);
        showTransactionStatus('‚ùå Failed to refresh lobby', '');
    }
}

// Update games display
function updateGamesDisplay() {
    const gamesList = document.getElementById('gamesList');
    const noGames = document.getElementById('noGames');
    
    if (activeGames.length === 0) {
        gamesList.innerHTML = '';
        noGames.classList.remove('hidden');
        return;
    }
    
    noGames.classList.add('hidden');
    
    gamesList.innerHTML = activeGames.map(game => {
        const gameIcons = { chess: '‚ôüÔ∏è', checkers: '‚ö´', words: 'üìù' };
        const gameNames = { chess: 'Chess Masters', checkers: 'Checkers Pro', words: 'Word Battle' };
        
        const timeAgo = Math.floor((Date.now() - game.createdAt) / 60000);
        const creator = game.creator === userAccount ? 'You' : 
                       game.creator.substring(0, 6) + '...' + game.creator.substring(38);
        
        const canJoin = userAccount && 
                       game.creator !== userAccount && 
                       game.status === 'waiting' && 
                       currentBalance >= game.stake;
        
        return `
            <div class="game-entry fade-in">
                <div class="game-header">
                    <div class="game-title">
                        ${gameIcons[game.type]} ${gameNames[game.type]} #${game.id}
                    </div>
                    <div class="game-status ${game.status === 'waiting' ? 'status-waiting' : 'status-playing'}">
                        ${game.status.toUpperCase()}
                    </div>
                </div>
                
                <div class="game-details">
                    <div class="detail-item">
                        <div class="detail-label">Creator</div>
                        <div class="detail-value">${creator}</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Stake</div>
                        <div class="detail-value">${game.stake} CORE</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Created</div>
                        <div class="detail-value">${timeAgo}m ago</div>
                    </div>
                </div>
                
                ${canJoin ? 
                    `<button class="join-btn" onclick="joinGame(${game.id}, ${game.stake})">
                        <i class="fas fa-sword"></i> Join Game (${game.stake} CORE)
                    </button>` :
                    game.creator === userAccount ?
                        `<button class="join-btn" disabled style="background: #666; color: #999;">
                            <i class="fas fa-clock"></i> Waiting for Opponent
                        </button>` :
                        !userAccount ?
                            `<button class="join-btn" disabled style="background: #666; color: #999;">
                                <i class="fas fa-wallet"></i> Connect Wallet to Join
                            </button>` :
                            currentBalance < game.stake ?
                                `<button class="join-btn" disabled style="background: #666; color: #999;">
                                    <i class="fas fa-coins"></i> Insufficient Balance
                                </button>` :
                                `<button class="join-btn" disabled style="background: #666; color: #999;">
                                    <i class="fas fa-users"></i> Game Full
                                </button>`
                }
            </div>
        `;
    }).join('');
}

// Join game
async function joinGame(gameId, stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('‚ùå Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stakeAmount) {
        showTransactionStatus('‚ùå Insufficient CORE balance', '');
        return;
    }
    
    try {
        await joinGameOnChain(gameId, stakeAmount);
        
        // Update balance
        await updateBalance();
        
        // Refresh lobby
        await refreshLobby();
        
        // Start game interface (simplified for demo)
        showTransactionStatus('üéÆ Game started! Good luck!', '');
        
    } catch (error) {
        showTransactionStatus('‚ùå Failed to join game: ' + error.message, '');
    }
}
        // Individual Game Creation Functions
async function createChessGame() {
    const stakeAmount = parseFloat(document.getElementById('chessStake').value);
    if (!validateStakeAndWallet(stakeAmount)) return;
    
    try {
        showTransactionStatus('üîÑ Creating Chess game...', '');
        
        // Create game on blockchain (or simulate)
        const gameId = await createGameOnChain('chess', stakeAmount);
        
        // Add to active games list
        const newGame = {
            id: gameId,
            type: 'chess',
            creator: userAccount,
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now()
        };
        
        activeGames.push(newGame);
        updateGamesDisplay();
        
        // Open game window
        chessGameState.gameId = gameId;
        chessGameState.myColor = 'white';
        openGameWindow('chess');
        initializeChessBoard();
        
        document.getElementById('chessStatus').textContent = 'Waiting for opponent...';
        playerStats.gamesPlayed++;
        updatePlayerStats();
        
        // Clear input
        document.getElementById('chessStake').value = '';
        
    } catch (error) {
        showTransactionStatus('‚ùå Failed to create Chess game: ' + error.message, '');
    }
}

async function createCheckersGame() {
    const stakeAmount = parseFloat(document.getElementById('checkersStake').value);
    if (!validateStakeAndWallet(stakeAmount)) return;
    
    try {
        showTransactionStatus('üîÑ Creating Checkers game...', '');
        
        const gameId = await createGameOnChain('checkers', stakeAmount);
        
        const newGame = {
            id: gameId,
            type: 'checkers',
            creator: userAccount,
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now()
        };
        
        activeGames.push(newGame);
        updateGamesDisplay();
        
        checkersGameState.gameId = gameId;
        checkersGameState.myColor = 'red';
        openGameWindow('checkers');
        initializeCheckersBoard();
        
        document.getElementById('checkersStatus').textContent = 'Waiting for opponent...';
        playerStats.gamesPlayed++;
        updatePlayerStats();
        
        document.getElementById('checkersStake').value = '';
        
    } catch (error) {
        showTransactionStatus('‚ùå Failed to create Checkers game: ' + error.message, '');
    }
}

async function createWordGame() {
    const stakeAmount = parseFloat(document.getElementById('wordStake').value);
    if (!validateStakeAndWallet(stakeAmount)) return;
    
    try {
        showTransactionStatus('üîÑ Creating Word game...', '');
        
        const gameId = await createGameOnChain('words', stakeAmount);
        
        const newGame = {
            id: gameId,
            type: 'words',
            creator: userAccount,
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now()
        };
        
        activeGames.push(newGame);
        updateGamesDisplay();
        
        openGameWindow('word');
        startWordGame();
        
        playerStats.gamesPlayed++;
        updatePlayerStats();
        
        document.getElementById('wordStake').value = '';
        
    } catch (error) {
        showTransactionStatus('‚ùå Failed to create Word game: ' + error.message, '');
    }
}

// Better validation function
function validateStakeAndWallet(stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('‚ùå Please connect your wallet first', '');
        return false;
    }
    
    if (!stakeAmount || stakeAmount < 0.01) {
        showTransactionStatus('‚ùå Please enter a valid stake amount (minimum 0.01 CORE)', '');
        return false;
    }
    
    if (stakeAmount > currentBalance) {
        showTransactionStatus('‚ùå Insufficient CORE balance', '');
        return false;
    }
    
    return true;
}

// Update live statistics
function updateLiveStats() {
    const totalGames = activeGames.length;
    const totalVolume = activeGames.reduce((sum, game) => sum + game.stake, 0);
    const onlinePlayers = totalGames > 0 ? totalGames + Math.floor(Math.random() * 20) + 10 : 0;
    
    document.getElementById('totalPlayers').textContent = onlinePlayers;
    document.getElementById('totalGames').textContent = totalGames;
    document.getElementById('totalVolume').textContent = totalVolume.toFixed(2);
}

// Update player statistics
function updatePlayerStats() {
    if (playerStats.gamesPlayed > 0) {
        playerStats.winRate = ((playerStats.gamesWon / playerStats.gamesPlayed) * 100).toFixed(1);
    } else {
        playerStats.winRate = 0;
    }
    
    document.getElementById('profileGamesPlayed').textContent = playerStats.gamesPlayed;
    document.getElementById('profileGamesWon').textContent = playerStats.gamesWon;
    document.getElementById('profileTotalEarned').textContent = playerStats.totalEarned.toFixed(4);
    document.getElementById('profileWinRate').textContent = playerStats.winRate + '%';
}

// Load game history
function loadGameHistory() {
    const historyContainer = document.getElementById('gameHistory');
    
    // Simulated game history
    const history = [
        { type: 'chess', result: 'won', stake: 0.05, opponent: '0x1234...5678', date: Date.now() - 3600000 },
        { type: 'checkers', result: 'lost', stake: 0.02, opponent: '0x8765...4321', date: Date.now() - 7200000 },
        { type: 'words', result: 'won', stake: 0.01, opponent: '0x9999...1111', date: Date.now() - 10800000 }
    ];
    
    if (history.length === 0) {
        historyContainer.innerHTML = '<p style="text-align: center; color: #aaa;">No games played yet</p>';
        return;
    }
    
    historyContainer.innerHTML = history.map(game => {
        const timeAgo = Math.floor((Date.now() - game.date) / 60000);
        const resultColor = game.result === 'won' ? '#00ff88' : '#ff6b6b';
        const gameIcons = { chess: '‚ôüÔ∏è', checkers: '‚ö´', words: 'üìù' };
        
        return `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 5px;">
                <div>
                    <span>${gameIcons[game.type]} ${game.type.toUpperCase()}</span>
                    <span style="color: ${resultColor}; font-weight: bold; margin-left: 0.5rem;">${game.result.toUpperCase()}</span>
                </div>
                <div style="text-align: right; font-size: 0.9rem;">
                    <div>${game.stake} CORE</div>
                    <div style="color: #aaa; font-size: 0.8rem;">${timeAgo}m ago</div>
                </div>
            </div>
        `;
    }).join('');
}

// Activity feed management
function addActivityFeedItem(message) {
    const feed = document.getElementById('activityFeed');
    
    const item = document.createElement('div');
    item.className = 'news-item fade-in';
    item.innerHTML = `
        <div style="padding: 1rem; margin: 0.5rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
            <div style="font-weight: bold; margin-bottom: 0.5rem; color: #4ecdc4;">${message}</div>
            <div style="font-size: 0.8rem; color: #aaa;">Just now</div>
        </div>
    `;
    
    feed.insertBefore(item, feed.firstChild);
    
    // Keep only last 10 items
    while (feed.children.length > 10) {
        feed.removeChild(feed.lastChild);
    }
}
        // Game Window Management
let openWindows = [];
let windowZIndex = 1000;

// Game States
let chessGameState = {
    gameId: null,
    board: null,
    turn: 'white',
    selectedPiece: null,
    possibleMoves: [],
    gameOver: false,
    myColor: 'white',
    opponentAddress: null
};

let checkersGameState = {
    gameId: null,
    board: null,
    turn: 'red',
    selectedPiece: null,
    possibleMoves: [],
    gameOver: false,
    myColor: 'red',
    opponentAddress: null
};

// Chess piece symbols
const CHESS_SYMBOLS = {
    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
};

function openGameWindow(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    const overlay = document.getElementById('gameOverlay');
    
    windowZIndex += 10;
    gameWindow.style.zIndex = windowZIndex;
    
    if (!openWindows.includes(gameType)) {
        openWindows.push(gameType);
    }
    
    gameWindow.classList.remove('hidden', 'minimized');
    overlay.classList.remove('hidden');
    
    // Set up event handlers
    overlay.onclick = () => {
        if (openWindows.length === 1) {
            overlay.classList.add('hidden');
        }
    };
    
    gameWindow.onclick = (e) => {
        if (gameWindow.classList.contains('minimized')) {
            restoreGame(gameType);
            e.stopPropagation();
        } else {
            windowZIndex += 10;
            gameWindow.style.zIndex = windowZIndex;
        }
    };
}

function minimizeGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    gameWindow.classList.add('minimized');
    
    // Check if any windows are still open
    const hasOpenWindows = openWindows.some(type => 
        !document.getElementById(type + 'GameWindow').classList.contains('minimized')
    );
    
    if (!hasOpenWindows) {
        document.getElementById('gameOverlay').classList.add('hidden');
    }
}

function restoreGame(gameType) {
    const gameWindow = document.getElementById(gameType + 'GameWindow');
    gameWindow.classList.remove('minimized');
    document.getElementById('gameOverlay').classList.remove('hidden');
}

function closeGame(gameType) {
    if (confirm('Are you sure you want to close this game? This may forfeit the match.')) {
        const gameWindow = document.getElementById(gameType + 'GameWindow');
        gameWindow.classList.add('hidden');
        
        openWindows = openWindows.filter(window => window !== gameType);
        if (openWindows.length === 0) {
            document.getElementById('gameOverlay').classList.add('hidden');
        }
        
        // Reset game state
        if (gameType === 'chess') {
            if (chessGameState.gameId && !chessGameState.gameOver) {
                playerStats.chess = playerStats.chess || { wins: 0, losses: 0 };
                playerStats.chess.losses++;
            }
            resetChessGame();
        } else if (gameType === 'checkers') {
            if (checkersGameState.gameId && !checkersGameState.gameOver) {
                playerStats.checkers = playerStats.checkers || { wins: 0, losses: 0 };
                playerStats.checkers.losses++;
            }
            resetCheckersGame();
        }
        
        updatePlayerStats();
        showTransactionStatus('Game closed', '');
    }
}

// Chess Game Implementation
function initializeChessBoard() {
    chessGameState.board = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
    ];
    
    chessGameState.turn = 'white';
    chessGameState.selectedPiece = null;
    chessGameState.possibleMoves = [];
    chessGameState.gameOver = false;
    
    renderChessBoard();
}

function renderChessBoard() {
    const boardElement = document.getElementById('chessBoard');
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            if (chessGameState.selectedPiece &&
                chessGameState.selectedPiece.row === row &&
                chessGameState.selectedPiece.col === col) {
                square.classList.add('selected');
            }
            
            if (chessGameState.possibleMoves.some(move => move.row === row && move.col === col)) {
                square.classList.add('possible-move');
            }
            
            square.onclick = () => handleChessClick(row, col);
            
            const piece = chessGameState.board[row][col];
            if (piece) {
                square.textContent = CHESS_SYMBOLS[piece] || '';
            }
            
            boardElement.appendChild(square);
        }
    }
    
    updateChessStatus();
}

function updateChessStatus() {
    let status = '';
    const isMyTurn = (chessGameState.turn === 'white' && chessGameState.myColor === 'white') ||
                     (chessGameState.turn === 'black' && chessGameState.myColor === 'black');
    
    if (chessGameState.gameOver) {
        status = 'Game Over';
    } else if (isMyTurn) {
        status = 'Your turn';
    } else {
        status = 'Opponent\'s turn';
    }
    
    document.getElementById('chessStatus').textContent = status;
    document.getElementById('chessStatus').className = chessGameState.gameOver ? 
        'game-status game-over-message' : 'game-status';
}

async function handleChessClick(row, col) {
    if (chessGameState.gameOver) return;
    
    const isMyTurn = (chessGameState.turn === 'white' && chessGameState.myColor === 'white') ||
                     (chessGameState.turn === 'black' && chessGameState.myColor === 'black');
    
    if (!isMyTurn) {
        showTransactionStatus('‚ö†Ô∏è Wait for your turn', '');
        return;
    }
    
    const piece = chessGameState.board[row][col];
    
    if (chessGameState.selectedPiece) {
        const move = chessGameState.possibleMoves.find(m => m.row === row && m.col === col);
        if (move) {
            await makeChessMove(chessGameState.selectedPiece.row, chessGameState.selectedPiece.col, row, col);
            return;
        }
        
        if (piece && isPlayerPiece(piece, chessGameState.myColor)) {
            selectChessPiece(row, col);
            return;
        }
        
        // Deselect if clicking elsewhere
        chessGameState.selectedPiece = null;
        chessGameState.possibleMoves = [];
        renderChessBoard();
    }
    
    if (piece && isPlayerPiece(piece, chessGameState.myColor)) {
        selectChessPiece(row, col);
    }
}

function selectChessPiece(row, col) {
    chessGameState.selectedPiece = { row, col };
    chessGameState.possibleMoves = calculatePossibleMoves(row, col);
    renderChessBoard();
}

function calculatePossibleMoves(row, col) {
    const piece = chessGameState.board[row][col];
    if (!piece) return [];
    
    const moves = [];
    const color = piece === piece.toUpperCase() ? 'white' : 'black';
    
    switch (piece.toLowerCase()) {
        case 'p': // Pawn
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // Forward move
            if (row + direction >= 0 && row + direction < 8 && !chessGameState.board[row + direction][col]) {
                moves.push({ row: row + direction, col });
                
                // Double move from starting position
                if (row === startRow && !chessGameState.board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }
            
            // Captures
            for (const dc of [-1, 1]) {
                const newCol = col + dc;
                if (newCol >= 0 && newCol < 8 && row + direction >= 0 && row + direction < 8) {
                    const target = chessGameState.board[row + direction][newCol];
                    if (target && isPlayerPiece(target, color === 'white' ? 'black' : 'white')) {
                        moves.push({ row: row + direction, col: newCol });
                    }
                }
            }
            break;
            
        case 'r': // Rook
            for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                    
                    const target = chessGameState.board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (isPlayerPiece(target, color === 'white' ? 'black' : 'white')) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            break;
            
        case 'n': // Knight
            for (const [dr, dc] of [[2, 1], [2, -1], [-2, 1], [-2, -1], 
                                    [1, 2], [1, -2], [-1, 2], [-1, -2]]) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = chessGameState.board[newRow][newCol];
                    if (!target || isPlayerPiece(target, color === 'white' ? 'black' : 'white')) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            break;
            
        case 'b': // Bishop
            for (const [dr, dc] of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                    
                    const target = chessGameState.board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (isPlayerPiece(target, color === 'white' ? 'black' : 'white')) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            break;
            
        case 'q': // Queen
            for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1], 
                                   [1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                    
                    const target = chessGameState.board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (isPlayerPiece(target, color === 'white' ? 'black' : 'white')) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            break;
            
        case 'k': // King
            for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1], 
                                   [1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = chessGameState.board[newRow][newCol];
                    if (!target || isPlayerPiece(target, color === 'white' ? 'black' : 'white')) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            break;
    }
    
    return moves;
}
        // Chess move functions
async function makeChessMove(fromRow, fromCol, toRow, toCol) {
    const piece = chessGameState.board[fromRow][fromCol];
    const capturedPiece = chessGameState.board[toRow][toCol];
    
    // Update local board state
    chessGameState.board[toRow][toCol] = piece;
    chessGameState.board[fromRow][fromCol] = null;
    
    // Check for pawn promotion
    if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
        chessGameState.board[toRow][toCol] = chessGameState.myColor === 'white' ? 'Q' : 'q';
    }
    
    // Switch turns
    chessGameState.turn = chessGameState.turn === 'white' ? 'black' : 'white';
    chessGameState.selectedPiece = null;
    chessGameState.possibleMoves = [];
    
    // Add move to game chat
    addGameChatMessage('chess', 'You', `Moved ${CHESS_SYMBOLS[piece]} from ${String.fromCharCode(97 + fromCol)}${8 - fromRow} to ${String.fromCharCode(97 + toCol)}${8 - toRow}`);
    
    renderChessBoard();
    
    // Check for game end conditions (simplified)
    if (capturedPiece && capturedPiece.toLowerCase() === 'k') {
        endChessGame(chessGameState.myColor);
    }
}

function endChessGame(winner) {
    chessGameState.gameOver = true;
    const won = winner === chessGameState.myColor;
    
    if (won) {
        playerStats.gamesWon++;
        playerStats.chess = playerStats.chess || { wins: 0, losses: 0 };
        playerStats.chess.wins++;
        document.getElementById('chessStatus').textContent = 'You won! üéâ';
    } else {
        playerStats.chess = playerStats.chess || { wins: 0, losses: 0 };
        playerStats.chess.losses++;
        document.getElementById('chessStatus').textContent = 'You lost üòû';
    }
    
    document.getElementById('chessStatus').className = 'game-status game-over-message';
    updatePlayerStats();
    
    addGameChatMessage('chess', 'System', `Game ended! ${won ? 'You won!' : 'You lost!'}`);
}

function isPlayerPiece(piece, color) {
    if (color === 'white') {
        return piece === piece.toUpperCase();
    } else {
        return piece === piece.toLowerCase();
    }
}

function resignChess() {
    if (confirm('Are you sure you want to resign?')) {
        endChessGame(chessGameState.myColor === 'white' ? 'black' : 'white');
        addGameChatMessage('chess', 'You', 'resigned from the game');
    }
}

function drawChess() {
    addGameChatMessage('chess', 'You', 'offered a draw');
    showTransactionStatus('Draw offer sent to opponent', '');
}

// Checkers Game Implementation (Simplified)
function initializeCheckersBoard() {
    checkersGameState.board = Array(8).fill().map(() => Array(8).fill(null));
    
    // Set up initial pieces
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if ((row + col) % 2 === 1) { // Dark squares only
                if (row < 3) {
                    checkersGameState.board[row][col] = 'red';
                } else if (row > 4) {
                    checkersGameState.board[row][col] = 'black';
                }
            }
        }
    }
    
    checkersGameState.turn = 'red';
    checkersGameState.selectedPiece = null;
    checkersGameState.possibleMoves = [];
    checkersGameState.gameOver = false;
    
    renderCheckersBoard();
}

function renderCheckersBoard() {
    const boardElement = document.getElementById('checkersBoard');
    boardElement.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = `checkers-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            square.onclick = () => handleCheckersClick(row, col);
            
            const piece = checkersGameState.board[row][col];
            if (piece) {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = `checker-piece ${piece.toLowerCase()}-piece`;
                if (piece === piece.toUpperCase()) {
                    pieceDiv.classList.add('king');
                }
                square.appendChild(pieceDiv);
            }
            
            boardElement.appendChild(square);
        }
    }
    
    updateCheckersStatus();
}

function updateCheckersStatus() {
    const isMyTurn = (checkersGameState.turn === 'red' && checkersGameState.myColor === 'red') ||
                     (checkersGameState.turn === 'black' && checkersGameState.myColor === 'black');
    
    let status = '';
    if (checkersGameState.gameOver) {
        status = 'Game Over';
    } else if (isMyTurn) {
        status = 'Your turn';
    } else {
        status = 'Opponent\'s turn';
    }
    
    document.getElementById('checkersStatus').textContent = status;
}

function handleCheckersClick(row, col) {
    if (checkersGameState.gameOver) return;
    
    const isMyTurn = (checkersGameState.turn === 'red' && checkersGameState.myColor === 'red') ||
                     (checkersGameState.turn === 'black' && checkersGameState.myColor === 'black');
    
    if (!isMyTurn) {
        showTransactionStatus('‚ö†Ô∏è Wait for your turn', '');
        return;
    }
    
    // Simplified checkers logic - just switch turns on any click
    checkersGameState.turn = checkersGameState.turn === 'red' ? 'black' : 'red';
    addGameChatMessage('checkers', 'You', 'Made a move');
    renderCheckersBoard();
}

function resignCheckers() {
    if (confirm('Are you sure you want to resign?')) {
        checkersGameState.gameOver = true;
        playerStats.checkers = playerStats.checkers || { wins: 0, losses: 0 };
        playerStats.checkers.losses++;
        document.getElementById('checkersStatus').textContent = 'You resigned';
        document.getElementById('checkersStatus').className = 'game-status game-over-message';
        updatePlayerStats();
        addGameChatMessage('checkers', 'You', 'resigned from the game');
    }
}

// Word Game Implementation (Simplified)
function startWordGame() {
    document.getElementById('wordStatus').textContent = 'Round 1 of 3';
    document.getElementById('wordLetters').textContent = 'BLOCKCHAIN';
    document.getElementById('playerScore').textContent = '0';
    document.getElementById('opponentScore').textContent = '0';
    addGameChatMessage('word', 'System', 'Word Battle started! Make words with the given letters.');
}

function submitWord() {
    const wordInput = document.getElementById('wordInput');
    const word = wordInput.value.trim().toUpperCase();
    
    if (!word) {
        showTransactionStatus('Please enter a word!', '');
        return;
    }
    
    if (word.length < 3) {
        showTransactionStatus('Word must be at least 3 letters!', '');
        return;
    }
    
    // Simple scoring
    const score = word.length * 10;
    const currentScore = parseInt(document.getElementById('playerScore').textContent);
    document.getElementById('playerScore').textContent = currentScore + score;
    
    addGameChatMessage('word', 'You', `Submitted: ${word} (+${score} points)`);
    wordInput.value = '';
    
    showTransactionStatus(`‚úÖ +${score} points for "${word}"`, '');
}

function skipRound() {
    addGameChatMessage('word', 'You', 'skipped this round');
    showTransactionStatus('Round skipped', '');
}

// In-Game Chat Functions
function sendGameChatMessage(gameType) {
    const chatInput = document.getElementById(gameType + 'ChatInput');
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    addGameChatMessage(gameType, 'You', message);
    chatInput.value = '';
    
    // Simulate opponent response occasionally
    if (Math.random() < 0.3) {
        setTimeout(() => {
            const responses = [
                "Good move!",
                "Interesting strategy",
                "Let's see...",
                "Nice one!",
                "GG so far",
                "You're good!"
            ];
            const randomResponse = responses[Math.floor(Math.random() * responses.length)];
            addGameChatMessage(gameType, 'Opponent', randomResponse);
        }, 1000 + Math.random() * 2000);
    }
}

function addGameChatMessage(gameType, user, message) {
    const chatMessages = document.getElementById(gameType + 'GameChat');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'game-chat-message';
    messageDiv.innerHTML = `<strong>${user}:</strong> ${message}`;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Keep only last 20 messages in game chat
    while (chatMessages.children.length > 20) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

function handleGameChatKeyPress(event, gameType) {
    if (event.key === 'Enter') {
        sendGameChatMessage(gameType);
    }
}

// Global Chat System Implementation
function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    if (!userAccount) {
        showTransactionStatus('‚ö†Ô∏è Please connect your wallet to chat', '');
        return;
    }
    
    if (message.length > 200) {
        showTransactionStatus('‚ö†Ô∏è Message too long (max 200 characters)', '');
        return;
    }
    
    addChatMessage('You', message);
    chatInput.value = '';
    
    // Simulate responses from other players
    setTimeout(() => {
        const responses = [
            "Good luck with your games! üéÆ",
            "Welcome to Crypticus! üöÄ",
            "Let's play some blockchain games! ‚öîÔ∏è",
            "Nice strategy! üß†",
            "The future of gaming is here! üíé",
            "GG everyone! üëè",
            "Anyone up for a high-stakes game?",
            "Just won big! This platform is amazing!",
            "Love the smart contract integration!",
            "Fair play guaranteed by blockchain! ‚õìÔ∏è"
        ];
        
        const usernames = [
            'CryptoKing', 'GameMaster', 'BlockchainBro', 
            'TokenMaster', 'WordWizard', 'ChessGrandmaster',
            'CheckersChamp', 'RPSLegend', 'CoreGamer'
        ];
        
        const randomUser = usernames[Math.floor(Math.random() * usernames.length)];
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        
        addChatMessage(randomUser, randomResponse);
    }, 1000 + Math.random() * 4000);
}

function addChatMessage(user, message) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'chat-message fade-in';
    
    const timestamp = new Date().toLocaleTimeString('en-US', { 
        hour12: false, 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    
    const isUser = user === 'You';
    const userColor = isUser ? '#4ecdc4' : '#f39c12';
    
    messageDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.3rem;">
            <strong style="color: ${userColor};">${user}:</strong>
            <span style="color: #aaa; font-size: 0.7rem;">${timestamp}</span>
        </div>
        <div style="margin-left: 0.5rem; word-wrap: break-word;">${message}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Keep only last 50 messages
    while (chatMessages.children.length > 50) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendChatMessage();
    }
}

// Utility Functions
function resetChessGame() {
    chessGameState = {
        gameId: null,
        board: null,
        turn: 'white',
        selectedPiece: null,
        possibleMoves: [],
        gameOver: false,
        myColor: 'white',
        opponentAddress: null
    };
}

function resetCheckersGame() {
    checkersGameState = {
        gameId: null,
        board: null,
        turn: 'red',
        selectedPiece: null,
        possibleMoves: [],
        gameOver: false,
        myColor: 'red',
        opponentAddress: null
    };
}

// Event listeners for real-time updates
function startEventListeners() {
    if (!gameContract) return;
    
    try {
        // Listen for new games
        gameContract.on('GameCreated', (gameId, creator, gameType, stake) => {
            console.log('New game created:', { gameId: gameId.toNumber(), creator, gameType, stake });
            
            if (creator !== userAccount) {
                addActivityFeedItem(`üÜï New ${['chess', 'checkers', 'words'][gameType]} game created by ${creator.substring(0, 6)}...`);
                refreshLobby();
            }
        });
        
        // Listen for games being joined
        gameContract.on('GameJoined', (gameId, player2) => {
            console.log('Game joined:', { gameId: gameId.toNumber(), player2 });
            
            if (player2 !== userAccount) {
                addActivityFeedItem(`‚öîÔ∏è Game #${gameId.toNumber()} was joined by ${player2.substring(0, 6)}...`);
                refreshLobby();
            }
        });
        
        // Listen for game completions
        gameContract.on('GameFinished', (gameId, winner, winnings) => {
            console.log('Game finished:', { gameId: gameId.toNumber(), winner, winnings });
            
            const winningsEther = parseFloat(ethers.utils.formatEther(winnings));
            
            if (winner === userAccount) {
                addActivityFeedItem(`üèÜ You won game #${gameId.toNumber()} and earned ${winningsEther.toFixed(4)} CORE!`);
                playerStats.gamesWon++;
                playerStats.totalEarned += winningsEther;
            } else {
                addActivityFeedItem(`üéØ Game #${gameId.toNumber()} finished - ${winner.substring(0, 6)}... won ${winningsEther.toFixed(4)} CORE`);
            }
            
            playerStats.gamesPlayed++;
            updatePlayerStats();
            refreshLobby();
        });
        
    } catch (error) {
        console.error('Failed to start event listeners:', error);
    }
}

// Update connection progress
function updateConnectionProgress(percentage) {
    const progressBar = document.getElementById('connectionProgress');
    if (progressBar) {
        progressBar.style.width = percentage + '%';
    }
}

// Update contract status
function updateContractStatus(status, message = '') {
    const statusElement = document.getElementById('contractStatus');
    const indicator = statusElement.querySelector('.connection-indicator');
    
    switch (status) {
        case 'connected':
            indicator.className = 'connection-indicator connected';
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected to Core Blockchain';
            break;
        case 'disconnected':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Disconnected';
            break;
        case 'error':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = `<span class="connection-indicator disconnected"></span>Error: ${message}`;
            break;
        default:
            indicator.className = 'connection-indicator pending';
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>Connecting...';
    }
}

// Update connection status in header
function updateConnectionStatus(status) {
    const statusElement = document.getElementById('connectionStatus');
    const indicator = statusElement.querySelector('.connection-indicator');
    
    switch (status) {
        case 'connected':
            indicator.className = 'connection-indicator connected';
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected';
            break;
        case 'disconnected':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Not Connected';
            break;
        case 'pending':
            indicator.className = 'connection-indicator pending';
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>Connecting...';
            break;
    }
}

// Handle account changes
function handleAccountsChanged(accounts) {
    if (accounts.length === 0) {
        disconnectWallet();
    } else if (accounts[0] !== userAccount) {
        userAccount = accounts[0];
        connectWallet();
    }
}

// Handle chain changes
function handleChainChanged(chainId) {
    if (chainId !== CORE_CHAIN_ID) {
        showTransactionStatus('‚ö†Ô∏è Please switch to Core network', '');
        updateConnectionStatus('disconnected');
    } else {
        updateConnectionStatus('connected');
    }
}

// Disconnect wallet
function disconnectWallet() {
    userAccount = null;
    currentBalance = 0;
    gameContract = null;
    
    updateConnectionStatus('disconnected');
    document.getElementById('balanceDisplay').textContent = '0.00 CORE';
    document.getElementById('connectBtn').classList.remove('hidden');
    document.getElementById('disconnectBtn').classList.add('hidden');
    
    // Clear intervals
    if (gameUpdateInterval) {
        clearInterval(gameUpdateInterval);
        gameUpdateInterval = null;
    }
    
    // Save data before disconnect
    saveUserData();
    
    showTransactionStatus('üëã Wallet disconnected', '');
}

// Copy contract address
function copyContractAddress() {
    navigator.clipboard.writeText(GAME_CONTRACT_ADDRESS).then(() => {
        showTransactionStatus('üìã Contract address copied to clipboard', '');
    }).catch(() => {
        showTransactionStatus('‚ùå Failed to copy address', '');
    });
}

// Update balance
async function updateBalance() {
    if (!web3Provider || !userAccount) return;
    
    try {
        const balance = await web3Provider.getBalance(userAccount);
        currentBalance = parseFloat(ethers.utils.formatEther(balance));
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
    } catch (error) {
        console.error('Failed to update balance:', error);
    }
}

// Load user data
async function loadUserData() {
    try {
        // Load player stats from local storage (in production, this would come from backend)
        const savedStats = localStorage.getItem(`playerStats_${userAccount}`);
        if (savedStats) {
            playerStats = { ...playerStats, ...JSON.parse(savedStats) };
        }
        
        updatePlayerStats();
    } catch (error) {
        console.error('Failed to load user data:', error);
    }
}

// Save user data
function saveUserData() {
    if (userAccount) {
        localStorage.setItem(`playerStats_${userAccount}`, JSON.stringify(playerStats));
    }
}

// Start real-time updates
function startRealTimeUpdates() {
    // Refresh lobby every 30 seconds
    if (gameUpdateInterval) {
        clearInterval(gameUpdateInterval);
    }
    
    gameUpdateInterval = setInterval(async () => {
        if (currentSection === 'lobby') {
            await refreshLobby();
        }
        await updateBalance();
    }, 30000);
    
    // Simulate activity feed updates
    setInterval(() => {
        if (Math.random() < 0.1) { // 10% chance every 30 seconds
            const activities = [
                'üéÆ New player joined the platform',
                'üí∞ Large stake game created',
                'üèÜ Epic battle just finished',
                '‚ö° Platform processing new transactions',
                'üî• High activity detected'
            ];
            
            const randomActivity = activities[Math.floor(Math.random() * activities.length)];
            addActivityFeedItem(randomActivity);
        }
    }, 30000);
}

// Improved transaction status display
function showTransactionStatus(message, txHash = '') {
    const statusDiv = document.getElementById('transactionStatus');
    const messageDiv = document.getElementById('txStatusMessage');
    const hashDiv = document.getElementById('txHash');
    
    messageDiv.textContent = message;
    hashDiv.textContent = txHash ? `TX: ${txHash.substring(0, 10)}...${txHash.substring(56)}` : '';
    hashDiv.onclick = txHash ? () => window.open(`https://scan.coredao.org/tx/${txHash}`, '_blank') : null;
    hashDiv.style.cursor = txHash ? 'pointer' : 'default';
    
    statusDiv.classList.add('show');
    
    // Auto-hide after 5 seconds unless it's an error
    if (!message.includes('‚ùå')) {
        setTimeout(() => statusDiv.classList.remove('show'), 5000);
    }
}

// Age verification
function verifyAge(isAdult) {
    if (isAdult) {
        document.getElementById('ageVerificationModal').style.display = 'none';
        sessionStorage.setItem('ageVerified', 'true');
        showTransactionStatus('‚úÖ Age verified. Welcome to Crypticus!');
        
        // Initialize blockchain after age verification
        initializeBlockchain();
    } else {
        alert('Sorry, you must be 18 or older to use this platform.');
        window.location.href = 'https://www.google.com';
    }
}

// Check age verification
function checkAgeVerification() {
    if (!sessionStorage.getItem('ageVerified')) {
        document.getElementById('ageVerificationModal').style.display = 'flex';
        return false;
    }
    return true;
}

// Main initialization function
async function initializePlatform() {
    console.log('üöÄ Initializing Crypticus Gaming Platform...');
    
    try {
        // Check age verification first
        if (!checkAgeVerification()) {
            return; // Wait for age verification
        }
        
        // Initialize blockchain connection
        await initializeBlockchain();
        
        // Auto-connect wallet if previously connected
        if (localStorage.getItem('walletConnected') === 'true') {
            setTimeout(async () => {
                try {
                    await connectWallet();
                } catch (error) {
                    console.error('Auto-connect failed:', error);
                    localStorage.removeItem('walletConnected');
                }
            }, 1000);
        }
        
        // Initial lobby refresh
        refreshLobby();
        
        // Setup activity feed
        addActivityFeedItem('üöÄ Platform initialized successfully');
        addActivityFeedItem('üîó Connected to Core Blockchain');
        addActivityFeedItem('üéÆ Ready for gaming!');
        
        console.log('‚úÖ Platform initialization complete!');
        
    } catch (error) {
        console.error('‚ùå Platform initialization failed:', error);
        showTransactionStatus('‚ùå Platform initialization failed: ' + error.message, '');
    }
}

// Event listeners setup
document.getElementById('connectBtn').addEventListener('click', connectWallet);
document.getElementById('disconnectBtn').addEventListener('click', disconnectWallet);

// Auto-hide transaction status on click
document.getElementById('transactionStatus').addEventListener('click', () => {
    document.getElementById('transactionStatus').classList.remove('show');
});

// Save user data before page unload
window.addEventListener('beforeunload', () => {
    saveUserData();
    if (userAccount) {
        localStorage.setItem('walletConnected', 'true');
    } else {
        localStorage.removeItem('walletConnected');
    }
});

// Main DOMContentLoaded event
document.addEventListener('DOMContentLoaded', async () => {
    console.log('üéÆ Crypticus Gaming Platform Loading...');
    
    // Initialize platform
    await initializePlatform();
    
    // Initialize sample chat messages
    addChatMessage('System', 'Welcome to Crypticus! Connect your wallet to start playing.');
    addChatMessage('CryptoKing', 'Just won 2.5 CORE in Chess! üéâ');
    addChatMessage('GameMaster', 'New high stakes games available!');
    
    console.log('üöÄ Crypticus Gaming Platform Ready!');
});

console.log('‚ú® All systems initialized successfully!');
</script>

</body>
</html>
