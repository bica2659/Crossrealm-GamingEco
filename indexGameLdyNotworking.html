<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypticus - Live Blockchain Gaming Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #4e54c8;
            --primary-dark: #363a9e;
            --secondary: #f39c12;
            --dark: #1a1c2c;
            --light: #f5f7fa;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f1c40f;
            --gray: #95a5a6;
        }

        html, body {
            height: 100%;
            overflow-x: hidden;
        }

        body {
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            color: var(--light);
            position: relative;
        }

        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://images.unsplash.com/photo-1620336655052-b57986f5a26a?q=80&w=1920') no-repeat center center;
            background-size: cover;
            opacity: 0.1;
            z-index: -1;
        }

        /* Header Styles */
        .header {
            position: relative;
            z-index: 100;
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-height: 80px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.8rem;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .logo-icon {
            font-size: 2.5rem;
            color: var(--secondary);
        }

        .nav-menu {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-item {
            padding: 0.5rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(78, 205, 196, 0.5);
        }

        .nav-item.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .live-badge {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .wallet-info {
            text-align: right;
        }

        .connection-status {
            font-size: 0.9rem;
            color: #ff6b6b;
        }

        .balance {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .connect-btn, .disconnect-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .disconnect-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            margin-left: 0.5rem;
        }

        .connect-btn:hover, .disconnect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(78, 205, 196, 0.3);
        }

        .hidden {
            display: none;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            min-height: calc(100vh - 80px);
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #4ecdc4;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Connection Status Indicators */
        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .connected {
            background: #00ff88;
            animation: pulse 2s infinite;
        }

        .disconnected {
            background: #ff6b6b;
        }

        .pending {
            background: #f1c40f;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
    </style>
</head>
<style>
        /* Enhanced Game Lobby Styles */
        .live-lobby {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 2px solid #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .lobby-stats {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }

        /* Game Entry Styles */
        .game-entry {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1));
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .game-entry::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .game-entry:hover::before {
            left: 100%;
        }

        .game-entry:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .game-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4ecdc4;
        }

        .game-status {
            padding: 0.2rem 0.8rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-waiting {
            background: linear-gradient(45deg, #f1c40f, #f39c12);
            color: #000;
        }

        .status-playing {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .game-details {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .detail-item {
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .detail-label {
            color: #aaa;
            font-size: 0.8rem;
        }

        .detail-value {
            font-weight: bold;
            margin-top: 0.2rem;
        }

        .join-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border: none;
            padding: 0.8rem;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .join-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 255, 136, 0.3);
        }

        .join-btn:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Smart Contract Status */
        .contract-status {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .contract-address {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            border-radius: 5px;
            margin: 0.5rem 0;
            word-break: break-all;
        }

        /* Transaction Status */
        .transaction-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #4ecdc4;
            border-radius: 10px;
            padding: 1rem;
            max-width: 350px;
            z-index: 2000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            word-wrap: break-word;
        }

        .transaction-status.show {
            transform: translateX(0);
        }

        .tx-hash {
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            color: #4ecdc4;
            margin-top: 0.5rem;
            cursor: pointer;
        }

        /* Game Creation Styles */
        .create-game-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .game-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .game-type-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-type-card:hover, .game-type-card.selected {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            transform: translateY(-3px);
        }

        .game-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .stake-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
            color: white;
            font-size: 1.1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .stake-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .create-btn {
            width: 100%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .create-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(255, 107, 107, 0.3);
        }

        .create-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
</style>
<style>
        /* Age Verification Modal */
        .age-verification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
        }

        .verification-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            position: relative;
            z-index: 10000;
        }

        .verification-content h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: var(--secondary);
        }

        .verification-content p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: var(--light);
        }

        .verification-content .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid var(--danger);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            text-align: left;
        }

        .verification-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .verify-btn {
            padding: 1rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-width: 120px;
        }

        .verify-btn.accept {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .verify-btn.decline {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .verify-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                order: 2;
                padding: 1rem;
                max-height: none;
            }

            .content-area {
                order: 1;
                padding: 1rem;
                max-height: none;
            }

            .lobby-stats {
                flex-direction: column;
                gap: 1rem;
            }

            .game-details {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }

            .verification-content {
                margin: 1rem;
                padding: 2rem 1rem;
            }

            .verification-content h1 {
                font-size: 1.8rem;
            }

            .verification-content p {
                font-size: 1rem;
            }

            .verify-btn {
                min-width: 100px;
                padding: 0.8rem 1.5rem;
            }

            .transaction-status {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .nav-menu {
                gap: 1rem;
                flex-wrap: wrap;
            }

            .nav-item {
                padding: 0.3rem 0.8rem;
                font-size: 0.9rem;
            }

            .wallet-section {
                flex-direction: column;
                gap: 0.5rem;
            }

            .game-type-selector {
                grid-template-columns: 1fr;
            }
        }

        /* Additional Utility Classes */
        .pulse {
            animation: pulse 2s infinite;
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .fade-in {
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .glow {
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        /* Tooltip Styles */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem;
            border-radius: 5px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .tooltip:hover::after {
            opacity: 1;
        }

        /* Game Status Indicators */
        .game-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .indicator-waiting {
            background: #f1c40f;
            animation: blink 1s infinite;
        }

        .indicator-playing {
            background: #e74c3c;
        }

        .indicator-finished {
            background: #2ecc71;
        }

        /* Enhanced Buttons */
        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        /* Copy Button for Contract Address */
        .copy-btn {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid #4ecdc4;
            border-radius: 5px;
            padding: 0.3rem 0.6rem;
            color: #4ecdc4;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            margin-left: 0.5rem;
        }

        .copy-btn:hover {
            background: rgba(78, 205, 196, 0.3);
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #00ff88);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
    </style>
</head>
  <body>
    <div class="background"></div>
    
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <i class="fas fa-dice-d20 logo-icon"></i>
            <h1>CRYPTICUS</h1>
        </div>
        <div class="nav-menu" id="navMenu">
            <div class="nav-item active" onclick="showSection('lobby')">🎯 Game Lobby</div>
            <div class="nav-item" onclick="showSection('create')">🎮 Create Game</div>
            <div class="nav-item" onclick="showSection('profile')">👤 Profile</div>
            <div class="nav-item" onclick="showSection('chat')">💬 Chat</div>
        </div>
        <div class="live-badge">🔴 LIVE ON CORE</div>
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">
                    <span class="connection-indicator disconnected"></span>Not Connected
                </div>
                <div class="balance" id="balanceDisplay">0.00 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn">
                <i class="fas fa-plug"></i> Connect Wallet
            </button>
            <button class="disconnect-btn hidden" id="disconnectBtn">Disconnect</button>
        </div>
    </div>

    <!-- Age Verification Modal -->
    <div class="age-verification" id="ageVerificationModal">
        <div class="verification-content">
            <h1><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h1>
            <p>This platform contains blockchain-based games that involve financial stakes. You must be 18 years or older to access this content.</p>
            <div class="warning">
                <p><i class="fas fa-exclamation-circle"></i> Gambling involves risk. Please play responsibly. Only gamble with funds you can afford to lose.</p>
            </div>
            <p>By entering this site, you confirm that you are at least 18 years of age and agree to our Terms of Service.</p>
            <div class="verification-buttons">
                <button class="verify-btn accept" onclick="verifyAge(true)">I am 18+</button>
                <button class="verify-btn decline" onclick="verifyAge(false)">Under 18</button>
            </div>
        </div>
    </div>

    <!-- Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash"></div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Smart Contract Status -->
            <div class="contract-status">
                <h3>🔐 Smart Contract Status</h3>
                <div class="contract-address" id="contractAddress">
                    0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A
                    <button class="copy-btn" onclick="copyContractAddress()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <div id="contractStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to Core Blockchain...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="connectionProgress" style="width: 0%"></div>
                </div>
            </div>

            <!-- Live Statistics -->
            <div class="live-lobby">
                <h3>📊 Live Platform Stats</h3>
                <div class="lobby-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalPlayers">0</div>
                        <div class="stat-label">Online Players</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalGames">0</div>
                        <div class="stat-label">Active Games</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalVolume">0</div>
                        <div class="stat-label">CORE Volume</div>
                    </div>
                </div>
            </div>

            <!-- Recent Activity Feed -->
            <div class="live-lobby">
                <h3>🔥 Recent Activity</h3>
                <div id="activityFeed">
                    <!-- Activity items will be populated here -->
                </div>
            </div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <!-- Game Lobby Section -->
            <div id="lobbySection">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2>🎯 Live Game Lobby</h2>
                        <button onclick="refreshLobby()" class="btn-primary" style="width: auto; padding: 0.5rem 1rem;">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                    
                    <div id="gamesList">
                        <!-- Games will be populated here -->
                    </div>
                    
                    <div id="noGames" class="hidden" style="text-align: center; padding: 3rem; color: #aaa;">
                        <i class="fas fa-gamepad" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3>No Active Games</h3>
                        <p>Be the first to create a game and start earning CORE!</p>
                        <button onclick="showSection('create')" class="btn-primary" style="margin-top: 1rem;">
                            Create First Game
                        </button>
                    </div>
                </div>
            </div>

            <!-- Create Game Section -->
            <div id="createSection" class="hidden">
                <div class="create-game-section">
                    <h2>🎮 Create New Game</h2>
                    
                    <div class="game-type-selector">
                        <div class="game-type-card" data-type="chess" onclick="selectGameType('chess')">
                            <div class="game-icon">♟️</div>
                            <h3>Chess Masters</h3>
                            <p>Strategic blockchain chess</p>
                            <small>5-30 minutes per game</small>
                        </div>
                        <div class="game-type-card" data-type="checkers" onclick="selectGameType('checkers')">
                            <div class="game-icon">⚫</div>
                            <h3>Checkers Pro</h3>
                            <p>Fast-paced checkers</p>
                            <small>3-15 minutes per game</small>
                        </div>
                        <div class="game-type-card" data-type="rps" onclick="selectGameType('rps')">
                            <div class="game-icon">✂️</div>
                            <h3>Rock Paper Scissors</h3>
                            <p>Quick decision game</p>
                            <small>1-3 minutes per game</small>
                        </div>
                    </div>
                    
                    <div style="margin: 2rem 0;">
                        <label for="gameStake" style="display: block; margin-bottom: 0.5rem; color: #4ecdc4; font-weight: bold;">
                            Stake Amount (CORE)
                        </label>
                        <input type="number" class="stake-input" id="gameStake" 
                               placeholder="Enter stake amount (min 0.01 CORE)" 
                               min="0.01" step="0.01" 
                               oninput="updateCreateButton()">
                        <small style="color: #aaa; display: block; margin-top: 0.5rem;">
                            Winner takes 97% of total pool (3% platform fee)
                        </small>
                    </div>
                    
                    <button class="create-btn" id="createGameBtn" onclick="createGame()" disabled>
                        <i class="fas fa-plus"></i> Select Game Type & Enter Stake
                    </button>
                </div>
            </div>

            <!-- Profile Section -->
            <div id="profileSection" class="hidden">
                <div class="live-lobby">
                    <h3 style="color: #4ecdc4; margin-bottom: 1rem;">👤 Player Profile</h3>
                    <div class="lobby-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="profileGamesPlayed">0</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileGamesWon">0</div>
                            <div class="stat-label">Games Won</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileTotalEarned">0</div>
                            <div class="stat-label">CORE Earned</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="profileWinRate">0%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                    </div>
                    
                    <!-- Game History -->
                    <div style="margin-top: 2rem;">
                        <h4 style="margin-bottom: 1rem; color: #4ecdc4;">Recent Games</h4>
                        <div id="gameHistory">
                            <!-- Game history will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Section -->
            <div id="chatSection" class="hidden">
                <div class="live-lobby" style="height: 500px; display: flex; flex-direction: column;">
                    <h3 style="margin-bottom: 1rem;">💬 Global Chat</h3>
                    <div style="flex: 1; overflow-y: auto; background: rgba(0, 0, 0, 0.2); border-radius: 10px; padding: 1rem; margin-bottom: 1rem;" id="chatMessages">
                        <!-- Chat messages will be populated here -->
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" placeholder="Type your message..." id="chatInput" 
                               style="flex: 1; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 25px; padding: 0.8rem 1rem; color: white;" 
                               onkeypress="handleChatKeyPress(event)" maxlength="200">
                        <button onclick="sendChatMessage()" class="btn-primary">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
// Enhanced Blockchain Integration with Real Smart Contract
const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
const CORE_CHAIN_ID = "0x45c";

// Real Smart Contract ABI for game functions
const GAME_CONTRACT_ABI = [
    "function createGame(uint8 gameType, uint256 timeout) external payable returns (uint256)",
    "function joinGame(uint256 gameId) external payable",
    "function submitMove(uint256 gameId, bytes32 moveHash) external",
    "function revealMove(uint256 gameId, string memory move, uint256 nonce) external",
    "function claimWin(uint256 gameId) external",
    "function getGame(uint256 gameId) external view returns (address player1, address player2, uint256 stake, uint8 status, uint8 gameType, uint256 createdAt)",
    "function getActiveGames() external view returns (uint256[] memory)",
    "function withdrawWinnings(uint256 gameId) external",
    "event GameCreated(uint256 indexed gameId, address indexed creator, uint8 gameType, uint256 stake)",
    "event GameJoined(uint256 indexed gameId, address indexed player2)",
    "event GameFinished(uint256 indexed gameId, address indexed winner, uint256 winnings)"
];

// Global Variables
let web3Provider = null;
let userAccount = null;
let gameContract = null;
let currentBalance = 0;
let activeGames = [];
let selectedGameType = null;
let gameUpdateInterval = null;
let playerStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarned: 0,
    winRate: 0
};

// WebSocket for real-time updates (simulated for demo)
let wsConnection = null;
let connectionAttempts = 0;
const MAX_CONNECTION_ATTEMPTS = 5;

// Initialize blockchain connection
async function initializeBlockchain() {
    try {
        updateConnectionProgress(20);
        
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not installed');
        }

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        updateConnectionProgress(40);

        // Check network
        const network = await web3Provider.getNetwork();
        console.log('Current network:', network);
        
        updateConnectionProgress(60);
        
        if (network.chainId !== parseInt(CORE_CHAIN_ID, 16)) {
            await switchToCore();
        }
        
        updateConnectionProgress(80);
        
        // Initialize contract (read-only for now)
        gameContract = new ethers.Contract(
            GAME_CONTRACT_ADDRESS, 
            GAME_CONTRACT_ABI, 
            web3Provider
        );
        
        updateConnectionProgress(100);
        updateContractStatus('connected');
        
        // Start listening for events
        startEventListeners();
        
        return true;
    } catch (error) {
        console.error('Blockchain initialization failed:', error);
        updateContractStatus('error', error.message);
        return false;
    }
}

// Enhanced wallet connection
async function connectWallet() {
    try {
        showTransactionStatus('🔄 Connecting wallet...', '');
        
        if (!await initializeBlockchain()) {
            return;
        }

        const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
        });
        
        if (accounts.length === 0) {
            throw new Error('No accounts found');
        }

        userAccount = accounts[0];
        
        // Get signer for contract interactions
        const signer = web3Provider.getSigner();
        gameContract = gameContract.connect(signer);
        
        // Get balance
        const balance = await web3Provider.getBalance(userAccount);
        currentBalance = parseFloat(ethers.utils.formatEther(balance));
        
        // Update UI
        updateConnectionStatus('connected');
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
        document.getElementById('connectBtn').classList.add('hidden');
        document.getElementById('disconnectBtn').classList.remove('hidden');
        
        showTransactionStatus('✅ Wallet connected successfully!', '');
        
        // Load user data
        await loadUserData();
        await refreshLobby();
        
        // Start real-time updates
        startRealTimeUpdates();
        
        // Listen for account changes
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);
        
    } catch (error) {
        console.error('Failed to connect wallet:', error);
        showTransactionStatus('❌ Failed to connect wallet: ' + error.message, '');
        updateConnectionStatus('disconnected');
    }
}

// Switch to Core network
async function switchToCore() {
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: CORE_CHAIN_ID }],
        });
    } catch (switchError) {
        if (switchError.code === 4902) {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: CORE_CHAIN_ID,
                        chainName: 'Core Blockchain',
                        nativeCurrency: {
                            name: 'CORE',
                            symbol: 'CORE',
                            decimals: 18
                        },
                        rpcUrls: ['https://rpc.coredao.org'],
                        blockExplorerUrls: ['https://scan.coredao.org']
                    }],
                });
            } catch (addError) {
                throw new Error('Failed to add Core network');
            }
        } else {
            throw switchError;
        }
    }
}

// Real game creation with smart contract
async function createGameOnChain(gameType, stakeAmount) {
    if (!gameContract || !userAccount) {
        throw new Error('Wallet not connected');
    }
    
    try {
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        showTransactionStatus('🔄 Creating game on blockchain...', '');
        
        // Set timeout based on game type (in seconds)
        const timeouts = { chess: 1800, checkers: 900, rps: 300 }; // 30min, 15min, 5min
        const timeout = timeouts[gameType] || 900;
        
        const gameTypeId = { chess: 0, checkers: 1, rps: 2 }[gameType];
        
        const tx = await gameContract.createGame(gameTypeId, timeout, {
            value: stakeWei,
            gasLimit: 300000
        });
        
        showTransactionStatus('⏳ Transaction submitted...', tx.hash);
        
        const receipt = await tx.wait();
        
        // Extract game ID from events
        const gameCreatedEvent = receipt.events?.find(e => e.event === 'GameCreated');
        const gameId = gameCreatedEvent?.args?.gameId?.toNumber();
        
        if (!gameId) {
            throw new Error('Failed to get game ID from transaction');
        }
        
        showTransactionStatus('✅ Game created successfully!', tx.hash);
        
        // Add to local tracking
        const newGame = {
            id: gameId,
            type: gameType,
            creator: userAccount,
            stake: stakeAmount,
            status: 'waiting',
            createdAt: Date.now(),
            txHash: tx.hash
        };
        
        activeGames.push(newGame);
        addActivityFeedItem(`🎮 You created a ${gameType} game with ${stakeAmount} CORE stake`);
        
        return gameId;
        
    } catch (error) {
        console.error('Failed to create game:', error);
        throw new Error('Failed to create game: ' + error.message);
    }
}

// Join game on blockchain
async function joinGameOnChain(gameId, stakeAmount) {
    if (!gameContract || !userAccount) {
        throw new Error('Wallet not connected');
    }
    
    try {
        const stakeWei = ethers.utils.parseEther(stakeAmount.toString());
        
        showTransactionStatus('🔄 Joining game...', '');
        
        const tx = await gameContract.joinGame(gameId, {
            value: stakeWei,
            gasLimit: 200000
        });
        
        showTransactionStatus('⏳ Transaction submitted...', tx.hash);
        
        await tx.wait();
        
        showTransactionStatus('✅ Joined game successfully!', tx.hash);
        
        addActivityFeedItem(`⚔️ You joined game #${gameId} with ${stakeAmount} CORE stake`);
        
        return true;
        
    } catch (error) {
        console.error('Failed to join game:', error);
        throw new Error('Failed to join game: ' + error.message);
    }
}

// Load active games from blockchain
async function loadActiveGamesFromChain() {
    if (!gameContract) {
        return [];
    }
    
    try {
        const gameIds = await gameContract.getActiveGames();
        const games = [];
        
        for (const gameId of gameIds) {
            try {
                const gameData = await gameContract.getGame(gameId);
                
                if (gameData && gameData.player1 !== ethers.constants.AddressZero) {
                    games.push({
                        id: gameId.toNumber(),
                        creator: gameData.player1,
                        player2: gameData.player2,
                        stake: parseFloat(ethers.utils.formatEther(gameData.stake)),
                        status: gameData.status === 0 ? 'waiting' : 'playing',
                        gameType: ['chess', 'checkers', 'rps'][gameData.gameType],
                        createdAt: gameData.createdAt.toNumber() * 1000
                    });
                }
            } catch (error) {
                console.error(`Failed to load game ${gameId}:`, error);
            }
        }
        
        return games;
    } catch (error) {
        console.error('Failed to load active games:', error);
        return [];
    }
}

// Event listeners for real-time updates
function startEventListeners() {
    if (!gameContract) return;
    
    try {
        // Listen for new games
        gameContract.on('GameCreated', (gameId, creator, gameType, stake) => {
            console.log('New game created:', { gameId: gameId.toNumber(), creator, gameType, stake });
            
            if (creator !== userAccount) {
                addActivityFeedItem(`🆕 New ${['chess', 'checkers', 'rps'][gameType]} game created by ${creator.substring(0, 6)}...`);
                refreshLobby();
            }
        });
        
        // Listen for games being joined
        gameContract.on('GameJoined', (gameId, player2) => {
            console.log('Game joined:', { gameId: gameId.toNumber(), player2 });
            
            if (player2 !== userAccount) {
                addActivityFeedItem(`⚔️ Game #${gameId.toNumber()} was joined by ${player2.substring(0, 6)}...`);
                refreshLobby();
            }
        });
        
        // Listen for game completions
        gameContract.on('GameFinished', (gameId, winner, winnings) => {
            console.log('Game finished:', { gameId: gameId.toNumber(), winner, winnings });
            
            const winningsEther = parseFloat(ethers.utils.formatEther(winnings));
            
            if (winner === userAccount) {
                addActivityFeedItem(`🏆 You won game #${gameId.toNumber()} and earned ${winningsEther.toFixed(4)} CORE!`);
                playerStats.gamesWon++;
                playerStats.totalEarned += winningsEther;
            } else {
                addActivityFeedItem(`🎯 Game #${gameId.toNumber()} finished - ${winner.substring(0, 6)}... won ${winningsEther.toFixed(4)} CORE`);
            }
            
            playerStats.gamesPlayed++;
            updatePlayerStats();
            refreshLobby();
        });
        
    } catch (error) {
        console.error('Failed to start event listeners:', error);
    }
}

// Update connection progress
function updateConnectionProgress(percentage) {
    const progressBar = document.getElementById('connectionProgress');
    if (progressBar) {
        progressBar.style.width = percentage + '%';
    }
}

// Update contract status
function updateContractStatus(status, message = '') {
    const statusElement = document.getElementById('contractStatus');
    const indicator = statusElement.querySelector('.connection-indicator');
    
    switch (status) {
        case 'connected':
            indicator.className = 'connection-indicator connected';
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected to Core Blockchain';
            break;
        case 'disconnected':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Disconnected';
            break;
        case 'error':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = `<span class="connection-indicator disconnected"></span>Error: ${message}`;
            break;
        default:
            indicator.className = 'connection-indicator pending';
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>Connecting...';
    }
}

// Update connection status in header
function updateConnectionStatus(status) {
    const statusElement = document.getElementById('connectionStatus');
    const indicator = statusElement.querySelector('.connection-indicator');
    
    switch (status) {
        case 'connected':
            indicator.className = 'connection-indicator connected';
            statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected';
            break;
        case 'disconnected':
            indicator.className = 'connection-indicator disconnected';
            statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Not Connected';
            break;
        case 'pending':
            indicator.className = 'connection-indicator pending';
            statusElement.innerHTML = '<span class="connection-indicator pending"></span>Connecting...';
            break;
    }
}
</script>
<script>
// Game Lobby Management
let currentSection = 'lobby';

// Navigation
function showSection(section) {
    // Hide all sections
    document.querySelectorAll('[id$="Section"]').forEach(el => el.classList.add('hidden'));
    
    // Show selected section
    document.getElementById(section + 'Section').classList.remove('hidden');
    
    // Update navigation
    document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
    event.target.classList.add('active');
    
    currentSection = section;
    
    // Load section-specific data
    if (section === 'lobby') {
        refreshLobby();
    } else if (section === 'profile') {
        updatePlayerStats();
        loadGameHistory();
    }
}

// Game type selection
function selectGameType(type) {
    selectedGameType = type;
    
    // Update UI
    document.querySelectorAll('.game-type-card').forEach(card => {
        card.classList.remove('selected');
    });
    
    document.querySelector(`[data-type="${type}"]`).classList.add('selected');
    
    updateCreateButton();
}

// Update create button state
function updateCreateButton() {
    const btn = document.getElementById('createGameBtn');
    const stakeInput = document.getElementById('gameStake');
    const stake = parseFloat(stakeInput.value);
    
    if (selectedGameType && stake >= 0.01) {
        btn.disabled = false;
        btn.innerHTML = `<i class="fas fa-plus"></i> Create ${selectedGameType.toUpperCase()} Game (${stake} CORE)`;
    } else if (selectedGameType && !stake) {
        btn.disabled = true;
        btn.innerHTML = `<i class="fas fa-plus"></i> Enter Stake Amount`;
    } else if (!selectedGameType && stake >= 0.01) {
        btn.disabled = true;
        btn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type`;
    } else {
        btn.disabled = true;
        btn.innerHTML = `<i class="fas fa-plus"></i> Select Game Type & Enter Stake`;
    }
}

// Create game
async function createGame() {
    const stakeAmount = parseFloat(document.getElementById('gameStake').value);
    
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (!selectedGameType) {
        showTransactionStatus('❌ Please select a game type', '');
        return;
    }
    
    if (!stakeAmount || stakeAmount < 0.01) {
        showTransactionStatus('❌ Please enter a valid stake amount (minimum 0.01 CORE)', '');
        return;
    }
    
    if (stakeAmount > currentBalance) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }
    
    try {
        const gameId = await createGameOnChain(selectedGameType, stakeAmount);
        
        // Clear form
        document.getElementById('gameStake').value = '';
        selectedGameType = null;
        document.querySelectorAll('.game-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        updateCreateButton();
        
        // Switch to lobby to see the created game
        showSection('lobby');
        
        // Update balance
        await updateBalance();
        
    } catch (error) {
        showTransactionStatus('❌ Failed to create game: ' + error.message, '');
    }
}

// Refresh game lobby
async function refreshLobby() {
    try {
        showTransactionStatus('🔄 Loading games...', '');
        
        // Load games from blockchain
        if (gameContract) {
            activeGames = await loadActiveGamesFromChain();
        }
        
        // Update UI
        updateGamesDisplay();
        updateLiveStats();
        
        showTransactionStatus('✅ Lobby refreshed', '');
        
    } catch (error) {
        console.error('Failed to refresh lobby:', error);
        showTransactionStatus('❌ Failed to refresh lobby', '');
    }
}

// Update games display
function updateGamesDisplay() {
    const gamesList = document.getElementById('gamesList');
    const noGames = document.getElementById('noGames');
    
    if (activeGames.length === 0) {
        gamesList.innerHTML = '';
        noGames.classList.remove('hidden');
        return;
    }
    
    noGames.classList.add('hidden');
    
    gamesList.innerHTML = activeGames.map(game => {
        const gameIcons = { chess: '♟️', checkers: '⚫', rps: '✂️' };
        const gameNames = { chess: 'Chess Masters', checkers: 'Checkers Pro', rps: 'Rock Paper Scissors' };
        
        const timeAgo = Math.floor((Date.now() - game.createdAt) / 60000);
        const creator = game.creator === userAccount ? 'You' : 
                       game.creator.substring(0, 6) + '...' + game.creator.substring(38);
        
        const canJoin = userAccount && 
                       game.creator !== userAccount && 
                       game.status === 'waiting' && 
                       currentBalance >= game.stake;
        
        return `
            <div class="game-entry fade-in">
                <div class="game-header">
                    <div class="game-title">
                        ${gameIcons[game.type]} ${gameNames[game.type]} #${game.id}
                    </div>
                    <div class="game-status ${game.status === 'waiting' ? 'status-waiting' : 'status-playing'}">
                        <span class="game-indicator indicator-${game.status}"></span>
                        ${game.status.toUpperCase()}
                    </div>
                </div>
                
                <div class="game-details">
                    <div class="detail-item">
                        <div class="detail-label">Creator</div>
                        <div class="detail-value">${creator}</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Stake</div>
                        <div class="detail-value">${game.stake} CORE</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Created</div>
                        <div class="detail-value">${timeAgo}m ago</div>
                    </div>
                </div>
                
                ${canJoin ? 
                    `<button class="join-btn" onclick="joinGame(${game.id}, ${game.stake})">
                        <i class="fas fa-sword"></i> Join Game (${game.stake} CORE)
                    </button>` :
                    game.creator === userAccount ?
                        `<button class="join-btn" disabled style="background: #666; color: #999;">
                            <i class="fas fa-clock"></i> Waiting for Opponent
                        </button>` :
                        !userAccount ?
                            `<button class="join-btn" disabled style="background: #666; color: #999;">
                                <i class="fas fa-wallet"></i> Connect Wallet to Join
                            </button>` :
                            currentBalance < game.stake ?
                                `<button class="join-btn" disabled style="background: #666; color: #999;">
                                    <i class="fas fa-coins"></i> Insufficient Balance
                                </button>` :
                                `<button class="join-btn" disabled style="background: #666; color: #999;">
                                    <i class="fas fa-users"></i> Game Full
                                </button>`
                }
            </div>
        `;
    }).join('');
}

// Join game
async function joinGame(gameId, stakeAmount) {
    if (!userAccount) {
        showTransactionStatus('❌ Please connect your wallet first', '');
        return;
    }
    
    if (currentBalance < stakeAmount) {
        showTransactionStatus('❌ Insufficient CORE balance', '');
        return;
    }
    
    try {
        await joinGameOnChain(gameId, stakeAmount);
        
        // Update balance
        await updateBalance();
        
        // Refresh lobby
        await refreshLobby();
        
        // Start game interface (simplified for demo)
        showTransactionStatus('🎮 Game started! Good luck!', '');
        
    } catch (error) {
        showTransactionStatus('❌ Failed to join game: ' + error.message, '');
    }
}

// Update live statistics
function updateLiveStats() {
    const totalGames = activeGames.length;
    const totalVolume = activeGames.reduce((sum, game) => sum + game.stake, 0);
    const onlinePlayers = totalGames > 0 ? totalGames + Math.floor(Math.random() * 20) + 10 : 0;
    
    document.getElementById('totalPlayers').textContent = onlinePlayers;
    document.getElementById('totalGames').textContent = totalGames;
    document.getElementById('totalVolume').textContent = totalVolume.toFixed(2);
}

// Update player statistics
function updatePlayerStats() {
    if (playerStats.gamesPlayed > 0) {
        playerStats.winRate = ((playerStats.gamesWon / playerStats.gamesPlayed) * 100).toFixed(1);
    } else {
        playerStats.winRate = 0;
    }
    
    document.getElementById('profileGamesPlayed').textContent = playerStats.gamesPlayed;
    document.getElementById('profileGamesWon').textContent = playerStats.gamesWon;
    document.getElementById('profileTotalEarned').textContent = playerStats.totalEarned.toFixed(4);
    document.getElementById('profileWinRate').textContent = playerStats.winRate + '%';
}

// Load game history
function loadGameHistory() {
    const historyContainer = document.getElementById('gameHistory');
    
    // Simulated game history
    const history = [
        { type: 'chess', result: 'won', stake: 0.05, opponent: '0x1234...5678', date: Date.now() - 3600000 },
        { type: 'checkers', result: 'lost', stake: 0.02, opponent: '0x8765...4321', date: Date.now() - 7200000 },
        { type: 'rps', result: 'won', stake: 0.01, opponent: '0x9999...1111', date: Date.now() - 10800000 }
    ];
    
    if (history.length === 0) {
        historyContainer.innerHTML = '<p style="text-align: center; color: #aaa;">No games played yet</p>';
        return;
    }
    
    historyContainer.innerHTML = history.map(game => {
        const timeAgo = Math.floor((Date.now() - game.date) / 60000);
        const resultColor = game.result === 'won' ? '#00ff88' : '#ff6b6b';
        const gameIcons = { chess: '♟️', checkers: '⚫', rps: '✂️' };
        
        return `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.05); border-radius: 5px;">
                <div>
                    <span>${gameIcons[game.type]} ${game.type.toUpperCase()}</span>
                    <span style="color: ${resultColor}; font-weight: bold; margin-left: 0.5rem;">${game.result.toUpperCase()}</span>
                </div>
                <div style="text-align: right; font-size: 0.9rem;">
                    <div>${game.stake} CORE</div>
                    <div style="color: #aaa; font-size: 0.8rem;">${timeAgo}m ago</div>
                </div>
            </div>
        `;
    }).join('');
}

// Activity feed management
function addActivityFeedItem(message) {
    const feed = document.getElementById('activityFeed');
    
    const item = document.createElement('div');
    item.className = 'news-item fade-in';
    item.innerHTML = `
        <div class="news-title">${message}</div>
        <div class="news-time">Just now</div>
    `;
    
    feed.insertBefore(item, feed.firstChild);
    
    // Keep only last 10 items
    while (feed.children.length > 10) {
        feed.removeChild(feed.lastChild);
    }
}

// Copy contract address
function copyContractAddress() {
    navigator.clipboard.writeText(GAME_CONTRACT_ADDRESS).then(() => {
        showTransactionStatus('📋 Contract address copied to clipboard', '');
    }).catch(() => {
        showTransactionStatus('❌ Failed to copy address', '');
    });
}

// Update balance
async function updateBalance() {
    if (!web3Provider || !userAccount) return;
    
    try {
        const balance = await web3Provider.getBalance(userAccount);
        currentBalance = parseFloat(ethers.utils.formatEther(balance));
        document.getElementById('balanceDisplay').textContent = currentBalance.toFixed(4) + ' CORE';
    } catch (error) {
        console.error('Failed to update balance:', error);
    }
}

// Load user data
async function loadUserData() {
    try {
        // Load player stats from local storage (in production, this would come from backend)
        const savedStats = localStorage.getItem(`playerStats_${userAccount}`);
        if (savedStats) {
            playerStats = { ...playerStats, ...JSON.parse(savedStats) };
        }
        
        updatePlayerStats();
    } catch (error) {
        console.error('Failed to load user data:', error);
    }
}

// Save user data
function saveUserData() {
    if (userAccount) {
        localStorage.setItem(`playerStats_${userAccount}`, JSON.stringify(playerStats));
    }
}

// Start real-time updates
function startRealTimeUpdates() {
    // Refresh lobby every 30 seconds
    if (gameUpdateInterval) {
        clearInterval(gameUpdateInterval);
    }
    
    gameUpdateInterval = setInterval(async () => {
        if (currentSection === 'lobby') {
            await refreshLobby();
        }
        await updateBalance();
    }, 30000);
    
    // Simulate activity feed updates
    setInterval(() => {
        if (Math.random() < 0.1) { // 10% chance every 30 seconds
            const activities = [
                '🎮 New player joined the platform',
                '💰 Large stake game created',
                '🏆 Epic battle just finished',
                '⚡ Platform processing new transactions',
                '🔥 High activity detected'
            ];
            
            const randomActivity = activities[Math.floor(Math.random() * activities.length)];
            addActivityFeedItem(randomActivity);
        }
    }, 30000);
}

// Handle account changes
function handleAccountsChanged(accounts) {
    if (accounts.length === 0) {
        disconnectWallet();
    } else if (accounts[0] !== userAccount) {
        userAccount = accounts[0];
        connectWallet();
    }
}

// Handle chain changes
function handleChainChanged(chainId) {
    if (chainId !== CORE_CHAIN_ID) {
        showTransactionStatus('⚠️ Please switch to Core network', '');
        updateConnectionStatus('disconnected');
    } else {
        updateConnectionStatus('connected');
    }
}

// Disconnect wallet
function disconnectWallet() {
    userAccount = null;
    currentBalance = 0;
    gameContract = null;
    
    updateConnectionStatus('disconnected');
    document.getElementById('balanceDisplay').textContent = '0.00 CORE';
    document.getElementById('connectBtn').classList.remove('hidden');
    document.getElementById('disconnectBtn').classList.add('hidden');
    
    // Clear intervals
    if (gameUpdateInterval) {
        clearInterval(gameUpdateInterval);
        gameUpdateInterval = null;
    }
    
    // Save data before disconnect
    saveUserData();
    
    showTransactionStatus('👋 Wallet disconnected', '');
}
</script>
<script>
// Chat System
let chatMessages = [];

// Send chat message
function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message) return;
    
    if (!userAccount) {
        showTransactionStatus('⚠️ Please connect your wallet to chat', '');
        return;
    }
    
    if (message.length > 200) {
        showTransactionStatus('⚠️ Message too long (max 200 characters)', '');
        return;
    }
    
    addChatMessage('You', message);
    chatInput.value = '';
    
    // Simulate responses from other players
    setTimeout(() => {
        const responses = [
            "Good luck with your games! 🎮",
            "Welcome to Crypticus! 🚀",
            "Let's play some blockchain games! ⚔️",
            "Nice strategy! 🧠",
            "The future of gaming is here! 💎",
            "GG everyone! 👏",
            "Anyone up for a high-stakes game?",
            "Just won big! This platform is amazing!",
            "Love the smart contract integration!",
            "Fair play guaranteed by blockchain! ⛓️"
        ];
        
        const usernames = [
            'CryptoKing', 'GameMaster', 'BlockchainBro', 
            'TokenMaster', 'WordWizard', 'ChessGrandmaster',
            'CheckersChamp', 'RPSLegend', 'CoreGamer'
        ];
        
        const randomUser = usernames[Math.floor(Math.random() * usernames.length)];
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        
        addChatMessage(randomUser, randomResponse);
    }, 1000 + Math.random() * 4000);
}

// Add chat message
function addChatMessage(user, message) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'chat-message fade-in';
    
    const timestamp = new Date().toLocaleTimeString('en-US', { 
        hour12: false, 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    
    const isUser = user === 'You';
    const userColor = isUser ? '#4ecdc4' : '#f39c12';
    
    messageDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.3rem;">
            <strong style="color: ${userColor};">${user}:</strong>
            <span style="color: #aaa; font-size: 0.7rem;">${timestamp}</span>
        </div>
        <div style="margin-left: 0.5rem; word-wrap: break-word;">${message}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Keep only last 50 messages
    while (chatMessages.children.length > 50) {
        chatMessages.removeChild(chatMessages.firstChild);
    }
}

// Handle chat key press
function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendChatMessage();
    }
}

// Transaction status display
function showTransactionStatus(message, txHash = '') {
    const statusDiv = document.getElementById('transactionStatus');
    const messageDiv = document.getElementById('txStatusMessage');
    const hashDiv = document.getElementById('txHash');
    
    messageDiv.textContent = message;
    hashDiv.textContent = txHash ? `TX: ${txHash.substring(0, 10)}...${txHash.substring(56)}` : '';
    hashDiv.onclick = txHash ? () => window.open(`https://scan.coredao.org/tx/${txHash}`, '_blank') : null;
    hashDiv.style.cursor = txHash ? 'pointer' : 'default';
    
    statusDiv.classList.add('show');
    
    // Auto-hide after 5 seconds unless it's an error
    if (!message.includes('❌')) {
        setTimeout(() => statusDiv.classList.remove('show'), 5000);
    }
}

// Age verification
function verifyAge(isAdult) {
    if (isAdult) {
        document.getElementById('ageVerificationModal').style.display = 'none';
        sessionStorage.setItem('ageVerified', 'true');
        showTransactionStatus('✅ Age verified. Welcome to Crypticus!');
        
        // Initialize blockchain after age verification
        initializeBlockchain();
    } else {
        alert('Sorry, you must be 18 or older to use this platform.');
        window.location.href = 'https://www.google.com';
    }
}

// Check age verification
function checkAgeVerification() {
    if (!sessionStorage.getItem('ageVerified')) {
        document.getElementById('ageVerificationModal').style.display = 'flex';
        return false;
    }
    return true;
}

// Utility Functions
function formatAddress(address) {
    if (!address) return '---';
    return address.substring(0, 6) + '...' + address.substring(38);
}

function formatTime(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'Just now';
}

function formatCurrency(amount, decimals = 4) {
    return parseFloat(amount).toFixed(decimals);
}

// Error handling
window.addEventListener('error', (event) => {
    console.error('Global error:', event.error);
    showTransactionStatus('❌ An unexpected error occurred', '');
});

// Prevent page refresh on form submission
document.addEventListener('DOMContentLoaded', () => {
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
        form.addEventListener('submit', (e) => {
            e.preventDefault();
        });
    });
});

// Initialize sample chat messages
function initializeSampleChat() {
    const sampleMessages = [
        { user: 'System', message: 'Welcome to Crypticus Global Chat! Connect your wallet to participate.' },
        { user: 'CryptoKing', message: 'Just won 2.5 CORE in Chess! This platform is amazing! 🎉' },
        { user: 'GameMaster', message: 'New high stakes games starting soon! Who\'s ready?' },
        { user: 'BlockchainBro', message: 'Love how fair and transparent the smart contracts make everything!' },
        { user: 'CheckersChamp', message: 'Anyone up for some fast checkers? Looking for worthy opponents!' }
    ];
    
    sampleMessages.forEach((msg, index) => {
        setTimeout(() => {
            addChatMessage(msg.user, msg.message);
        }, index * 1000);
    });
}

// Auto-refresh functions
function startAutoRefresh() {
    // Refresh lobby every 30 seconds if on lobby page
    setInterval(() => {
        if (currentSection === 'lobby' && userAccount) {
            refreshLobby();
        }
    }, 30000);
    
    // Update live stats every 15 seconds
    setInterval(() => {
        updateLiveStats();
    }, 15000);
    
    // Simulate random chat messages
    setInterval(() => {
        if (Math.random() < 0.15) { // 15% chance every 45 seconds
            const messages = [
                "New game starting soon! 🎮",
                "Just had an epic battle! GG!",
                "This platform keeps getting better!",
                "Blockchain gaming is the future! 🚀",
                "Fair play guaranteed by smart contracts! ⛓️",
                "Who wants to challenge me? 😈",
                "Just earned some CORE! Feeling good! 💰"
            ];
            
            const users = ['CryptoGamer', 'BlockchainMaster', 'CoreEnthusiast', 'GameLover', 'StrategyKing'];
            const randomUser = users[Math.floor(Math.random() * users.length)];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            
            if (currentSection === 'chat') {
                addChatMessage(randomUser, randomMessage);
            }
        }
    }, 45000);
}

// Clean up old data
function cleanupOldData() {
    // Clean up old games (older than 1 hour)
    const oneHourAgo = Date.now() - 3600000;
    activeGames = activeGames.filter(game => game.createdAt > oneHourAgo);
    
    // Clean up activity feed
    const feed = document.getElementById('activityFeed');
    if (feed && feed.children.length > 20) {
        while (feed.children.length > 20) {
            feed.removeChild(feed.lastChild);
        }
    }
}

// Network status monitoring
function checkNetworkStatus() {
    if (web3Provider) {
        web3Provider.getNetwork().then(network => {
            if (network.chainId !== parseInt(CORE_CHAIN_ID, 16)) {
                updateConnectionStatus('disconnected');
                showTransactionStatus('⚠️ Wrong network detected. Please switch to Core.', '');
            } else {
                updateConnectionStatus('connected');
            }
        }).catch(error => {
            console.error('Network check failed:', error);
            updateConnectionStatus('disconnected');
        });
    }
}

// Keyboard shortcuts
document.addEventListener('keydown', (event) => {
    // Ctrl/Cmd + R to refresh lobby
    if ((event.ctrlKey || event.metaKey) && event.key === 'r' && currentSection === 'lobby') {
        event.preventDefault();
        refreshLobby();
    }
    
    // Escape to close transaction status
    if (event.key === 'Escape') {
        document.getElementById('transactionStatus').classList.remove('show');
    }
});

// Visibility change handling (pause updates when tab is not active)
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        // Resume updates when tab becomes visible
        if (userAccount && currentSection === 'lobby') {
            refreshLobby();
        }
    }
});

// Connection recovery
let connectionRetryCount = 0;
const MAX_RETRY_COUNT = 3;

async function attemptConnectionRecovery() {
    if (connectionRetryCount >= MAX_RETRY_COUNT) {
        showTransactionStatus('❌ Connection failed. Please refresh the page.', '');
        return;
    }
    
    connectionRetryCount++;
    showTransactionStatus(`🔄 Attempting to reconnect... (${connectionRetryCount}/${MAX_RETRY_COUNT})`, '');
    
    try {
        await initializeBlockchain();
        connectionRetryCount = 0; // Reset on success
        showTransactionStatus('✅ Connection restored!', '');
    } catch (error) {
        setTimeout(attemptConnectionRecovery, 5000); // Retry after 5 seconds
    }
}

// Performance monitoring
let performanceMetrics = {
    transactionTimes: [],
    lobbyRefreshTimes: [],
    errorCount: 0
};

function recordPerformanceMetric(action, duration) {
    if (action === 'transaction') {
        performanceMetrics.transactionTimes.push(duration);
        if (performanceMetrics.transactionTimes.length > 10) {
            performanceMetrics.transactionTimes.shift();
        }
    } else if (action === 'lobbyRefresh') {
        performanceMetrics.lobbyRefreshTimes.push(duration);
        if (performanceMetrics.lobbyRefreshTimes.length > 10) {
            performanceMetrics.lobbyRefreshTimes.shift();
        }
    }
}

// Event listeners setup
document.getElementById('connectBtn').addEventListener('click', connectWallet);
document.getElementById('disconnectBtn').addEventListener('click', disconnectWallet);

// Auto-hide transaction status on click
document.getElementById('transactionStatus').addEventListener('click', () => {
    document.getElementById('transactionStatus').classList.remove('show');
});

// Save user data before page unload
window.addEventListener('beforeunload', () => {
    saveUserData();
    if (userAccount) {
        localStorage.setItem('walletConnected', 'true');
    } else {
        localStorage.removeItem('walletConnected');
    }
});
</script>
<script>
// Main initialization function
async function initializePlatform() {
    console.log('🚀 Initializing Crypticus Gaming Platform...');
    
    try {
        // Check age verification first
        if (!checkAgeVerification()) {
            return; // Wait for age verification
        }
        
        // Initialize blockchain connection
        await initializeBlockchain();
        
        // Auto-connect wallet if previously connected
        if (localStorage.getItem('walletConnected') === 'true') {
            setTimeout(async () => {
                try {
                    await connectWallet();
                } catch (error) {
                    console.error('Auto-connect failed:', error);
                    localStorage.removeItem('walletConnected');
                }
            }, 1000);
        }
        
        // Initialize chat with sample messages
        initializeSampleChat();
        
        // Start auto-refresh intervals
        startAutoRefresh();
        
        // Initial lobby refresh
        refreshLobby();
        
        // Setup periodic cleanup
        setInterval(cleanupOldData, 300000); // Every 5 minutes
        
        // Setup network monitoring
        setInterval(checkNetworkStatus, 60000); // Every minute
        
        // Setup activity feed
        addActivityFeedItem('🚀 Platform initialized successfully');
        addActivityFeedItem('🔗 Connected to Core Blockchain');
        addActivityFeedItem('🎮 Ready for gaming!');
        
        console.log('✅ Platform initialization complete!');
        
    } catch (error) {
        console.error('❌ Platform initialization failed:', error);
        showTransactionStatus('❌ Platform initialization failed: ' + error.message, '');
    }
}

// Enhanced game statistics
function updateGameStatistics() {
    const stats = {
        totalGames: activeGames.length,
        waitingGames: activeGames.filter(g => g.status === 'waiting').length,
        playingGames: activeGames.filter(g => g.status === 'playing').length,
        totalVolume: activeGames.reduce((sum, game) => sum + game.stake, 0),
        averageStake: activeGames.length > 0 ? 
            (activeGames.reduce((sum, game) => sum + game.stake, 0) / activeGames.length) : 0,
        chessGames: activeGames.filter(g => g.type === 'chess').length,
        checkersGames: activeGames.filter(g => g.type === 'checkers').length,
        rpsGames: activeGames.filter(g => g.type === 'rps').length
    };
    
    return stats;
}

// Platform health monitoring
function monitorPlatformHealth() {
    const health = {
        blockchainConnected: !!web3Provider,
        walletConnected: !!userAccount,
        contractInitialized: !!gameContract,
        activeGamesLoaded: activeGames.length >= 0,
        chatFunctional: true,
        lastRefresh: Date.now()
    };
    
    const healthScore = Object.values(health).filter(Boolean).length / Object.keys(health).length;
    
    if (healthScore < 0.8) {
        console.warn('Platform health below optimal:', health);
        if (healthScore < 0.5) {
            attemptConnectionRecovery();
        }
    }
    
    return health;
}

// Advanced error recovery
async function handleCriticalError(error, context) {
    console.error(`Critical error in ${context}:`, error);
    performanceMetrics.errorCount++;
    
    // Try to recover based on error type
    if (error.message.includes('network')) {
        await attemptConnectionRecovery();
    } else if (error.message.includes('user rejected')) {
        showTransactionStatus('❌ Transaction rejected by user', '');
    } else if (error.message.includes('insufficient funds')) {
        showTransactionStatus('❌ Insufficient funds for transaction', '');
    } else {
        showTransactionStatus(`❌ Error in ${context}: ${error.message}`, '');
    }
}

// Game session management
class GameSession {
    constructor(gameId, gameType, stake) {
        this.gameId = gameId;
        this.gameType = gameType;
        this.stake = stake;
        this.startTime = Date.now();
        this.moves = [];
        this.status = 'active';
    }
    
    addMove(move) {
        this.moves.push({
            move: move,
            timestamp: Date.now(),
            player: userAccount
        });
    }
    
    getGameDuration() {
        return Date.now() - this.startTime;
    }
    
    endGame(result) {
        this.status = 'finished';
        this.endTime = Date.now();
        this.result = result;
        
        // Update player stats
        playerStats.gamesPlayed++;
        if (result === 'won') {
            playerStats.gamesWon++;
            playerStats.totalEarned += this.stake * 1.94; // 97% of total pool
        }
        
        saveUserData();
        updatePlayerStats();
    }
}

// Game session tracking
let currentGameSession = null;

// Advanced transaction handling
async function executeTransaction(transactionFunction, description) {
    const startTime = Date.now();
    
    try {
        showTransactionStatus(`🔄 ${description}...`, '');
        
        const result = await transactionFunction();
        
        const duration = Date.now() - startTime;
        recordPerformanceMetric('transaction', duration);
        
        showTransactionStatus(`✅ ${description} successful!`, result.hash || '');
        
        return result;
    } catch (error) {
        const duration = Date.now() - startTime;
        await handleCriticalError(error, description);
        throw error;
    }
}

// Enhanced lobby features
function setupAdvancedLobbyFeatures() {
    // Game filtering
    window.filterGames = function(filterType) {
        const filteredGames = filterType === 'all' ? 
            activeGames : 
            activeGames.filter(game => game.type === filterType);
        
        // Update display with filtered games
        updateGamesDisplay(filteredGames);
    };
    
    // Game sorting
    window.sortGames = function(sortBy) {
        let sortedGames = [...activeGames];
        
        switch (sortBy) {
            case 'stake-high':
                sortedGames.sort((a, b) => b.stake - a.stake);
                break;
            case 'stake-low':
                sortedGames.sort((a, b) => a.stake - b.stake);
                break;
            case 'newest':
                sortedGames.sort((a, b) => b.createdAt - a.createdAt);
                break;
            case 'oldest':
                sortedGames.sort((a, b) => a.createdAt - b.createdAt);
                break;
        }
        
        activeGames = sortedGames;
        updateGamesDisplay();
    };
}

// WebSocket simulation for real-time updates
function simulateWebSocketConnection() {
    // Simulate periodic updates from other players
    setInterval(() => {
        if (Math.random() < 0.3) { // 30% chance every 10 seconds
            const updateTypes = [
                'game_created',
                'game_joined', 
                'game_finished',
                'player_joined',
                'new_message'
            ];
            
            const updateType = updateTypes[Math.floor(Math.random() * updateTypes.length)];
            handleRealtimeUpdate(updateType);
        }
    }, 10000);
}

// Handle real-time updates
function handleRealtimeUpdate(updateType) {
    switch (updateType) {
        case 'game_created':
            if (Math.random() < 0.5) { // 50% chance to add a new game
                simulateNewGame();
            }
            break;
            
        case 'game_joined':
            if (activeGames.length > 0) {
                const waitingGames = activeGames.filter(g => g.status === 'waiting');
                if (waitingGames.length > 0) {
                    const randomGame = waitingGames[Math.floor(Math.random() * waitingGames.length)];
                    randomGame.status = 'playing';
                    updateGamesDisplay();
                    addActivityFeedItem(`⚔️ Game #${randomGame.id} started!`);
                }
            }
            break;
            
        case 'game_finished':
            if (activeGames.length > 0) {
                const playingGames = activeGames.filter(g => g.status === 'playing');
                if (playingGames.length > 0) {
                    const randomGame = playingGames[Math.floor(Math.random() * playingGames.length)];
                    activeGames = activeGames.filter(g => g.id !== randomGame.id);
                    updateGamesDisplay();
                    addActivityFeedItem(`🏆 Game #${randomGame.id} finished! Winner earned ${(randomGame.stake * 1.94).toFixed(4)} CORE`);
                }
            }
            break;
    }
}

// Simulate new game creation
function simulateNewGame() {
    const gameTypes = ['chess', 'checkers', 'rps'];
    const stakes = [0.01, 0.02, 0.05, 0.1, 0.25, 0.5, 1.0];
    
    const newGame = {
        id: Math.floor(Math.random() * 1000000),
        type: gameTypes[Math.floor(Math.random() * gameTypes.length)],
        creator: '0x' + Math.random().toString(16).substring(2, 42),
        stake: stakes[Math.floor(Math.random() * stakes.length)],
        status: 'waiting',
        createdAt: Date.now()
    };
    
    activeGames.push(newGame);
    updateGamesDisplay();
    addActivityFeedItem(`🎮 New ${newGame.type} game created with ${newGame.stake} CORE stake`);
}

// Platform analytics
function trackUserAction(action, details = {}) {
    const analyticsData = {
        action: action,
        timestamp: Date.now(),
        userAccount: userAccount,
        details: details,
        sessionId: sessionStorage.getItem('sessionId') || 'anonymous'
    };
    
    // In production, this would send to analytics service
    console.log('Analytics:', analyticsData);
    
    // Store locally for demo
    let analytics = JSON.parse(localStorage.getItem('crypticus_analytics') || '[]');
    analytics.push(analyticsData);
    
    // Keep only last 100 events
    if (analytics.length > 100) {
        analytics = analytics.slice(-100);
    }
    
    localStorage.setItem('crypticus_analytics', JSON.stringify(analytics));
}

// Enhanced navigation with analytics
function showSectionWithAnalytics(section) {
    trackUserAction('navigation', { section: section, from: currentSection });
    showSection(section);
}

// Initialize session
function initializeSession() {
    if (!sessionStorage.getItem('sessionId')) {
        sessionStorage.setItem('sessionId', 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2));
    }
    
    trackUserAction('session_start', {
        userAgent: navigator.userAgent,
        timestamp: Date.now()
    });
}

// Main DOMContentLoaded event
document.addEventListener('DOMContentLoaded', async () => {
    console.log('🎮 Crypticus Gaming Platform Loading...');
    
    // Initialize session
    initializeSession();
    
    // Setup advanced features
    setupAdvancedLobbyFeatures();
    
    // Start WebSocket simulation
    simulateWebSocketConnection();
    
    // Initialize platform
    await initializePlatform();
    
    // Setup health monitoring
    setInterval(monitorPlatformHealth, 30000); // Every 30 seconds
    
    // Track platform load
    trackUserAction('platform_loaded', {
        loadTime: Date.now(),
        userAgent: navigator.userAgent
    });
    
    console.log('🚀 Crypticus Gaming Platform Ready!');
});

// Service worker registration for offline support
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
            .then((registration) => {
                console.log('ServiceWorker registration successful');
            })
            .catch((error) => {
                console.log('ServiceWorker registration failed');
            });
    });
}

// Performance optimization
function optimizePerformance() {
    // Debounce rapid updates
    let updateTimeout;
    window.debouncedUpdate = function(updateFunction, delay = 300) {
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(updateFunction, delay);
    };
    
    // Lazy load images
    const lazyImages = document.querySelectorAll('img[data-src]');
    const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                img.removeAttribute('data-src');
                imageObserver.unobserve(img);
            }
        });
    });
    
    lazyImages.forEach(img => imageObserver.observe(img));
}

// Initialize performance optimizations
optimizePerformance();

console.log('✨ All systems initialized successfully!');
</script>

</body>
</html>
