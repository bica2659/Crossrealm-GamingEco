<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CrossRealm Gaming - Play2Earn on Core Blockchain</title>
    <meta name="description" content="Play multiplayer games and earn CORE tokens on the blockchain. Chess, Checkers, Word Games with real crypto rewards.">
    <meta property="og:title" content="CrossRealm Gaming - Blockchain Gaming Platform">
    <meta property="og:description" content="Earn CORE tokens by playing skill-based games">
    <meta property="og:image" content="https://crossrealm.netlify.app/og-image.jpg">
    <meta name="theme-color" content="#667eea">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQ3Jvc3NSZWFsbSBHYW1pbmciLCJzaG9ydF9uYW1lIjoiQ3Jvc3NSZWFsbSIsImRlc2NyaXB0aW9uIjoiQmxvY2tjaGFpbiBHYW1pbmcgUGxhdGZvcm0iLCJzdGFydF91cmwiOiIvIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJ0aGVtZV9jb2xvciI6IiM2NjdlZWEiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzFhMWExYSIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVEE0SWlCb1pXbG5hSFE5SWpFd09DSWdkbWxsZDBKdmVEMGlNQ0F3SURRME5DQTBORFFpSUdobGJXNXpQU0pvZEhSd09pOHZkM2QzTG5jekxuQnliMmN2TWpBd01DOXpkbWNpUGp4eVpXTjBJSGRwWkhSb1BTSTBORFFpSUdobGFXZG9kRDBpTkRRMElpQm1hV3hzUFNJak5qWTNaV1ZoSWk4K1BIUmxlSFFnZUQwaU1qSXlJaUI1UFNJeU1qSWlJSFJsZUhRdFlXNWphRzl5UFNKdGFXUmtiR1VpSUdacGJHdzlJaU0zWmpabVptWWlJR1p2Ym5RdGMybDZaVDBpTXpaaUlpQm1iMjUwTFhkbGFXZG9kRDBpWW05c1pDSStRMUpQVTFOU1JVRk1UVHd2ZEdWNGRENDhMM04yWno0PSIsInNpemVzIjoiMTkyeDE5MiIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn0seyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWdkbWxsZDBKdmVEMGlNQ0F3SURRME5DQTBORFFpSUhocGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxuQnliMmN2TWpBd01DOXpkbWNpUGp4eVpXTjBJSGRwWkhSb1BTSTBORFFpSUdobGFXZG9kRDBpTkRRMElpQm1hV3hzUFNJak5qWTNaV1ZoSWk4K1BIUmxlSFFnZUQwaU1qVTJJaUI1UFNJeU5UWWlJSFJsZUhRdFlXNWphRzl5UFNKdGFXUmtiR1VpSUdacGJHeDlJaU0zWmpabVptWWlJR1p2Ym5RdGMybDZaVDBpTkRWaUlpQm1iMjUwTFhkbGFXZG9kRDBpWW05c1pDSStRMUpQVTFOU1JVRk1UVHd2ZEdWNGRENDhMM04yWno0PSIsInNpemVzIjoiNTEyeDUxMiIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">
    
    <!-- External Dependencies -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDQ0NCA0NDQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjQ0NCIgaGVpZ2h0PSI0NDQiIGZpbGw9IiM2NjdlZWEiLz48dGV4dCB4PSIyMjIiIHk9IjIyMiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzdmNmZmZiIgZm9udC1zaXplPSIzNmIiIGZvbnQtd2VpZ2h0PSJib2xkIj5DUk9TU1JFQUxNPC90ZXh0Pjwvc3ZnPg==">
    <style>
        /* ENHANCED CROSSREALM GAMING PLATFORM - CORE STYLES */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #4e54c8;
            --primary-dark: #363a9e;
            --secondary: #f39c12;
            --dark: #1a1c2c;
            --light: #f5f7fa;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f1c40f;
            --gray: #95a5a6;
            --accent: #4ecdc4;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            --gradient-danger: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            --gradient-accent: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
        }

        html, body {
            height: 100%;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        body {
            background: linear-gradient(135deg, #1a1c2c, #2c3e50);
            color: var(--light);
            position: relative;
        }

        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="%23ffffff" stroke-width="0.5" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>') repeat;
            opacity: 0.1;
            z-index: -1;
        }

        .hidden {
            display: none !important;
        }

        /* Enhanced Click Handlers and Interactions */
        button, .clickable, .nav-item, .game-btn, .verify-btn, .connect-btn, .disconnect-btn,
        .game-type-card, .stake-preset, .control-btn, .filter-btn, .tournament-btn,
        .settlement-btn, .empty-action-btn, .create-btn, .tab-btn {
            cursor: pointer;
            pointer-events: auto;
            position: relative;
            z-index: 10;
            user-select: none;
            border: none;
            outline: none;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        button:disabled {
            cursor: not-allowed !important;
            opacity: 0.6;
            pointer-events: none;
        }

        button:focus, .nav-item:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* Enhanced Animation System */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px var(--accent); }
            50% { box-shadow: 0 0 20px var(--accent), 0 0 30px var(--accent); }
        }

        @keyframes fall {
            to { transform: translateY(100vh) rotate(360deg); }
        }

        /* Enhanced Connection Status Indicators */
        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .connected {
            background: #00ff88;
            animation: pulse 2s infinite;
        }

        .disconnected {
            background: #ff6b6b;
        }

        .pending {
            background: #f1c40f;
            animation: blink 1s infinite;
        }

        .error {
            background: #e74c3c;
            animation: shake 0.5s infinite;
        }

        /* Enhanced Header Styles */
        .header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: linear-gradient(135deg, rgba(26, 28, 44, 0.95), rgba(44, 62, 80, 0.95));
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            min-height: 80px;
            box-shadow: var(--shadow);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.8rem;
            background: var(--gradient-accent);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .logo-icon {
            font-size: 2.5rem;
            color: var(--secondary);
            animation: spin 20s linear infinite;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .nav-menu {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            flex-wrap: wrap;
            max-width: 100%;
        }

        .nav-menu::-webkit-scrollbar {
            display: none;
        }

        .nav-item {
            padding: 0.8rem 1.2rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            white-space: nowrap;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .nav-item:hover::before {
            left: 100%;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(78, 205, 196, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.2);
        }

        .nav-item.active {
            background: var(--gradient-accent);
            color: white;
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
            font-weight: 600;
        }

        .live-badge {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            padding: 0.6rem 1.2rem;
            border-radius: 25px;
            font-weight: bold;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Enhanced Player Progress Display */
        .player-progress {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0 1rem;
        }

        .progress-info {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--accent);
            font-weight: 500;
        }

        .xp-bar {
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .xp-fill {
            height: 100%;
            background: var(--gradient-accent);
            transition: width 0.8s ease;
            border-radius: 4px;
            position: relative;
        }

        .xp-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .wallet-info {
            text-align: right;
        }

        .connection-status {
            font-size: 0.9rem;
            color: #ff6b6b;
            font-weight: 500;
            display: flex;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .balance {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .connect-btn, .disconnect-btn {
            background: var(--gradient-accent);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 48px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .disconnect-btn {
            background: var(--gradient-danger);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .connect-btn:hover, .disconnect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .disconnect-btn:hover {
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        /* Enhanced Main Layout */
        .main-container {
            display: flex;
            min-height: calc(100vh - 80px);
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(15px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
            scrollbar-width: thin;
            scrollbar-color: var(--accent) transparent;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        .content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
            scrollbar-width: thin;
            scrollbar-color: var(--accent) transparent;
        }

        .content-area::-webkit-scrollbar {
            width: 6px;
        }

        .content-area::-webkit-scrollbar-track {
            background: transparent;
        }

        .content-area::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        /* Enhanced Loading States */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        .skeleton {
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.1) 25%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.1) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Enhanced Error States */
        .error-message {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .success-message {
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .warning-message {
            background: rgba(241, 196, 15, 0.1);
            border: 1px solid var(--warning);
            color: var(--warning);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
      /* GAME COMPONENTS AND MODAL STYLES */

        /* Enhanced Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background: var(--dark);
            border-radius: 20px;
            padding: 2rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: var(--shadow);
            border: 2px solid var(--accent);
            animation: bounce 0.6s ease;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.5rem;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Age Verification Modal */
        .age-verification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(15px);
            animation: fadeIn 0.5s ease;
        }

        .verification-content {
            background: var(--dark);
            border-radius: 20px;
            padding: 3rem;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: var(--shadow);
            border: 2px solid var(--primary);
            position: relative;
            animation: slideIn 0.5s ease;
        }

        .verification-content h1 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            color: var(--secondary);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .verification-content p {
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
            line-height: 1.6;
            color: var(--light);
        }

        .verification-content .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid var(--danger);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
            text-align: left;
            backdrop-filter: blur(5px);
        }

        .verification-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .verify-btn {
            padding: 1rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-width: 140px;
            position: relative;
            overflow: hidden;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .verify-btn.accept {
            background: var(--gradient-accent);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .verify-btn.decline {
            background: var(--gradient-danger);
            color: white;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .verify-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* Enhanced Transaction Status */
        .transaction-status {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--accent);
            border-radius: 15px;
            padding: 1.5rem;
            max-width: 380px;
            z-index: 9000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            word-wrap: break-word;
            backdrop-filter: blur(15px);
            box-shadow: var(--shadow);
        }

        .transaction-status.show {
            transform: translateX(0);
            animation: slideIn 0.3s ease;
        }

        .tx-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .tx-status-icon {
            font-size: 1.5rem;
            margin-right: 0.5rem;
        }

        .tx-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.3s ease;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tx-close:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .tx-hash {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            word-break: break-all;
            color: var(--accent);
            margin-top: 1rem;
            cursor: pointer;
            transition: color 0.3s ease;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tx-hash:hover {
            color: #44a08d;
            background: rgba(255, 255, 255, 0.1);
        }

        .tx-progress {
            margin-top: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient-accent);
            border-radius: 3px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        /* Enhanced Settlement Modal */
        .settlement-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(15px);
            animation: fadeIn 0.5s ease;
        }

        .settlement-content {
            background: var(--dark);
            border-radius: 20px;
            padding: 2.5rem;
            max-width: 550px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: var(--shadow);
            border: 2px solid var(--accent);
            animation: bounce 0.6s ease;
            position: relative;
        }

        .settlement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid rgba(78, 205, 196, 0.3);
        }

        .settlement-header h2 {
            color: var(--accent);
            font-size: 1.8rem;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .settlement-result {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .settlement-amount {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .settlement-amount.win {
            color: var(--success);
        }

        .settlement-amount.loss {
            color: var(--danger);
        }

        .settlement-breakdown {
            margin-bottom: 2rem;
            text-align: left;
            font-size: 0.95rem;
            color: #ccc;
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 10px;
            line-height: 1.6;
        }

        .settlement-breakdown h4 {
            color: var(--accent);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .settlement-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .settlement-btn {
            padding: 1rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-width: 160px;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .settlement-btn.primary {
            background: var(--gradient-success);
            color: white;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
        }

        .settlement-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--accent);
            border: 2px solid var(--accent);
        }

        .settlement-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* Turn Indicator System */
        .turn-indicator {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 1.5rem;
            z-index: 8000;
            min-width: 280px;
            backdrop-filter: blur(15px);
            animation: slideIn 0.5s ease;
            box-shadow: var(--shadow);
        }

        .turn-indicator.my-turn {
            border-color: var(--success);
            background: rgba(46, 204, 113, 0.1);
        }

        .turn-indicator.opponent-turn {
            border-color: var(--danger);
            background: rgba(231, 76, 60, 0.1);
        }

        /* GAME BOARD & UI COMPONENTS STYLES */

        .turn-status {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .turn-timer {
            margin-top: 0.8rem;
            font-size: 1rem;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .move-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .move-indicator.active {
            background: var(--success);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
        }

        .move-indicator.waiting {
            background: var(--danger);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        .game-status-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--accent);
            border-radius: 25px;
            padding: 1rem 2rem;
            z-index: 8000;
            backdrop-filter: blur(15px);
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 320px;
            justify-content: center;
            box-shadow: var(--shadow);
        }

        .disabled-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(231, 76, 60, 0.3);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.3rem;
            backdrop-filter: blur(3px);
            border-radius: 10px;
        }

        /* Enhanced Game Windows */
        .game-window {
            position: fixed;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 1400px;
            height: 90vh;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--accent);
            border-radius: 20px;
            backdrop-filter: blur(20px);
            z-index: 6000;
            animation: fadeIn 0.5s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .game-window.minimized {
            height: 80px;
            overflow: hidden;
        }

        .game-window.minimized .game-window-content {
            display: none;
        }

        .game-window-header {
            background: var(--gradient-accent);
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .game-window-title {
            font-size: 1.4rem;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .skill-badge {
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .skill-bronze {
            background: linear-gradient(45deg, #cd7f32, #b8860b);
            color: white;
        }

        .skill-silver {
            background: linear-gradient(45deg, #c0c0c0, #a8a8a8);
            color: black;
        }

        .skill-gold {
            background: linear-gradient(45deg, #ffd700, #ffb347);
            color: black;
        }

        .skill-diamond {
            background: linear-gradient(45deg, #b9f2ff, #9ee5ff);
            color: black;
        }

        .validation-status {
            color: var(--success);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .sync-status {
            font-size: 0.9rem;
            animation: spin 2s linear infinite;
            color: var(--accent);
        }

        .game-window-controls {
            display: flex;
            gap: 0.8rem;
        }

        .window-btn {
            width: 35px;
            height: 35px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .minimize-btn {
            background: linear-gradient(45deg, #f1c40f, #f39c12);
            color: black;
        }

        .close-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .window-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .game-window-content {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .game-info-bar {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 1.5rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            flex-shrink: 0;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .player-info, .opponent-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .player-avatar {
            font-size: 2.5rem;
            color: var(--accent);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .player-details {
            flex: 1;
        }

        .player-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            margin-bottom: 0.3rem;
        }

        .timer {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--warning);
            font-family: 'Courier New', monospace;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .move-indicator-small {
            font-size: 1.1rem;
            color: var(--accent);
            margin-top: 0.3rem;
        }

        .game-status-center {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 0.8rem;
        }

        .game-status {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .move-history {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) transparent;
        }

        .move-history::-webkit-scrollbar {
            width: 4px;
        }

        .move-history::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 2px;
        }

        .move-list {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #ccc;
            line-height: 1.4;
            white-space: pre-line;
        }

        /* Chess Board Styles */
        .chess-board-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.8rem;
        }

        .chess-coordinates-top, .chess-coordinates-bottom {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            width: 100%;
            max-width: 520px;
            text-align: center;
            font-size: 0.9rem;
            color: #aaa;
            font-weight: 500;
        }

        .chess-board-wrapper {
            display: flex;
            gap: 0.8rem;
            align-items: center;
        }

        .chess-coordinates-left, .chess-coordinates-right {
            display: flex;
            flex-direction: column;
            gap: 2px;
            height: 520px;
            justify-content: space-around;
            font-size: 0.9rem;
            color: #aaa;
            text-align: center;
            font-weight: 500;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 520px;
            height: 520px;
            border: 3px solid var(--accent);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
        }

        .chess-square.white {
            background: #f0d9b5;
            color: #8b4513;
        }

        .chess-square.black {
            background: #b58863;
            color: #f0d9b5;
        }

        .chess-square:hover {
            box-shadow: inset 0 0 0 4px var(--accent);
            transform: scale(1.05);
            z-index: 10;
        }

        .chess-square.selected {
            box-shadow: inset 0 0 0 4px #ffd700;
            background-color: rgba(255, 215, 0, 0.3);
        }

        .chess-square.last-move {
            box-shadow: inset 0 0 0 4px #ff6b6b;
            background-color: rgba(255, 107, 107, 0.2);
        }

        .chess-square.legal-move::after {
            content: '';
            position: absolute;
            width: 40%;
            height: 40%;
            background: rgba(46, 204, 113, 0.7);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .chess-square.capture-move::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border: 4px solid rgba(231, 76, 60, 0.8);
            border-radius: 50%;
            background: transparent;
            animation: pulse 2s infinite;
        }

        .chess-square.check {
            background: rgba(255, 0, 0, 0.4) !important;
            animation: shake 0.5s infinite;
        }

        /* Checkers Board Styles */
        .checkers-board-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .checkers-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 520px;
            height: 520px;
            border: 3px solid var(--accent);
            border-radius: 8px;
            margin: 0 auto;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .checkers-square {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .checkers-square.light {
            background: #f0d9b5;
        }

        .checkers-square.dark {
            background: #b58863;
        }

        .checkers-square:hover {
            box-shadow: inset 0 0 0 4px var(--accent);
        }

        .checkers-square.selected {
            box-shadow: inset 0 0 0 4px #ffd700;
            background-color: rgba(255, 215, 0, 0.3);
        }

        .checkers-square.legal-move::after {
            content: '';
            position: absolute;
            width: 40%;
            height: 40%;
            background: rgba(46, 204, 113, 0.7);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .checker-piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            border: 3px solid #333;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .checker-piece.red-piece {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #dc3545);
        }

        .checker-piece.black-piece {
            background: radial-gradient(circle at 30% 30%, #6c757d, #343a40);
        }

        .checker-piece.king::after {
            content: '♔';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: gold;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .checker-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 15px rgba(78, 205, 196, 0.5);
        }

        /* Word Game Styles */
        .word-game {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .word-prompt {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 15px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .word-prompt h4 {
            color: var(--accent);
            margin-bottom: 0.8rem;
            font-size: 1.2rem;
        }

        .available-letters {
            font-size: 2.5rem;
            font-weight: bold;
            letter-spacing: 0.3rem;
            color: var(--secondary);
            font-family: 'Courier New', monospace;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .word-input-section {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .word-input {
            width: 100%;
            padding: 1.2rem;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1.3rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.2rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .word-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.2);
            background: rgba(255, 255, 255, 0.1);
        }

        .word-validation {
            text-align: center;
            min-height: 2rem;
            font-weight: bold;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .word-validation.valid {
            color: var(--success);
        }

        .word-validation.invalid {
            color: var(--danger);
        }

        .word-scoring {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .scoring-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .score-breakdown {
            display: flex;
            gap: 1.5rem;
            font-size: 1rem;
            color: #ccc;
        }

        .total-score {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent);
        }

        .submitted-words {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .submitted-words h5 {
            color: var(--accent);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .words-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
        }

        .word-chip {
            background: var(--gradient-accent);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .round-indicator {
            display: flex;
            gap: 0.8rem;
            justify-content: center;
            align-items: center;
        }

        .round-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
        }

        .round-dot.active {
            background: var(--accent);
            box-shadow: 0 0 15px var(--accent);
            animation: pulse 2s infinite;
        }

        .round-dot.completed {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .round-dot.completed::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
        }
      /* GAME CONTROLS & COMPONENT STYLES */

        /* Enhanced Game Controls */
        .game-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            flex-shrink: 0;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .game-controls .game-btn {
            padding: 1rem 1.8rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            min-height: 48px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .game-controls .game-btn.primary {
            background: var(--gradient-accent);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .game-controls .game-btn.secondary {
            background: linear-gradient(45deg, var(--secondary), #e67e22);
            color: white;
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }

        .game-controls .game-btn.neutral {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .game-controls .game-btn.danger {
            background: var(--gradient-danger);
            color: white;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .game-controls .game-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .game-controls .game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Enhanced Game Chat */
        .game-chat {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            flex-shrink: 0;
            max-height: 250px;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .game-chat h4 {
            margin: 0 0 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            color: var(--accent);
            font-size: 1.1rem;
        }

        .game-chat-messages {
            flex: 1;
            overflow-y: auto;
            max-height: 150px;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) transparent;
        }

        .game-chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .game-chat-messages::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        .game-chat-message {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            line-height: 1.5;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .game-chat-message.system {
            color: #ffd700;
            font-style: italic;
            background: rgba(255, 215, 0, 0.1);
        }

        .game-chat-message.player {
            color: var(--accent);
            background: rgba(78, 205, 196, 0.1);
        }

        .game-chat-message.opponent {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .game-chat-input {
            display: flex;
            gap: 0.8rem;
        }

        .game-chat-input input {
            flex: 1;
            padding: 0.8rem;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .game-chat-input input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
        }

        .game-chat-input button {
            padding: 0.8rem 1rem;
            border: none;
            border-radius: 8px;
            background: var(--gradient-accent);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-chat-input button:hover {
            background: linear-gradient(45deg, #44a08d, #4ecdc4);
            transform: translateY(-2px);
        }

        /* Enhanced Sidebar Styles */
        .contract-status {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .contract-status h3 {
            color: var(--accent);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            font-size: 1.2rem;
        }

        .contract-address {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            word-break: break-all;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.8rem;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .copy-btn {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid var(--accent);
            color: var(--accent);
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            min-width: 35px;
            min-height: 35px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .copy-btn:hover {
            background: rgba(78, 205, 196, 0.3);
            transform: scale(1.05);
        }

        .contract-verification {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .verification-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.95rem;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .verification-item i.verified {
            color: var(--success);
            font-size: 1.2rem;
        }

        /* SIDEBAR & CONTENT COMPONENTS STYLES */

        .verification-item i.stats {
            color: var(--accent);
            font-size: 1.2rem;
        }

        .live-lobby {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .live-lobby h2, .live-lobby h3 {
            color: var(--accent);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            font-size: 1.3rem;
        }

        .lobby-stats {
            display: grid;
            gap: 1rem;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 1.2rem;
            padding: 1.2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }

        .stat-icon {
            font-size: 1.8rem;
            color: var(--accent);
            width: 50px;
            text-align: center;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .stat-details {
            flex: 1;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent);
            line-height: 1;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stat-label {
            color: #aaa;
            font-size: 0.85rem;
            margin-top: 0.3rem;
            font-weight: 500;
        }

        .activity-feed {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            max-height: 220px;
            overflow-y: auto;
            margin-bottom: 1.5rem;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) transparent;
        }

        .activity-feed::-webkit-scrollbar {
            width: 4px;
        }

        .activity-feed::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 2px;
        }

        .activity-item {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            font-size: 0.9rem;
            line-height: 1.4;
            border-left: 3px solid var(--accent);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .activity-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(8px);
            border-left-width: 5px;
        }

        .activity-refresh {
            width: 100%;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.8rem;
            font-weight: 600;
        }

        .activity-refresh:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 1.2rem;
            padding: 1.2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .leaderboard-item.gold {
            border-left: 4px solid #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .leaderboard-item.silver {
            border-left: 4px solid #c0c0c0;
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.1), rgba(192, 192, 192, 0.05));
        }

        .leaderboard-item.bronze {
            border-left: 4px solid #cd7f32;
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.1), rgba(205, 127, 50, 0.05));
        }

        .rank {
            font-size: 1.8rem;
            width: 50px;
            text-align: center;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: bold;
            color: var(--light);
            font-size: 1.1rem;
            margin-bottom: 0.2rem;
        }

        .player-games {
            font-size: 0.8rem;
            color: #aaa;
            font-style: italic;
        }

        .player-score {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .leaderboard-view-all {
            width: 100%;
            padding: 1rem;
            background: var(--gradient-accent);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .leaderboard-view-all:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(78, 205, 196, 0.3);
        }

        .server-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .server-item {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .server-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .server-item.online {
            border-left: 3px solid var(--success);
        }

        .server-item.offline {
            border-left: 3px solid var(--danger);
        }

        .server-icon {
            color: var(--accent);
            font-size: 1.4rem;
            width: 30px;
            text-align: center;
        }

        .server-info {
            flex: 1;
        }

        .server-status {
            font-weight: bold;
            color: var(--light);
            font-size: 0.95rem;
            margin-bottom: 0.2rem;
        }

        .server-label {
            font-size: 0.75rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .network-info {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .network-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.85rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .network-label {
            color: #aaa;
            font-weight: 500;
        }

        .network-value {
            color: var(--accent);
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        /* Enhanced Content Area Styles */
        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid rgba(78, 205, 196, 0.3);
        }

        .lobby-header h2 {
            margin: 0;
            font-size: 2rem;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .lobby-controls {
            display: flex;
            gap: 0.8rem;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 0.8rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
        }

        .control-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .games-list {
            display: grid;
            gap: 1.5rem;
        }

        .game-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .game-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.08);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .game-type {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-stake {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--secondary);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            color: #ccc;
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .game-actions {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .game-btn {
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            min-height: 45px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .game-btn.primary {
            background: var(--gradient-accent);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .game-btn.danger {
            background: var(--gradient-danger);
            color: white;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .game-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--accent);
            border: 2px solid var(--accent);
        }

        .game-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        /* Enhanced Create Game Section */
        .create-game-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 2.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
        }

        .create-game-section h2 {
            color: var(--accent);
            margin-bottom: 2.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 2rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2.5rem;
        }

        .game-type-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .game-type-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .game-type-card:hover::before {
            left: 100%;
        }

        .game-type-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }

        .game-type-card.selected {
            border-color: var(--accent);
            background: rgba(78, 205, 196, 0.15);
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.3);
            transform: translateY(-5px);
        }

        .game-icon {
            font-size: 3.5rem;
            margin-bottom: 1.5rem;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .game-type-card h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .game-type-card p {
            color: #aaa;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }

        .game-features {
            display: flex;
            gap: 0.8rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .feature-tag {
            background: rgba(78, 205, 196, 0.2);
            color: var(--accent);
            padding: 0.4rem 0.8rem;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: bold;
            border: 1px solid rgba(78, 205, 196, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .popularity-indicator {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }

        .popularity-bar {
            height: 6px;
            background: var(--gradient-accent);
            border-radius: 3px;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .popularity-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        .popularity-text {
            font-size: 0.75rem;
            color: #aaa;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
      /* FORMS, MOBILE & RESPONSIVE STYLES */

        .stake-section {
            margin: 2.5rem 0;
        }

        .stake-section label {
            display: block;
            margin-bottom: 1rem;
            font-weight: bold;
            color: var(--light);
            font-size: 1.1rem;
        }

        .stake-input {
            width: 100%;
            padding: 1.2rem;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            margin-bottom: 1.5rem;
            font-weight: 500;
        }

        .stake-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.2);
            background: rgba(255, 255, 255, 0.1);
        }

        .stake-presets {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .stake-preset {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.8rem 1.2rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            min-height: 40px;
            font-weight: 600;
        }

        .stake-preset:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .create-btn {
            width: 100%;
            padding: 1.2rem 2rem;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            margin-top: 2.5rem;
            background: var(--gradient-accent);
            color: white;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.3);
        }

        .create-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .create-btn:not(:disabled):hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.4);
        }

        /* Enhanced Empty State */
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: #aaa;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 15px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }

        .empty-icon {
            font-size: 5rem;
            margin-bottom: 2rem;
            opacity: 0.6;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .empty-state h3 {
            margin-bottom: 1.5rem;
            color: var(--accent);
            font-size: 1.5rem;
        }

        .empty-state p {
            margin-bottom: 2.5rem;
            line-height: 1.6;
            font-size: 1.1rem;
        }

        .empty-actions {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .empty-action-btn {
            background: var(--gradient-accent);
            border: none;
            padding: 1rem 2rem;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            min-height: 48px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .empty-action-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: var(--accent);
        }

        .empty-action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        /* Enhanced Notification Styles */
        .notification {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 1.5rem;
            z-index: 9500;
            animation: slideIn 0.5s ease;
            max-width: 350px;
            backdrop-filter: blur(15px);
            box-shadow: var(--shadow);
        }

        .level-up-notification {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .xp-notification {
            border-color: var(--accent);
            background: rgba(78, 205, 196, 0.1);
        }

        .achievement-notification {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .connection-quality-indicator {
            position: fixed;
            top: 200px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.8rem;
            border-radius: 10px;
            z-index: 7500;
            font-size: 0.85rem;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .connection-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.5rem;
        }

        /* Enhanced Mobile Responsiveness */
        @media (max-width: 1200px) {
            .chess-board, .checkers-board {
                width: 450px;
                height: 450px;
            }

            .chess-coordinates-left, .chess-coordinates-right {
                height: 450px;
            }

            .chess-coordinates-top, .chess-coordinates-bottom {
                max-width: 450px;
            }
        }

        @media (max-width: 992px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                order: 2;
                padding: 1.5rem;
                max-height: none;
            }

            .content-area {
                order: 1;
                padding: 1.5rem;
                max-height: none;
            }

            .game-window {
                width: 98%;
                height: 95vh;
                top: 2.5%;
            }

            .chess-board, .checkers-board {
                width: 400px;
                height: 400px;
            }

            .chess-coordinates-left, .chess-coordinates-right {
                height: 400px;
            }

            .chess-coordinates-top, .chess-coordinates-bottom {
                max-width: 400px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
                min-height: auto;
            }

            .nav-menu {
                order: 3;
                width: 100%;
                justify-content: flex-start;
                gap: 0.5rem;
                padding: 0.5rem 0;
                overflow-x: auto;
            }

            .nav-item {
                padding: 0.6rem 1rem;
                font-size: 0.85rem;
                min-height: 40px;
                flex-shrink: 0;
            }

            .wallet-section {
                order: 2;
                width: 100%;
                justify-content: space-between;
                flex-wrap: wrap;
                gap: 1rem;
            }

            .player-progress {
                margin-left: 0;
                margin-top: 0.5rem;
                order: 1;
            }

            .game-window {
                width: 100%;
                height: 100vh;
                top: 0;
                border-radius: 0;
            }

            .game-info-bar {
                grid-template-columns: 1fr;
                gap: 1rem;
                text-align: center;
            }

            .player-info, .opponent-info {
                justify-content: center;
            }

            .chess-board, .checkers-board {
                width: 320px;
                height: 320px;
            }

            .chess-coordinates-left, .chess-coordinates-right {
                height: 320px;
                font-size: 0.8rem;
            }

            .chess-coordinates-top, .chess-coordinates-bottom {
                max-width: 320px;
                font-size: 0.8rem;
            }

            .chess-square {
                font-size: 1.6rem;
            }

            .available-letters {
                font-size: 2rem;
                letter-spacing: 0.15rem;
            }

            .game-controls {
                flex-direction: column;
                align-items: center;
                gap: 0.8rem;
            }

            /* MOBILE RESPONSIVE CONTINUED & UTILITIES */

            .game-controls .game-btn {
                width: 100%;
                max-width: 250px;
                justify-content: center;
            }

            .game-window-header {
                padding: 1rem;
            }

            .game-window-title {
                font-size: 1.1rem;
            }

            .skill-badge {
                font-size: 0.65rem;
                padding: 0.25rem 0.6rem;
            }

            .turn-indicator {
                top: 80px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }

            .game-status-bar {
                bottom: 10px;
                left: 10px;
                right: 10px;
                transform: none;
                min-width: auto;
            }

            .transaction-status {
                top: 70px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .notification {
                top: 70px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .connection-quality-indicator {
                top: 140px;
                right: 10px;
            }

            .game-type-selector {
                grid-template-columns: 1fr;
            }

            .stake-presets {
                justify-content: center;
            }

            .empty-actions {
                flex-direction: column;
                align-items: center;
            }

            .empty-action-btn {
                width: 100%;
                max-width: 250px;
            }

            .verification-buttons {
                flex-direction: column;
                align-items: center;
            }

            .verify-btn {
                width: 100%;
                max-width: 200px;
            }

            .settlement-actions {
                flex-direction: column;
                align-items: center;
            }

            .settlement-btn {
                width: 100%;
                max-width: 200px;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 0.5rem;
            }

            .logo h1 {
                font-size: 1.4rem;
            }

            .logo-icon {
                font-size: 2rem;
            }

            .nav-item {
                padding: 0.5rem 0.8rem;
                font-size: 0.8rem;
                min-height: 36px;
            }

            .chess-board, .checkers-board {
                width: 280px;
                height: 280px;
            }

            .chess-coordinates-left, .chess-coordinates-right {
                height: 280px;
                font-size: 0.7rem;
            }

            .chess-coordinates-top, .chess-coordinates-bottom {
                max-width: 280px;
                font-size: 0.7rem;
            }

            .chess-square {
                font-size: 1.4rem;
            }

            .available-letters {
                font-size: 1.6rem;
                letter-spacing: 0.1rem;
            }

            .word-input {
                font-size: 1.1rem;
                padding: 1rem;
            }

            .game-window-content {
                padding: 1rem;
                gap: 1rem;
            }

            .game-info-bar {
                padding: 1rem;
            }

            .player-avatar {
                font-size: 2rem;
            }

            .timer {
                font-size: 1.1rem;
            }
        }

        /* Enhanced Accessibility Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }

            .chess-square, .checkers-square, .checker-piece, .game-btn, .window-btn {
                transition: none;
            }

            .sync-status, .logo-icon {
                animation: none;
            }

            .move-indicator.active, .move-indicator.waiting {
                animation: none;
            }

            .shimmer::after, .xp-fill::after, .progress-fill::after {
                animation: none;
            }
        }

        @media (prefers-contrast: high) {
            :root {
                --accent: #00ffff;
                --secondary: #ffff00;
                --primary: #ffffff;
                --success: #00ff00;
                --danger: #ff0000;
                --warning: #ff8800;
            }

            .chess-square.white {
                background: #ffffff;
                color: #000000;
            }

            .chess-square.black {
                background: #000000;
                color: #ffffff;
            }

            .checkers-square.light {
                background: #ffffff;
            }

            .checkers-square.dark {
                background: #000000;
            }

            .game-window, .modal-content, .verification-content {
                border-width: 3px;
            }
        }

        @media (prefers-color-scheme: light) {
            body {
                background: linear-gradient(135deg, #f8f9fa, #e9ecef);
                color: #212529;
            }

            .header {
                background: linear-gradient(135deg, rgba(248, 249, 250, 0.95), rgba(233, 236, 239, 0.95));
            }

            .game-window {
                background: rgba(255, 255, 255, 0.95);
            }

            .nav-item {
                background: rgba(0, 0, 0, 0.05);
            }
        }

        /* Enhanced Focus Indicators for Accessibility */
        .keyboard-navigation .nav-item:focus,
        .keyboard-navigation .connect-btn:focus,
        .keyboard-navigation .verify-btn:focus,
        .keyboard-navigation button:focus,
        .keyboard-navigation .game-btn:focus,
        .keyboard-navigation .chess-square:focus,
        .keyboard-navigation .checkers-square:focus,
        .keyboard-navigation .word-input:focus {
            outline: 3px solid var(--accent);
            outline-offset: 2px;
            z-index: 100;
        }

        /* Touch Device Optimizations */
        @media (hover: none) and (pointer: coarse) {
            .chess-square, .checkers-square {
                min-height: 44px;
                min-width: 44px;
            }

            .nav-item, .game-btn, .verify-btn, .settlement-btn, .create-btn {
                min-height: 48px;
                min-width: 48px;
            }

            .window-btn, .control-btn, .copy-btn {
                min-height: 44px;
                min-width: 44px;
            }

            .tx-close, .modal-close {
                min-height: 44px;
                min-width: 44px;
            }
        }

        /* Print Styles */
        @media print {
            .header, .sidebar, .game-window-controls, .game-controls, 
            .transaction-status, .turn-indicator, .game-status-bar,
            .notification, .connection-quality-indicator {
                display: none !important;
            }

            body {
                background: white !important;
                color: black !important;
            }

            .chess-board, .checkers-board {
                border: 2px solid black !important;
                print-color-adjust: exact;
            }

            .chess-square.white {
                background: white !important;
                color: black !important;
            }

            .chess-square.black {
                background: #cccccc !important;
                color: black !important;
            }
        }

        /* Enhanced Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gradient-accent);
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #44a08d, #4ecdc4);
        }

        ::-webkit-scrollbar-corner {
            background: transparent;
        }

        /* Selection Styling */
        ::selection {
            background: rgba(78, 205, 196, 0.3);
            color: white;
        }

        ::-moz-selection {
            background: rgba(78, 205, 196, 0.3);
            color: white;
        }

        /* Enhanced Loading States */
        .loading-spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid rgba(78, 205, 196, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        .loading-dots {
            display: inline-flex;
            gap: 4px;
        }

        .loading-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            animation: loading-dots 1.4s ease-in-out infinite both;
        }

        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }
        .loading-dot:nth-child(3) { animation-delay: 0s; }

        @keyframes loading-dots {
            0%, 80%, 100% {
                transform: scale(0);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Enhanced Button States */
        .btn-loading {
            position: relative;
            color: transparent !important;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }

        /* Enhanced Form Validation */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--light);
        }

        .form-input {
            width: 100%;
            padding: 1rem;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.2);
        }

        .form-input.invalid {
            border-color: var(--danger);
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.2);
        }

        .form-input.valid {
            border-color: var(--success);
            box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.2);
        }

        .form-error {
            color: var(--danger);
            font-size: 0.85rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-success {
            color: var(--success);
            font-size: 0.85rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Enhanced Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip::before,
        .tooltip::after {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            transform: translateY(5px);
        }

        .tooltip::before {
            content: attr(data-tooltip);
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(5px);
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 10001;
        }

        .tooltip::after {
            content: '';
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(2px);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            z-index: 10000;
        }

        .tooltip:hover::before,
        .tooltip:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px);
        }

        /* Enhanced Dark/Light Mode Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 80px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--gradient-accent);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 8000;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        /* Performance Optimizations */
        .game-window,
        .modal-overlay,
        .transaction-status,
        .turn-indicator {
            will-change: transform, opacity;
        }

        .chess-square,
        .checkers-square,
        .game-btn {
            will-change: transform;
        }

        .loading-spinner,
        .sync-status,
        .move-indicator {
            will-change: transform;
        }
    </style>
  </head>
<body>
    <div class="background"></div>
    
    <!-- Enhanced Header -->
    <div class="header">
        <div class="logo">
            <i class="fas fa-dice-d20 logo-icon"></i>
            <h1>CROSSREALM</h1>
        </div>
        <div class="nav-menu" id="navMenu">
            <div class="nav-item active" tabindex="0" role="button" aria-label="Game Lobby">
                <i class="fas fa-dice"></i> Game Lobby
            </div>
            <div class="nav-item" tabindex="0" role="button" aria-label="My Games">
                <i class="fas fa-gamepad"></i> My Games
            </div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Create Game">
                <i class="fas fa-plus-circle"></i> Create Game
            </div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Games">
                <i class="fas fa-chess-board"></i> Games
            </div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Tournaments">
                <i class="fas fa-trophy"></i> Tournaments
            </div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Leaderboard">
                <i class="fas fa-crown"></i> Leaderboard
            </div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Profile">
                <i class="fas fa-user-circle"></i> Profile
            </div>
            <div class="nav-item" tabindex="0" role="button" aria-label="Settings">
                <i class="fas fa-cog"></i> Settings
            </div>
        </div>
        <div class="live-badge">🔴 LIVE ON CORE</div>
        
        <!-- Enhanced Player Progress Display -->
        <div class="player-progress">
            <div class="progress-info">
                <div id="playerLevel">Level 1</div>
                <div id="playerXP">0 XP</div>
                <div id="playerRank">Rookie</div>
            </div>
            <div class="xp-bar">
                <div class="xp-fill" id="xpBar" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="wallet-section">
            <div class="wallet-info">
                <div class="connection-status" id="connectionStatus">
                    <span class="connection-indicator disconnected"></span>Not Connected
                </div>
                <div class="balance" id="balanceDisplay">0.0000 CORE</div>
            </div>
            <button class="connect-btn" id="connectBtn" aria-label="Connect Wallet">
                <i class="fas fa-wallet"></i> Connect Wallet
            </button>
            <button class="disconnect-btn hidden" id="disconnectBtn" aria-label="Disconnect Wallet">
                <i class="fas fa-sign-out-alt"></i> Disconnect
            </button>
        </div>
    </div>

    <!-- Enhanced Age Verification Modal -->
    <div class="age-verification" id="ageVerificationModal">
        <div class="verification-content">
            <h1><i class="fas fa-exclamation-triangle"></i> Age Verification Required</h1>
            <p>CrossRealm is a skill-based gaming platform where you can earn real CORE tokens. You must be 18 years or older to participate.</p>
            <div class="warning">
                <p><i class="fas fa-exclamation-circle"></i> <strong>Important:</strong> This platform involves real cryptocurrency transactions. Only participate with funds you can afford to lose. Gaming involves skill and chance.</p>
            </div>
            <p>By entering this platform, you confirm that you are at least 18 years of age and agree to our <a href="#" style="color: #4ecdc4;">Terms of Service</a> and <a href="#" style="color: #4ecdc4;">Privacy Policy</a>.</p>
            <div class="verification-buttons">
                <button class="verify-btn accept" onclick="verifyAge(true)" aria-label="I am 18 or older">
                    <i class="fas fa-check"></i> I am 18+
                </button>
                <button class="verify-btn decline" onclick="verifyAge(false)" aria-label="I am under 18">
                    <i class="fas fa-times"></i> Under 18
                </button>
            </div>
        </div>
    </div>

    <!-- Enhanced Transaction Status -->
    <div class="transaction-status" id="transactionStatus">
        <div class="tx-header">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span class="tx-status-icon" id="txStatusIcon">🔄</span>
                <span id="txStatusTitle">Processing...</span>
            </div>
            <button class="tx-close" onclick="hideTransactionStatus()" aria-label="Close transaction status">×</button>
        </div>
        <div id="txStatusMessage">Processing transaction...</div>
        <div class="tx-hash" id="txHash" onclick="openTxInExplorer()" style="display: none;"></div>
        <div class="tx-progress" id="txProgress">
            <div class="progress-bar">
                <div class="progress-fill" id="txProgressFill" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Enhanced Settlement Modal -->
    <div class="settlement-modal hidden" id="settlementModal">
        <div class="settlement-content">
            <div class="settlement-header">
                <h2 id="settlementTitle">🎉 Game Complete!</h2>
                <button class="settlement-close modal-close" onclick="closeSettlement()" aria-label="Close settlement">×</button>
            </div>
            <div class="settlement-body">
                <div class="settlement-result" id="settlementResult">
                    <div class="settlement-amount win" id="settlementAmount">+0.0000 CORE</div>
                    <div id="settlementMessage">Congratulations! You won!</div>
                </div>
                <div class="settlement-breakdown" id="settlementBreakdown">
                    <h4>Settlement Breakdown:</h4>
                    <div id="settlementDetails"></div>
                </div>
                <div class="settlement-actions">
                    <button class="settlement-btn primary" id="claimBtn" onclick="claimWinnings()">
                        <i class="fas fa-coins"></i> Claim Winnings
                    </button>
                    <button class="settlement-btn secondary" onclick="viewGameAnalysis()">
                        <i class="fas fa-chart-line"></i> View Analysis
                    </button>
                    <button class="settlement-btn secondary" onclick="playAgain()">
                        <i class="fas fa-redo"></i> Play Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Turn Indicator (Will be created dynamically) -->
    <div class="turn-indicator hidden" id="turnIndicator">
        <div class="turn-status">
            <div class="move-indicator waiting"></div>
            <span class="status-text">Waiting for game...</span>
        </div>
        <div class="turn-timer">
            <i class="fas fa-clock"></i>
            <span class="timer-text">Time: --:--</span>
        </div>
    </div>

    <!-- Enhanced Game Status Bar (Will be created dynamically) -->
    <div class="game-status-bar hidden" id="gameStatusBar">
        <span class="game-info">No active game</span>
    </div>

    <!-- Connection Quality Indicator (Will be created dynamically) -->
    <div class="connection-quality-indicator hidden" id="connectionQuality">
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <div class="connection-dot" style="background: #2ecc71;"></div>
            <span>Connection: Good</span>
        </div>
    </div>

    <!-- Enhanced Anti-Bot Challenge Modal -->
    <div class="modal-overlay hidden" id="antiBotChallenge">
        <div class="modal-content">
            <button class="modal-close" onclick="closeAntiBotChallenge()" aria-label="Close challenge">×</button>
            <h3 style="color: #4ecdc4; margin-bottom: 1rem;">
                <i class="fas fa-shield-alt"></i> Human Verification
            </h3>
            <p style="margin-bottom: 1rem;">Please complete this challenge to continue playing:</p>
            <p id="captchaInstructions" style="margin-bottom: 1rem; font-weight: bold; color: #f39c12;">
                Select all squares containing chess pieces
            </p>
            
            <div class="captcha-grid" id="captchaGrid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin: 1rem 0;">
                <!-- Grid will be populated by JavaScript -->
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1.5rem;">
                <button class="verify-btn accept" id="verifyCaptchaBtn" onclick="verifyCaptcha()" disabled>
                    <i class="fas fa-check"></i> Verify
                </button>
                <button class="verify-btn secondary" onclick="refreshCaptcha()">
                    <i class="fas fa-refresh"></i> New Challenge
                </button>
            </div>
            
            <p style="margin-top: 1rem; font-size: 0.8rem; color: #aaa; text-align: center;">
                This helps us prevent automated bots and ensures fair play for all users.
            </p>
        </div>
    </div>

    <!-- Notification Container (For dynamic notifications) -->
    <div id="notificationContainer" style="position: fixed; top: 120px; right: 20px; z-index: 9500; max-width: 350px;"></div>

    <!-- Loading Overlay -->
    <div class="modal-overlay hidden" id="loadingOverlay">
        <div style="text-align: center; color: white;">
            <div class="loading-spinner" style="margin-bottom: 1rem;"></div>
            <h3 id="loadingMessage">Loading...</h3>
            <p id="loadingSubtext" style="color: #aaa; margin-top: 0.5rem;">Please wait...</p>
        </div>
    </div>
  <!-- Enhanced Game Windows -->
    
    <!-- Chess Game Window -->
    <div class="game-window hidden" id="chessGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">
                ♟️ Chess Masters 
                <span class="skill-badge skill-gold" id="chessSkillBadge">Gold</span>
                <span class="validation-status" title="Server Validated">
                    <i class="fas fa-check-circle"></i> Validated
                </span>
                <span class="sync-status" id="chessSyncStatus" title="Synchronized">
                    <i class="fas fa-sync-alt"></i>
                </span>
            </div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('chess')" aria-label="Minimize chess game">−</button>
                <button class="window-btn close-btn" onclick="closeGame('chess')" aria-label="Close chess game">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-info-bar">
                <div class="player-info">
                    <div class="player-avatar">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <div class="player-name" id="chessPlayerName">You (White)</div>
                        <div class="timer" id="chessPlayerTimer">10:00</div>
                        <div class="move-indicator-small" id="chessPlayerMove">●</div>
                    </div>
                </div>
                <div class="game-status-center">
                    <div class="game-status" id="chessStatus">Waiting for opponent...</div>
                    <div class="move-history" id="chessMoveHistory">
                        <div class="move-list" id="chessMoveList">Game starting...</div>
                    </div>
                </div>
                <div class="opponent-info">
                    <div class="player-avatar">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <div class="player-name" id="chessOpponentName">Opponent</div>
                        <div class="timer" id="chessOpponentTimer">10:00</div>
                        <div class="move-indicator-small" id="chessOpponentMove">○</div>
                    </div>
                </div>
            </div>
            
            <div class="chess-board-container">
                <div class="chess-coordinates-top">
                    <span>a</span><span>b</span><span>c</span><span>d</span>
                    <span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
                <div class="chess-board-wrapper">
                    <div class="chess-coordinates-left">
                        <span>8</span><span>7</span><span>6</span><span>5</span>
                        <span>4</span><span>3</span><span>2</span><span>1</span>
                    </div>
                    <div class="chess-board" id="chessBoard">
                        <!-- Chess squares will be generated by JavaScript -->
                    </div>
                    <div class="chess-coordinates-right">
                        <span>8</span><span>7</span><span>6</span><span>5</span>
                        <span>4</span><span>3</span><span>2</span><span>1</span>
                    </div>
                </div>
                <div class="chess-coordinates-bottom">
                    <span>a</span><span>b</span><span>c</span><span>d</span>
                    <span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
            </div>
            
            <div class="game-controls">
                <button class="game-btn danger" onclick="resignGame()">
                    <i class="fas fa-flag"></i> Resign
                </button>
                <button class="game-btn neutral" onclick="offerDraw()">
                    <i class="fas fa-handshake"></i> Offer Draw
                </button>
                <button class="game-btn neutral" onclick="requestUndo()">
                    <i class="fas fa-undo"></i> Request Undo
                </button>
                <button class="game-btn primary" onclick="analyzePosition()">
                    <i class="fas fa-brain"></i> Analyze
                </button>
            </div>
            
            <div class="game-chat">
                <h4>
                    <i class="fas fa-comments"></i> Game Chat
                </h4>
                <div class="game-chat-messages" id="chessGameChat">
                    <div class="game-chat-message system">
                        <strong>System:</strong> Game started! Good luck!
                    </div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="chessChatInput" 
                           maxlength="200" aria-label="Chess game chat input">
                    <button onclick="sendGameMessage('chess')" aria-label="Send chess chat message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Checkers Game Window -->
    <div class="game-window hidden" id="checkersGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">
                ⚫ Checkers Pro 
                <span class="skill-badge skill-silver" id="checkersSkillBadge">Silver</span>
                <span class="validation-status" title="Server Validated">
                    <i class="fas fa-check-circle"></i> Validated
                </span>
                <span class="sync-status" id="checkersSyncStatus" title="Synchronized">
                    <i class="fas fa-sync-alt"></i>
                </span>
            </div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('checkers')" aria-label="Minimize checkers game">−</button>
                <button class="window-btn close-btn" onclick="closeGame('checkers')" aria-label="Close checkers game">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-info-bar">
                <div class="player-info">
                    <div class="player-avatar">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <div class="player-name" id="checkersPlayerName">You (Red)</div>
                        <div class="timer" id="checkersPlayerTimer">5:00</div>
                        <div class="captured-pieces" id="checkersPlayerCaptured">
                            <span class="capture-count">0</span> captured
                        </div>
                    </div>
                </div>
                <div class="game-status-center">
                    <div class="game-status" id="checkersStatus">Waiting for opponent...</div>
                    <div class="game-score">
                        <div class="score-item">
                            <span class="score-label">Red Pieces:</span>
                            <span class="score-value" id="redPiecesCount">12</span>
                        </div>
                        <div class="score-item">
                            <span class="score-label">Black Pieces:</span>
                            <span class="score-value" id="blackPiecesCount">12</span>
                        </div>
                    </div>
                </div>
                <div class="opponent-info">
                    <div class="player-avatar">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    <div class="player-details">
                        <div class="player-name" id="checkersOpponentName">Opponent</div>
                        <div class="timer" id="checkersOpponentTimer">5:00</div>
                        <div class="captured-pieces" id="checkersOpponentCaptured">
                            <span class="capture-count">0</span> captured
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="checkers-board-container">
                <div class="checkers-board" id="checkersBoard">
                    <!-- Checkers squares will be generated by JavaScript -->
                </div>
            </div>
            
            <div class="game-controls">
                <button class="game-btn danger" onclick="resignGame()">
                    <i class="fas fa-flag"></i> Resign
                </button>
                <button class="game-btn neutral" onclick="requestUndo()">
                    <i class="fas fa-undo"></i> Request Undo
                </button>
                <button class="game-btn primary" onclick="showPossibleMoves()">
                    <i class="fas fa-eye"></i> Show Moves
                </button>
                <button class="game-btn secondary" onclick="getHint()">
                    <i class="fas fa-lightbulb"></i> Hint
                </button>
            </div>
            
            <div class="game-chat">
                <h4>
                    <i class="fas fa-comments"></i> Game Chat
                </h4>
                <div class="game-chat-messages" id="checkersGameChat">
                    <div class="game-chat-message system">
                        <strong>System:</strong> Checkers game started!
                    </div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="checkersChatInput" 
                           maxlength="200" aria-label="Checkers game chat input">
                    <button onclick="sendGameMessage('checkers')" aria-label="Send checkers chat message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Word Game Window -->
    <div class="game-window hidden" id="wordGameWindow">
        <div class="game-window-header">
            <div class="game-window-title">
                📝 Word Battle 
                <span class="skill-badge skill-bronze" id="wordSkillBadge">Bronze</span>
                <span class="validation-status" title="Server Validated">
                    <i class="fas fa-check-circle"></i> Validated
                </span>
                <span class="sync-status" id="wordSyncStatus" title="Synchronized">
                    <i class="fas fa-sync-alt"></i>
                </span>
            </div>
            <div class="game-window-controls">
                <button class="window-btn minimize-btn" onclick="minimizeGame('words')" aria-label="Minimize word game">−</button>
                <button class="window-btn close-btn" onclick="closeGame('words')" aria-label="Close word game">×</button>
            </div>
        </div>
        <div class="game-window-content">
            <div class="game-info-bar">
                <div class="player-info">
                    <div class="player-details">
                        <div class="player-name" id="wordPlayerName">You</div>
                        <div class="timer" id="wordPlayerTimer">2:00</div>
                        <div class="word-score">Score: <span id="playerWordScore">0</span></div>
                    </div>
                </div>
                <div class="game-status-center">
                    <div class="game-status" id="wordStatus">Round 1 of 3</div>
                    <div class="round-indicator">
                        <div class="round-dot active" title="Round 1"></div>
                        <div class="round-dot" title="Round 2"></div>
                        <div class="round-dot" title="Round 3"></div>
                    </div>
                </div>
                <div class="opponent-info">
                    <div class="player-details">
                        <div class="player-name" id="wordOpponentName">Opponent</div>
                        <div class="timer" id="wordOpponentTimer">2:00</div>
                        <div class="word-score">Score: <span id="opponentWordScore">0</span></div>
                    </div>
                </div>
            </div>
            
            <div class="word-game">
                <div class="word-prompt">
                    <h4 id="wordPrompt">Make words with these letters:</h4>
                    <div id="wordLetters" class="available-letters">BLOCKCHAIN</div>
                </div>
                
                <div class="word-input-section">
                    <input type="text" class="word-input" id="wordInput" 
                           placeholder="Enter your word..." maxlength="20" 
                           aria-label="Word input" autocomplete="off">
                    <div class="word-validation" id="wordValidation"></div>
                </div>
                
                <div class="word-scoring">
                    <div class="scoring-info">
                        <div class="score-breakdown">
                            <span>Base: +<span id="baseScore">0</span></span>
                            <span>Length: +<span id="lengthBonus">0</span></span>
                            <span>Special: +<span id="specialBonus">0</span></span>
                        </div>
                        <div class="total-score">Total: <span id="roundScore">0</span></div>
                    </div>
                </div>
                
                <div class="submitted-words">
                    <h5>Words This Round:</h5>
                    <div class="words-list" id="submittedWordsList">
                        <!-- Word chips will be added here -->
                    </div>
                </div>
            </div>
            
            <div class="game-controls">
                <button class="game-btn primary" onclick="submitWord()">
                    <i class="fas fa-check"></i> Submit Word
                </button>
                <button class="game-btn neutral" onclick="skipRound()">
                    <i class="fas fa-forward"></i> Skip Round
                </button>
                <button class="game-btn secondary" onclick="shuffleLetters()">
                    <i class="fas fa-random"></i> Shuffle
                </button>
                <button class="game-btn secondary" onclick="getWordHint()">
                    <i class="fas fa-lightbulb"></i> Hint
                </button>
            </div>
            
            <div class="game-chat">
                <h4>
                    <i class="fas fa-comments"></i> Game Chat
                </h4>
                <div class="game-chat-messages" id="wordGameChat">
                    <div class="game-chat-message system">
                        <strong>System:</strong> Word battle started! Find as many words as you can!
                    </div>
                </div>
                <div class="game-chat-input">
                    <input type="text" placeholder="Type a message..." id="wordChatInput" 
                           maxlength="200" aria-label="Word game chat input">
                    <button onclick="sendGameMessage('words')" aria-label="Send word game chat message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    <!-- Main Container -->
    <div class="main-container">
        <!-- Enhanced Sidebar -->
        <div class="sidebar">
            <!-- Smart Contract Status -->
            <div class="contract-status">
                <h3><i class="fas fa-shield-alt"></i> Smart Contract</h3>
                <div class="contract-address" id="contractAddress">
                    <span class="tooltip" data-tooltip="Click to copy">
                        0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A
                    </span>
                    <button class="copy-btn" onclick="copyContractAddress()" aria-label="Copy contract address">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <div id="contractStatus">
                    <span class="connection-indicator pending"></span>
                    Connecting to Core Blockchain...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="connectionProgress" style="width: 0%"></div>
                </div>
                <div class="contract-verification">
                    <div class="verification-item">
                        <i class="fas fa-check-circle verified"></i>
                        <span>Contract Verified</span>
                    </div>
                    <div class="verification-item">
                        <i class="fas fa-shield-check security"></i>
                        <span>Security Audited</span>
                    </div>
                    <div class="verification-item">
                        <i class="fas fa-chart-line stats"></i>
                        <span>Live Statistics</span>
                    </div>
                </div>
            </div>

            <!-- Enhanced Live Platform Stats -->
            <div class="live-lobby">
                <h3><i class="fas fa-chart-bar"></i> Live Platform Stats</h3>
                <div class="lobby-stats">
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-users"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalPlayers">247</div>
                            <div class="stat-label">Online Players</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-gamepad"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalGames">89</div>
                            <div class="stat-label">Active Games</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-coins"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalVolume">156.7</div>
                            <div class="stat-label">CORE Volume (24h)</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon"><i class="fas fa-trophy"></i></div>
                        <div class="stat-details">
                            <div class="stat-value" id="totalTournaments">3</div>
                            <div class="stat-label">Live Tournaments</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Recent Activity Feed -->
            <div class="live-lobby">
                <h3><i class="fas fa-rss"></i> Recent Activity</h3>
                <div id="activityFeed" class="activity-feed">
                    <div class="activity-item">🎮 Player123 won 0.5 CORE in Chess!</div>
                    <div class="activity-item">⚔️ New tournament starting in 5 minutes</div>
                    <div class="activity-item">🔥 High stakes game: 2.0 CORE</div>
                    <div class="activity-item">📝 WordMaster scored 150 points!</div>
                    <div class="activity-item">🏆 Daily leaderboard updated</div>
                    <div class="activity-item">💰 BigWinner claimed 5.0 CORE!</div>
                    <div class="activity-item">🎯 Perfect game by ChessMaster</div>
                    <div class="activity-item">🚀 Platform reaching new highs!</div>
                </div>
                <button class="activity-refresh" onclick="refreshActivityFeed()">
                    <i class="fas fa-sync-alt"></i> Refresh Feed
                </button>
            </div>

            <!-- Enhanced Tournament Leaderboard -->
            <div class="live-lobby">
                <h3><i class="fas fa-crown"></i> Tournament Leaders</h3>
                <div id="tournamentLeaderboard" class="leaderboard">
                    <div class="leaderboard-item gold">
                        <div class="rank">🥇</div>
                        <div class="player-info">
                            <div class="player-name">CryptoKing</div>
                            <div class="player-games">15 wins today</div>
                        </div>
                        <div class="player-score">127 pts</div>
                    </div>
                    <div class="leaderboard-item silver">
                        <div class="rank">🥈</div>
                        <div class="player-info">
                            <div class="player-name">GameMaster</div>
                            <div class="player-games">12 wins today</div>
                        </div>
                        <div class="player-score">89 pts</div>
                    </div>
                    <div class="leaderboard-item bronze">
                        <div class="rank">🥉</div>
                        <div class="player-info">
                            <div class="player-name">ChessGM</div>
                            <div class="player-games">8 wins today</div>
                        </div>
                        <div class="player-score">76 pts</div>
                    </div>
                </div>
                <button class="leaderboard-view-all" onclick="viewFullLeaderboard()">
                    <i class="fas fa-list"></i> View Full Leaderboard
                </button>
            </div>

            <!-- Enhanced Network Status -->
            <div class="live-lobby">
                <h3><i class="fas fa-server"></i> Network Status</h3>
                <div class="server-grid">
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-gamepad"></i></div>
                        <div class="server-info">
                            <div class="server-status">Online</div>
                            <div class="server-label">Game Server</div>
                        </div>
                    </div>
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-network-wired"></i></div>
                        <div class="server-info">
                            <div class="server-status" id="serverLatency">12ms</div>
                            <div class="server-label">Latency</div>
                        </div>
                    </div>
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-shield-check"></i></div>
                        <div class="server-info">
                            <div class="server-status">Active</div>
                            <div class="server-label">Anti-Cheat</div>
                        </div>
                    </div>
                    <div class="server-item online">
                        <div class="server-icon"><i class="fas fa-chart-line"></i></div>
                        <div class="server-info">
                            <div class="server-status">99.9%</div>
                            <div class="server-label">Uptime</div>
                        </div>
                    </div>
                </div>
                <div class="network-info">
                    <div class="network-item">
                        <span class="network-label">Block Height:</span>
                        <span class="network-value" id="blockHeight">15,234,567</span>
                    </div>
                    <div class="network-item">
                        <span class="network-label">Gas Price:</span>
                        <span class="network-value" id="gasPrice">15.2 gwei</span>
                    </div>
                    <div class="network-item">
                        <span class="network-label">CORE Price:</span>
                        <span class="network-value" id="corePrice">$1.234</span>
                    </div>
                    <div class="network-item">
                        <span class="network-label">Network:</span>
                        <span class="network-value">Core Mainnet</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- Content Area -->
        <div class="content-area">
            
            <!-- Game Lobby Section -->
            <div id="lobbySection">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-dice"></i> Live Game Lobby</h2>
                        <div class="lobby-controls">
                            <button class="control-btn tooltip" data-tooltip="Refresh Lobby" onclick="refreshLobby()" aria-label="Refresh Lobby">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="control-btn tooltip" data-tooltip="Auto Refresh" id="autoRefreshBtn" onclick="toggleAutoRefresh()" aria-label="Auto Refresh">
                                <i class="fas fa-play"></i>
                            </button>
                            <button class="control-btn tooltip" data-tooltip="Filter Games" onclick="showGameFilters()" aria-label="Filter Games">
                                <i class="fas fa-filter"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="games-list" id="gamesList">
                        <!-- Games will be populated by JavaScript -->
                    </div>
                    
                    <div id="noGames" class="hidden empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-gamepad"></i>
                        </div>
                        <h3>No Active Games</h3>
                        <p>Be the first to create a game and start earning CORE tokens!</p>
                        <div class="empty-actions">
                            <button class="empty-action-btn" onclick="showSection('create')">
                                <i class="fas fa-plus"></i> Create First Game
                            </button>
                            <button class="empty-action-btn secondary" onclick="refreshLobby()">
                                <i class="fas fa-refresh"></i> Refresh Lobby
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- My Active Games Section -->
            <div id="activeSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-play-circle"></i> My Active Games</h2>
                        <div class="lobby-controls">
                            <button class="control-btn tooltip" data-tooltip="Refresh Active Games" onclick="refreshActiveGames()" aria-label="Refresh Active Games">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="control-btn tooltip" data-tooltip="Game History" onclick="showGameHistory()" aria-label="Game History">
                                <i class="fas fa-history"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="games-list" id="activeGamesList">
                        <!-- Active games will be populated here -->
                    </div>
                    
                    <div id="noActiveGames" class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-chess-board"></i>
                        </div>
                        <h3>No Active Games</h3>
                        <p>Join a game from the lobby or create your own to start playing and earning!</p>
                        <div class="empty-actions">
                            <button class="empty-action-btn" onclick="showSection('lobby')">
                                <i class="fas fa-search"></i> Browse Games
                            </button>
                            <button class="empty-action-btn secondary" onclick="showSection('create')">
                                <i class="fas fa-plus"></i> Create Game
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Create Game Section -->
            <div id="createSection" class="hidden">
                <div class="create-game-section">
                    <h2><i class="fas fa-plus-circle"></i> Create New Game</h2>
                    <p style="margin-bottom: 2rem; color: #aaa;">Choose your game type and set your stake to challenge other players.</p>
                    
                    <div class="game-type-selector">
                        <div class="game-type-card" data-type="chess" onclick="selectGameType('chess')">
                            <div class="game-icon">♟️</div>
                            <h3>Chess Masters</h3>
                            <p>Strategic blockchain chess with full move validation and anti-cheat protection.</p>
                            <div class="game-features">
                                <span class="feature-tag">5-30 min</span>
                                <span class="feature-tag">ELO Rating</span>
                                <span class="feature-tag">Move Analysis</span>
                            </div>
                            <div class="popularity-indicator">
                                <div class="popularity-bar" style="width: 85%"></div>
                                <span class="popularity-text">Very Popular</span>
                            </div>
                        </div>
                        
                        <div class="game-type-card" data-type="checkers" onclick="selectGameType('checkers')">
                            <div class="game-icon">⚫</div>
                            <h3>Checkers Pro</h3>
                            <p>Fast-paced checkers with instant blockchain settlements and king promotions.</p>
                            <div class="game-features">
                                <span class="feature-tag">3-15 min</span>
                                <span class="feature-tag">Quick Play</span>
                                <span class="feature-tag">Beginner Friendly</span>
                            </div>
                            <div class="popularity-indicator">
                                <div class="popularity-bar" style="width: 65%"></div>
                                <span class="popularity-text">Popular</span>
                            </div>
                        </div>
                        
                        <div class="game-type-card" data-type="words" onclick="selectGameType('words')">
                            <div class="game-icon">📝</div>
                            <h3>Word Battle</h3>
                            <p>Quick word-building competition with dictionary verification and scoring bonuses.</p>
                            <div class="game-features">
                                <span class="feature-tag">1-5 min</span>
                                <span class="feature-tag">Dictionary Verified</span>
                                <span class="feature-tag">Educational</span>
                            </div>
                            <div class="popularity-indicator">
                                <div class="popularity-bar" style="width: 45%"></div>
                                <span class="popularity-text">Growing</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stake-section">
                        <label for="gameStake">
                            <i class="fas fa-coins"></i> Stake Amount (CORE)
                        </label>
                        <input type="number" class="stake-input" id="gameStake" 
                               placeholder="Enter stake amount (min 0.01 CORE)" 
                               min="0.01" step="0.01" 
                               aria-label="Game stake amount"
                               oninput="updateCreateButton()">
                        <div class="stake-presets">
                            <button class="stake-preset" onclick="setStake(0.01)">0.01 CORE</button>
                            <button class="stake-preset" onclick="setStake(0.1)">0.1 CORE</button>
                            <button class="stake-preset" onclick="setStake(0.5)">0.5 CORE</button>
                            <button class="stake-preset" onclick="setStake(1.0)">1.0 CORE</button>
                            <button class="stake-preset" onclick="setStake(5.0)">5.0 CORE</button>
                        </div>
                        <div style="margin-top: 1rem; font-size: 0.85rem; color: #aaa;">
                            <i class="fas fa-info-circle"></i> Platform fee: 3% • Winner takes 97% of total stakes
                        </div>
                    </div>
                    
                    <button class="create-btn" id="createGameBtn" disabled onclick="createGame()">
                        <i class="fas fa-plus"></i> Select Game Type & Enter Stake
                    </button>
                </div>
            </div>

            <!-- Games Showcase Section -->
            <div id="gamesSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-gamepad"></i> Available Games</h2>
                        <div class="lobby-controls">
                            <button class="control-btn tooltip" data-tooltip="Game Statistics" onclick="showGameStats()" aria-label="Game Statistics">
                                <i class="fas fa-chart-bar"></i>
                            </button>
                        </div>
                    </div>
                    </div>
                    <p style="margin-bottom: 2rem; color: #aaa;">Choose from our collection of blockchain-powered games. All games feature smart contract security and instant CORE payouts.</p>
                    
                    <div class="games-showcase">
                        <div class="game-showcase-card">
                            <div class="showcase-header">
                                <div class="showcase-icon">♟️</div>
                                <h3>Chess Masters</h3>
                                <div class="showcase-rating">
                                    <div class="stars">★★★★★</div>
                                    <span>(4.9/5 • 1,247 players)</span>
                                </div>
                            </div>
                            <p>Professional chess with blockchain stakes, ELO rating system, and smart contract security. Perfect for strategic minds.</p>
                            <div class="showcase-features">
                                <span class="feature-pill">ELO Rating</span>
                                <span class="feature-pill">Move Analysis</span>
                                <span class="feature-pill">Anti-Cheat</span>
                            </div>
                            <button class="showcase-btn" onclick="showSection('create'); selectGameType('chess')">
                                <i class="fas fa-chess-board"></i> Create Chess Game
                            </button>
                        </div>
                        
                        <div class="game-showcase-card">
                            <div class="showcase-header">
                                <div class="showcase-icon">⚫</div>
                                <h3>Checkers Pro</h3>
                                <div class="showcase-rating">
                                    <div class="stars">★★★★☆</div>
                                    <span>(4.6/5 • 892 players)</span>
                                </div>
                            </div>
                            <p>Fast-paced checkers with instant blockchain settlements. Quick games, quick rewards!</p>
                            <div class="showcase-features">
                                <span class="feature-pill">Quick Play</span>
                                <span class="feature-pill">King Promotion</span>
                                <span class="feature-pill">Instant Rewards</span>
                            </div>
                            <button class="showcase-btn" onclick="showSection('create'); selectGameType('checkers')">
                                <i class="fas fa-th"></i> Create Checkers Game
                            </button>
                        </div>
                        
                        <div class="game-showcase-card">
                            <div class="showcase-header">
                                <div class="showcase-icon">📝</div>
                                <h3>Word Battle</h3>
                                <div class="showcase-rating">
                                    <div class="stars">★★★★☆</div>
                                    <span>(4.4/5 • 634 players)</span>
                                </div>
                            </div>
                            <p>Competitive word games with dictionary verification and special scoring bonuses for rare letters.</p>
                            <div class="showcase-features">
                                <span class="feature-pill">Dictionary Check</span>
                                <span class="feature-pill">Scoring Bonuses</span>
                                <span class="feature-pill">Educational</span>
                            </div>
                            <button class="showcase-btn" onclick="showSection('create'); selectGameType('words')">
                                <i class="fas fa-font"></i> Create Word Game
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Tournaments Section -->
            <div id="tournamentsSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-trophy"></i> Tournaments</h2>
                        <div class="lobby-controls">
                            <button class="control-btn tooltip" data-tooltip="Refresh Tournaments" onclick="refreshTournaments()" aria-label="Refresh Tournaments">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="empty-action-btn" onclick="createTournament()">
                                <i class="fas fa-plus"></i> Create Tournament
                            </button>
                        </div>
                    </div>
                    
                    <div class="tournament-filters">
                        <button class="filter-btn active" onclick="filterTournaments('all')">All</button>
                        <button class="filter-btn" onclick="filterTournaments('live')">Live</button>
                        <button class="filter-btn" onclick="filterTournaments('upcoming')">Upcoming</button>
                        <button class="filter-btn" onclick="filterTournaments('chess')">Chess</button>
                        <button class="filter-btn" onclick="filterTournaments('checkers')">Checkers</button>
                        <button class="filter-btn" onclick="filterTournaments('words')">Words</button>
                    </div>
                    
                    <div class="tournaments-grid" id="tournamentsGrid">
                        <!-- Sample tournament -->
                        <div class="tournament-card live-tournament">
                            <div class="tournament-header">
                                <div class="tournament-type">♟️ Chess Masters Cup</div>
                                <div class="tournament-status live">LIVE</div>
                            </div>
                            <div class="tournament-info">
                                <div class="tournament-detail">
                                    <i class="fas fa-coins"></i>
                                    <span>Prize Pool: <strong>15.0 CORE</strong></span>
                                </div>
                                <div class="tournament-detail">
                                    <i class="fas fa-users"></i>
                                    <span>Players: <strong>32/64</strong></span>
                                </div>
                                <div class="tournament-detail">
                                    <i class="fas fa-dollar-sign"></i>
                                    <span>Entry: <strong>0.5 CORE</strong></span>
                                </div>
                                <div class="tournament-detail">
                                    <i class="fas fa-clock"></i>
                                    <span>Format: <strong>Single Elimination</strong></span>
                                </div>
                            </div>
                            <div class="tournament-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: 33%"></div>
                                </div>
                                <span class="progress-text">Round 2 of 6</span>
                            </div>
                            <div class="tournament-actions">
                                <button class="tournament-btn primary" onclick="joinTournament('chess_masters_001')">
                                    <i class="fas fa-trophy"></i> Join Tournament
                                </button>
                                <button class="tournament-btn secondary" onclick="viewTournament('chess_masters_001')">
                                    <i class="fas fa-eye"></i> View Bracket
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="noTournaments" class="hidden empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-trophy"></i>
                        </div>
                        <h3>No Active Tournaments</h3>
                        <p>Be the first to create a tournament and compete for bigger prizes!</p>
                        <div class="empty-actions">
                            <button class="empty-action-btn" onclick="createTournament()">
                                <i class="fas fa-plus"></i> Create Tournament
                            </button>
                            <button class="empty-action-btn secondary" onclick="refreshTournaments()">
                                <i class="fas fa-refresh"></i> Refresh
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Leaderboard Section -->
            <div id="leaderboardSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-crown"></i> Global Leaderboard</h2>
                        <div class="lobby-controls">
                            <button class="control-btn tooltip" data-tooltip="Refresh Rankings" onclick="refreshLeaderboard()" aria-label="Refresh Leaderboard">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="control-btn tooltip" data-tooltip="My Rank" onclick="showMyRank()" aria-label="Show My Rank">
                                <i class="fas fa-user"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="tournament-filters">
                        <button class="filter-btn active" onclick="filterLeaderboard('overall')">Overall</button>
                        <button class="filter-btn" onclick="filterLeaderboard('weekly')">This Week</button>
                        <button class="filter-btn" onclick="filterLeaderboard('monthly')">This Month</button>
                        <button class="filter-btn" onclick="filterLeaderboard('chess')">Chess</button>
                        <button class="filter-btn" onclick="filterLeaderboard('checkers')">Checkers</button>
                        <button class="filter-btn" onclick="filterLeaderboard('words')">Words</button>
                    </div>
                    
                    <div class="leaderboard" id="globalLeaderboard">
                        <!-- Leaderboard items will be populated here -->
                    </div>
                    
                    <div class="empty-state" id="noLeaderboardData" style="display: none;">
                        <div class="empty-icon">
                            <i class="fas fa-crown"></i>
                        </div>
                        <h3>Leaderboard Loading</h3>
                        <p>Rankings are being updated...</p>
                    </div>
                </div>
            </div>

            <!-- Enhanced Profile Section -->
            <div id="profileSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-user-circle"></i> Player Profile</h2>
                        <div class="lobby-controls">
                            <button class="control-btn tooltip" data-tooltip="Export Stats" onclick="exportPlayerStats()" aria-label="Export Statistics">
                                <i class="fas fa-download"></i>
                            </button>
                            <button class="control-btn tooltip" data-tooltip="Share Profile" onclick="shareProfile()" aria-label="Share Profile">
                                <i class="fas fa-share"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="profile-content">
                        <div class="profile-header">
                            <div class="profile-avatar">
                                <i class="fas fa-user-circle"></i>
                            </div>
                            <div class="profile-info">
                                <div class="profile-name" id="profilePlayerName">Player</div>
                                <div class="profile-level">
                                    Level <span id="profileLevel">1</span> • 
                                    <span id="profileRank">Rookie</span>
                                </div>
                                <div class="profile-xp">
                                    <span id="profileXP">0</span> XP • 
                                    Next level: <span id="profileXPNeeded">1000</span> XP
                                </div>
                                <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #aaa;">
                                    Member since: <span id="memberSince">Today</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="profile-stats">
                            <div class="stat-card">
                                <div class="stat-icon">🎮</div>
                                <div class="stat-value" id="profileGamesPlayed">0</div>
                                <div class="stat-label">Games Played</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">🏆</div>
                                <div class="stat-value" id="profileGamesWon">0</div>
                                <div class="stat-label">Games Won</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">💰</div>
                                <div class="stat-value" id="profileTotalEarned">0.0000</div>
                                <div class="stat-label">CORE Earned</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">📈</div>
                                <div class="stat-value" id="profileWinRate">0%</div>
                                <div class="stat-label">Win Rate</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">⚡</div>
                                <div class="stat-value" id="profileWinStreak">0</div>
                                <div class="stat-label">Win Streak</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">👑</div>
                                <div class="stat-value" id="profileGlobalRank">-</div>
                                <div class="stat-label">Global Rank</div>
                            </div>
                        </div>
                        
                        <div class="achievements-section">
                            <h3><i class="fas fa-medal"></i> Achievements</h3>
                            <div class="achievements-grid" id="achievementsGrid">
                                <!-- Achievements will be populated here -->
                            </div>
                        </div>
                        
                        <div class="achievements-section">
                            <h3><i class="fas fa-chart-line"></i> Game Statistics</h3>
                            <div class="profile-stats">
                                <div class="stat-card">
                                    <div class="stat-icon">♟️</div>
                                    <div class="stat-value" id="chessELO">1200</div>
                                    <div class="stat-label">Chess ELO</div>
                                </div>
                                <div class="stat-card">
                                    <div class="stat-icon">⚫</div>
                                    <div class="stat-value" id="checkersRating">1200</div>
                                    <div class="stat-label">Checkers Rating</div>
                                </div>
                                <div class="stat-card">
                                    <div class="stat-icon">📝</div>
                                    <div class="stat-value" id="wordsRating">1200</div>
                                    <div class="stat-label">Words Rating</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Section -->
            <div id="settingsSection" class="hidden">
                <div class="live-lobby">
                    <div class="lobby-header">
                        <h2><i class="fas fa-cog"></i> Settings</h2>
                        <div class="lobby-controls">
                            <button class="control-btn tooltip" data-tooltip="Reset Settings" onclick="resetSettings()" aria-label="Reset Settings">
                                <i class="fas fa-undo"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="create-game-section">
                        <h3><i class="fas fa-palette"></i> Appearance</h3>
                        <div class="form-group">
                            <label class="form-label">Theme</label>
                            <select class="form-input" id="themeSelect" onchange="changeTheme()">
                                <option value="dark">Dark Theme</option>
                                <option value="light">Light Theme</option>
                                <option value="auto">Auto (System)</option>
                            </select>
                        </div>
                        
                        <h3><i class="fas fa-bell"></i> Notifications</h3>
                        <div class="form-group">
                            <label class="form-label">
                                <input type="checkbox" id="enableNotifications" onchange="toggleNotifications()" checked>
                                Enable game notifications
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="form-label">
                                <input type="checkbox" id="enableSounds" onchange="toggleSounds()" checked>
                                Enable sound effects
                            </label>
                        </div>
                        
                        <h3><i class="fas fa-gamepad"></i> Gameplay</h3>
                        <div class="form-group">
                            <label class="form-label">
                                <input type="checkbox" id="showMoveHints" onchange="toggleMoveHints()" checked>
                                Show move hints
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="form-label">
                                <input type="checkbox" id="autoSaveGames" onchange="toggleAutoSave()" checked>
                                Auto-save game progress
                            </label>
                        </div>
                        
                        <h3><i class="fas fa-shield-alt"></i> Security</h3>
                        <div class="form-group">
                            <button class="create-btn" onclick="exportPrivateKey()">
                                <i class="fas fa-key"></i> Export Wallet Backup
                            </button>
                        </div>
                        
                        <div class="empty-state" style="margin-top: 2rem;">
                            <h3>More Settings Coming Soon</h3>
                            <p>Additional customization options will be added in future updates!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  <!-- Enhanced JavaScript Implementation -->
    <script>
        // ENHANCED CROSSREALM GAMING PLATFORM - COMPLETE JAVASCRIPT IMPLEMENTATION
        // Updated with Firebase integration, real multiplayer, and Core blockchain settlements

        // Enhanced Global Configuration
        const GAME_CONTRACT_ADDRESS = "0x7af2cB8f93D0a75E0ba39E974B4e968EAe49028A";
        const CORE_CHAIN_ID = "0x45c"; // Core mainnet
        const CORE_RPC_URL = "https://rpc.coredao.org";
        const CORE_EXPLORER = "https://scan.coredao.org";

        // Firebase Configuration - Replace with your Firebase config
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyBxxxxxxxxxxxxxxxxxxx", // Replace with your API key
            authDomain: "crossrealm-demo.firebaseapp.com",
            databaseURL: "https://crossrealm-demo-default-rtdb.firebaseio.com",
            projectId: "crossrealm-demo",
            storageBucket: "crossrealm-demo.appspot.com",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abcdef123456"
        };

        // Dictionary API Configuration
        const DICTIONARY_CONFIG = {
            PRIMARY_API: 'https://api.dictionaryapi.dev/api/v2/entries/en/',
            BACKUP_API: 'https://dictionaryapi.com/api/v3/references/collegiate/json/',
            FALLBACK_WORDS: new Set([
                'cat', 'dog', 'car', 'book', 'game', 'code', 'block', 'chain',
                'coin', 'token', 'key', 'lock', 'hack', 'link', 'node', 'data',
                'tech', 'core', 'name', 'rock', 'back', 'lack', 'neck', 'deck',
                'chess', 'check', 'king', 'queen', 'pawn', 'rook', 'knight'
            ])
        };

        // Smart Contract ABI for Core Blockchain
        const GAME_CONTRACT_ABI = [
            "function createGame(string memory gameType, uint256 timeLimit) external payable returns (uint256)",
            "function joinGame(uint256 gameId) external payable",
            "function submitMove(uint256 gameId, bytes memory moveData, bytes32 gameStateHash) external",
            "function finalizeGame(uint256 gameId, address winner, bytes32 finalStateHash) external",
            "function claimWinnings(uint256 gameId) external",
            "function refundStake(uint256 gameId) external",
            "function createTournament(string memory name, uint256 entryFee, uint256 maxPlayers) external payable returns (uint256)",
            "function joinTournament(uint256 tournamentId) external payable",
            "function getGame(uint256 gameId) external view returns (tuple(address player1, address player2, uint256 stake, uint256 status, string gameType))",
            "function getTotalGames() external view returns (uint256)",
            "function getPlayerGames(address player) external view returns (uint256[] memory)",
            "function getPlayerStats(address player) external view returns (tuple(uint256 gamesPlayed, uint256 gamesWon, uint256 totalEarned))",
            "event GameCreated(uint256 indexed gameId, address indexed creator, uint256 stake, string gameType)",
            "event GameJoined(uint256 indexed gameId, address indexed player)",
            "event GameFinalized(uint256 indexed gameId, address indexed winner, uint256 payout)",
            "event MoveSubmitted(uint256 indexed gameId, address indexed player, bytes32 moveHash)"
        ];

        // Enhanced Global Variables
        let web3Provider = null;
        let userAccount = null;
        let gameContract = null;
        let currentBalance = 0;
        let activeGames = [];
        let myActiveGames = [];
        let globalGamesList = [];
        let selectedGameType = null;
        let gameUpdateInterval = null;
        let autoRefreshEnabled = false;
        let tournaments = [];
        let currentSection = 'lobby';
        let isGameActive = false;
        let activeGameType = null;

        // Enhanced Firebase Manager
        class FirebaseManager {
            constructor() {
                this.db = null;
                this.auth = null;
                this.initialized = false;
                this.gameStateCache = new Map();
                this.listeners = new Map();
            }

            async initialize() {
                try {
                    if (typeof firebase !== 'undefined') {
                        firebase.initializeApp(FIREBASE_CONFIG);
                        this.db = firebase.database();
                        this.auth = firebase.auth();
                        this.initialized = true;
                        console.log('🔥 Firebase initialized successfully');
                        
                        // Setup connection state monitoring
                        this.setupConnectionMonitoring();
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    return false;
                }
            }

            setupConnectionMonitoring() {
                if (this.db) {
                    const connectedRef = this.db.ref('.info/connected');
                    connectedRef.on('value', (snapshot) => {
                        if (snapshot.val() === true) {
                            console.log('🔥 Firebase connected');
                            this.updateConnectionIndicator('connected');
                        } else {
                            console.log('🔥 Firebase disconnected');
                            this.updateConnectionIndicator('disconnected');
                        }
                    });
                }
            }

            updateConnectionIndicator(status) {
                const indicator = document.querySelector('#connectionQuality .connection-dot');
                if (indicator) {
                    indicator.style.background = status === 'connected' ? '#2ecc71' : '#e74c3c';
                }
            }

            async saveGame(gameData) {
                if (!this.initialized || !this.db) return false;
                
                try {
                    const ref = this.db.ref(`games/${gameData.id}`);
                    await ref.set({
                        ...gameData,
                        lastUpdated: firebase.database.ServerValue.TIMESTAMP
                    });
                    return true;
                } catch (error) {
                    console.error('Failed to save game:', error);
                    return false;
                }
            }

            async getGames() {
                if (!this.initialized || !this.db) return {};
                
                try {
                    const snapshot = await this.db.ref('games').once('value');
                    return snapshot.val() || {};
                } catch (error) {
                    console.error('Failed to get games:', error);
                    return {};
                }
            }

            watchGames(callback) {
                if (!this.initialized || !this.db) return;
                
                const gamesRef = this.db.ref('games');
                gamesRef.on('value', (snapshot) => {
                    const games = snapshot.val() || {};
                    callback(games);
                });
                
                this.listeners.set('games', gamesRef);
            }

            async saveGameState(gameId, gameState) {
                if (!this.initialized || !this.db) return false;
                
                try {
                    const ref = this.db.ref(`gameStates/${gameId}`);
                    await ref.set({
                        ...gameState,
                        lastUpdated: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    this.gameStateCache.set(gameId, gameState);
                    return true;
                } catch (error) {
                    console.error('Failed to save game state:', error);
                    return false;
                }
            }

            async getGameState(gameId) {
                if (!this.initialized || !this.db) return null;
                
                try {
                    // Check cache first
                    if (this.gameStateCache.has(gameId)) {
                        return this.gameStateCache.get(gameId);
                    }
                    
                    const snapshot = await this.db.ref(`gameStates/${gameId}`).once('value');
                    const gameState = snapshot.val();
                    
                    if (gameState) {
                        this.gameStateCache.set(gameId, gameState);
                    }
                    
                    return gameState;
                } catch (error) {
                    console.error('Failed to get game state:', error);
                    return null;
                }
            }

            watchGameState(gameId, callback) {
                if (!this.initialized || !this.db) return;
                
                const gameStateRef = this.db.ref(`gameStates/${gameId}`);
                gameStateRef.on('value', (snapshot) => {
                    const gameState = snapshot.val();
                    if (gameState) {
                        this.gameStateCache.set(gameId, gameState);
                        callback(gameState);
                    }
                });
                
                this.listeners.set(`gameState_${gameId}`, gameStateRef);
            }

            async savePlayerStats(playerAddress, stats) {
                if (!this.initialized || !this.db) return false;
                
                try {
                    const ref = this.db.ref(`playerStats/${playerAddress}`);
                    await ref.update({
                        ...stats,
                        lastUpdated: firebase.database.ServerValue.TIMESTAMP
                    });
                    return true;
                } catch (error) {
                    console.error('Failed to save player stats:', error);
                    return false;
                }
            }

            async getPlayerStats(playerAddress) {
                if (!this.initialized || !this.db) return null;
                
                try {
                    const snapshot = await this.db.ref(`playerStats/${playerAddress}`).once('value');
                    return snapshot.val();
                } catch (error) {
                    console.error('Failed to get player stats:', error);
                    return null;
                }
            }

            cleanup() {
                // Remove all listeners
                this.listeners.forEach((ref) => {
                    ref.off();
                });
                this.listeners.clear();
                this.gameStateCache.clear();
            }
        }

        // Enhanced Blockchain Manager with Core support
        class CoreBlockchainManager {
            constructor() {
                this.provider = null;
                this.signer = null;
                this.contract = null;
                this.networkInfo = {};
                this.eventListeners = new Map();
                this.transactionQueue = [];
                this.isProcessingTx = false;
            }

            async initialize() {
                try {
                    if (typeof window.ethereum === 'undefined') {
                        console.log('MetaMask not detected');
                        this.showMetaMaskPrompt();
                        return false;
                    }

                    this.provider = new ethers.providers.Web3Provider(window.ethereum);
                    await this.updateNetworkInfo();
                    
                    this.contract = new ethers.Contract(
                        GAME_CONTRACT_ADDRESS,
                        GAME_CONTRACT_ABI,
                        this.provider
                    );

                    this.setupEventListeners();
                    console.log('⛓️ Blockchain manager initialized');
                    return true;
                } catch (error) {
                    console.error('Blockchain initialization failed:', error);
                    return false;
                }
            }

            showMetaMaskPrompt() {
                showTransactionStatus('❌ MetaMask Required', 'Please install MetaMask to use real CORE tokens');
                
                setTimeout(() => {
                    if (confirm('MetaMask is required for blockchain features. Install now?')) {
                        window.open('https://metamask.io/download/', '_blank');
                    }
                }, 2000);
            }

            async connectWallet() {
                try {
                    showTransactionStatus('🔄 Connecting to MetaMask...', '');
                    updateConnectionStatus('pending');

                    const accounts = await window.ethereum.request({
                        method: 'eth_requestAccounts'
                    });

                    if (accounts.length === 0) {
                        throw new Error('No accounts found');
                    }

                    userAccount = accounts[0];
                    this.signer = this.provider.getSigner();
                    
                    if (this.contract) {
                        this.contract = this.contract.connect(this.signer);
                    }

                    await this.ensureCoreNetwork();

                    const balance = await this.provider.getBalance(userAccount);
                    currentBalance = parseFloat(ethers.utils.formatEther(balance));

                    updateConnectionStatus('connected');
                    showTransactionStatus('✅ Connected to Core Blockchain!', '
                                          // Initialize Global Managers
        window.firebaseManager = new FirebaseManager();
        window.blockchainManager = new CoreBlockchainManager();
        window.playerProgression = new PlayerProgression();

        // Age verification functions
        function checkAgeVerification() {
            try {
                const verified = localStorage.getItem('ageVerified');
                if (verified === 'true') {
                    const modal = document.getElementById('ageVerificationModal');
                    if (modal) modal.style.display = 'none';
                    return true;
                }
                return false;
            } catch (error) {
                console.log('localStorage not available, showing verification modal');
                return false;
            }
        }

        function verifyAge(isAdult) {
            if (isAdult) {
                try {
                    localStorage.setItem('ageVerified', 'true');
                } catch (error) {
                    console.log('localStorage not available');
                }
                const modal = document.getElementById('ageVerificationModal');
                if (modal) modal.style.display = 'none';
                initializePlatform();
            } else {
                alert('You must be 18 or older to access this platform.');
                window.location.href = 'https://www.example.com';
            }
        }

        // Enhanced navigation functions
        function showSection(sectionName) {
            const sections = ['lobby', 'active', 'create', 'games', 'tournaments', 'leaderboard', 'profile', 'settings'];
            
            sections.forEach(section => {
                const element = document.getElementById(section + 'Section');
                if (element) element.classList.add('hidden');
            });

            const targetSection = document.getElementById(sectionName + 'Section');
            if (targetSection) {
                targetSection.classList.remove('hidden');
            }

            // Update navigation
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const navItems = document.querySelectorAll('.nav-item');
            const navMapping = {
                'lobby': 0, 'active': 1, 'create': 2, 'games': 3, 
                'tournaments': 4, 'leaderboard': 5, 'profile': 6, 'settings': 7
            };
            
            if (navMapping[sectionName] !== undefined && navItems[navMapping[sectionName]]) {
                navItems[navMapping[sectionName]].classList.add('active');
            }

            currentSection = sectionName;
            
            // Load section-specific data
            switch (sectionName) {
                case 'tournaments':
                    refreshTournaments();
                    break;
                case 'profile':
                    window.playerProgression.updateDisplays();
                    break;
                case 'active':
                    refreshActiveGames();
                    break;
                case 'lobby':
                    refreshLobby();
                    break;
                case 'leaderboard':
                    refreshLeaderboard();
                    break;
            }
        }

        // Enhanced wallet connection
        async function connectWallet() {
            try {
                showLoadingOverlay('Connecting Wallet', 'Initializing blockchain connection...');
                
                const initialized = await window.blockchainManager.initialize();
                if (!initialized) {
                    hideLoadingOverlay();
                    return demoMode();
                }

                updateLoadingMessage('Connecting to MetaMask', 'Please approve the connection...');
                const walletResult = await window.blockchainManager.connectWallet();
                
                userAccount = walletResult.account;
                currentBalance = walletResult.balance;

                update

          /* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 18: ADVANCED SECURITY & ANTI-CHEAT SYSTEMS
   =========================== */

'use strict';

// ===========================
// SECURITY MANAGER
// ===========================

class SecurityManager {
    constructor() {
        this.activeSessions = new Map();
        this.suspiciousActivity = new Map();
        this.rateLimiter = new Map();
        this.encryptionKey = null;
        this.securityLevel = 'HIGH';
        
        this.initializeSecurity();
    }
    
    async initializeSecurity() {
        try {
            // Generate session encryption key
            this.encryptionKey = await this.generateEncryptionKey();
            
            // Initialize security monitoring
            this.startSecurityMonitoring();
            
            // Setup anti-bot measures
            this.initializeAntiBotSystem();
            
            console.log('✅ Security Manager initialized');
            
        } catch (error) {
            console.error('❌ Security initialization failed:', error);
        }
    }
    
    async generateEncryptionKey() {
        const keyMaterial = await crypto.subtle.generateKey(
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
        return keyMaterial;
    }
    
    async encryptData(data) {
        try {
            const encoder = new TextEncoder();
            const encodedData = encoder.encode(JSON.stringify(data));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encryptedData = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                this.encryptionKey,
                encodedData
            );
            
            return {
                encryptedData: Array.from(new Uint8Array(encryptedData)),
                iv: Array.from(iv),
                timestamp: Date.now()
            };
            
        } catch (error) {
            throw new Error('Encryption failed: ' + error.message);
        }
    }
    
    async decryptData(encryptedPayload) {
        try {
            const { encryptedData, iv } = encryptedPayload;
            
            const decryptedData = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: new Uint8Array(iv) },
                this.encryptionKey,
                new Uint8Array(encryptedData)
            );
            
            const decoder = new TextDecoder();
            return JSON.parse(decoder.decode(decryptedData));
            
        } catch (error) {
            throw new Error('Decryption failed: ' + error.message);
        }
    }
    
    validateSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session) return false;
        
        // Check session expiry
        if (Date.now() - session.created > 24 * 60 * 60 * 1000) {
            this.activeSessions.delete(sessionId);
            return false;
        }
        
        // Update last activity
        session.lastActivity = Date.now();
        return true;
    }
    
    createSession(walletAddress) {
        const sessionId = this.generateSecureId();
        const session = {
            id: sessionId,
            walletAddress: walletAddress.toLowerCase(),
            created: Date.now(),
            lastActivity: Date.now(),
            ipAddress: this.getClientIP(),
            userAgent: navigator.userAgent,
            attempts: 0,
            verified: false
        };
        
        this.activeSessions.set(sessionId, session);
        return sessionId;
    }
    
    generateSecureId() {
        const timestamp = Date.now();
        const randomBytes = crypto.getRandomValues(new Uint8Array(16));
        const randomHex = Array.from(randomBytes, b => b.toString(16).padStart(2, '0')).join('');
        return `${timestamp}_${randomHex}`;
    }
    
    getClientIP() {
        // In a real implementation, you'd get this from the server
        return '127.0.0.1';
    }
}

// ===========================
// ANTI-CHEAT SYSTEM
// ===========================

class AntiCheatSystem {
    constructor() {
        this.playerBehaviors = new Map();
        this.gameIntegrityChecks = new Map();
        this.suspiciousPatterns = new Map();
        this.cheatDetectionThreshold = 0.85;
        this.monitoringActive = true;
        
        this.initializeAntiCheat();
    }
    
    initializeAntiCheat() {
        // Start behavior monitoring
        this.startBehaviorAnalysis();
        
        // Initialize integrity checks
        this.setupIntegrityMonitoring();
        
        // Setup pattern detection
        this.initializePatternDetection();
        
        console.log('✅ Anti-Cheat System initialized');
    }
    
    startBehaviorAnalysis() {
        setInterval(() => {
            this.analyzeBehaviorPatterns();
        }, 5000); // Check every 5 seconds
    }
    
    analyzeBehaviorPatterns() {
        this.playerBehaviors.forEach((behavior, playerId) => {
            const suspiciousScore = this.calculateSuspiciousScore(behavior);
            
            if (suspiciousScore > this.cheatDetectionThreshold) {
                this.flagSuspiciousActivity(playerId, suspiciousScore);
            }
        });
    }
    
    calculateSuspiciousScore(behavior) {
        let score = 0;
        
        // Check move timing patterns (too consistent = suspicious)
        if (behavior.moveTimes && behavior.moveTimes.length > 5) {
            const avgTime = behavior.moveTimes.reduce((a, b) => a + b) / behavior.moveTimes.length;
            const variance = behavior.moveTimes.reduce((sum, time) => sum + Math.pow(time - avgTime, 2), 0) / behavior.moveTimes.length;
            
            // Very low variance in move times is suspicious
            if (variance < 100) score += 0.3;
        }
        
        // Check win rate (too high = suspicious)
        if (behavior.gamesPlayed > 10) {
            const winRate = behavior.gamesWon / behavior.gamesPlayed;
            if (winRate > 0.95) score += 0.4;
        }
        
        // Check mouse movement patterns
        if (behavior.mouseMovements && behavior.mouseMovements.length > 0) {
            const straightLineMovements = behavior.mouseMovements.filter(m => m.straight).length;
            const straightLineRatio = straightLineMovements / behavior.mouseMovements.length;
            
            // Too many straight line movements is suspicious (bot-like)
            if (straightLineRatio > 0.8) score += 0.3;
        }
        
        return Math.min(score, 1.0);
    }
    
    recordPlayerAction(playerId, action) {
        if (!this.playerBehaviors.has(playerId)) {
            this.playerBehaviors.set(playerId, {
                moveTimes: [],
                mouseMovements: [],
                gamesPlayed: 0,
                gamesWon: 0,
                actions: []
            });
        }
        
        const behavior = this.playerBehaviors.get(playerId);
        
        switch (action.type) {
            case 'MOVE':
                behavior.moveTimes.push(action.duration);
                behavior.actions.push(action);
                break;
                
            case 'MOUSE_MOVEMENT':
                behavior.mouseMovements.push({
                    x: action.x,
                    y: action.y,
                    timestamp: action.timestamp,
                    straight: this.isStraightLineMovement(action, behavior.mouseMovements)
                });
                break;
                
            case 'GAME_END':
                behavior.gamesPlayed++;
                if (action.won) behavior.gamesWon++;
                break;
        }
        
        // Keep only recent data (last 100 actions)
        if (behavior.actions.length > 100) {
            behavior.actions = behavior.actions.slice(-100);
        }
        if (behavior.moveTimes.length > 50) {
            behavior.moveTimes = behavior.moveTimes.slice(-50);
        }
        if (behavior.mouseMovements.length > 200) {
            behavior.mouseMovements = behavior.mouseMovements.slice(-200);
        }
    }
    
    isStraightLineMovement(currentAction, previousMovements) {
        if (previousMovements.length < 2) return false;
        
        const prev = previousMovements[previousMovements.length - 1];
        const prevPrev = previousMovements[previousMovements.length - 2];
        
        // Calculate if movement is in a straight line
        const dx1 = prev.x - prevPrev.x;
        const dy1 = prev.y - prevPrev.y;
        const dx2 = currentAction.x - prev.x;
        const dy2 = currentAction.y - prev.y;
        
        // Check if vectors are parallel (cross product near zero)
        const crossProduct = Math.abs(dx1 * dy2 - dy1 * dx2);
        return crossProduct < 5; // Threshold for "straight enough"
    }
    
    setupIntegrityMonitoring() {
        // Monitor game state integrity
        setInterval(() => {
            this.checkGameStateIntegrity();
        }, 10000); // Check every 10 seconds
    }
    
    checkGameStateIntegrity() {
        // Check if game states are valid and haven't been tampered with
        window.GameStateManager.getAllGameStates().forEach((state, gameId) => {
            const integrityHash = this.calculateStateHash(state);
            const expectedHash = this.gameIntegrityChecks.get(gameId);
            
            if (expectedHash && integrityHash !== expectedHash) {
                this.reportIntegrityViolation(gameId, 'State hash mismatch');
            }
            
            this.gameIntegrityChecks.set(gameId, integrityHash);
        });
    }
    
    calculateStateHash(gameState) {
        const stateString = JSON.stringify(gameState, Object.keys(gameState).sort());
        return this.simpleHash(stateString);
    }
    
    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString(16);
    }
    
    flagSuspiciousActivity(playerId, suspiciousScore) {
        console.warn(`🚨 Suspicious activity detected for player ${playerId}, score: ${suspiciousScore}`);
        
        this.suspiciousPatterns.set(playerId, {
            score: suspiciousScore,
            timestamp: Date.now(),
            actions: ['MONITOR', 'VERIFY_MOVES']
        });
        
        // Notify security manager
        window.SecurityManager?.handleSuspiciousActivity?.(playerId, suspiciousScore);
    }
    
    reportIntegrityViolation(gameId, violation) {
        console.error(`🚨 Game integrity violation in ${gameId}: ${violation}`);
        
        // Take immediate action
        this.handleIntegrityViolation(gameId, violation);
    }
    
    handleIntegrityViolation(gameId, violation) {
        // Pause the game
        window.GameStateManager?.pauseGame?.(gameId);
        
        // Notify players
        window.UIManager?.showSecurityAlert?.(
            `Game paused due to security violation: ${violation}`
        );
        
        // Log for investigation
        this.logSecurityEvent('INTEGRITY_VIOLATION', {
            gameId,
            violation,
            timestamp: Date.now()
        });
    }
    
    logSecurityEvent(eventType, data) {
        const event = {
            type: eventType,
            data: data,
            timestamp: Date.now(),
            sessionId: window.SecurityManager?.currentSession?.id
        };
        
        // Store locally and send to server
        const securityLogs = JSON.parse(localStorage.getItem('securityLogs') || '[]');
        securityLogs.push(event);
        
        // Keep only last 1000 events
        if (securityLogs.length > 1000) {
            securityLogs.splice(0, securityLogs.length - 1000);
        }
        
        localStorage.setItem('securityLogs', JSON.stringify(securityLogs));
    }
}

// ===========================
// RATE LIMITING SYSTEM
// ===========================

class RateLimiter {
    constructor() {
        this.limits = new Map();
        this.defaultLimits = {
            'MOVE': { maxRequests: 10, windowMs: 10000 }, // 10 moves per 10 seconds
            'GAME_CREATE': { maxRequests: 3, windowMs: 60000 }, // 3 games per minute
            'MESSAGE': { maxRequests: 20, windowMs: 60000 }, // 20 messages per minute
            'LOGIN': { maxRequests: 5, windowMs: 300000 } // 5 login attempts per 5 minutes
        };
        
        this.requests = new Map();
        this.blocked = new Map();
        
        this.startCleanup();
    }
    
    startCleanup() {
        // Clean up old requests every minute
        setInterval(() => {
            this.cleanupOldRequests();
        }, 60000);
    }
    
    cleanupOldRequests() {
        const now = Date.now();
        
        this.requests.forEach((userRequests, userId) => {
            Object.keys(userRequests).forEach(action => {
                userRequests[action] = userRequests[action].filter(
                    timestamp => now - timestamp < this.defaultLimits[action]?.windowMs || 300000
                );
            });
        });
        
        // Remove users with no recent requests
        this.requests.forEach((userRequests, userId) => {
            const hasRecentRequests = Object.values(userRequests).some(
                timestamps => timestamps.length > 0
            );
            
            if (!hasRecentRequests) {
                this.requests.delete(userId);
            }
        });
    }
    
    checkRateLimit(userId, action) {
        const now = Date.now();
        const limit = this.defaultLimits[action];
        
        if (!limit) return true; // No limit defined for this action
        
        // Check if user is currently blocked
        const blocked = this.blocked.get(userId);
        if (blocked && now < blocked.until) {
            return false;
        }
        
        // Initialize user requests if not exists
        if (!this.requests.has(userId)) {
            this.requests.set(userId, {});
        }
        
        const userRequests = this.requests.get(userId);
        if (!userRequests[action]) {
            userRequests[action] = [];
        }
        
        // Clean old requests within window
        userRequests[action] = userRequests[action].filter(
            timestamp => now - timestamp < limit.windowMs
        );
        
        // Check if limit exceeded
        if (userRequests[action].length >= limit.maxRequests) {
            // Block user for double the window time
            this.blocked.set(userId, {
                until: now + (limit.windowMs * 2),
                reason: `Rate limit exceeded for ${action}`
            });
            
            console.warn(`🚨 Rate limit exceeded for user ${userId}, action: ${action}`);
            return false;
        }
        
        // Record this request
        userRequests[action].push(now);
        return true;
    }
    
    isBlocked(userId) {
        const blocked = this.blocked.get(userId);
        if (!blocked) return false;
        
        const now = Date.now();
        if (now >= blocked.until) {
            this.blocked.delete(userId);
            return false;
        }
        
        return blocked;
    }
    
    unblock(userId) {
        this.blocked.delete(userId);
        console.log(`✅ User ${userId} unblocked`);
    }
}

// ===========================
// SECURITY MONITORING DASHBOARD
// ===========================

class SecurityDashboard {
    constructor() {
        this.alerts = [];
        this.metrics = {
            totalAlerts: 0,
            blockedRequests: 0,
            suspiciousActivities: 0,
            integrityViolations: 0
        };
        
        this.initializeDashboard();
    }
    
    initializeDashboard() {
        this.createDashboardUI();
        this.startMetricsUpdates();
    }
    
    createDashboardUI() {
        const dashboard = document.createElement('div');
        dashboard.id = 'securityDashboard';
        dashboard.className = 'security-dashboard';
        dashboard.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
            padding: 15px;
            font-size: 12px;
            z-index: 10000;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        `;
        
        dashboard.innerHTML = `
            <div class="dashboard-header">
                <h4>🛡️ Security Monitor</h4>
                <button onclick="this.parentElement.parentElement.style.display='none'">×</button>
            </div>
            <div class="metrics">
                <div>Total Alerts: <span id="totalAlerts">0</span></div>
                <div>Blocked Requests: <span id="blockedRequests">0</span></div>
                <div>Suspicious Activities: <span id="suspiciousActivities">0</span></div>
                <div>Integrity Violations: <span id="integrityViolations">0</span></div>
            </div>
            <div class="alerts-container">
                <h5>Recent Alerts:</h5>
                <div id="alertsList"></div>
            </div>
        `;
        
        document.body.appendChild(dashboard);
        
        // Add toggle button
        const toggleBtn = document.createElement('button');
        toggleBtn.innerHTML = '🛡️';
        toggleBtn.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10001;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
        `;
        toggleBtn.onclick = () => {
            dashboard.style.display = dashboard.style.display === 'none' ? 'block' : 'none';
        };
        
        document.body.appendChild(toggleBtn);
    }
    
    startMetricsUpdates() {
        setInterval(() => {
            this.updateMetrics();
        }, 5000);
    }
    
    updateMetrics() {
        document.getElementById('totalAlerts').textContent = this.metrics.totalAlerts;
        document.getElementById('blockedRequests').textContent = this.metrics.blockedRequests;
        document.getElementById('suspiciousActivities').textContent = this.metrics.suspiciousActivities;
        document.getElementById('integrityViolations').textContent = this.metrics.integrityViolations;
    }
    
    addAlert(type, message, severity = 'medium') {
        const alert = {
            id: Date.now(),
            type: type,
            message: message,
            severity: severity,
            timestamp: new Date().toISOString()
        };
        
        this.alerts.unshift(alert);
        this.metrics.totalAlerts++;
        
        // Keep only last 50 alerts
        if (this.alerts.length > 50) {
            this.alerts = this.alerts.slice(0, 50);
        }
        
        this.updateAlertsDisplay();
        
        // Show notification for high severity alerts
        if (severity === 'high') {
            this.showNotification(alert);
        }
    }
    
    updateAlertsDisplay() {
        const alertsList = document.getElementById('alertsList');
        if (!alertsList) return;
        
        alertsList.innerHTML = this.alerts.slice(0, 10).map(alert => `
            <div class="alert-item ${alert.severity}">
                <small>${new Date(alert.timestamp).toLocaleTimeString()}</small>
                <div>${alert.type}: ${alert.message}</div>
            </div>
        `).join('');
    }
    
    showNotification(alert) {
        // Create toast notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 60px;
            right: 10px;
            background: #ff4444;
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 10002;
            max-width: 300px;
        `;
        notification.innerHTML = `
            <strong>🚨 Security Alert</strong><br>
            ${alert.type}: ${alert.message}
        `;
        
        document.body.appendChild(notification);
        
        // Remove after 5 seconds
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
}

// ===========================
// INITIALIZE SECURITY SYSTEMS
// ===========================

// Initialize all security systems
window.SecurityManager = new SecurityManager();
window.AntiCheatSystem = new AntiCheatSystem();
window.RateLimiter = new RateLimiter();
window.SecurityDashboard = new SecurityDashboard();

// Add security event listeners
document.addEventListener('mousemove', (event) => {
    const playerId = window.PlayerManager?.getCurrentPlayerId?.();
    if (playerId) {
        window.AntiCheatSystem.recordPlayerAction(playerId, {
            type: 'MOUSE_MOVEMENT',
            x: event.clientX,
            y: event.clientY,
            timestamp: Date.now()
        });
    }
});

// Monitor game moves
document.addEventListener('gameMove', (event) => {
    const playerId = window.PlayerManager?.getCurrentPlayerId?.();
    if (playerId) {
        window.AntiCheatSystem.recordPlayerAction(playerId, {
            type: 'MOVE',
            duration: event.detail.duration,
            move: event.detail.move,
            timestamp: Date.now()
        });
    }
});

console.log('✅ Section 18: Advanced Security & Anti-Cheat Systems loaded successfully');
              /* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 19: TOURNAMENT SYSTEM & ADVANCED MATCHMAKING
   =========================== */

'use strict';

// ===========================
// TOURNAMENT MANAGER
// ===========================

class TournamentManager {
    constructor() {
        this.tournaments = new Map();
        this.activeTournaments = new Map();
        this.playerRankings = new Map();
        this.tournamentHistory = [];
        this.prizeDistribution = {
            'SINGLE_ELIMINATION': [0.5, 0.3, 0.15, 0.05],
            'DOUBLE_ELIMINATION': [0.45, 0.25, 0.15, 0.1, 0.05],
            'ROUND_ROBIN': [0.4, 0.25, 0.15, 0.1, 0.05, 0.05],
            'SWISS_SYSTEM': [0.35, 0.20, 0.15, 0.10, 0.08, 0.07, 0.05]
        };
        
        this.initializeTournamentSystem();
    }
    
    initializeTournamentSystem() {
        this.loadTournamentTemplates();
        this.startTournamentScheduler();
        this.createTournamentUI();
        
        console.log('✅ Tournament Manager initialized');
    }
    
    loadTournamentTemplates() {
        const templates = [
            {
                id: 'daily_chess_blitz',
                name: 'Daily Chess Blitz',
                gameType: 'chess',
                format: 'SINGLE_ELIMINATION',
                entryFee: 1.0,
                maxPlayers: 16,
                timeControl: '5+3',
                schedule: 'daily',
                startTime: '19:00',
                duration: 120 // minutes
            },
            {
                id: 'weekly_checkers_championship',
                name: 'Weekly Checkers Championship',
                gameType: 'checkers',
                format: 'DOUBLE_ELIMINATION',
                entryFee: 2.5,
                maxPlayers: 32,
                timeControl: '10+5',
                schedule: 'weekly',
                startTime: 'saturday_20:00',
                duration: 180
            },
            {
                id: 'monthly_grand_prix',
                name: 'Monthly Grand Prix',
                gameType: 'mixed',
                format: 'SWISS_SYSTEM',
                entryFee: 5.0,
                maxPlayers: 64,
                timeControl: 'variable',
                schedule: 'monthly',
                startTime: 'first_saturday_18:00',
                duration: 360
            }
        ];
        
        templates.forEach(template => {
            this.createTournamentFromTemplate(template);
        });
    }
    
    createTournamentFromTemplate(template) {
        const tournamentId = this.generateTournamentId();
        const tournament = {
            ...template,
            id: tournamentId,
            status: 'SCHEDULED',
            participants: [],
            brackets: null,
            matches: [],
            prizePool: 0,
            created: Date.now(),
            nextStartTime: this.calculateNextStartTime(template)
        };
        
        this.tournaments.set(tournamentId, tournament);
        return tournamentId;
    }
    
    calculateNextStartTime(template) {
        const now = new Date();
        let nextStart;
        
        switch (template.schedule) {
            case 'daily':
                const [hours, minutes] = template.startTime.split(':').map(Number);
                nextStart = new Date();
                nextStart.setHours(hours, minutes, 0, 0);
                
                // If time has passed today, schedule for tomorrow
                if (nextStart <= now) {
                    nextStart.setDate(nextStart.getDate() + 1);
                }
                break;
                
            case 'weekly':
                const [day, time] = template.startTime.split('_');
                const dayIndex = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'].indexOf(day.toLowerCase());
                const [weekHours, weekMinutes] = time.split(':').map(Number);
                
                nextStart = new Date();
                nextStart.setHours(weekHours, weekMinutes, 0, 0);
                
                // Calculate days until target day
                const daysUntilTarget = (dayIndex - nextStart.getDay() + 7) % 7;
                nextStart.setDate(nextStart.getDate() + daysUntilTarget);
                
                // If it's the same day but time has passed
                if (daysUntilTarget === 0 && nextStart <= now) {
                    nextStart.setDate(nextStart.getDate() + 7);
                }
                break;
                
            case 'monthly':
                // First Saturday of next month at specified time
                nextStart = new Date();
                nextStart.setMonth(nextStart.getMonth() + 1, 1);
                nextStart.setHours(18, 0, 0, 0);
                
                // Find first Saturday
                while (nextStart.getDay() !== 6) {
                    nextStart.setDate(nextStart.getDate() + 1);
                }
                break;
        }
        
        return nextStart.getTime();
    }
    
    generateTournamentId() {
        return `tournament_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async registerForTournament(tournamentId, playerId) {
        const tournament = this.tournaments.get(tournamentId);
        if (!tournament) {
            throw new Error('Tournament not found');
        }
        
        // Check if player is already registered
        if (tournament.participants.some(p => p.playerId === playerId)) {
            throw new Error('Player already registered');
        }
        
        // Check if tournament is full
        if (tournament.participants.length >= tournament.maxPlayers) {
            throw new Error('Tournament is full');
        }
        
        // Check if registration is still open
        if (tournament.status !== 'SCHEDULED' && tournament.status !== 'REGISTERING') {
            throw new Error('Registration is closed');
        }
        
        // Check entry fee
        const playerBalance = await window.BlockchainManager.getBalance(playerId);
        if (playerBalance < tournament.entryFee) {
            throw new Error('Insufficient balance for entry fee');
        }
        
        // Charge entry fee
        await window.BlockchainManager.transferTokens(
            playerId,
            'TOURNAMENT_POOL',
            tournament.entryFee,
            `Tournament entry: ${tournament.name}`
        );
        
        // Add player to tournament
        tournament.participants.push({
            playerId: playerId,
            registeredAt: Date.now(),
            seed: 0, // Will be calculated before tournament starts
            status: 'ACTIVE'
        });
        
        // Update prize pool
        tournament.prizePool += tournament.entryFee * 0.95; // 5% platform fee
        
        // Update tournament status
        if (tournament.status === 'SCHEDULED') {
            tournament.status = 'REGISTERING';
        }
        
        console.log(`✅ Player ${playerId} registered for tournament ${tournament.name}`);
        return true;
    }
    
    async startTournament(tournamentId) {
        const tournament = this.tournaments.get(tournamentId);
        if (!tournament) {
            throw new Error('Tournament not found');
        }
        
        if (tournament.participants.length < 4) {
            throw new Error('Not enough participants to start tournament');
        }
        
        // Calculate seeds based on player ratings
        await this.calculateSeeds(tournament);
        
        // Generate tournament brackets
        tournament.brackets = this.generateBrackets(tournament);
        
        // Create initial matches
        tournament.matches = this.createInitialMatches(tournament);
        
        // Update status
        tournament.status = 'ACTIVE';
        tournament.startedAt = Date.now();
        
        // Move to active tournaments
        this.activeTournaments.set(tournamentId, tournament);
        
        console.log(`🏆 Tournament "${tournament.name}" started with ${tournament.participants.length} players`);
        
        // Notify all participants
        this.notifyTournamentStart(tournament);
        
        return tournament;
    }
    
    async calculateSeeds(tournament) {
        for (let i = 0; i < tournament.participants.length; i++) {
            const participant = tournament.participants[i];
            const playerRating = await this.getPlayerRating(participant.playerId, tournament.gameType);
            participant.rating = playerRating;
        }
        
        // Sort by rating (highest first) and assign seeds
        tournament.participants.sort((a, b) => b.rating - a.rating);
        tournament.participants.forEach((participant, index) => {
            participant.seed = index + 1;
        });
    }
    
    async getPlayerRating(playerId, gameType) {
        const rankings = this.playerRankings.get(playerId);
        if (!rankings || !rankings[gameType]) {
            return 1000; // Default rating
        }
        return rankings[gameType].rating;
    }
    
    generateBrackets(tournament) {
        switch (tournament.format) {
            case 'SINGLE_ELIMINATION':
                return this.generateSingleEliminationBracket(tournament.participants);
            case 'DOUBLE_ELIMINATION':
                return this.generateDoubleEliminationBracket(tournament.participants);
            case 'ROUND_ROBIN':
                return this.generateRoundRobinBracket(tournament.participants);
            case 'SWISS_SYSTEM':
                return this.generateSwissBracket(tournament.participants);
            default:
                throw new Error(`Unknown tournament format: ${tournament.format}`);
        }
    }
    
    generateSingleEliminationBracket(participants) {
        const rounds = [];
        let currentRound = [...participants];
        let roundNumber = 1;
        
        while (currentRound.length > 1) {
            const matches = [];
            const nextRound = [];
            
            // Pair players for matches
            for (let i = 0; i < currentRound.length; i += 2) {
                if (i + 1 < currentRound.length) {
                    matches.push({
                        player1: currentRound[i],
                        player2: currentRound[i + 1],
                        winner: null,
                        status: 'PENDING'
                    });
                    nextRound.push(null); // Placeholder for winner
                } else {
                    // Bye - player advances automatically
                    nextRound.push(currentRound[i]);
                }
            }
            
            rounds.push({
                roundNumber: roundNumber++,
                matches: matches,
                status: roundNumber === 2 ? 'ACTIVE' : 'PENDING'
            });
            
            currentRound = nextRound;
        }
        
        return {
            type: 'SINGLE_ELIMINATION',
            rounds: rounds,
            currentRound: 1
        };
    }
    
    generateDoubleEliminationBracket(participants) {
        // Winner's bracket
        const winnersBracket = this.generateSingleEliminationBracket(participants);
        
        // Loser's bracket (more complex, simplified for demo)
        const losersBracket = {
            rounds: [],
            eliminated: []
        };
        
        return {
            type: 'DOUBLE_ELIMINATION',
            winnersBracket: winnersBracket,
            losersBracket: losersBracket,
            currentRound: 1
        };
    }
    
    generateRoundRobinBracket(participants) {
        const matches = [];
        
        // Generate all possible pairings
        for (let i = 0; i < participants.length; i++) {
            for (let j = i + 1; j < participants.length; j++) {
                matches.push({
                    player1: participants[i],
                    player2: participants[j],
                    winner: null,
                    status: 'PENDING',
                    round: 1
                });
            }
        }
        
        return {
            type: 'ROUND_ROBIN',
            matches: matches,
            standings: participants.map(p => ({
                ...p,
                wins: 0,
                losses: 0,
                points: 0
            }))
        };
    }
    
    generateSwissBracket(participants) {
        return {
            type: 'SWISS_SYSTEM',
            rounds: [],
            participants: participants.map(p => ({
                ...p,
                score: 0,
                opponents: [],
                colors: []
            })),
            currentRound: 1,
            totalRounds: Math.ceil(Math.log2(participants.length))
        };
    }
    
    createInitialMatches(tournament) {
        const matches = [];
        
        if (tournament.format === 'SINGLE_ELIMINATION' || tournament.format === 'DOUBLE_ELIMINATION') {
            const firstRound = tournament.brackets.rounds[0];
            firstRound.matches.forEach((match, index) => {
                matches.push({
                    id: `${tournament.id}_R1_M${index + 1}`,
                    tournamentId: tournament.id,
                    round: 1,
                    player1: match.player1.playerId,
                    player2: match.player2.playerId,
                    status: 'READY',
                    timeControl: tournament.timeControl,
                    createdAt: Date.now()
                });
            });
        }
        
        return matches;
    }
    
    notifyTournamentStart(tournament) {
        tournament.participants.forEach(participant => {
            window.NotificationManager?.send(participant.playerId, {
                type: 'TOURNAMENT_START',
                title: 'Tournament Started!',
                message: `${tournament.name} has begun. Good luck!`,
                tournamentId: tournament.id
            });
        });
    }
    
    async recordTournamentMatch(tournamentId, matchId, winnerId, gameData) {
        const tournament = this.activeTournaments.get(tournamentId);
        if (!tournament) {
            throw new Error('Tournament not found');
        }
        
        const match = tournament.matches.find(m => m.id === matchId);
        if (!match) {
            throw new Error('Match not found');
        }
        
        // Record match result
        match.winnerId = winnerId;
        match.loserId = match.player1 === winnerId ? match.player2 : match.player1;
        match.status = 'COMPLETED';
        match.completedAt = Date.now();
        match.gameData = gameData;
        
        // Update tournament brackets
        this.updateTournamentBrackets(tournament, match);
        
        // Check if tournament is complete
        if (this.isTournamentComplete(tournament)) {
            await this.completeTournament(tournament);
        } else {
            // Create next round matches if needed
            this.createNextRoundMatches(tournament);
        }
        
        console.log(`✅ Tournament match completed: ${matchId}`);
    }
    
    updateTournamentBrackets(tournament, completedMatch) {
        if (tournament.format === 'SINGLE_ELIMINATION') {
            this.updateSingleEliminationBracket(tournament, completedMatch);
        } else if (tournament.format === 'ROUND_ROBIN') {
            this.updateRoundRobinStandings(tournament, completedMatch);
        }
        // Add other formats as needed
    }
    
    updateSingleEliminationBracket(tournament, completedMatch) {
        const brackets = tournament.brackets;
        const currentRound = brackets.rounds[brackets.currentRound - 1];
        
        // Find and update the match in brackets
        const bracketMatch = currentRound.matches.find(m => 
            (m.player1.playerId === completedMatch.player1 && m.player2.playerId === completedMatch.player2) ||
            (m.player1.playerId === completedMatch.player2 && m.player2.playerId === completedMatch.player1)
        );
        
        if (bracketMatch) {
            bracketMatch.winner = completedMatch.winnerId;
            bracketMatch.status = 'COMPLETED';
        }
        
        // Check if round is complete
        const roundComplete = currentRound.matches.every(m => m.status === 'COMPLETED');
        
        if (roundComplete && brackets.currentRound < brackets.rounds.length) {
            // Advance winners to next round
            this.advanceWinnersToNextRound(tournament);
            brackets.currentRound++;
            
            if (brackets.currentRound <= brackets.rounds.length) {
                brackets.rounds[brackets.currentRound - 1].status = 'ACTIVE';
            }
        }
    }
    
    advanceWinnersToNextRound(tournament) {
        const brackets = tournament.brackets;
        const currentRound = brackets.rounds[brackets.currentRound - 1];
        const nextRound = brackets.rounds[brackets.currentRound];
        
        if (!nextRound) return;
        
        // Update next round matches with winners
        let nextMatchIndex = 0;
        currentRound.matches.forEach((match, index) => {
            if (match.winner) {
                const nextMatch = nextRound.matches[Math.floor(nextMatchIndex / 2)];
                if (nextMatchIndex % 2 === 0) {
                    nextMatch.player1 = tournament.participants.find(p => p.playerId === match.winner);
                } else {
                    nextMatch.player2 = tournament.participants.find(p => p.playerId === match.winner);
                }
                nextMatchIndex++;
            }
        });
    }
    
    updateRoundRobinStandings(tournament, completedMatch) {
        const standings = tournament.brackets.standings;
        
        const winner = standings.find(p => p.playerId === completedMatch.winnerId);
        const loser = standings.find(p => p.playerId === completedMatch.loserId);
        
        if (winner) {
            winner.wins++;
            winner.points += 3; // 3 points for win
        }
        
        if (loser) {
            loser.losses++;
            loser.points += 0; // 0 points for loss
        }
        
        // Sort standings by points, then by wins
        standings.sort((a, b) => {
            if (b.points !== a.points) return b.points - a.points;
            return b.wins - a.wins;
        });
    }
    
    isTournamentComplete(tournament) {
        if (tournament.format === 'SINGLE_ELIMINATION') {
            const finalRound = tournament.brackets.rounds[tournament.brackets.rounds.length - 1];
            return finalRound.matches.every(m => m.status === 'COMPLETED');
        } else if (tournament.format === 'ROUND_ROBIN') {
            return tournament.brackets.matches.every(m => m.status === 'COMPLETED');
        }
        
        return false;
    }
    
    async completeTournament(tournament) {
        tournament.status = 'COMPLETED';
        tournament.completedAt = Date.now();
        
        // Determine final standings
        const finalStandings = this.calculateFinalStandings(tournament);
        tournament.finalStandings = finalStandings;
        
        // Distribute prizes
        await this.distributePrizes(tournament, finalStandings);
        
        // Update player ratings
        await this.updatePlayerRatings(tournament, finalStandings);
        
        // Move to tournament history
        this.tournamentHistory.push(tournament);
        this.activeTournaments.delete(tournament.id);
        
        // Notify participants of results
        this.notifyTournamentComplete(tournament, finalStandings);
        
        console.log(`🏆 Tournament "${tournament.name}" completed!`);
    }
    
    calculateFinalStandings(tournament) {
        if (tournament.format === 'SINGLE_ELIMINATION') {
            return this.calculateSingleEliminationStandings(tournament);
        } else if (tournament.format === 'ROUND_ROBIN') {
            return tournament.brackets.standings;
        }
        
        return [];
    }
    
    calculateSingleEliminationStandings(tournament) {
        const standings = [];
        const brackets = tournament.brackets;
        
        // Winner is from final match
        const finalMatch = brackets.rounds[brackets.rounds.length - 1].matches[0];
        if (finalMatch.winner) {
            standings.push({
                position: 1,
                playerId: finalMatch.winner,
                prize: tournament.prizePool * this.prizeDistribution[tournament.format][0]
            });
            
            const runnerId = finalMatch.player1.playerId === finalMatch.winner ? 
                           finalMatch.player2.playerId : finalMatch.player1.playerId;
            standings.push({
                position: 2,
                playerId: runnerId,
                prize: tournament.prizePool * this.prizeDistribution[tournament.format][1]
            });
        }
        
        // Add other positions based on elimination rounds
        // Simplified implementation
        
        return standings;
    }
    
    async distributePrizes(tournament, standings) {
        const distribution = this.prizeDistribution[tournament.format];
        
        for (let i = 0; i < Math.min(standings.length, distribution.length); i++) {
            const standing = standings[i];
            const prizeAmount = tournament.prizePool * distribution[i];
            
            if (prizeAmount > 0) {
                await window.BlockchainManager.transferTokens(
                    'TOURNAMENT_POOL',
                    standing.playerId,
                    prizeAmount,
                    `Tournament prize - ${tournament.name} - Position ${standing.position}`
                );
                
                standing.prize = prizeAmount;
            }
        }
    }
    
    async updatePlayerRatings(tournament, standings) {
        // Simplified ELO-style rating updates
        const K = 32; // K-factor
        
        standings.forEach(async (standing, index) => {
            const playerId = standing.playerId;
            const currentRating = await this.getPlayerRating(playerId, tournament.gameType);
            
            // Calculate expected score based on final position
            const expectedScore = (standings.length - index) / standings.length;
            const actualScore = (standings.length - index) / standings.length;
            
            const newRating = currentRating + K * (actualScore - expectedScore);
            
            // Update player ranking
            if (!this.playerRankings.has(playerId)) {
                this.playerRankings.set(playerId, {});
            }
            
            const playerRankings = this.playerRankings.get(playerId);
            if (!playerRankings[tournament.gameType]) {
                playerRankings[tournament.gameType] = {
                    rating: 1000,
                    gamesPlayed: 0,
                    tournamentsPlayed: 0
                };
            }
            
            playerRankings[tournament.gameType].rating = newRating;
            playerRankings[tournament.gameType].tournamentsPlayed++;
        });
    }
    
    notifyTournamentComplete(tournament, standings) {
        standings.forEach((standing, index) => {
            let message;
            if (index === 0) {
                message = `Congratulations! You won ${tournament.name}!`;
            } else if (index === 1) {
                message = `Great job! You finished 2nd in ${tournament.name}!`;
            } else if (index === 2) {
                message = `Well played! You finished 3rd in ${tournament.name}!`;
            } else {
                message = `Thanks for participating in ${tournament.name}!`;
            }
            
            if (standing.prize > 0) {
                message += ` You earned ${standing.prize.toFixed(4)} CORE tokens!`;
            }
            
            window.NotificationManager?.send(standing.playerId, {
                type: 'TOURNAMENT_COMPLETE',
                title: 'Tournament Complete!',
                message: message,
                tournamentId: tournament.id
            });
        });
    }
    
    createNextRoundMatches(tournament) {
        if (tournament.format === 'SINGLE_ELIMINATION') {
            const brackets = tournament.brackets;
            const currentRoundIndex = brackets.currentRound - 1;
            
            if (currentRoundIndex + 1 < brackets.rounds.length) {
                const nextRound = brackets.rounds[currentRoundIndex + 1];
                
                nextRound.matches.forEach((match, index) => {
                    if (match.player1 && match.player2) {
                        const matchId = `${tournament.id}_R${brackets.currentRound + 1}_M${index + 1}`;
                        
                        tournament.matches.push({
                            id: matchId,
                            tournamentId: tournament.id,
                            round: brackets.currentRound + 1,
                            player1: match.player1.playerId,
                            player2: match.player2.playerId,
                            status: 'READY',
                            timeControl: tournament.timeControl,
                            createdAt: Date.now()
                        });
                    }
                });
            }
        }
    }
    
    startTournamentScheduler() {
        // Check for tournaments to start every minute
        setInterval(() => {
            this.checkScheduledTournaments();
        }, 60000);
    }
    
    checkScheduledTournaments() {
        const now = Date.now();
        
        this.tournaments.forEach((tournament, id) => {
            if (tournament.status === 'SCHEDULED' && tournament.nextStartTime <= now) {
                if (tournament.participants.length >= 4) {
                    this.startTournament(id);
                } else {
                    // Postpone tournament
                    tournament.nextStartTime = now + (60 * 60 * 1000); // 1 hour later
                    console.log(`⏰ Tournament ${tournament.name} postponed - not enough participants`);
                }
            }
        });
    }
    
    createTournamentUI() {
        // This would create the tournament interface
        console.log('🎨 Tournament UI components ready');
    }
    
    getTournamentList() {
        return Array.from(this.tournaments.values()).map(t => ({
            id: t.id,
            name: t.name,
            gameType: t.gameType,
            format: t.format,
            entryFee: t.entryFee,
            prizePool: t.prizePool,
            participants: t.participants.length,
            maxPlayers: t.maxPlayers,
            status: t.status,
            nextStartTime: t.nextStartTime
        }));
    }
    
    getActiveTournaments() {
        return Array.from(this.activeTournaments.values());
    }
    
    getPlayerTournamentHistory(playerId) {
        return this.tournamentHistory.filter(t => 
            t.participants.some(p => p.playerId === playerId)
        );
    }
}

// ===========================
// ADVANCED MATCHMAKING SYSTEM
// ===========================

class AdvancedMatchmaking {
    constructor() {
        this.matchmakingQueue = new Map();
        this.playerSkills = new Map();
        this.matchHistory = new Map();
        this.balanceThreshold = 100; // Rating difference threshold
        this.maxWaitTime = 300000; // 5 minutes max wait
        
        this.initializeMatchmaking();
    }
    
    initializeMatchmaking() {
        this.startMatchmakingLoop();
        console.log('✅ Advanced Matchmaking initialized');
    }
    
    startMatchmakingLoop() {
        setInterval(() => {
            this.processMatchmakingQueue();
        }, 5000); // Process every 5 seconds
    }
    
    async addToQueue(playerId, gameType, stakeAmount, preferences = {}) {
        // Remove player from queue if already queued
        this.removeFromQueue(playerId);
        
        // Get player skill rating
        const skillRating = await this.getPlayerSkillRating(playerId, gameType);
        
        const queueEntry = {
            playerId: playerId,
            gameType: gameType,
            stakeAmount: stakeAmount,
            skillRating: skillRating,
            preferences: {
                maxRatingDifference: preferences.maxRatingDifference || 200,
                preferredTimeControl: preferences.preferredTimeControl || 'normal',
                avoidPlayers: preferences.avoidPlayers || [],
                ...preferences
            },
            joinTime: Date.now(),
            expandedSearch: false
        };
        
        if (!this.matchmakingQueue.has(gameType)) {
            this.matchmakingQueue.set(gameType, []);
        }
        
        this.matchmakingQueue.get(gameType).push(queueEntry);
        
        console.log(`➕ Player ${playerId} added to ${gameType} matchmaking queue`);
        
        // Immediate match attempt
        this.processMatchmakingQueue();
    }
    
    removeFromQueue(playerId) {
        this.matchmakingQueue.forEach((queue, gameType) => {
            const index = queue.findIndex(entry => entry.playerId === playerId);
            if (index !== -1) {
                queue.splice(index, 1);
                console.log(`➖ Player ${playerId} removed from ${gameType} queue`);
            }
        });
    }
    
    processMatchmakingQueue() {
        this.matchmakingQueue.forEach((queue, gameType) => {
            if (queue.length < 2) return;
            
            // Sort queue by join time
            queue.sort((a, b) => a.joinTime - b.joinTime);
            
            const matches = this.findMatches(queue, gameType);
            matches.forEach(match => {
                this.createMatch(match.player1, match.player2, gameType);
            });
        });
    }
    
    findMatches(queue, gameType) {
        const matches = [];
        const matched = new Set();
        
        for (let i = 0; i < queue.length - 1; i++) {
            if (matched.has(i)) continue;
            
            const player1 = queue[i];
            
            for (let j = i + 1; j < queue.length; j++) {
                if (matched.has(j)) continue;
                
                const player2 = queue[j];
                
                if (this.arePlayersCompatible(player1, player2)) {
                    matches.push({ player1, player2 });
                    matched.add(i);
                    matched.add(j);
                    break;
                }
            }
        }
        
        // Remove matched players from queue
        for (let i = queue.length - 1; i >= 0; i--) {
            if (matched.has(i)) {
                queue.splice(i, 1);
            }
        }
        
        // Expand search criteria for long-waiting players
        this.expandSearchCriteria(queue);
        
        return matches;
    }
    
    arePlayersCompatible(player1, player2) {
        // Check stake amount match
        if (player1.stakeAmount !== player2.stakeAmount) {
            return false;
        }
        
        // Check if players want to avoid each other
        if (player1.preferences.avoidPlayers.includes(player2.playerId) ||
            player2.preferences.avoidPlayers.includes(player1.playerId)) {
            return false;
        }
        
        // Check recent match history
        if (this.hasRecentMatch(player1.playerId, player2.playerId)) {
            return false;
        }
        
        // Check skill rating difference
        const ratingDiff = Math.abs(player1.skillRating - player2.skillRating);
        const maxDiff = Math.min(player1.preferences.maxRatingDifference, player2.preferences.maxRatingDifference);
        
        if (ratingDiff > maxDiff) {
            // Allow if both players have been waiting long enough
            const waitTime1 = Date.now() - player1.joinTime;
            const waitTime2 = Date.now() - player2.joinTime;
            
            if (waitTime1 < 60000 || waitTime2 < 60000) { // Less than 1 minute
                return false;
            }
        }
        
        return true;
    }
    
    hasRecentMatch(playerId1, playerId2) {
        const history1 = this.matchHistory.get(playerId1) || [];
        return history1.some(match => 
            match.opponent === playerId2 && 
            Date.now() - match.timestamp < 3600000 // Within last hour
        );
    }
    
    expandSearchCriteria(queue) {
        const now = Date.now();
        
        queue.forEach(entry => {
            const waitTime = now - entry.joinTime;
            
            if (waitTime > 60000 && !entry.expandedSearch) { // After 1 minute
                entry.preferences.maxRatingDifference *= 1.5;
                entry.expandedSearch = true;
                console.log(`🔍 Expanded search criteria for player ${entry.playerId}`);
            }
            
            if (waitTime > this.maxWaitTime) {
                // Create match with AI opponent if no human match found
                this.createAIMatch(entry);
                queue.splice(queue.indexOf(entry), 1);
            }
        });
    }
    
    async createMatch(player1Entry, player2Entry, gameType) {
        try {
            const gameId = window.Utils.generateGameId();
            
            // Create game instance
            const gameConfig = {
                gameId: gameId,
                gameType: gameType,
                player1: player1Entry.playerId,
                player2: player2Entry.playerId,
                stakeAmount: player1Entry.stakeAmount,
                timeControl: this.negotiateTimeControl(player1Entry, player2Entry),
                isRanked: true,
                matchmade: true
            };
            
            const game = await window.GameManager.createGame(gameConfig);
            
            // Record match history
            this.recordMatchHistory(player1Entry.playerId, player2Entry.playerId);
            
            // Notify players
            window.NotificationManager?.send(player1Entry.playerId, {
                type: 'MATCH_FOUND',
                title: 'Match Found!',
                message: `Found opponent for ${gameType}. Game starting...`,
                gameId: gameId
            });
            
            window.NotificationManager?.send(player2Entry.playerId, {
                type: 'MATCH_FOUND',
                title: 'Match Found!',
                message: `Found opponent for ${gameType}. Game starting...`,
                gameId: gameId
            });
            
            console.log(`🎮 Match created: ${player1Entry.playerId} vs ${player2Entry.playerId}`);
            
            return game;
            
        } catch (error) {
            console.error('❌ Failed to create match:', error);
            
            // Re-add players to queue
            this.matchmakingQueue.get(gameType).push(player1Entry, player2Entry);
        }
    }
    
    negotiateTimeControl(player1, player2) {
        // Simple negotiation - use faster time control
        const p1Control = player1.preferences.preferredTimeControl;
        const p2Control = player2.preferences.preferredTimeControl;
        
        const timeControls = {
            'bullet': 1,
            'blitz': 2,
            'rapid': 3,
            'normal': 4,
            'long': 5
        };
        
        const p1Priority = timeControls[p1Control] || 4;
        const p2Priority = timeControls[p2Control] || 4;
        
        return p1Priority <= p2Priority ? p1Control : p2Control;
    }
    
    recordMatchHistory(playerId1, playerId2) {
        const now = Date.now();
        
        // Record for player 1
        if (!this.matchHistory.has(playerId1)) {
            this.matchHistory.set(playerId1, []);
        }
        this.matchHistory.get(playerId1).push({
            opponent: playerId2,
            timestamp: now
        });
        
        // Record for player 2
        if (!this.matchHistory.has(playerId2)) {
            this.matchHistory.set(playerId2, []);
        }
        this.matchHistory.get(playerId2).push({
            opponent: playerId1,
            timestamp: now
        });
        
        // Keep only recent history (last 50 matches)
        [playerId1, playerId2].forEach(pid => {
            const history = this.matchHistory.get(pid);
            if (history.length > 50) {
                this.matchHistory.set(pid, history.slice(-50));
            }
        });
    }
    
    async createAIMatch(playerEntry) {
        try {
            const gameId = window.Utils.generateGameId();
            
            const gameConfig = {
                gameId: gameId,
                gameType: playerEntry.gameType,
                player1: playerEntry.playerId,
                player2: 'AI_OPPONENT',
                stakeAmount: playerEntry.stakeAmount,
                timeControl: playerEntry.preferences.preferredTimeControl,
                isRanked: false,
                vsAI: true,
                aiDifficulty: this.calculateAIDifficulty(playerEntry.skillRating)
            };
            
            const game = await window.GameManager.createGame(gameConfig);
            
            window.NotificationManager?.send(playerEntry.playerId, {
                type: 'AI_MATCH_CREATED',
                title: 'AI Match Created',
                message: `No human opponents found. Playing against AI opponent.`,
                gameId: gameId
            });
            
            console.log(`🤖 AI match created for player ${playerEntry.playerId}`);
            
        } catch (error) {
            console.error('❌ Failed to create AI match:', error);
        }
    }
    
    calculateAIDifficulty(playerRating) {
        if (playerRating < 800) return 'beginner';
        if (playerRating < 1200) return 'intermediate';
        if (playerRating < 1600) return 'advanced';
        if (playerRating < 2000) return 'expert';
        return 'master';
    }
    
    async getPlayerSkillRating(playerId, gameType) {
        const rankings = window.TournamentManager?.playerRankings?.get(playerId);
        if (rankings && rankings[gameType]) {
            return rankings[gameType].rating;
        }
        
        // Get from blockchain or default
        try {
            const rating = await window.BlockchainManager.getPlayerRating(playerId, gameType);
            return rating || 1000;
        } catch (error) {
            return 1000; // Default rating
        }
    }
    
    getQueueStatus(playerId) {
        let status = null;
        
        this.matchmakingQueue.forEach((queue, gameType) => {
            const entry = queue.find(e => e.playerId === playerId);
            if (entry) {
                status = {
                    gameType: gameType,
                    position: queue.indexOf(entry) + 1,
                    totalInQueue: queue.length,
                    waitTime: Date.now() - entry.joinTime,
                    estimatedWait: this.estimateWaitTime(queue, entry)
                };
            }
        });
        
        return status;
    }
    
    estimateWaitTime(queue, playerEntry) {
        const position = queue.indexOf(playerEntry);
        const averageMatchTime = 30000; // 30 seconds average to find match
        
        return Math.max(0, (position - 1) * averageMatchTime);
    }
}

// ===========================
// LEADERBOARD SYSTEM
// ===========================

class LeaderboardSystem {
    constructor() {
        this.leaderboards = new Map();
        this.seasonalData = new Map();
        this.achievementSystem = new AchievementSystem();
        
        this.initializeLeaderboards();
    }
    
    initializeLeaderboards() {
        const gameTypes = ['chess', 'checkers', 'tictactoe', 'connect4', 'poker'];
        
        gameTypes.forEach(gameType => {
            this.leaderboards.set(gameType, {
                daily: [],
                weekly: [],
                monthly: [],
                allTime: []
            });
        });
        
        this.leaderboards.set('overall', {
            daily: [],
            weekly: [],
            monthly: [],
            allTime: []
        });
        
        this.startLeaderboardUpdates();
        console.log('✅ Leaderboard System initialized');
    }
    
    startLeaderboardUpdates() {
        // Update leaderboards every 5 minutes
        setInterval(() => {
            this.updateAllLeaderboards();
        }, 300000);
        
        // Reset daily leaderboards at midnight
        setInterval(() => {
            const now = new Date();
            if (now.getHours() === 0 && now.getMinutes() === 0) {
                this.resetDailyLeaderboards();
            }
        }, 60000);
    }
    
    async updateAllLeaderboards() {
        const gameTypes = ['chess', 'checkers', 'tictactoe', 'connect4', 'poker', 'overall'];
        
        for (const gameType of gameTypes) {
            await this.updateLeaderboard(gameType, 'daily');
            await this.updateLeaderboard(gameType, 'weekly');
            await this.updateLeaderboard(gameType, 'monthly');
            await this.updateLeaderboard(gameType, 'allTime');
        }
    }
    
    async updateLeaderboard(gameType, period) {
        try {
            const players = await this.getTopPlayers(gameType, period, 100);
            const leaderboard = this.leaderboards.get(gameType);
            
            if (leaderboard) {
                leaderboard[period] = players.map((player, index) => ({
                    rank: index + 1,
                    playerId: player.playerId,
                    playerName: player.playerName || `Player_${player.playerId.slice(-6)}`,
                    rating: player.rating,
                    gamesPlayed: player.gamesPlayed,
                    gamesWon: player.gamesWon,
                    winRate: player.gamesPlayed > 0 ? (player.gamesWon / player.gamesPlayed * 100).toFixed(1) : '0.0',
                    totalEarnings: player.totalEarnings || 0,
                    lastActive: player.lastActive
                }));
            }
            
        } catch (error) {
            console.error(`❌ Failed to update ${gameType} ${period} leaderboard:`, error);
        }
    }
    
    async getTopPlayers(gameType, period, limit = 100) {
        // This would typically fetch from database/blockchain
        // For demo, we'll use mock data from tournament manager
        
        const players = [];
        const now = Date.now();
        let timeThreshold = 0;
        
        switch (period) {
            case 'daily':
                timeThreshold = now - (24 * 60 * 60 * 1000);
                break;
            case 'weekly':
                timeThreshold = now - (7 * 24 * 60 * 60 * 1000);
                break;
            case 'monthly':
                timeThreshold = now - (30 * 24 * 60 * 60 * 1000);
                break;
            case 'allTime':
                timeThreshold = 0;
                break;
        }
        
        // Get player data from tournament manager
        const tournamentManager = window.TournamentManager;
        if (tournamentManager && tournamentManager.playerRankings) {
            tournamentManager.playerRankings.forEach((rankings, playerId) => {
                if (gameType === 'overall') {
                    // Calculate overall rating as average of all game types
                    const gameRatings = Object.values(rankings);
                    if (gameRatings.length > 0) {
                        const avgRating = gameRatings.reduce((sum, game) => sum + game.rating, 0) / gameRatings.length;
                        const totalGames = gameRatings.reduce((sum, game) => sum + game.gamesPlayed, 0);
                        const totalWins = gameRatings.reduce((sum, game) => sum + (game.gamesWon || 0), 0);
                        
                        players.push({
                            playerId: playerId,
                            rating: Math.round(avgRating),
                            gamesPlayed: totalGames,
                            gamesWon: totalWins,
                            lastActive: now
                        });
                    }
                } else if (rankings[gameType]) {
                    const gameRanking = rankings[gameType];
                    players.push({
                        playerId: playerId,
                        rating: gameRanking.rating,
                        gamesPlayed: gameRanking.gamesPlayed,
                        gamesWon: gameRanking.gamesWon || 0,
                        lastActive: now
                    });
                }
            });
        }
        
        // Sort by rating and limit results
        return players
            .sort((a, b) => b.rating - a.rating)
            .slice(0, limit);
    }
    
    resetDailyLeaderboards() {
        this.leaderboards.forEach((leaderboard, gameType) => {
            leaderboard.daily = [];
        });
        console.log('🔄 Daily leaderboards reset');
    }
    
    getLeaderboard(gameType, period = 'allTime', limit = 50) {
        const leaderboard = this.leaderboards.get(gameType);
        if (!leaderboard || !leaderboard[period]) {
            return [];
        }
        
        return leaderboard[period].slice(0, limit);
    }
    
    getPlayerRank(playerId, gameType, period = 'allTime') {
        const leaderboard = this.getLeaderboard(gameType, period, 1000);
        const playerIndex = leaderboard.findIndex(p => p.playerId === playerId);
        
        return playerIndex >= 0 ? playerIndex + 1 : null;
    }
    
    async updatePlayerStats(playerId, gameType, gameResult) {
        // This would typically update database/blockchain
        // For now, we'll update local rankings
        
        const tournamentManager = window.TournamentManager;
        if (!tournamentManager) return;
        
        if (!tournamentManager.playerRankings.has(playerId)) {
            tournamentManager.playerRankings.set(playerId, {});
        }
        
        const playerRankings = tournamentManager.playerRankings.get(playerId);
        
        if (!playerRankings[gameType]) {
            playerRankings[gameType] = {
                rating: 1000,
                gamesPlayed: 0,
                gamesWon: 0
            };
        }
        
        const gameRanking = playerRankings[gameType];
        gameRanking.gamesPlayed++;
        
        if (gameResult.won) {
            gameRanking.gamesWon++;
        }
        
        // Update rating based on result
        const ratingChange = this.calculateRatingChange(gameRanking.rating, gameResult);
        gameRanking.rating = Math.max(100, gameRanking.rating + ratingChange);
        
        // Check for achievements
        this.achievementSystem.checkAchievements(playerId, gameType, gameResult);
    }
    
    calculateRatingChange(currentRating, gameResult) {
        const K = 32; // K-factor
        const opponentRating = gameResult.opponentRating || 1000;
        
        // Calculate expected score
        const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - currentRating) / 400));
        const actualScore = gameResult.won ? 1 : 0;
        
        return Math.round(K * (actualScore - expectedScore));
    }
}

// ===========================
// ACHIEVEMENT SYSTEM
// ===========================

class AchievementSystem {
    constructor() {
        this.achievements = new Map();
        this.playerAchievements = new Map();
        
        this.initializeAchievements();
    }
    
    initializeAchievements() {
        const achievements = [
            {
                id: 'first_win',
                name: 'First Victory',
                description: 'Win your first game',
                icon: '🏆',
                condition: (stats) => stats.totalWins >= 1,
                reward: 0.1
            },
            {
                id: 'winning_streak_5',
                name: 'Hot Streak',
                description: 'Win 5 games in a row',
                icon: '🔥',
                condition: (stats) => stats.currentStreak >= 5,
                reward: 0.5
            },
            {
                id: 'chess_master',
                name: 'Chess Master',
                description: 'Reach 1800 rating in Chess',
                icon: '♛',
                condition: (stats) => stats.chessRating >= 1800,
                reward: 2.0
            },
            {
                id: 'tournament_winner',
                name: 'Tournament Champion',
                description: 'Win a tournament',
                icon: '👑',
                condition: (stats) => stats.tournamentsWon >= 1,
                reward: 5.0
            },
            {
                id: 'high_roller',
                name: 'High Roller',
                description: 'Win a game with 10+ CORE stake',
                icon: '💎',
                condition: (stats) => stats.highestStakeWin >= 10,
                reward: 1.0
            }
        ];
        
        achievements.forEach(achievement => {
            this.achievements.set(achievement.id, achievement);
        });
        
        console.log('✅ Achievement System initialized');
    }
    
    checkAchievements(playerId, gameType, gameResult) {
        const playerStats = this.getPlayerStats(playerId);
        const newAchievements = [];
        
        this.achievements.forEach((achievement, achievementId) => {
            if (!this.hasAchievement(playerId, achievementId)) {
                if (achievement.condition(playerStats)) {
                    this.awardAchievement(playerId, achievementId);
                    newAchievements.push(achievement);
                }
            }
        });
        
        if (newAchievements.length > 0) {
            this.notifyAchievements(playerId, newAchievements);
        }
    }
    
    getPlayerStats(playerId) {
        // This would typically fetch comprehensive player stats
        // For demo, we'll create mock stats
        return {
            totalWins: 0,
            currentStreak: 0,
            chessRating: 1000,
            tournamentsWon: 0,
            highestStakeWin: 0
        };
    }
    
    hasAchievement(playerId, achievementId) {
        const playerAchievements = this.playerAchievements.get(playerId) || [];
        return playerAchievements.includes(achievementId);
    }
    
    async awardAchievement(playerId, achievementId) {
        const achievement = this.achievements.get(achievementId);
        if (!achievement) return;
        
        // Add to player achievements
        if (!this.playerAchievements.has(playerId)) {
            this.playerAchievements.set(playerId, []);
        }
        
        this.playerAchievements.get(playerId).push({
            id: achievementId,
            unlockedAt: Date.now()
        });
        
        // Award tokens if specified
        if (achievement.reward > 0) {
            try {
                await window.BlockchainManager.transferTokens(
                    'ACHIEVEMENT_POOL',
                    playerId,
                    achievement.reward,
                    `Achievement reward: ${achievement.name}`
                );
            } catch (error) {
                console.error('❌ Failed to award achievement tokens:', error);
            }
        }
        
        console.log(`🎉 Achievement unlocked: ${playerId} - ${achievement.name}`);
    }
    
    notifyAchievements(playerId, achievements) {
        achievements.forEach(achievement => {
            window.NotificationManager?.send(playerId, {
                type: 'ACHIEVEMENT_UNLOCKED',
                title: 'Achievement Unlocked!',
                message: `${achievement.icon} ${achievement.name}: ${achievement.description}`,
                achievement: achievement
            });
        });
    }
    
    getPlayerAchievements(playerId) {
        const playerAchievementIds = this.playerAchievements.get(playerId) || [];
        return playerAchievementIds.map(entry => {
            const achievement = this.achievements.get(entry.id);
            return {
                ...achievement,
                unlockedAt: entry.unlockedAt
            };
        });
    }
    
    getAllAchievements() {
        return Array.from(this.achievements.values());
    }
}

// ===========================
// INITIALIZE TOURNAMENT AND MATCHMAKING SYSTEMS
// ===========================

window.TournamentManager = new TournamentManager();
window.AdvancedMatchmaking = new AdvancedMatchmaking();
window.LeaderboardSystem = new LeaderboardSystem();

// Tournament event handlers
document.addEventListener('gameComplete', async (event) => {
    const { gameId, winnerId, loserId, gameData } = event.detail;
    
    // Check if this was a tournament match
    const tournamentMatch = Array.from(window.TournamentManager.activeTournaments.values())
        .find(t => t.matches.some(m => m.id === gameId));
        
    if (tournamentMatch) {
        await window.TournamentManager.recordTournamentMatch(
            tournamentMatch.id, 
            gameId, 
            winnerId, 
            gameData
        );
    }
    
    // Update leaderboards
    await window.LeaderboardSystem.updatePlayerStats(winnerId, gameData.gameType, {
        won: true,
        opponentRating: gameData.opponentRating,
        stakeAmount: gameData.stakeAmount
    });
    
    await window.LeaderboardSystem.updatePlayerStats(loserId, gameData.gameType, {
        won: false,
        opponentRating: gameData.playerRating,
        stakeAmount: gameData.stakeAmount
    });
});

// Matchmaking queue management
window.addEventListener('beforeunload', () => {
    const playerId = window.PlayerManager?.getCurrentPlayerId?.();
    if (playerId) {
        window.AdvancedMatchmaking.removeFromQueue(playerId);
    }
});

console.log('✅ Section 19: Tournament System & Advanced Matchmaking loaded successfully');
              /* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 20: REAL-TIME COMMUNICATION & SOCIAL FEATURES
   =========================== */

'use strict';

// ===========================
// REAL-TIME CHAT SYSTEM
// ===========================

class ChatSystem {
    constructor() {
        this.chatRooms = new Map();
        this.activeConnections = new Map();
        this.messageHistory = new Map();
        this.chatFilters = new ChatFilter();
        this.emoteSystem = new EmoteSystem();
        this.maxMessageLength = 500;
        this.rateLimits = new Map();
        
        this.initializeChatSystem();
    }
    
    initializeChatSystem() {
        this.createDefaultRooms();
        this.setupEventHandlers();
        this.startCleanupTasks();
        
        console.log('✅ Chat System initialized');
    }
    
    createDefaultRooms() {
        const defaultRooms = [
            {
                id: 'global',
                name: 'Global Chat',
                type: 'public',
                maxUsers: 1000,
                description: 'General discussion for all players'
            },
            {
                id: 'chess',
                name: 'Chess Players',
                type: 'public',
                maxUsers: 500,
                description: 'Chat for chess enthusiasts'
            },
            {
                id: 'tournaments',
                name: 'Tournament Hub',
                type: 'public',
                maxUsers: 200,
                description: 'Tournament discussions and announcements'
            },
            {
                id: 'help',
                name: 'Help & Support',
                type: 'public',
                maxUsers: 100,
                description: 'Get help from moderators and other players'
            }
        ];
        
        defaultRooms.forEach(room => {
            this.createChatRoom(room);
        });
    }
    
    createChatRoom(roomConfig) {
        const room = {
            id: roomConfig.id,
            name: roomConfig.name,
            type: roomConfig.type || 'public',
            maxUsers: roomConfig.maxUsers || 50,
            description: roomConfig.description || '',
            users: new Set(),
            messages: [],
            moderators: new Set(),
            banned: new Set(),
            muted: new Set(),
            created: Date.now(),
            settings: {
                allowEmotes: true,
                allowLinks: false,
                slowMode: false,
                slowModeDelay: 5000,
                requireVerification: false
            }
        };
        
        this.chatRooms.set(room.id, room);
        this.messageHistory.set(room.id, []);
        
        return room;
    }
    
    async joinChatRoom(roomId, userId) {
        const room = this.chatRooms.get(roomId);
        if (!room) {
            throw new Error('Chat room not found');
        }
        
        // Check if user is banned
        if (room.banned.has(userId)) {
            throw new Error('You are banned from this chat room');
        }
        
        // Check room capacity
        if (room.users.size >= room.maxUsers) {
            throw new Error('Chat room is full');
        }
        
        // Add user to room
        room.users.add(userId);
        
        // Send join notification
        this.broadcastToRoom(roomId, {
            type: 'USER_JOINED',
            userId: userId,
            username: await this.getUsername(userId),
            timestamp: Date.now()
        }, userId);
        
        // Send recent message history to new user
        const recentMessages = this.getRecentMessages(roomId, 50);
        this.sendToUser(userId, {
            type: 'MESSAGE_HISTORY',
            roomId: roomId,
            messages: recentMessages
        });
        
        console.log(`👥 User ${userId} joined room ${roomId}`);
    }
    
    leaveChatRoom(roomId, userId) {
        const room = this.chatRooms.get(roomId);
        if (!room) return;
        
        room.users.delete(userId);
        
        // Send leave notification
        this.broadcastToRoom(roomId, {
            type: 'USER_LEFT',
            userId: userId,
            timestamp: Date.now()
        }, userId);
        
        console.log(`👋 User ${userId} left room ${roomId}`);
    }
    
    async sendMessage(roomId, userId, content, messageType = 'text') {
        const room = this.chatRooms.get(roomId);
        if (!room) {
            throw new Error('Chat room not found');
        }
        
        // Check if user is in room
        if (!room.users.has(userId)) {
            throw new Error('You are not in this chat room');
        }
        
        // Check if user is muted
        if (room.muted.has(userId)) {
            throw new Error('You are muted in this chat room');
        }
        
        // Rate limiting
        if (!this.checkRateLimit(userId, roomId)) {
            throw new Error('You are sending messages too quickly');
        }
        
        // Validate and filter message
        const processedContent = await this.processMessage(content, messageType);
        
        const message = {
            id: this.generateMessageId(),
            roomId: roomId,
            userId: userId,
            username: await this.getUsername(userId),
            content: processedContent.content,
            type: messageType,
            timestamp: Date.now(),
            edited: false,
            reactions: new Map(),
            mentions: processedContent.mentions || [],
            emotes: processedContent.emotes || []
        };
        
        // Add message to room history
        room.messages.push(message);
        
        // Maintain message history limit
        if (room.messages.length > 1000) {
            room.messages = room.messages.slice(-1000);
        }
        
        // Store in persistent history
        const history = this.messageHistory.get(roomId);
        history.push(message);
        if (history.length > 10000) {
            this.messageHistory.set(roomId, history.slice(-10000));
        }
        
        // Broadcast message to all users in room
        this.broadcastToRoom(roomId, {
            type: 'NEW_MESSAGE',
            message: message
        });
        
        // Handle mentions
        if (message.mentions.length > 0) {
            this.handleMentions(message);
        }
        
        console.log(`💬 Message sent in ${roomId} by ${userId}`);
        return message;
    }
    
    async processMessage(content, messageType) {
        // Validate message length
        if (content.length > this.maxMessageLength) {
            throw new Error(`Message too long (max ${this.maxMessageLength} characters)`);
        }
        
        // Filter profanity and inappropriate content
        const filteredContent = await this.chatFilters.filterContent(content);
        
        // Extract mentions (@username)
        const mentions = this.extractMentions(filteredContent);
        
        // Extract emotes
        const emotes = this.emoteSystem.extractEmotes(filteredContent);
        
        // Process links if allowed
        const processedLinks = this.processLinks(filteredContent);
        
        return {
            content: processedLinks,
            mentions: mentions,
            emotes: emotes
        };
    }
    
    extractMentions(content) {
        const mentionRegex = /@(\w+)/g;
        const mentions = [];
        let match;
        
        while ((match = mentionRegex.exec(content)) !== null) {
            mentions.push({
                username: match[1],
                position: match.index,
                length: match[0].length
            });
        }
        
        return mentions;
    }
    
    processLinks(content) {
        // Simple URL detection and processing
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        
        return content.replace(urlRegex, (url) => {
            // Sanitize and validate URL
            return `[LINK: ${url}]`; // Simple placeholder
        });
    }
    
    handleMentions(message) {
        message.mentions.forEach(async (mention) => {
            const mentionedUserId = await this.getUserIdByUsername(mention.username);
            if (mentionedUserId) {
                // Send notification to mentioned user
                window.NotificationManager?.send(mentionedUserId, {
                    type: 'CHAT_MENTION',
                    title: 'You were mentioned',
                    message: `${message.username} mentioned you in ${this.chatRooms.get(message.roomId)?.name}`,
                    roomId: message.roomId,
                    messageId: message.id
                });
            }
        });
    }
    
    checkRateLimit(userId, roomId) {
        const key = `${userId}_${roomId}`;
        const now = Date.now();
        
        if (!this.rateLimits.has(key)) {
            this.rateLimits.set(key, []);
        }
        
        const userLimits = this.rateLimits.get(key);
        
        // Remove old timestamps (older than 1 minute)
        const oneMinuteAgo = now - 60000;
        const recentMessages = userLimits.filter(timestamp => timestamp > oneMinuteAgo);
        
        // Check if user exceeded limit (10 messages per minute)
        if (recentMessages.length >= 10) {
            return false;
        }
        
        // Add current timestamp
        recentMessages.push(now);
        this.rateLimits.set(key, recentMessages);
        
        return true;
    }
    
    broadcastToRoom(roomId, data, excludeUser = null) {
        const room = this.chatRooms.get(roomId);
        if (!room) return;
        
        room.users.forEach(userId => {
            if (userId !== excludeUser) {
                this.sendToUser(userId, data);
            }
        });
    }
    
    sendToUser(userId, data) {
        // In a real implementation, this would use WebSocket connections
        // For now, we'll use custom events
        window.dispatchEvent(new CustomEvent('chatMessage', {
            detail: { userId, data }
        }));
    }
    
    async getUsername(userId) {
        // Get username from player manager or blockchain
        const playerName = await window.PlayerManager?.getPlayerName?.(userId);
        return playerName || `Player_${userId.slice(-6)}`;
    }
    
    async getUserIdByUsername(username) {
        // This would typically query a database
        // For now, we'll return null
        return null;
    }
    
    generateMessageId() {
        return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    getRecentMessages(roomId, limit = 50) {
        const room = this.chatRooms.get(roomId);
        if (!room) return [];
        
        return room.messages.slice(-limit);
    }
    
    setupEventHandlers() {
        // Listen for chat messages
        window.addEventListener('chatMessage', (event) => {
            const { userId, data } = event.detail;
            this.handleIncomingMessage(userId, data);
        });
    }
    
    handleIncomingMessage(userId, data) {
        // Process incoming messages from WebSocket or other transport
        console.log(`📨 Incoming message from ${userId}:`, data);
    }
    
    startCleanupTasks() {
        // Clean up old messages and inactive connections
        setInterval(() => {
            this.cleanupOldMessages();
            this.cleanupInactiveUsers();
        }, 600000); // Every 10 minutes
    }
    
    cleanupOldMessages() {
        const oneHourAgo = Date.now() - (60 * 60 * 1000);
        
        this.chatRooms.forEach((room, roomId) => {
            // Keep only recent messages in active memory
            room.messages = room.messages.filter(msg => msg.timestamp > oneHourAgo);
        });
        
        // Clean rate limits
        this.rateLimits.forEach((timestamps, key) => {
            const recent = timestamps.filter(ts => ts > oneHourAgo);
            if (recent.length === 0) {
                this.rateLimits.delete(key);
            } else {
                this.rateLimits.set(key, recent);
            }
        });
    }
    
    cleanupInactiveUsers() {
        // This would typically check for inactive WebSocket connections
        console.log('🧹 Cleaning up inactive chat users');
    }
    
    // Moderation functions
    async muteUser(roomId, userId, moderatorId, duration = 300000) {
        const room = this.chatRooms.get(roomId);
        if (!room || !room.moderators.has(moderatorId)) return false;
        
        room.muted.add(userId);
        
        // Remove mute after duration
        setTimeout(() => {
            room.muted.delete(userId);
            this.broadcastToRoom(roomId, {
                type: 'USER_UNMUTED',
                userId: userId,
                timestamp: Date.now()
            });
        }, duration);
        
        this.broadcastToRoom(roomId, {
            type: 'USER_MUTED',
            userId: userId,
            duration: duration,
            timestamp: Date.now()
        });
        
        return true;
    }
    
    async banUser(roomId, userId, moderatorId, reason = '') {
        const room = this.chatRooms.get(roomId);
        if (!room || !room.moderators.has(moderatorId)) return false;
        
        room.banned.add(userId);
        room.users.delete(userId);
        
        this.broadcastToRoom(roomId, {
            type: 'USER_BANNED',
            userId: userId,
            reason: reason,
            timestamp: Date.now()
        });
        
        return true;
    }
    
    getRoomInfo(roomId) {
        const room = this.chatRooms.get(roomId);
        if (!room) return null;
        
        return {
            id: room.id,
            name: room.name,
            type: room.type,
            description: room.description,
            userCount: room.users.size,
            maxUsers: room.maxUsers,
            settings: room.settings
        };
    }
    
    getUserRooms(userId) {
        const userRooms = [];
        
        this.chatRooms.forEach((room, roomId) => {
            if (room.users.has(userId)) {
                userRooms.push(this.getRoomInfo(roomId));
            }
        });
        
        return userRooms;
    }
}

// ===========================
// CHAT FILTER SYSTEM
// ===========================

class ChatFilter {
    constructor() {
        this.bannedWords = new Set([
            // Add banned words here
            'spam', 'scam', 'hack', 'cheat'
        ]);
        
        this.suspiciousPatterns = [
            /(.)\1{4,}/g, // Repeated characters
            /[A-Z]{5,}/g, // All caps words
            /\b\d{4,}\b/g // Long numbers (phone numbers, etc.)
        ];
        
        this.replacements = new Map([
            ['damn', 'd***'],
            ['hell', 'h***'],
            ['stupid', 's*****']
        ]);
    }
    
    async filterContent(content) {
        let filtered = content;
        
        // Replace banned words
        this.bannedWords.forEach(word => {
            const regex = new RegExp(`\\b${word}\\b`, 'gi');
            const replacement = '*'.repeat(word.length);
            filtered = filtered.replace(regex, replacement);
        });
        
        // Apply word replacements
        this.replacements.forEach((replacement, word) => {
            const regex = new RegExp(`\\b${word}\\b`, 'gi');
            filtered = filtered.replace(regex, replacement);
        });
        
        // Check for suspicious patterns
        this.suspiciousPatterns.forEach(pattern => {
            if (pattern.test(content)) {
                console.warn('🚨 Suspicious pattern detected in chat message');
            }
        });
        
        return filtered;
    }
    
    isSuspiciousContent(content) {
        return this.suspiciousPatterns.some(pattern => pattern.test(content));
    }
}

// ===========================
// EMOTE SYSTEM
// ===========================

class EmoteSystem {
    constructor() {
        this.emotes = new Map([
            [':smile:', '😊'],
            [':laugh:', '😂'],
            [':wink:', '😉'],
            [':cool:', '😎'],
            [':heart:', '❤️'],
            [':fire:', '🔥'],
            [':crown:', '👑'],
            [':chess:', '♛'],
            [':checkmate:', '♔'],
            [':victory:', '🏆'],
            [':gg:', '🤝'],
            [':thinking:', '🤔'],
            [':rage:', '😡'],
            [':sad:', '😢'],
            [':party:', '🎉']
        ]);
        
        this.customEmotes = new Map();
    }
    
    extractEmotes(content) {
        const foundEmotes = [];
        const emoteRegex = /:([\w]+):/g;
        let match;
        
        while ((match = emoteRegex.exec(content)) !== null) {
            const emoteName = `:${match[1]}:`;
            const emoteChar = this.emotes.get(emoteName) || this.customEmotes.get(emoteName);
            
            if (emoteChar) {
                foundEmotes.push({
                    name: emoteName,
                    character: emoteChar,
                    position: match.index,
                    length: match[0].length
                });
            }
        }
        
        return foundEmotes;
    }
    
    processEmotes(content) {
        let processed = content;
        
        this.emotes.forEach((character, name) => {
            const regex = new RegExp(name.replace(/[.*+?^${}()|[\]\\]/g, '\\    startCleanupTasks() {
        // Clean up old messages and inactive connections
        setInterval(() => {
            this.cleanupOldMessages();
            this.cleanupInactiveUsers();
        }, 600000); // Every 10 minutes
    }
    
    cleanupOldMessages() {
        const oneHourAgo = Date.now() - (60 * 60 * 1000);
        
        this.chatR'), 'g');
            processed = processed.replace(regex, character);
        });
        
        this.customEmotes.forEach((character, name) => {
            const regex = new RegExp(name.replace(/[.*+?^${}()|[\]\\]/g, '\\    startCleanupTasks() {
        // Clean up old messages and inactive connections
        setInterval(() => {
            this.cleanupOldMessages();
            this.cleanupInactiveUsers();
        }, 600000); // Every 10 minutes
    }
    
    cleanupOldMessages() {
        const oneHourAgo = Date.now() - (60 * 60 * 1000);
        
        this.chatR'), 'g');
            processed = processed.replace(regex, character);
        });
        
        return processed;
    }
    
    addCustomEmote(name, character, requiresPermission = false) {
        if (requiresPermission) {
            // Check if user has permission to add custom emotes
            return false;
        }
        
        this.customEmotes.set(name, character);
        return true;
    }
    
    getAvailableEmotes() {
        return {
            standard: Array.from(this.emotes.entries()),
            custom: Array.from(this.customEmotes.entries())
        };
    }
}

// ===========================
// FRIEND SYSTEM
// ===========================

class FriendSystem {
    constructor() {
        this.friendships = new Map();
        this.friendRequests = new Map();
        this.blockedUsers = new Map();
        this.onlineStatus = new Map();
        
        this.initializeFriendSystem();
    }
    
    initializeFriendSystem() {
        this.startOnlineStatusUpdates();
        console.log('✅ Friend System initialized');
    }
    
    async sendFriendRequest(fromUserId, toUserId) {
        // Check if users are already friends
        if (this.areFriends(fromUserId, toUserId)) {
            throw new Error('Users are already friends');
        }
        
        // Check if there's already a pending request
        const existingRequest = this.getFriendRequest(fromUserId, toUserId);
        if (existingRequest) {
            throw new Error('Friend request already sent');
        }
        
        // Check if user is blocked
        if (this.isBlocked(fromUserId, toUserId)) {
            throw new Error('Cannot send friend request to blocked user');
        }
        
        const requestId = this.generateRequestId();
        const request = {
            id: requestId,
            fromUserId: fromUserId,
            toUserId: toUserId,
            timestamp: Date.now(),
            status: 'PENDING'
        };
        
        if (!this.friendRequests.has(toUserId)) {
            this.friendRequests.set(toUserId, []);
        }
        
        this.friendRequests.get(toUserId).push(request);
        
        // Notify recipient
        window.NotificationManager?.send(toUserId, {
            type: 'FRIEND_REQUEST',
            title: 'New Friend Request',
            message: `${await this.getUsername(fromUserId)} wants to be your friend`,
            fromUserId: fromUserId,
            requestId: requestId
        });
        
        console.log(`👫 Friend request sent: ${fromUserId} -> ${toUserId}`);
        return requestId;
    }
    
    async acceptFriendRequest(requestId, userId) {
        const request = this.findFriendRequest(requestId, userId);
        if (!request) {
            throw new Error('Friend request not found');
        }
        
        if (request.status !== 'PENDING') {
            throw new Error('Friend request is not pending');
        }
        
        // Create friendship
        this.createFriendship(request.fromUserId, request.toUserId);
        
        // Update request status
        request.status = 'ACCEPTED';
        request.acceptedAt = Date.now();
        
        // Notify both users
        window.NotificationManager?.send(request.fromUserId, {
            type: 'FRIEND_REQUEST_ACCEPTED',
            title: 'Friend Request Accepted',
            message: `${await this.getUsername(userId)} accepted your friend request`,
            friendId: userId
        });
        
        console.log(`✅ Friend request accepted: ${request.fromUserId} <-> ${request.toUserId}`);
    }
    
    async declineFriendRequest(requestId, userId) {
        const request = this.findFriendRequest(requestId, userId);
        if (!request) {
            throw new Error('Friend request not found');
        }
        
        request.status = 'DECLINED';
        request.declinedAt = Date.now();
        
        console.log(`❌ Friend request declined: ${request.fromUserId} -> ${request.toUserId}`);
    }
    
    createFriendship(userId1, userId2) {
        // Add each user to the other's friends list
        if (!this.friendships.has(userId1)) {
            this.friendships.set(userId1, new Set());
        }
        if (!this.friendships.has(userId2)) {
            this.friendships.set(userId2, new Set());
        }
        
        this.friendships.get(userId1).add(userId2);
        this.friendships.get(userId2).add(userId1);
    }
    
    removeFriend(userId1, userId2) {
        const friends1 = this.friendships.get(userId1);
        const friends2 = this.friendships.get(userId2);
        
        if (friends1) friends1.delete(userId2);
        if (friends2) friends2.delete(userId1);
        
        console.log(`💔 Friendship removed: ${userId1} <-> ${userId2}`);
    }
    
    areFriends(userId1, userId2) {
        const friends = this.friendships.get(userId1);
        return friends ? friends.has(userId2) : false;
    }
    
    getFriends(userId) {
        const friendSet = this.friendships.get(userId);
        if (!friendSet) return [];
        
        return Array.from(friendSet).map(friendId => ({
            userId: friendId,
            status: this.onlineStatus.get(friendId) || 'offline',
            lastSeen: this.getLastSeen(friendId)
        }));
    }
    
    getFriendRequests(userId, type = 'received') {
        if (type === 'received') {
            const requests = this.friendRequests.get(userId) || [];
            return requests.filter(req => req.status === 'PENDING');
        } else if (type === 'sent') {
            const sentRequests = [];
            this.friendRequests.forEach(requests => {
                requests.forEach(req => {
                    if (req.fromUserId === userId && req.status === 'PENDING') {
                        sentRequests.push(req);
                    }
                });
            });
            return sentRequests;
        }
        
        return [];
    }
    
    findFriendRequest(requestId, toUserId) {
        const requests = this.friendRequests.get(toUserId) || [];
        return requests.find(req => req.id === requestId);
    }
    
    getFriendRequest(fromUserId, toUserId) {
        const requests = this.friendRequests.get(toUserId) || [];
        return requests.find(req => req.fromUserId === fromUserId && req.status === 'PENDING');
    }
    
    blockUser(userId, blockedUserId) {
        if (!this.blockedUsers.has(userId)) {
            this.blockedUsers.set(userId, new Set());
        }
        
        this.blockedUsers.get(userId).add(blockedUserId);
        
        // Remove friendship if exists
        this.removeFriend(userId, blockedUserId);
        
        console.log(`🚫 User blocked: ${userId} blocked ${blockedUserId}`);
    }
    
    unblockUser(userId, blockedUserId) {
        const blocked = this.blockedUsers.get(userId);
        if (blocked) {
            blocked.delete(blockedUserId);
        }
        
        console.log(`✅ User unblocked: ${userId} unblocked ${blockedUserId}`);
    }
    
    isBlocked(userId, otherUserId) {
        const blocked = this.blockedUsers.get(otherUserId);
        return blocked ? blocked.has(userId) : false;
    }
    
    getBlockedUsers(userId) {
        const blocked = this.blockedUsers.get(userId);
        return blocked ? Array.from(blocked) : [];
    }
    
    updateOnlineStatus(userId, status) {
        this.onlineStatus.set(userId, {
            status: status,
            timestamp: Date.now()
        });
        
        // Notify friends of status change
        const friends = this.getFriends(userId);
        friends.forEach(friend => {
            window.NotificationManager?.send(friend.userId, {
                type: 'FRIEND_STATUS_CHANGE',
                friendId: userId,
                status: status
            });
        });
    }
    
    getLastSeen(userId) {
        const status = this.onlineStatus.get(userId);
        return status ? status.timestamp : null;
    }
    
    startOnlineStatusUpdates() {
        // Update online status every 30 seconds
        setInterval(() => {
            this.updatePlayerOnlineStatus();
        }, 30000);
    }
    
    updatePlayerOnlineStatus() {
        // This would typically check WebSocket connections
        // For demo, we'll simulate some online players
        const currentUserId = window.PlayerManager?.getCurrentPlayerId?.();
        if (currentUserId) {
            this.updateOnlineStatus(currentUserId, 'online');
        }
    }
    
    generateRequestId() {
        return `friend_req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async getUsername(userId) {
        const playerName = await window.PlayerManager?.getPlayerName?.(userId);
        return playerName || `Player_${userId.slice(-6)}`;
    }
}

// ===========================
// NOTIFICATION SYSTEM
// ===========================

class NotificationManager {
    constructor() {
        this.notifications = new Map();
        this.unreadCounts = new Map();
        this.settings = new Map();
        this.maxNotifications = 100;
        
        this.initializeNotificationSystem();
    }
    
    initializeNotificationSystem() {
        this.setupDefaultSettings();
        this.startNotificationCleanup();
        
        console.log('✅ Notification Manager initialized');
    }
    
    setupDefaultSettings() {
        const defaultSettings = {
            gameInvites: true,
            friendRequests: true,
            chatMentions: true,
            tournamentUpdates: true,
            achievements: true,
            systemMessages: true,
            soundEnabled: true,
            desktopNotifications: false
        };
        
        // This would typically load from user preferences
        this.settings.set('default', defaultSettings);
    }
    
    async send(userId, notification) {
        if (!this.shouldSendNotification(userId, notification.type)) {
            return;
        }
        
        const notificationId = this.generateNotificationId();
        const fullNotification = {
            id: notificationId,
            userId: userId,
            type: notification.type,
            title: notification.title,
            message: notification.message,
            data: notification.data || {},
            timestamp: Date.now(),
            read: false,
            priority: notification.priority || 'normal'
        };
        
        // Add to user's notifications
        if (!this.notifications.has(userId)) {
            this.notifications.set(userId, []);
        }
        
        const userNotifications = this.notifications.get(userId);
        userNotifications.unshift(fullNotification);
        
        // Maintain max notifications limit
        if (userNotifications.length > this.maxNotifications) {
            userNotifications.splice(this.maxNotifications);
        }
        
        // Update unread count
        this.incrementUnreadCount(userId);
        
        // Send to client
        this.deliverNotification(userId, fullNotification);
        
        console.log(`🔔 Notification sent to ${userId}: ${notification.title}`);
        return notificationId;
    }
    
    deliverNotification(userId, notification) {
        // Deliver via custom event (in real app, would use WebSocket)
        window.dispatchEvent(new CustomEvent('notification', {
            detail: { userId, notification }
        }));
        
        // Show desktop notification if enabled
        if (this.isDesktopNotificationEnabled(userId) && 'Notification' in window) {
            this.showDesktopNotification(notification);
        }
        
        // Play sound if enabled
        if (this.isSoundEnabled(userId)) {
            this.playNotificationSound(notification.type);
        }
    }
    
    showDesktopNotification(notification) {
        if (Notification.permission === 'granted') {
            new Notification(notification.title, {
                body: notification.message,
                icon: '/favicon.ico',
                tag: notification.id
            });
        }
    }
    
    playNotificationSound(type) {
        // Play different sounds for different notification types
        const sounds = {
            'GAME_INVITE': '/sounds/game_invite.mp3',
            'FRIEND_REQUEST': '/sounds/friend_request.mp3',
            'CHAT_MENTION': '/sounds/mention.mp3',
            'ACHIEVEMENT_UNLOCKED': '/sounds/achievement.mp3',
            'default': '/sounds/notification.mp3'
        };
        
        const soundFile = sounds[type] || sounds.default;
        
        try {
            const audio = new Audio(soundFile);
            audio.volume = 0.5;
            audio.play().catch(() => {
                // Ignore audio play errors
            });
        } catch (error) {
            // Ignore audio errors
        }
    }
    
    markAsRead(userId, notificationId) {
        const userNotifications = this.notifications.get(userId);
        if (!userNotifications) return false;
        
        const notification = userNotifications.find(n => n.id === notificationId);
        if (!notification) return false;
        
        if (!notification.read) {
            notification.read = true;
            notification.readAt = Date.now();
            this.decrementUnreadCount(userId);
        }
        
        return true;
    }
    
    markAllAsRead(userId) {
        const userNotifications = this.notifications.get(userId);
        if (!userNotifications) return 0;
        
        let markedCount = 0;
        userNotifications.forEach(notification => {
            if (!notification.read) {
                notification.read = true;
                notification.readAt = Date.now();
                markedCount++;
            }
        });
        
        this.unreadCounts.set(userId, 0);
        return markedCount;
    }
    
    getNotifications(userId, limit = 50, offset = 0) {
        const userNotifications = this.notifications.get(userId) || [];
        return userNotifications.slice(offset, offset + limit);
    }
    
    getUnreadCount(userId) {
        return this.unreadCounts.get(userId) || 0;
    }
    
    incrementUnreadCount(userId) {
        const current = this.unreadCounts.get(userId) || 0;
        this.unreadCounts.set(userId, current + 1);
    }
    
    decrementUnreadCount(userId) {
        const current = this.unreadCounts.get(userId) || 0;
        this.unreadCounts.set(userId, Math.max(0, current - 1));
    }
    
    shouldSendNotification(userId, type) {
        const settings = this.settings.get(userId) || this.settings.get('default');
        
        const typeMapping = {
            'GAME_INVITE': 'gameInvites',
            'FRIEND_REQUEST': 'friendRequests',
            'FRIEND_REQUEST_ACCEPTED': 'friendRequests',
            'CHAT_MENTION': 'chatMentions',
            'TOURNAMENT_START': 'tournamentUpdates',
            'TOURNAMENT_COMPLETE': 'tournamentUpdates',
            'ACHIEVEMENT_UNLOCKED': 'achievements'
        };
        
        const settingKey = typeMapping[type] || 'systemMessages';
        return settings[settingKey] !== false;
    }
    
    updateSettings(userId, newSettings) {
        const currentSettings = this.settings.get(userId) || this.settings.get('default');
        const updatedSettings = { ...currentSettings, ...newSettings };
        
        this.settings.set(userId, updatedSettings);
        console.log(`⚙️ Notification settings updated for ${userId}`);
    }
    
    getSettings(userId) {
        return this.settings.get(userId) || this.settings.get('default');
    }
    
    isDesktopNotificationEnabled(userId) {
        const settings = this.getSettings(userId);
        return settings.desktopNotifications && Notification.permission === 'granted';
    }
    
    isSoundEnabled(userId) {
        const settings = this.getSettings(userId);
        return settings.soundEnabled;
    }
    
    async requestDesktopPermission() {
        if ('Notification' in window) {
            const permission = await Notification.requestPermission();
            return permission === 'granted';
        }
        return false;
    }
    
    startNotificationCleanup() {
        // Clean up old notifications every hour
        setInterval(() => {
            this.cleanupOldNotifications();
        }, 3600000);
    }
    
    cleanupOldNotifications() {
        const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
        
        this.notifications.forEach((userNotifications, userId) => {
            const filtered = userNotifications.filter(n => n.timestamp > oneWeekAgo);
            this.notifications.set(userId, filtered);
        });
        
        console.log('🧹 Old notifications cleaned up');
    }
    
    generateNotificationId() {
        return `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    deleteNotification(userId, notificationId) {
        const userNotifications = this.notifications.get(userId);
        if (!userNotifications) return false;
        
        const index = userNotifications.findIndex(n => n.id === notificationId);
        if (index === -1) return false;
        
        const notification = userNotifications[index];
        if (!notification.read) {
            this.decrementUnreadCount(userId);
        }
        
        userNotifications.splice(index, 1);
        return true;
    }
    
    clearAllNotifications(userId) {
        const userNotifications = this.notifications.get(userId);
        if (!userNotifications) return 0;
        
        const count = userNotifications.length;
        this.notifications.set(userId, []);
        this.unreadCounts.set(userId, 0);
        
        return count;
    }
}

// ===========================
// INITIALIZE SOCIAL SYSTEMS
// ===========================

window.ChatSystem = new ChatSystem();
window.FriendSystem = new FriendSystem();
window.NotificationManager = new NotificationManager();

// Setup event listeners for social features
document.addEventListener('playerConnect', (event) => {
    const playerId = event.detail.playerId;
    window.FriendSystem.updateOnlineStatus(playerId, 'online');
});

document.addEventListener('playerDisconnect', (event) => {
    const playerId = event.detail.playerId;
    window.FriendSystem.updateOnlineStatus(playerId, 'offline');
});

// Chat integration with game events
document.addEventListener('gameStart', (event) => {
    const { gameId, players } = event.detail;
    
    // Create temporary game chat room
    const gameRoom = window.ChatSystem.createChatRoom({
        id: `game_${gameId}`,
        name: `Game Chat - ${gameId.slice(-8)}`,
        type: 'game',
        maxUsers: players.length,
        description: 'In-game chat'
    });
    
    // Add players to game chat
    players.forEach(playerId => {
        window.ChatSystem.joinChatRoom(gameRoom.id, playerId);
    });
});

document.addEventListener('gameEnd', (event) => {
    const { gameId } = event.detail;
    const roomId = `game_${gameId}`;
    
    // Remove game chat room after delay
    setTimeout(() => {
        window.ChatSystem.chatRooms.delete(roomId);
    }, 300000); // Keep for 5 minutes after game ends
});

console.log('✅ Section 20: Real-time Communication & Social Features loaded successfully');
              trackEvent(eventName, properties = {}, userId = null) {
        const event = {
            id: this.generateEventId(),
            name: eventName,
            properties: properties,
            userId: userId || this.getCurrentUserId(),
            sessionId: this.currentSessionId,
            timestamp: Date.now(),
            url: window.location.href,
            userAgent: navigator.userAgent
        };
        
        // Add to events queue
        this.events.push(event);
        
        // Add to current session
        const session = this.sessionData.get(this.currentSessionId);
        if (session) {
            session.events.push(event);
        }
        
        // Update user behavior tracking
        this.updateUserBehavior(event);
        
        // Process real-time analytics
        this.processRealtimeEvent(event);
        
        // Keep only last 10000 events in memory
        if (this.events.length > 10000) {
            this.events = this.events.slice(-10000);
        }
        
        console.log(`📊 Event tracked: ${eventName}`, properties);
        
        // Send to analytics service (in production)
        this.sendEventToService(event);
    }
    
    trackPageView(path, title = document.title) {
        const pageView = {
            path: path,
            title: title,
            timestamp: Date.now(),
            referrer: document.referrer,
            sessionId: this.currentSessionId
        };
        
        const session = this.sessionData.get(this.currentSessionId);
        if (session) {
            session.pageViews.push(pageView);
        }
        
        this.trackEvent('page_view', {
            path: path,
            title: title
        });
    }
    
    trackGameEvent(gameId, eventType, data = {}) {
        this.trackEvent('game_event', {
            gameId: gameId,
            eventType: eventType,
            gameData: data,
            duration: data.duration || 0
        });
        
        // Update game-specific metrics
        this.updateGameMetrics(gameId, eventType, data);
    }
    
    trackTransaction(transactionId, amount, currency, type) {
        this.trackEvent('transaction', {
            transactionId: transactionId,
            amount: amount,
            currency: currency,
            type: type
        });
        
        // Update financial metrics
        this.realtimeStats.totalTransactions++;
    }
    
    trackError(error, context = {}) {
        const errorEvent = {
            message: error.message || error,
            stack: error.stack || '',
            context: context,
            timestamp: Date.now(),
            sessionId: this.currentSessionId,
            url: window.location.href
        };
        
        const session = this.sessionData.get(this.currentSessionId);
        if (session) {
            session.errors.push(errorEvent);
        }
        
        this.trackEvent('error', {
            errorMessage: errorEvent.message,
            errorType: error.name || 'Unknown',
            context: context
        });
        
        // Update error rate
        this.updateErrorRate();
    }
    
    updateUserBehavior(event) {
        const userId = event.userId;
        if (!userId || userId === 'anonymous') return;
        
        if (!this.userBehavior.has(userId)) {
            this.userBehavior.set(userId, {
                firstSeen: Date.now(),
                lastSeen: Date.now(),
                sessionCount: 0,
                totalEvents: 0,
                gamesSplayed: 0,
                totalSpent: 0,
                preferredGameTypes: new Map(),
                averageSessionDuration: 0,
                clickPatterns: [],
                conversionEvents: []
            });
        }
        
        const behavior = this.userBehavior.get(userId);
        behavior.lastSeen = Date.now();
        behavior.totalEvents++;
        
        // Track game preferences
        if (event.name === 'game_start') {
            const gameType = event.properties.gameType;
            if (gameType) {
                const count = behavior.preferredGameTypes.get(gameType) || 0;
                behavior.preferredGameTypes.set(gameType, count + 1);
            }
            behavior.gamesPlayed++;
        }
        
        // Track spending
        if (event.name === 'transaction' && event.properties.type === 'spend') {
            behavior.totalSpent += event.properties.amount;
        }
        
        // Track conversion events
        const conversionEvents = ['first_game', 'first_purchase', 'tournament_join', 'friend_invite'];
        if (conversionEvents.includes(event.name)) {
            behavior.conversionEvents.push({
                event: event.name,
                timestamp: Date.now()
            });
        }
    }
    
    processRealtimeEvent(event) {
        // Update real-time statistics
        switch (event.name) {
            case 'session_start':
                this.realtimeStats.activeUsers++;
                break;
            case 'session_end':
                this.realtimeStats.activeUsers = Math.max(0, this.realtimeStats.activeUsers - 1);
                break;
            case 'game_start':
                this.realtimeStats.activeGames++;
                break;
            case 'game_end':
                this.realtimeStats.activeGames = Math.max(0, this.realtimeStats.activeGames - 1);
                break;
        }
    }
    
    updateGameMetrics(gameId, eventType, data) {
        const gameMetrics = this.performanceMetrics.get('games') || new Map();
        
        if (!gameMetrics.has(data.gameType)) {
            gameMetrics.set(data.gameType, {
                totalGames: 0,
                totalDuration: 0,
                averageDuration: 0,
                completionRate: 0,
                playerRetention: 0,
                averageStake: 0,
                totalVolume: 0
            });
        }
        
        const metrics = gameMetrics.get(data.gameType);
        
        switch (eventType) {
            case 'game_start':
                metrics.totalGames++;
                if (data.stakeAmount) {
                    metrics.totalVolume += data.stakeAmount;
                    metrics.averageStake = metrics.totalVolume / metrics.totalGames;
                }
                break;
            case 'game_end':
                if (data.duration) {
                    metrics.totalDuration += data.duration;
                    metrics.averageDuration = metrics.totalDuration / metrics.totalGames;
                }
                break;
        }
        
        this.performanceMetrics.set('games', gameMetrics);
    }
    
    updateErrorRate() {
        const session = this.sessionData.get(this.currentSessionId);
        if (session) {
            const totalEvents = session.events.length;
            const errorEvents = session.errors.length;
            this.realtimeStats.errorRate = totalEvents > 0 ? (errorEvents / totalEvents) * 100 : 0;
        }
    }
    
    startMetricsCollection() {
        // Collect metrics every 30 seconds
        setInterval(() => {
            this.collectSystemMetrics();
            this.updateRealtimeStats();
        }, 30000);
        
        // Save analytics data every 5 minutes
        setInterval(() => {
            this.saveAnalyticsData();
        }, 300000);
    }
    
    collectSystemMetrics() {
        const metrics = {
            timestamp: Date.now(),
            memory: this.getMemoryUsage(),
            performance: this.getPerformanceMetrics(),
            network: this.getNetworkMetrics(),
            errors: this.getErrorMetrics()
        };
        
        const systemMetrics = this.performanceMetrics.get('system') || [];
        systemMetrics.push(metrics);
        
        // Keep only last 1000 system metrics
        if (systemMetrics.length > 1000) {
            systemMetrics.splice(0, systemMetrics.length - 1000);
        }
        
        this.performanceMetrics.set('system', systemMetrics);
    }
    
    getMemoryUsage() {
        if ('memory' in performance) {
            return {
                usedJSHeapSize: performance.memory.usedJSHeapSize,
                totalJSHeapSize: performance.memory.totalJSHeapSize,
                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
            };
        }
        return null;
    }
    
    getPerformanceMetrics() {
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
            return {
                domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
                loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
                responseTime: navigation.responseEnd - navigation.requestStart,
                domInteractive: navigation.domInteractive - navigation.navigationStart
            };
        }
        return null;
    }
    
    getNetworkMetrics() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection) {
            return {
                effectiveType: connection.effectiveType,
                downlink: connection.downlink,
                rtt: connection.rtt,
                saveData: connection.saveData
            };
        }
        return null;
    }
    
    getErrorMetrics() {
        const session = this.sessionData.get(this.currentSessionId);
        if (session) {
            return {
                totalErrors: session.errors.length,
                errorRate: this.realtimeStats.errorRate,
                lastError: session.errors[session.errors.length - 1] || null
            };
        }
        return null;
    }
    
    updateRealtimeStats() {
        // Update average response time
        const systemMetrics = this.performanceMetrics.get('system') || [];
        if (systemMetrics.length > 0) {
            const recentMetrics = systemMetrics.slice(-10);
            const totalResponseTime = recentMetrics.reduce((sum, metric) => {
                return sum + (metric.performance?.responseTime || 0);
            }, 0);
            this.realtimeStats.avgResponseTime = totalResponseTime / recentMetrics.length;
        }
    }
    
    saveAnalyticsData() {
        try {
            // Save to localStorage (in production, send to server)
            const analyticsData = {
                timestamp: Date.now(),
                events: this.events.slice(-1000), // Last 1000 events
                realtimeStats: this.realtimeStats,
                userBehavior: Object.fromEntries(this.userBehavior),
                performanceMetrics: Object.fromEntries(this.performanceMetrics)
            };
            
            localStorage.setItem('crossrealm_analytics', JSON.stringify(analyticsData));
            console.log('💾 Analytics data saved');
            
        } catch (error) {
            console.error('❌ Failed to save analytics data:', error);
        }
    }
    
    sendEventToService(event) {
        // In production, send to analytics service
        // For demo, we'll just log important events
        const importantEvents = ['transaction', 'game_start', 'game_end', 'error', 'conversion'];
        if (importantEvents.includes(event.name)) {
            console.log('📡 Sending event to analytics service:', event.name);
        }
    }
    
    setupEventListeners() {
        // Track page visibility changes
        document.addEventListener('visibilitychange', () => {
            this.trackEvent(document.hidden ? 'page_hidden' : 'page_visible');
        });
        
        // Track clicks
        document.addEventListener('click', (event) => {
            this.trackEvent('click', {
                element: event.target.tagName,
                className: event.target.className,
                id: event.target.id,
                x: event.clientX,
                y: event.clientY
            });
        });
        
        // Track form submissions
        document.addEventListener('submit', (event) => {
            this.trackEvent('form_submit', {
                formId: event.target.id,
                formAction: event.target.action
            });
        });
        
        // Track errors
        window.addEventListener('error', (event) => {
            this.trackError(event.error, {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });
        
        // Track unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            this.trackError(new Error('Unhandled Promise Rejection'), {
                reason: event.reason
            });
        });
        
        // Track before page unload
        window.addEventListener('beforeunload', () => {
            this.endSession();
        });
    }
    
    initializePerformanceMonitoring() {
        // Monitor Web Vitals
        this.monitorWebVitals();
        
        // Monitor resource loading
        this.monitorResourceLoading();
        
        // Monitor API response times
        this.monitorAPIResponses();
    }
    
    monitorWebVitals() {
        // First Paint
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.name === 'first-paint') {
                    this.trackEvent('web_vital', {
                        metric: 'first_paint',
                        value: entry.startTime
                    });
                } else if (entry.name === 'first-contentful-paint') {
                    this.trackEvent('web_vital', {
                        metric: 'first_contentful_paint',
                        value: entry.startTime
                    });
                }
            }
        });
        
        try {
            observer.observe({ entryTypes: ['paint'] });
        } catch (error) {
            console.warn('Performance observer not supported');
        }
        
        // Largest Contentful Paint
        try {
            const lcpObserver = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                const lastEntry = entries[entries.length - 1];
                
                this.trackEvent('web_vital', {
                    metric: 'largest_contentful_paint',
                    value: lastEntry.startTime
                });
            });
            
            lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
        } catch (error) {
            console.warn('LCP observer not supported');
        }
    }
    
    monitorResourceLoading() {
        const resourceObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.duration > 1000) { // Resources taking more than 1 second
                    this.trackEvent('slow_resource', {
                        resource: entry.name,
                        duration: entry.duration,
                        size: entry.transferSize
                    });
                }
            }
        });
        
        try {
            resourceObserver.observe({ entryTypes: ['resource'] });
        } catch (error) {
            console.warn('Resource observer not supported');
        }
    }
    
    monitorAPIResponses() {
        // Monkey patch fetch to monitor API calls
        const originalFetch = window.fetch;
        window.fetch = async (...args) => {
            const startTime = Date.now();
            const url = args[0];
            
            try {
                const response = await originalFetch(...args);
                const duration = Date.now() - startTime;
                
                this.trackEvent('api_call', {
                    url: url,
                    method: args[1]?.method || 'GET',
                    status: response.status,
                    duration: duration,
                    success: response.ok
                });
                
                return response;
            } catch (error) {
                const duration = Date.now() - startTime;
                
                this.trackEvent('api_error', {
                    url: url,
                    method: args[1]?.method || 'GET',
                    duration: duration,
                    error: error.message
                });
                
                throw error;
            }
        };
    }
    
    endSession() {
        const session = this.sessionData.get(this.currentSessionId);
        if (session) {
            session.endTime = Date.now();
            session.duration = session.endTime - session.startTime;
            
            this.trackEvent('session_end', {
                sessionId: this.currentSessionId,
                duration: session.duration,
                eventCount: session.events.length,
                errorCount: session.errors.length
            });
        }
        
        // Save final analytics data
        this.saveAnalyticsData();
    }
    
    getCurrentUserId() {
        return window.PlayerManager?.getCurrentPlayerId?.() || 'anonymous';
    }
    
    generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    generateEventId() {
        return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Public API methods
    getAnalyticsSummary() {
        return {
            realtimeStats: this.realtimeStats,
            totalEvents: this.events.length,
            totalSessions: this.sessionData.size,
            totalUsers: this.userBehavior.size,
            errorRate: this.realtimeStats.errorRate
        };
    }
    
    getUserBehaviorData(userId) {
        return this.userBehavior.get(userId) || null;
    }
    
    getGameMetrics(gameType = null) {
        const gameMetrics = this.performanceMetrics.get('games') || new Map();
        return gameType ? gameMetrics.get(gameType) : Object.fromEntries(gameMetrics);
    }
    
    getSystemMetrics(limit = 100) {
        const systemMetrics = this.performanceMetrics.get('system') || [];
        return systemMetrics.slice(-limit);
    }
}

// ===========================
// PERFORMANCE DASHBOARD
// ===========================

class PerformanceDashboard {
    constructor() {
        this.updateInterval = 5000; // 5 seconds
        this.charts = new Map();
        this.isVisible = false;
        
        this.initializeDashboard();
    }
    
    initializeDashboard() {
        this.createDashboardUI();
        this.startDataUpdates();
        
        console.log('✅ Performance Dashboard initialized');
    }
    
    createDashboardUI() {
        const dashboard = document.createElement('div');
        dashboard.id = 'performanceDashboard';
        dashboard.className = 'performance-dashboard';
        dashboard.style.cssText = `
            position: fixed;
            top: 60px;
            right: 10px;
            width: 400px;
            height: 600px;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            border-radius: 12px;
            padding: 20px;
            font-size: 14px;
            z-index: 9999;
            display: none;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        `;
        
        dashboard.innerHTML = `
            <div class="dashboard-header">
                <h3>📊 Performance Dashboard</h3>
                <button onclick="this.parentElement.parentElement.style.display='none'" style="float: right; background: none; border: none; color: white; font-size: 18px; cursor: pointer;">×</button>
            </div>
            
            <div class="metrics-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 20px 0;">
                <div class="metric-card" style="background: #1a1a2e; padding: 15px; border-radius: 8px;">
                    <div class="metric-title">Active Users</div>
                    <div class="metric-value" id="activeUsers">0</div>
                </div>
                <div class="metric-card" style="background: #1a1a2e; padding: 15px; border-radius: 8px;">
                    <div class="metric-title">Active Games</div>
                    <div class="metric-value" id="activeGames">0</div>
                </div>
                <div class="metric-card" style="background: #1a1a2e; padding: 15px; border-radius: 8px;">
                    <div class="metric-title">Response Time</div>
                    <div class="metric-value" id="responseTime">0ms</div>
                </div>
                <div class="metric-card" style="background: #1a1a2e; padding: 15px; border-radius: 8px;">
                    <div class="metric-title">Error Rate</div>
                    <div class="metric-value" id="errorRate">0%</div>
                </div>
            </div>
            
            <div class="performance-charts" style="margin: 20px 0;">
                <h4>System Performance</h4>
                <canvas id="performanceChart" width="360" height="200" style="background: #1a1a2e; border-radius: 8px;"></canvas>
            </div>
            
            <div class="game-metrics" style="margin: 20px 0;">
                <h4>Game Metrics</h4>
                <div id="gameMetricsList"></div>
            </div>
            
            <div class="recent-events" style="margin: 20px 0;">
                <h4>Recent Events</h4>
                <div id="recentEventsList" style="max-height: 150px; overflow-y: auto;"></div>
            </div>
        `;
        
        document.body.appendChild(dashboard);
        
        // Create toggle button
        const toggleBtn = document.createElement('button');
        toggleBtn.innerHTML = '📊';
        toggleBtn.title = 'Performance Dashboard';
        toggleBtn.style.cssText = `
            position: fixed;
            top: 60px;
            right: 10px;
            z-index: 10000;
            background: rgba(0, 123, 255, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 16px;
        `;
        
        toggleBtn.onclick = () => {
            const isVisible = dashboard.style.display !== 'none';
            dashboard.style.display = isVisible ? 'none' : 'block';
            this.isVisible = !isVisible;
            
            if (this.isVisible) {
                this.updateDashboard();
                this.initializeChart();
            }
        };
        
        document.body.appendChild(toggleBtn);
    }
    
    startDataUpdates() {
        setInterval(() => {
            if (this.isVisible) {
                this.updateDashboard();
            }
        }, this.updateInterval);
    }
    
    updateDashboard() {
        const analytics = window.AnalyticsSystem;
        if (!analytics) return;
        
        const stats = analytics.getAnalyticsSummary();
        
        // Update metric cards
        document.getElementById('activeUsers').textContent = stats.realtimeStats.activeUsers;
        document.getElementById('activeGames').textContent = stats.realtimeStats.activeGames;
        document.getElementById('responseTime').textContent = `${Math.round(stats.realtimeStats.avgResponseTime)}ms`;
        document.getElementById('errorRate').textContent = `${stats.errorRate.toFixed(2)}%`;
        
        // Update game metrics
        this.updateGameMetrics();
        
        // Update recent events
        this.updateRecentEvents();
        
        // Update chart
        this.updateChart();
    }
    
    updateGameMetrics() {
        const analytics = window.AnalyticsSystem;
        const gameMetrics = analytics.getGameMetrics();
        const gameMetricsList = document.getElementById('gameMetricsList');
        
        let html = '';
        Object.entries(gameMetrics).forEach(([gameType, metrics]) => {
            html += `
                <div style="background: #1a1a2e; margin: 5px 0; padding: 10px; border-radius: 6px; font-size: 12px;">
                    <strong>${gameType.toUpperCase()}</strong><br>
                    Games: ${metrics.totalGames} | Avg Duration: ${Math.round(metrics.averageDuration / 1000)}s<br>
                    Avg Stake: ${metrics.averageStake.toFixed(2)} CORE
                </div>
            `;
        });
        
        gameMetricsList.innerHTML = html || '<div style="color: #666;">No game data available</div>';
    }
    
    updateRecentEvents() {
        const analytics = window.AnalyticsSystem;
        const recentEvents = analytics.events.slice(-10);
        const eventsList = document.getElementById('recentEventsList');
        
        let html = '';
        recentEvents.reverse().forEach(event => {
            const time = new Date(event.timestamp).toLocaleTimeString();
            html += `
                <div style="margin: 3px 0; padding: 5px; background: #1a1a2e; border-radius: 4px; font-size: 11px;">
                    <span style="color: #666;">[${time}]</span> 
                    <span style="color: #4CAF50;">${event.name}</span>
                    ${event.properties.gameType ? `- ${event.properties.gameType}` : ''}
                </div>
            `;
        });
        
        eventsList.innerHTML = html || '<div style="color: #666;">No recent events</div>';
    }
    
    initializeChart() {
        const canvas = document.getElementById('performanceChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        this.chartContext = ctx;
        this.chartData = {
            labels: [],
            responseTime: [],
            memoryUsage: [],
            errorRate: []
        };
    }
    
    updateChart() {
        if (!this.chartContext) return;
        
        const analytics = window.AnalyticsSystem;
        const systemMetrics = analytics.getSystemMetrics(20);
        
        if (systemMetrics.length === 0) return;
        
        // Update chart data
        this.chartData.labels = systemMetrics.map((_, index) => index);
        this.chartData.responseTime = systemMetrics.map(m => m.performance?.responseTime || 0);
        this.chartData.memoryUsage = systemMetrics.map(m => 
            m.memory ? (m.memory.usedJSHeapSize / 1024 / 1024) : 0
        );
        this.chartData.errorRate = systemMetrics.map(m => m.errors?.errorRate || 0);
        
        this.drawChart();
    }
    
    drawChart() {
        const ctx = this.chartContext;
        const canvas = ctx.canvas;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw response time line
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const maxResponseTime = Math.max(...this.chartData.responseTime, 100);
        const stepX = canvas.width / (this.chartData.responseTime.length - 1);
        
        this.chartData.responseTime.forEach((value, index) => {
            const x = index * stepX;
            const y = canvas.height - (value / maxResponseTime) * canvas.height;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.stroke();
        
        // Draw memory usage line
        ctx.strokeStyle = '#FF9800';
        ctx.beginPath();
        
        const maxMemory = Math.max(...this.chartData.memoryUsage, 100);
        
        this.chartData.memoryUsage.forEach((value, index) => {
            const x = index * stepX;
            const y = canvas.height - (value / maxMemory) * canvas.height;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.stroke();
        
        // Add legend
        ctx.font = '12px Arial';
        ctx.fillStyle = '#4CAF50';
        ctx.fillText('Response Time', 10, 20);
        ctx.fillStyle = '#FF9800';
        ctx.fillText('Memory (MB)', 10, 35);
    }
}

// ===========================
// A/B TESTING SYSTEM
// ===========================

class ABTestingSystem {
    constructor() {
        this.activeTests = new Map();
        this.userAssignments = new Map();
        this.testResults = new Map();
        
        this.initializeABTesting();
    }
    
    initializeABTesting() {
        this.loadActiveTests();
        console.log('✅ A/B Testing System initialized');
    }
    
    loadActiveTests() {
        // Example A/B tests
        const tests = [
            {
                id: 'button_color_test',
                name: 'Game Button Color Test',
                variants: ['blue', 'green', 'red'],
                allocation: [0.34, 0.33, 0.33],
                startDate: Date.now() - (7 * 24 * 60 * 60 * 1000), // Started 7 days ago
                endDate: Date.now() + (7 * 24 * 60 * 60 * 1000), // Ends in 7 days
                targetMetric: 'game_start_rate',
                status: 'active'
            },
            {
                id: 'pricing_test',
                name: 'Entry Fee Pricing Test',
                variants: ['low', 'medium', 'high'],
                allocation: [0.33, 0.34, 0.33],
                startDate: Date.now() - (3 * 24 * 60 * 60 * 1000),
                endDate: Date.now() + (14 * 24 * 60 * 60 * 1000),
                targetMetric: 'conversion_rate',
                status: 'active'
            }
        ];
        
        tests.forEach(test => {
            this.activeTests.set(test.id, test);
            this.testResults.set(test.id, {
                variants: test.variants.reduce((acc, variant) => {
                    acc[variant] = { exposures: 0, conversions: 0, conversionRate: 0 };
                    return acc;
                }, {})
            });
        });
    }
    
    assignUserToTest(userId, testId) {
        const test = this.activeTests.get(testId);
        if (!test || test.status !== 'active') return null;
        
        // Check if user is already assigned
        const userKey = `${userId}_${testId}`;
        if (this.userAssignments.has(userKey)) {
            return this.userAssignments.get(userKey);
        }
        
        // Assign user to variant based on allocation
        const random = Math.random();
        let cumulativeAllocation = 0;
        let assignedVariant = null;
        
        for (let i = 0; i < test.variants.length; i++) {
            cumulativeAllocation += test.allocation[i];
            if (random <= cumulativeAllocation) {
                assignedVariant = test.variants[i];
                break;
            }
        }
        
        if (!assignedVariant) {
            assignedVariant = test.variants[0]; // Fallback
        }
        
        const assignment = {
            testId: testId,
            variant: assignedVariant,
            assignedAt: Date.now()
        };
        
        this.userAssignments.set(userKey, assignment);
        
        // Track exposure
        const results = this.testResults.get(testId);
        if (results) {
            results.variants[assignedVariant].exposures++;
        }
        
        // Track assignment event
        window.AnalyticsSystem?.trackEvent('ab_test_assignment', {
            testId: testId,
            variant: assignedVariant,
            userId: userId
        });
        
        return assignment;
    }
    
    getUserVariant(userId, testId) {
        const assignment = this.assignUserToTest(userId, testId);
        return assignment ? assignment.variant : null;
    }
    
    trackConversion(userId, testId, conversionValue = 1) {
        const userKey = `${userId}_${testId}`;
        const assignment = this.userAssignments.get(userKey);
        
        if (!assignment) return;
        
        const results = this.testResults.get(testId);
        if (results) {
            const variantResults = results.variants[assignment.variant];
            variantResults.conversions += conversionValue;
            variantResults.conversionRate = variantResults.exposures > 0 ? 
                (variantResults.conversions / variantResults.exposures) * 100 : 0;
        }
        
        // Track conversion event
        window.AnalyticsSystem?.trackEvent('ab_test_conversion', {
            testId: testId,
            variant: assignment.variant,
            userId: userId,
            conversionValue: conversionValue
        });
    }
    
    getTestResults(testId) {
        const test = this.activeTests.get(testId);
        const results = this.testResults.get(testId);
        
        if (!test || !results) return null;
        
        return {
            testInfo: test,
            results: results.variants,
            totalExposures: Object.values(results.variants).reduce((sum, v) => sum + v.exposures, 0),
            totalConversions: Object.values(results.variants).reduce((sum, v) => sum + v.conversions, 0)
        };
    }
    
    calculateStatisticalSignificance(testId) {
        const results = this.getTestResults(testId);
        if (!results) return null;
        
        const variants = Object.entries(results.results);
        if (variants.length < 2) return null;
        
        const [controlName, control] = variants[0];
        const significance = {};
        
        variants.slice(1).forEach(([variantName, variant]) => {
            // Simple Z-test for proportions
            const p1 = control.conversionRate / 100;
            const p2 = variant.conversionRate / 100;
            const n1 = control.exposures;
            const n2 = variant.exposures;
            
            if (n1 === 0 || n2 === 0) {
                significance[variantName] = { pValue: 1, significant: false };
                return;
            }
            
            const pooledP = (control.conversions + variant.conversions) / (n1 + n2);
            const se = Math.sqrt(pooledP * (1 - pooledP) * (1/n1 + 1/n2));
            const z = Math.abs(p2 - p1) / se;
            const pValue = 2 * (1 - this.normalCDF(Math.abs(z)));
            
            significance[variantName] = {
                pValue: pValue,
                significant: pValue < 0.05,
                zScore: z,
                lift: ((p2 - p1) / p1) * 100
            };
        });
        
        return significance;
    }
    
    normalCDF(x) {
        // Approximation of normal CDF
        return 0.5 * (1 + this.erf(x / Math.sqrt(2)));
    }
    
    erf(x) {
        // Approximation of error function
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        
        const sign = x >= 0 ? 1 : -1;
        x = Math.abs(x);
        
        const t = 1.0 / (1.0 + p * x);
        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        
        return sign * y;
    }
    
    getAllActiveTests() {
        return Array.from(this.activeTests.values()).filter(test => test.status === 'active');
    }
    
    endTest(testId, winningVariant = null) {
        const test = this.activeTests.get(testId);
        if (!test) return false;
        
        test.status = 'completed';
        test.endedAt = Date.now();
        test.winningVariant = winningVariant;
        
        // Track test completion
        window.AnalyticsSystem?.trackEvent('ab_test_completed', {
            testId: testId,
            winningVariant: winningVariant,
            duration: test.endedAt - test.startDate
        });
        
        return true;
    }
}

// ===========================
// HEAT MAP SYSTEM
// ===========================

class HeatMapSystem {
    constructor() {
        this.clickData = [];
        this.scrollData = [];
        this.hoverData = [];
        this.isRecording = false;
        
        this.initializeHeatMap();
    }
    
    initializeHeatMap() {
        this.setupEventListeners();
        console.log('✅ Heat Map System initialized');
    }
    
    startRecording() {
        this.isRecording = true;
        console.log('🎬 Heat map recording started');
    }
    
    stopRecording() {
        this.isRecording = false;
        console.log('⏹️ Heat map recording stopped');
    }
    
    setupEventListeners() {
        // Track clicks
        document.addEventListener('click', (event) => {
            if (!this.isRecording) return;
            
            this.recordClick(event.clientX, event.clientY, event.target);
        });
        
        // Track mouse movement/hover
        let hoverTimeout;
        document.addEventListener('mousemove', (event) => {
            if (!this.isRecording) return;
            
            clearTimeout(hoverTimeout);
            hoverTimeout = setTimeout(() => {
                this.recordHover(event.clientX, event.clientY, event.target);
            }, 500); // Record hover after 500ms
        });
        
        // Track scroll
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            if (!this.isRecording) return;
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                this.recordScroll(window.scrollY, document.documentElement.scrollHeight);
            }, 100);
        });
    }
    
    recordClick(x, y, element) {
        const clickPoint = {
            x: x,
            y: y,
            timestamp: Date.now(),
            element: this.getElementInfo(element),
            viewportWidth: window.innerWidth,
            viewportHeight: window.innerHeight,
            scrollX: window.scrollX,
            scrollY: window.scrollY
        };
        
        this.clickData.push(clickPoint);
        
        // Keep only last 1000 clicks
        if (this.clickData.length > 1000) {
            this.clickData = this.clickData.slice(-1000);
        }
        
        // Track in analytics
        window.AnalyticsSystem?.trackEvent('heatmap_click', {
            x: x,
            y: y,
            element: clickPoint.element.tagName
        });
    }
    
    recordHover(x, y, element) {
        const hoverPoint = {
            x: x,
            y: y,
            timestamp: Date.now(),
            element: this.getElementInfo(element),
            viewportWidth: window.innerWidth,
            viewportHeight: window.innerHeight
        };
        
        this.hoverData.push(hoverPoint);
        
        // Keep only last 500 hover points
        if (this.hoverData.length > 500) {
            this.hoverData = this.hoverData.slice(-500);
        }
    }
    
    recordScroll(scrollY, totalHeight) {
        const scrollPoint = {
            scrollY: scrollY,
            totalHeight: totalHeight,
            scrollPercentage: (scrollY / (totalHeight - window.innerHeight)) * 100,
            timestamp: Date.now()
        };
        
        this.scrollData.push(scrollPoint);
        
        // Keep only last 200 scroll points
        if (this.scrollData.length > 200) {
            this.scrollData = this.scrollData.slice(-200);
        }
    }
    
    getElementInfo(element) {
        return {
            tagName: element.tagName || '',
            id: element.id || '',
            className: element.className || '',
            textContent: (element.textContent || '').substring(0, 50),
            rect: element.getBoundingClientRect()
        };
    }
    
    generateHeatMapData() {
        // Process click data into heat map grid
        const gridSize = 20;
        const heatMap = [];
        
        for (let y = 0; y < Math.ceil(window.innerHeight / gridSize); y++) {
            heatMap[y] = [];
            for (let x = 0; x < Math.ceil(window.innerWidth / gridSize); x++) {
                heatMap[y][x] = 0;
            }
        }
        
        // Count clicks in each grid cell
        this.clickData.forEach(click => {
            const gridX = Math.floor(click.x / gridSize);
            const gridY = Math.floor(click.y / gridSize);
            
            if (gridX >= 0 && gridX < heatMap[0].length && gridY >= 0 && gridY < heatMap.length) {
                heatMap[gridY][gridX]++;
            }
        });
        
        return heatMap;
    }
    
    visualizeHeatMap() {
        const heatMapData = this.generateHeatMapData();
        const maxClicks = Math.max(...heatMapData.flat());
        
        // Remove existing heat map
        const existingHeatMap = document.getElementById('heatMapOverlay');
        if (existingHeatMap) {
            existingHeatMap.remove();
        }
        
        // Create heat map overlay
        const overlay = document.createElement('div');
        overlay.id = 'heatMapOverlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
        `;
        
        const gridSize = 20;
        heatMapData.forEach((row, y) => {
            row.forEach((clickCount, x) => {
                if (clickCount > 0) {
                    const intensity = clickCount / maxClicks;
                    const cell = document.createElement('div');
                    cell.style.cssText = `
                        position: absolute;
                        left: ${x * gridSize}px;
                        top: ${y * gridSize}px;
                        width: ${gridSize}px;
                        height: ${gridSize}px;
                        background-color: rgba(255, 0, 0, ${intensity * 0.7});
                        border-radius: 2px;
                    `;
                    overlay.appendChild(cell);
                }
            });
        });
        
        document.body.appendChild(overlay);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            overlay.remove();
        }, 10000);
    }
    
    getScrollAnalytics() {
        if (this.scrollData.length === 0) return null;
        
        const maxScroll = Math.max(...this.scrollData.map(s => s.scrollPercentage));
        const avgScroll = this.scrollData.reduce((sum, s) => sum + s.scrollPercentage, 0) / this.scrollData.length;
        const scrollSessions = this.scrollData.filter(s => s.scrollPercentage > 75).length;
        
        return {
            maxScrollPercentage: maxScroll,
            avgScrollPercentage: avgScroll,
            deepScrollSessions: scrollSessions,
            totalScrollEvents: this.scrollData.length
        };
    }
    
    getClickAnalytics() {
        if (this.clickData.length === 0) return null;
        
        const elementClicks = {};
        const hourlyClicks = {};
        
        this.clickData.forEach(click => {
            // Count by element type
            const element = click.element.tagName.toLowerCase();
            elementClicks[element] = (elementClicks[element] || 0) + 1;
            
            // Count by hour
            const hour = new Date(click.timestamp).getHours();
            hourlyClicks[hour] = (hourlyClicks[hour] || 0) + 1;
        });
        
        return {
            totalClicks: this.clickData.length,
            elementClicks: elementClicks,
            hourlyDistribution: hourlyClicks,
            mostClickedElement: Object.keys(elementClicks).reduce((a, b) => 
                elementClicks[a] > elementClicks[b] ? a : b
            )
        };
    }
    
    exportHeatMapData() {
        return {
            clicks: this.clickData,
            hovers: this.hoverData,
            scrolls: this.scrollData,
            analytics: {
                scroll: this.getScrollAnalytics(),
                clicks: this.getClickAnalytics()
            },
            exportedAt: Date.now()
        };
    }
    
    clearData() {
        this.clickData = [];
        this.scrollData = [];
        this.hoverData = [];
        console.log('🗑️ Heat map data cleared');
    }
}

// ===========================
// REAL-TIME MONITORING ALERTS
// ===========================

class MonitoringAlerts {
    constructor() {
        this.alerts = [];
        this.thresholds = {
            errorRate: 5, // 5%
            responseTime: 5000, // 5 seconds
            memoryUsage: 100, // 100 MB
            activeUsers: 1000, // 1000 users
            gameFailureRate: 10 // 10%
        };
        this.alertCallbacks = new Map();
        
        this.initializeMonitoring();
    }
    
    initializeMonitoring() {
        this.startMetricsMonitoring();
        console.log('✅ Monitoring Alerts initialized');
    }
    
    startMetricsMonitoring() {
        // Check metrics every 30 seconds
        setInterval(() => {
            this.checkThresholds();
        }, 30000);
    }
    
    checkThresholds() {
        const analytics = window.AnalyticsSystem;
        if (!analytics) return;
        
        const stats = analytics.getAnalyticsSummary();
        const systemMetrics = analytics.getSystemMetrics(5);
        
        // Check error rate
        if (stats.errorRate > this.thresholds.errorRate) {
            this.createAlert('HIGH_ERROR_RATE', `Error rate is ${stats.errorRate.toFixed(2)}%`, 'high');
        }
        
        // Check response time
        if (stats.realtimeStats.avgResponseTime > this.thresholds.responseTime) {
            this.createAlert('SLOW_RESPONSE_TIME', `Average response time is ${Math.round(stats.realtimeStats.avgResponseTime)}ms`, 'medium');
        }
        
        // Check memory usage
        if (systemMetrics.length > 0) {
            const latestMetric = systemMetrics[systemMetrics.length - 1];
            const memoryMB = latestMetric.memory ? latestMetric.memory.usedJSHeapSize / 1024 / 1024 : 0;
            
            if (memoryMB > this.thresholds.memoryUsage) {
                this.createAlert('HIGH_MEMORY_USAGE', `Memory usage is ${Math.round(memoryMB)}MB`, 'medium');
            }
        }
        
        // Check game failure rate
        this.checkGameFailureRate();
    }
    
    checkGameFailureRate() {
        const analytics = window.AnalyticsSystem;
        const recentEvents = analytics.events.slice(-100); // Last 100 events
        
        const gameStarts = recentEvents.filter(e => e.name === 'game_start').length;
        const gameErrors = recentEvents.filter(e => e.name === 'game_error').length;
        
        if (gameStarts > 0) {
            const failureRate = (gameErrors / gameStarts) * 100;
            
            if (failureRate > this.thresholds.gameFailureRate) {
                this.createAlert('HIGH_GAME_FAILURE_RATE', `Game failure rate is ${failureRate.toFixed(2)}%`, 'high');
            }
        }
    }
    
    createAlert(type, message, severity = 'medium') {
        // Check if similar alert exists recently (avoid spam)
        const recentAlert = this.alerts.find(alert => 
            alert.type === type && 
            Date.now() - alert.timestamp < 300000 // 5 minutes
        );
        
        if (recentAlert) return;
        
        const alert = {
            id: this.generateAlertId(),
            type: type,
            message: message,
            severity: severity,
            timestamp: Date.now(),
            acknowledged: false,
            resolved: false
        };
        
        this.alerts.push(alert);
        
        // Keep only last 100 alerts
        if (this.alerts.length > 100) {
            this.alerts = this.alerts.slice(-100);
        }
        
        // Trigger alert callbacks
        this.triggerAlertCallbacks(alert);
        
        // Show notification
        this.showAlertNotification(alert);
        
        // Log to console
        console.warn(`🚨 ALERT [${severity.toUpperCase()}]: ${message}`);
        
        // Track in analytics
        window.AnalyticsSystem?.trackEvent('monitoring_alert', {
            type: type,
            severity: severity,
            message: message
        });
    }
    
    triggerAlertCallbacks(alert) {
        this.alertCallbacks.forEach((callback, type) => {
            if (type === alert.type || type === 'all') {
                try {
                    callback(alert);
                } catch (error) {
                    console.error('Error in alert callback:', error);
                }
            }
        });
    }
    
    showAlertNotification(alert) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 400px;
            padding: 15px;
            background: ${this.getAlertColor(alert.severity)};
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10001;
            font-size: 14px;
        `;
        
        notification.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                <div>
                    <strong>🚨 ${alert.type.replace(/_/g, ' ')}</strong><br>
                    <div style="margin-top: 5px;">${alert.message}</div>
                    <div style="margin-top: 5px; font-size: 12px; opacity: 0.8;">
                        ${new Date(alert.timestamp).toLocaleTimeString()}
                    </div>
                </div>
                <button onclick="this.parentElement.parentElement.remove()" style="
                    background: none; 
                    border: none; 
                    color: white; 
                    font-size: 16px; 
                    cursor: pointer;
                    margin-left: 10px;
                ">×</button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 10000);
    }
    
    getAlertColor(severity) {
        switch (severity) {
            case 'high': return '#f44336';
            case 'medium': return '#ff9800';
            case 'low': return '#2196f3';
            default: return '#666';
        }
    }
    
    acknowledgeAlert(alertId) {
        const alert = this.alerts.find(a => a.id === alertId);
        if (alert) {
            alert.acknowledged = true;
            alert.acknowledgedAt = Date.now();
            return true;
        }
        return false;
    }
    
    resolveAlert(alertId) {
        const alert = this.alerts.find(a => a.id === alertId);
        if (alert) {
            alert.resolved = true;
            alert.resolvedAt = Date.now();
            return true;
        }
        return false;
    }
    
    onAlert(alertType, callback) {
        this.alertCallbacks.set(alertType, callback);
    }
    
    removeAlertCallback(alertType) {
        this.alertCallbacks.delete(alertType);
    }
    
    getActiveAlerts() {
        return this.alerts.filter(alert => !alert.resolved);
    }
    
    getAlertHistory(limit = 50) {
        return this.alerts.slice(-limit);
    }
    
    updateThreshold(metric, value) {
        if (this.thresholds.hasOwnProperty(metric)) {
            this.thresholds[metric] = value;
            console.log(`📏 Threshold updated: ${metric} = ${value}`);
            return true;
        }
        return false;
    }
    
    getThresholds() {
        return { ...this.thresholds };
    }
    
    generateAlertId() {
        return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    }
}

// ===========================
// INITIALIZE ANALYTICS SYSTEMS
// ===========================

window.AnalyticsSystem = new AnalyticsSystem();
window.PerformanceDashboard = new PerformanceDashboard();
window.ABTestingSystem = new ABTestingSystem();
window.HeatMapSystem = new HeatMapSystem();
window.MonitoringAlerts = new MonitoringAlerts();

// Start heat map recording automatically
window.HeatMapSystem.startRecording();

// Setup automatic A/B testing for current user
document.addEventListener('DOMContentLoaded', () => {
    const userId = window.PlayerManager?.getCurrentPlayerId?.();
    if (userId) {
        // Assign user to active A/B tests
        window.ABTestingSystem.getAllActiveTests().forEach(test => {
            window.ABTestingSystem.assignUserToTest(userId, test.id);
        });
    }
});

// Track page load completion
window.addEventListener('load', () => {
    window.AnalyticsSystem.trackEvent('page_loaded', {
        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
        domReady: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart
    });
});

// Set up alert callbacks for critical issues
window.MonitoringAlerts.onAlert('HIGH_ERROR_RATE', (alert) => {
    console.error('🚨 Critical: High error rate detected!', alert);
    // In production, this might send notifications to administrators
});

window.MonitoringAlerts.onAlert('HIGH_GAME_FAILURE_RATE', (alert) => {
    console.error('🚨 Critical: High game failure rate detected!', alert);
    // In production, this might trigger automatic failover or scaling
});

console.log('✅ Section 21: Platform Analytics & Performance Monitoring loaded successfully');/* ===========================
   CROSSREALM GAMING PLATFORM
   SECTION 21: PLATFORM ANALYTICS & PERFORMANCE MONITORING
   =========================== */

'use strict';

// ===========================
// ANALYTICS SYSTEM
// ===========================

class AnalyticsSystem {
    constructor() {
        this.events = [];
        this.sessionData = new Map();
        this.performanceMetrics = new Map();
        this.userBehavior = new Map();
        this.realtimeStats = {
            activeUsers: 0,
            activeGames: 0,
            totalTransactions: 0,
            avgResponseTime: 0,
            errorRate: 0
        };
        
        this.initializeAnalytics();
    }
    
    initializeAnalytics() {
        this.startSession();
        this.setupEventListeners();
        this.startMetricsCollection();
        this.initializePerformanceMonitoring();
        
        console.log('✅ Analytics System initialized');
    }
    
    startSession() {
        const sessionId = this.generateSessionId();
        const session = {
            id: sessionId,
            startTime: Date.now(),
            userId: window.PlayerManager?.getCurrentPlayerId?.() || 'anonymous',
            userAgent: navigator.userAgent,
            platform: this.detectPlatform(),
            referrer: document.referrer,
            screenResolution: `${screen.width}x${screen.height}`,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            language: navigator.language,
            events: [],
            pageViews: [],
            errors: [],
            performance: {
                loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
                domReady: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                firstPaint: 0,
                largestContentfulPaint: 0
            }
        };
        
        this.sessionData.set(sessionId, session);
        this.currentSessionId = sessionId;
        
        // Record session start
        this.trackEvent('session_start', {
            sessionId: sessionId,
            platform: session.platform,
            language: session.language
        });
    }
    
    detectPlatform() {
        const userAgent = navigator.userAgent.toLowerCase();
        
        if (userAgent.includes('mobile') || userAgent.includes('android') || userAgent.includes('iphone')) {
            return 'mobile';
        } else if (userAgent.includes('tablet') || userAgent.includes('ipad')) {
            return 'tablet';
        } else {
            return 'desktop';
        }
    }
    
    trackEvent(eventName, properties = {}, userId = null) {
        const event = {
            id: this.generateEventId(),
            name: eventName,
            properties: properties,
            userId: userId || this
// Complete the missing wallet connection and core functionality

// Complete the analytics trackEvent method
getCurrentUserId() || 'anonymous';
            
            this.trackEvent('session_start', {
                sessionId: sessionId,
                platform: session.platform,
                language: session.language
            });
        }
        
        // Complete wallet connection functionality
        async function connectWallet() {
            try {
                showLoadingOverlay('Connecting Wallet', 'Initializing blockchain connection...');
                
                // Check if MetaMask is available
                if (typeof window.ethereum === 'undefined') {
                    hideLoadingOverlay();
                    showTransactionStatus('❌ MetaMask Required', 'Please install MetaMask to connect your wallet');
                    return false;
                }
                
                // Request account access
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });
                
                if (accounts.length === 0) {
                    hideLoadingOverlay();
                    showTransactionStatus('❌ Connection Failed', 'No accounts found in MetaMask');
                    return false;
                }
                
                userAccount = accounts[0];
                
                // Switch to Core network if needed
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: CORE_CHAIN_ID }],
                    });
                } catch (switchError) {
                    // Network not added, try to add it
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: CORE_CHAIN_ID,
                                chainName: 'Core Blockchain Mainnet',
                                nativeCurrency: {
                                    name: 'Core',
                                    symbol: 'CORE',
                                    decimals: 18
                                },
                                rpcUrls: [CORE_RPC_URL],
                                blockExplorerUrls: [CORE_EXPLORER]
                            }]
                        });
                    }
                }
                
                // Initialize Web3 provider
                web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = web3Provider.getSigner();
                
                // Get balance
                const balance = await web3Provider.getBalance(userAccount);
                currentBalance = parseFloat(ethers.utils.formatEther(balance));
                
                // Initialize contract
                gameContract = new ethers.Contract(GAME_CONTRACT_ADDRESS, GAME_CONTRACT_ABI, signer);
                
                // Update UI
                updateConnectionStatus('connected');
                updateWalletDisplay();
                hideLoadingOverlay();
                
                showTransactionStatus('✅ Wallet Connected!', `Connected to ${userAccount.substring(0, 6)}...${userAccount.substring(38)}`);
                
                console.log('✅ Wallet connected successfully');
                return true;
                
            } catch (error) {
                console.error('❌ Wallet connection failed:', error);
                hideLoadingOverlay();
                showTransactionStatus('❌ Connection Failed', error.message || 'Failed to connect wallet');
                return false;
            }
        }
        
        // Initialize the platform
        async function initializePlatform() {
            try {
                console.log('🚀 Initializing CrossRealm Gaming Platform...');
                
                // Initialize core systems
                await initializeFirebase();
                await initializeBlockchain();
                
                // Set up UI
                setupNavigation();
                loadInitialData();
                
                // Start periodic updates
                startPeriodicUpdates();
                
                console.log('✅ Platform initialization complete');
                
            } catch (error) {
                console.error('❌ Platform initialization failed:', error);
                showTransactionStatus('❌ Initialization Failed', 'Platform failed to initialize properly');
            }
        }
        
        // Initialize Firebase
        async function initializeFirebase() {
            // Mock Firebase initialization for demo
            console.log('🔥 Firebase initialized (demo mode)');
            return true;
        }
        
        // Initialize Blockchain
        async function initializeBlockchain() {
            if (typeof window.ethereum !== 'undefined') {
                web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                console.log('⛓️ Blockchain provider initialized');
            } else {
                console.log('⛓️ No blockchain provider detected - running in demo mode');
            }
            return true;
        }
        
        // Update connection status
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const indicator = statusElement.querySelector('.connection-indicator');
            
            switch (status) {
                case 'connected':
                    statusElement.innerHTML = '<span class="connection-indicator connected"></span>Connected';
                    break;
                case 'connecting':
                    statusElement.innerHTML = '<span class="connection-indicator pending"></span>Connecting...';
                    break;
                case 'disconnected':
                default:
                    statusElement.innerHTML = '<span class="connection-indicator disconnected"></span>Not Connected';
                    break;
            }
        }
        
        // Update wallet display
        function updateWalletDisplay() {
            const balanceDisplay = document.getElementById('balanceDisplay');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (userAccount) {
                balanceDisplay.textContent = `${currentBalance.toFixed(4)} CORE`;
                connectBtn.classList.add('hidden');
                disconnectBtn.classList.remove('hidden');
            } else {
                balanceDisplay.textContent = '0.0000 CORE';
                connectBtn.classList.remove('hidden');
                disconnectBtn.classList.add('hidden');
            }
        }
        
        // Disconnect wallet
        function disconnectWallet() {
            userAccount = null;
            currentBalance = 0;
            web3Provider = null;
            gameContract = null;
            
            updateConnectionStatus('disconnected');
            updateWalletDisplay();
            
            showTransactionStatus('👋 Wallet Disconnected', 'Wallet has been disconnected');
        }
        
        // Show loading overlay
        function showLoadingOverlay(title, message) {
            const overlay = document.getElementById('loadingOverlay');
            const titleElement = document.getElementById('loadingMessage');
            const messageElement = document.getElementById('loadingSubtext');
            
            if (titleElement) titleElement.textContent = title;
            if (messageElement) messageElement.textContent = message;
            if (overlay) overlay.classList.remove('hidden');
        }
        
        // Hide loading overlay
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) overlay.classList.add('hidden');
        }
        
        // Show transaction status
        function showTransactionStatus(title, message) {
            const statusElement = document.getElementById('transactionStatus');
            const titleElement = document.getElementById('txStatusTitle');
            const messageElement = document.getElementById('txStatusMessage');
            
            if (titleElement) titleElement.textContent = title;
            if (messageElement) messageElement.textContent = message;
            
            if (statusElement) {
                statusElement.classList.add('show');
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    statusElement.classList.remove('show');
                }, 5000);
            }
        }
        
        // Hide transaction status
        function hideTransactionStatus() {
            const statusElement = document.getElementById('transactionStatus');
            if (statusElement) {
                statusElement.classList.remove('show');
            }
        }
        
        // Setup navigation
        function setupNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            
            navItems.forEach((item, index) => {
                item.addEventListener('click', () => {
                    const sections = ['lobby', 'active', 'create', 'games', 'tournaments', 'leaderboard', 'profile', 'settings'];
                    if (sections[index]) {
                        showSection(sections[index]);
                    }
                });
            });
        }
        
        // Load initial data
        function loadInitialData() {
            // Load sample games for demo
            populateSampleGames();
            
            // Update stats
            updateLiveStats();
        }
        
        // Populate sample games
        function populateSampleGames() {
            const gamesList = document.getElementById('gamesList');
            if (!gamesList) return;
            
            const sampleGames = [
                {
                    id: 'game_001',
                    type: 'Chess',
                    stake: '0.1 CORE',
                    player: 'ChessMaster',
                    status: 'waiting'
                },
                {
                    id: 'game_002',
                    type: 'Checkers',
                    stake: '0.05 CORE',
                    player: 'CheckersKing',
                    status: 'waiting'
                }
            ];
            
            gamesList.innerHTML = sampleGames.map(game => `
                <div class="game-item">
                    <div class="game-header">
                        <div class="game-type">${game.type}</div>
                        <div class="game-stake">${game.stake}</div>
                    </div>
                    <div class="game-info">
                        Created by ${game.player} • Waiting for opponent
                    </div>
                    <div class="game-actions">
                        <button class="game-btn primary" onclick="joinGame('${game.id}')">
                            <i class="fas fa-play"></i> Join Game
                        </button>
                    </div>
                </div>
            `).join('');
        }
        
        // Update live stats
        function updateLiveStats() {
            // Update sample stats
            document.getElementById('totalPlayers').textContent = '247';
            document.getElementById('totalGames').textContent = '89';
            document.getElementById('totalVolume').textContent = '156.7';
            document.getElementById('totalTournaments').textContent = '3';
        }
        
        // Start periodic updates
        function startPeriodicUpdates() {
            setInterval(() => {
                if (userAccount && web3Provider) {
                    updateBalance();
                }
                updateLiveStats();
            }, 30000); // Update every 30 seconds
        }
        
        // Update balance
        async function updateBalance() {
            try {
                const balance = await web3Provider.getBalance(userAccount);
                currentBalance = parseFloat(ethers.utils.formatEther(balance));
                updateWalletDisplay();
            } catch (error) {
                console.error('Failed to update balance:', error);
            }
        }
        
        // Refresh lobby
        function refreshLobby() {
            showTransactionStatus('🔄 Refreshing...', 'Loading latest games');
            
            setTimeout(() => {
                populateSampleGames();
                updateLiveStats();
                showTransactionStatus('✅ Refreshed', 'Game lobby updated');
            }, 1000);
        }
        
        // Join game (demo)
        function joinGame(gameId) {
            if (!userAccount) {
                showTransactionStatus('⚠️ Wallet Required', 'Please connect your wallet first');
                return;
            }
            
            showTransactionStatus('🎮 Joining Game...', 'Setting up game session');
            
            setTimeout(() => {
                showTransactionStatus('✅ Game Joined!', 'Starting match...');
            }, 2000);
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Check age verification first
            if (checkAgeVerification()) {
                initializePlatform();
            }
        });
        
        console.log('🎮 CrossRealm Gaming Platform loaded successfully');
        
